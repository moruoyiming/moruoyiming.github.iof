{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 个人信息：90后计算机网络技术专业从事Android开发，坚信代码改变世界摄影爱好者QQ: 798774875Email: moruoyiming123@gmail.comJianShu: jianzeyicongGithub: moruoyimingYouTube: Jean RilenInstagram: jianzeyicong500px: moruoyiming 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志： –2020.09.18：增加AdSense广告–2020.08.22：改版部分显示，优化速度–2020.06.18：icarus3.0主题适配–2019.12.16：增加不蒜子统计–2019.10.16：文章列表加上评论数显示–2019.03.13：改版评论–2017.12.16：icarus1.0主题适配–2017.08.12：搭建个人博客 本站推荐索引 技术知识点 Java教程 Python3教程 JavaScript教程 剑指Offer 免费学习资料 常用工具 图片压缩 在线转换工具 贝塞尔弧曲线 ProcessOn流程图 Youtube视频下载 免费翻墙 free-ss free-ss.site ss.pythonic.life 免费节点 软件下载 萌新网 麦氪派 福利 电影天堂 高清电影 BD电影 剧迷 高速车 持续更新~","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"电影","text":"","link":"/media/index.html"}],"posts":[{"title":"Android项目运行时丢失so文件","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 123456789101112defaultConfig { applicationId &quot;…&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' }} 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2020/09/11/Android%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%A2%E5%A4%B1so%E6%96%87%E4%BB%B6/"},{"title":"Mac系统壁纸路径","text":"在 Finder 中，菜单栏选取“前往”&gt;“前往文件夹”，弹出的框里输入/Library/Desktop Pictures/或/System/Library/Desktop Pictures/然后回车即可打开该文件夹。 系统壁纸默认路径存在两个地方，当时去了第一个路径上找未找到，后来通过命令行获取到路径发现System 下也有一个Desktop Pictures 文件夹。 终端命令：显示壁纸所在路径（路径显示在屏幕对应壁纸上）： defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE;killall Dock 终端命令：隐藏该路径： defaults delete com.apple.dock desktop-picture-show-debug-text;killall Dock","link":"/2020/09/11/Mac%20%E7%B3%BB%E7%BB%9F%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"title":"Mac 下移动硬盘的读写软件Mounty","text":"title: Mac下移动硬盘的读写软件Mountythumbnail: /gallery/thumbnails/sculpture.jpgcategories: Mac应用tags: 壁纸路径 Mounty Mac系统 终端运行: brew cask install mounty 官网地址:https://mounty.app/","link":"/2020/09/11/Mac%20%E4%B8%8B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E8%BD%AF%E4%BB%B6Mounty/"},{"title":"Mac下Google备份和同步问题","text":"1.下载并安装Google备份和同步 Google备份和同步（下载地址） 2.打开xx的http代理 在偏好设置中打开http代理服务器，配置默认即可 3.打开系统设置中的http代理 系统偏好设置→网络→高级→代理→网页代理(HTTP)，设置代理127.0.0.1:1087 4. 允许并登录Google账户 完全配置完成后即可食用 原文地址 https://www.fangpengjun.com/2017/09/08/%E8%A7%A3%E5%86%B3Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","link":"/2020/09/11/Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},{"title":"Mac下安装软件提示文件损坏解决办法","text":"1.打开应用程序-实用工具-终端；b2制以下代码（master注意是两个-）到终端中，回车（输入电脑密码）： 1sudo spctl --master-disable 3.打开应用程序-系统偏好设置-安全性和隐私-通用，消失的任何来源终于出现了（默认应该勾选了）；4.此时可以尽情使用第三方程序了如已经开启了任何来源，还无法安装当出现提示的时候，去系统偏好设置-安全和隐私那里允许下（会提示该软件的安装信息） 还提示损坏的，试试按住Control后，再次点击软件图标","link":"/2020/09/11/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Mac使用终端登录谷歌云","text":"1.网页SSH进入谷歌云，切换到root角色 sudo -i 2.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 3.给root用户设置密码 passwd root 4.重启SSH服务使修改生效 /etc/init.d/ssh restart 5.启动mac终端 ssh root@ip 输入密码即可进入SSH。","link":"/2020/09/11/Mac%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"title":"Mac安装oh-my-zsh出现TimeOut","text":"mac终端 安装 oh-my-zshsh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 提示错误 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 用这个连接wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh","link":"/2020/09/11/Mac%E5%AE%89%E8%A3%85oh-my-zsh%20%E5%87%BA%E7%8E%B0TimeOut/"},{"title":"Mac文件安装应用，打开提示文件已损坏，如何解决","text":"终端运行该命令:sudo xattr -d com.apple.quarantine /Applications/ColorFinale.app","link":"/2020/09/11/Mac%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%EF%BC%8C%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"},{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2019/02/20/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Android 项目中so文件丢失","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 1234567891011121314151617defaultConfig { applicationId &quot;...&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2019/02/26/SO%E6%96%87%E4%BB%B6%E7%BC%BA%E5%A4%B1/"},{"title":"TensorFlow Mac安装教程","text":".安装Python 3.7.5 版本百度云盘:链接:https://pan.baidu.com/s/1lC7ZPFAIB8pYor1DbIOL8Q 密码:v6tj官网:https://www.python.org/ftp/python/3.7.5/python-3.7.5-macosx10.9.pkg 查看版本号。 123python3 --versionpip3 --versionvirtualenv --version 输入which python3 查看路径 2.如果已经安装，跳过这步：如果没用过brew，需要先下载，关于brew查看这里: https://brew.sh/ 123/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 1234/usr/bin/ruby -e &quot;PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 3.安装virtualenv虚拟环境创建一个新的虚拟环境通过选择一个Python解释器,创建./venv目录来保存它:可修改为其他目录。目录会出现在 user的子目录下。 1virtualenv --system-site-packages -p python3 ./venv 4.激活虚拟环境 1source ./venv/bin/activate # sh, bash, ksh, or zsh virtualenv活跃时,shell提示符前缀(venv)。 安装包在一个虚拟环境在不影响主机系统设置。先升级pip: 12pip install --upgrade pippip list # show packages installed within the virtual environment 5.退出虚拟环境 deactivate # don’t exit until you’re done using TensorFlow 如果提示权限不够时，需要在命令后添加 –user。 6.安装TensorFlow 1pip install --upgrade tensorflow 验证安装 1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 问题汇总 1pip install Keras-Applications ModuleNotFoundError: No module named ‘matplotlib’ 1pip install matplotlib ModuleNotFoundError: No module named ‘tensorflow_datasets’ 1pip install tensorflow_datasets ModuleNotFoundError: No module named ‘tensorflow_hub’ 1pip install tensorflow_hub seaborn 绘制矩阵图 (pairplot) 1pip install seaborn 引入类库 TensorFlow and tf.keras12import tensorflow as tffrom tensorflow import keras Helper librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as sns","link":"/2020/09/11/TensorFlow%20Mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"指环王1：魔戒再现.蓝光加长版","text":"[[2000-2010][欧美][奇幻][BT下载][指环王1：魔戒再现.蓝光加长版][BD-MKV/4.03GB][国语双语中英字幕][1080P][奇幻冒险史诗巨制] ◎译 名 指环王1：魔戒再现/魔戒首部曲：魔戒现身/指环王I：护戒使者/魔戒1：护戒联盟 ◎片 名 The Lord of the Rings：The Fellowship of the Ring ◎年 代 2001 ◎国 家 新西兰/美国 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 国英双语 ◎字 幕 中英双字 ◎上映日期 2002-04-04(中国大陆)/2001-12-19(美国) ◎豆瓣评分 8.9/10 from 292224 users ◎豆瓣链接 https://movie.douban.com/subject/1291571/ ◎文件格式 X264+AC3 ◎视频尺寸 1920×1080 ◎文件大小 11.6GB ◎片 长 228min ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 肖恩·宾 Sean Bean 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 伊安·霍姆 Ian Holm 多米尼克·莫纳汉 Dominic Monaghan 萨拉·贝克 Sala Baker 约翰·瑞斯-戴维斯 John Rhys-Davies 【电影简介】 比尔博·巴金斯是100多岁的哈比人，住在故乡夏尔，生性喜欢冒险，在年轻时的一次探险经历中，他从怪物咕噜手中得到了至尊魔戒，这枚戒指是黑暗魔君索伦打造的至尊魔戒，拥有奴役世界的邪恶力量，能够统领其他几枚力量之戒，在3000年前的人类联盟和半兽人大军的战役中，联盟取得了胜利，并得到了至尊魔戒，数千年的辗转后，魔戒落到咕噜手中，被比尔博碰巧得到。 因为和魔戒的朝夕相处，比尔博的心性也受到了影响，在他111岁的生日宴会上，他决定把一切都留给侄子佛罗多(伊莱贾·伍德 饰)，继续冒险。 比尔博的好朋友灰袍巫师甘道夫（伊恩·麦凯伦 饰）知道至尊魔戒的秘密，同时，黑暗魔君索伦已经知道他的魔戒落在哈比族的手中。索伦正在重新建造要塞巴拉多，集结无数的半兽人，准备以大军 夺取魔戒，并且征服全世界。 甘道夫说服佛罗多将魔戒护送到精灵王国瑞文希尔，佛罗多在好朋友山姆、皮平和梅利的陪同下，在跃马旅店得到了刚铎王子阿拉贡的帮助，历经艰难，终于到达了精灵王国。 然而，精灵族并不愿意保管这个邪恶的至尊魔戒，中土各国代表开会讨论，达成意见，准备将至尊魔戒送到末日山脉的烈焰中彻底销毁，佛罗多挺身而出接受了这个任务，这次，陪伴他的除了三个好朋友，还有甘道夫、阿拉贡、精灵莱戈拉斯（奥兰多·布鲁姆 饰）、人类博罗米尔、侏儒金利。 一路上，魔戒远征军除了要逃避索伦爪牙黑骑士和半兽人的追杀之外，更要抵抗至尊魔界本身的邪恶诱惑，前途困难重重。 【电影截图】 指环王1.魔戒再现.国语双语中英字幕.The.Lord.of.the.Rings.The.Fellowship.of.the.Ring.2001.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B1%EF%BC%9A%E9%AD%94%E6%88%92%E5%86%8D%E7%8E%B0.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.03GB%5D%5B%E5%9B%BD%5D/"},{"title":"指环王3：王者无敌.加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王3：王者无敌.加长版][BD-MKV/5.17GB][国英双语中字][1080P][豆瓣9.2高分魔幻巨制] ◎译 名 指环王3：王者无敌/魔戒三部曲：王者再临/指环王III：王者无敌/魔戒3：王者归来/指环王3：国王归来 ◎片 名 The Lord of the Rings: The Return of the King ◎年 代 2003 ◎国 家 美国/新西兰 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 英语/昆雅语/古英语/辛达林语 ◎上映日期 2003-12-01(新西兰首映)/2003-12-17(美国)/2004-03-15(中国大陆) ◎IMDb评分 8.9/10 from 1,064,793 users ◎IMDb链接 http://www.imdb.com/title/tt0167260/ ◎豆瓣评分 9.1/10 from 218,212 users ◎豆瓣链接 http://movie.douban.com/subject/1291552/ ◎片 长 201分钟/251分钟(加长版)/263分钟(蓝光加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 维果·莫腾森 Viggo Mortensen 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 丽芙·泰勒 Liv Tyler 伊恩·麦克莱恩 Ian McKellen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 米兰达·奥图 Miranda Otto 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 多米尼克·莫纳汉 Dominic Monaghan 比利·博伊德 Billy Boyd 马尔顿·索克斯 Marton Csokas 卡尔·厄本 Karl Urban 克里斯托弗·李 Christopher Lee 约翰·瑞斯-戴维斯 John Rhys-Davies ◎简 介 魔幻战争逐渐进入高潮阶段。霍比特人弗拉多（伊利亚·伍德 Elijah Wood 饰）携带着魔戒，与伙伴山姆（Sean Astin 饰）以及狡猾阴暗的咕噜等前往末日山，一路上艰难险阻不断，魔君索伦为阻止魔戒被销毁用尽全力阻挠。另一方面，白袍巫师甘道夫（伊安·麦克莱恩 Ian McKellen 饰）率中土勇士们镇守刚铎首都——白城米那斯提里斯。魔兽大军压境，黑暗与光明的决战即将来临…… 本片是“指环王三部曲”的终结篇，根据英国作家J.R.R.托尔金（J.R.R. Tolkien）同名魔幻巨著《指环王》（The Lord of the Rings）改编，并荣获2004年第76届奥斯卡最佳影片、最佳导演、最佳改编剧本、最佳剪辑、最佳艺术指导、最佳服装设计、最佳化妆、最佳视觉效果、最佳音效、最佳配乐和最佳歌曲等11项大奖。 ◎获奖情况 第76届奥斯卡金像奖 (2004) 最佳影片 Barrie M. Osborne / 弗兰·威尔士 / 彼得·杰克逊 最佳导演 彼得·杰克逊 最佳改编剧本 弗兰·威尔士 / 彼得·杰克逊 / 菲利帕·鲍恩斯 最佳剪辑 Jamie Selkirk 最佳视觉效果 Alex Funke / Jim Rygiel / 乔·莱特瑞 / Randall William Cook 最佳混音 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳美术指导 丹·汉纳 / 格兰特·梅杰 / 艾伦·李 最佳服装设计 Ngila Dickson / 理查德·泰勒 最佳化妆 理查德·泰勒 / 彼得·金 最佳原创配乐 霍华德·肖 最佳原创歌曲 霍华德·肖 / 安妮·蓝妮克丝 / 弗兰·威尔士 第28届日本电影学院奖 (2005) 最佳外语片(提名) 指环王3.王者无敌.国语双语中英字幕.The.Lord.of.the.Rings.The.Return.of.the.King.2003.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B3%EF%BC%9A%E7%8E%8B%E8%80%85%E6%97%A0%E6%95%8C.%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV5.17GB%5D%5B%E5%9B%BD%E8%8B%B1%E5%8F%8C%5D/"},{"title":"指环王2：双塔奇兵.蓝光加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王2：双塔奇兵.蓝光加长版][BD-MKV/4.81GB][国语双语中英字幕][1080P][豆瓣9.1分史诗巨制] ◎译 名 指环王2：双塔奇兵 / 指环王II：双塔 / 魔戒2：双塔奇谋 / 魔戒二部曲：双城奇谋 ◎片 名 The Lord of the Rings: The Two Towers ◎年 代 2002 ◎产 地 美国 / 新西兰 ◎类 别 剧情 / 动作 / 奇幻 / 冒险 ◎语 言 英语 / 辛达林语 / 古代英语 ◎上映日期 2002-12-05(纽约首映) / 2002-12-18(美国) / 2003-04-25(中国大陆) ◎IMDb评分 8.7/10 from 1369619 users ◎IMDb链接 http://www.imdb.com/title/tt0167261 ◎豆瓣评分 9.1/10 from 410177 users ◎豆瓣链接 https://movie.douban.com/subject/1291572/ ◎片 长 179分钟 ◎导 演 彼得·杰克逊 Peter Jackson ◎编 剧 弗兰·威尔士 Fran Walsh / Philippa Boyens / Stephen Sinclair / 彼得·杰克逊 Peter Jackson / 托尔金 J.R.R. Tolkien ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 克里斯托弗·李 Christopher Lee 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 卡尔·厄本 Karl Urban 凯特·布兰切特 Cate Blanchett 多米尼克·莫纳汉 Dominic Monaghan 大卫·文翰 David Wenham 比利·博伊德 Billy Boyd 布拉德·道里夫 Brad Dourif 伯纳德·希尔 Bernard Hill 约翰·瑞斯-戴维斯 John Rhys-Davies 米兰达·奥图 Miranda Otto ◎标 签 魔幻 | 史诗 | 经典 | 美国 | 战争 | 大片 | 新西兰 | 2002 ◎简 介 第二部在延续第一部风格的同时，故事呈现出多线发展的格局，情节有了更高的观赏性。 第一部结尾，博罗米尔被强兽人杀死之后，两个哈比族人皮平和梅利也被强兽人绑架，阿拉贡、精灵莱戈拉斯（奥兰多?布鲁姆 饰）、侏儒金利一路追踪强兽人，营救皮平和梅利，遇到了“复活”的白袍巫师甘道夫（伊恩?麦凯伦 饰）。此时，投降索伦的白袍巫师萨鲁曼控制了人类洛汉王国的国王，并派出大量的强兽人军队，准备消灭人类。阿拉贡、莱戈拉斯和金利在甘道夫的带领下，帮助洛汉王国对抗邪恶力量的入侵。 幸运的皮平和梅利被会说话的树精救了出来，并且遇到“复活”的甘道夫，在甘道夫的授意下，树精保护了两人的安全，并且带他们参加树精大会，大会上，树精们讨论对待中土大战的态度：是继续当中立者，逆来顺受，还是奋起反抗？ 身负重任的佛罗多(伊莱贾?伍德 饰)和山姆继续向末日山脉前进，一路上被咕噜跟踪，弗罗多依靠至尊魔戒的力量，成为了咕噜的主人，在咕噜的带领下，他们到了末日山脉的入口，黑门。就在他们准备进入之时，博罗米尔的弟弟法莫尔出现，将他们带回了刚铎。弗罗多又遇上了新的危机：法莫尔想利用至尊魔戒的力量对抗萨鲁曼的攻击…… ◎获奖情况 第75届奥斯卡金像奖(2003) 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 最佳剪辑(提名) 迈克·霍顿 最佳视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 最佳音效剪辑 迈克·霍普金斯 / 伊桑·范德莱恩 最佳音响(提名) 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳艺术指导(提名) 格兰特·梅杰 / 丹·汉纳 / 艾伦·李 第56届英国电影学院奖(2003) 电影奖 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 电影奖 最佳导演(提名) 彼得·杰克逊 电影奖 最佳摄影(提名) 安德鲁·莱斯尼 电影奖 最佳剪辑(提名) 迈克·霍顿 / Jabez Olssen 电影奖 最佳化妆/发型(提名) Peter Owen / 彼得·金 / 理查德·泰勒 电影奖 最佳服装设计 恩吉拉·迪克森 / 理查德·泰勒 电影奖 最佳艺术指导(提名) 格兰特·梅杰 电影奖 最佳特殊视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 电影奖 最佳音效(提名) 迈克·亨吉斯 / 迈克·霍普金斯 / 迈克尔·斯曼内科 / 克里斯托弗·博伊斯 / 哈蒙德·匹克 / David Farmer / 伊桑·范德莱恩 电影奖 观众选择奖 第27届日本电影学院奖(2004) 最佳外语片(提名) 第3届美国电影学会奖(2002) 年度佳片 指环王2.双塔奇兵国语双语中英字幕.The.Lord.of.the.Rings.The.Two.Towers.2002.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B2%EF%BC%9A%E5%8F%8C%E5%A1%94%E5%A5%87%E5%85%B5.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.81GB%5D%5B%E5%9B%BD%5D/"},{"title":"霍比特人1.意外之旅.蓝光加长版","text":"[2012] [欧美][奇幻][BT下载][霍比特人1.意外之旅.蓝光加长版][BD-MKV/3.58GB][国英双语中英字幕][1080P][特效史诗巨制] ◎译 名 霍比特人1：意外之旅/哈比人：不思议之旅(港)/哈比人：意外旅程(台)/指环王前传：霍比特人(上) ◎片 名 The Hobbit: An Unexpected Journey ◎年 代 2012 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2012-11-28(新西兰首映)/2012-12-14(美国)/2013-02-22(中国大陆) ◎IMDb评分 8.0/10 from 548,633 users ◎IMDb链接 http://www.imdb.com/title/tt0903624 ◎豆瓣评分 8.1/10 from 178,214 users ◎豆瓣链接 http://movie.douban.com/subject/1966182 ◎片 长 169分钟/182分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 肯·斯托特 Ken Stott 格拉汉姆·麦克泰维什 Graham McTavish 詹姆斯·内斯比特 James Nesbitt 迪恩·奥戈曼 Dean O’Gorman 艾丹·特纳 Aidan Turner 雨果·维文 Hugo Weaving 凯特·布兰切特 Cate Blanchett 安迪·瑟金斯 Andy Serkis 西尔维斯特·迈可伊 Sylvester McCoy 克里斯托弗·李 Christopher Lee 伊利亚·伍德 Elijah Wood 伊安·霍姆 Ian Holm 李·佩斯 Lee Pace ◎简 介 中土最后一座矮人王国埃尔波尔，巍峨壮丽，庄严雄伟。老国王索尔积聚大量财富，却引来恶龙史茅革的觊觎和荼毒，最终导致这座城池陷落。许多年后，灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）找到弗罗多的舅舅——霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰），邀请他加入由13名矮人组成的远征队伍。原来史茅革已多年不见声息，背负家国仇恨的矮人王子索林（理查德·阿米蒂奇 Richard Armitage 饰）希望借此机会收复故土。经过一番考虑，巴金斯决定加入。令他想不到的是，远征旅途多灾多难，与索林结下深仇大恨的苍白半兽人及其爪牙阴魂不散，更有食人鬼和石人制造的无数艰险。而在旅途中，巴金斯也意外得到了日后影响整个中土的重要宝物…… 本片根据J.R.R·托尔金的同名原著改编。 霍比特人1.意外之旅.国英双语中英字幕 The.Hobbit.2012.EXTENDED.1080p.BluRay.AC3. x264.mkv.torrent","link":"/2020/09/23/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA1.%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.58GB%5D/"},{"title":"霍比特人3.五军之战.蓝光加长版","text":"[2014][欧美][动作][BT下载][霍比特人3.五军之战.蓝光加长版][BD-MKV/3.88GB][国英双语中英双字][1080P][超视效史诗巨制必看] ※※※※※※※ 影片信息 ※※※※※※※ ◎译 名 霍比特人3：五军之战/哈比人：五军之战(港台)/哈比人：奇境再返(台) ◎片 名 The Hobbit: The Battle of the Five Armies ◎年 代 2014 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2014-12-17(美国)/2015-01-23(中国大陆) ◎IMDb评分 7.5/10 from 307,296 users ◎IMDb链接 http://www.imdb.com/title/tt2310332/ ◎片 长 144分钟/164分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 马丁·弗瑞曼 Martin Freeman 伊恩·麦克莱恩 Ian McKellen 理查德·阿米蒂奇 Richard Armitage 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 本尼迪克特·康伯巴奇 Benedict Cumberbatch 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 比利·康诺利 Billy Connolly 凯特·布兰切特 Cate Blanchett 伊安·霍姆 Ian Holm 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 奥兰多·布鲁姆 Orlando Bloom 马努·贝内特 Manu Bennett 艾丹·特纳 Aidan Turner 迪恩·奥戈曼 Dean O’Gorman 格拉汉姆·麦克泰维什 Graham McTavish 斯蒂芬·弗雷 Stephen Fry 米卡埃尔·佩斯布兰特 Mikael Persbrandt ◎简 介 被吵醒的史矛革大闹长湖镇，最终为人类巴德（卢克·伊万斯 Luke Evans 饰）射杀。索林·橡木盾（理查德·阿米蒂奇 Richard Armitage 饰）多年的夙愿终于实现，孤山埃尔波尔重新回到矮人手中。然而这位矮人王子仿佛被史矛革的贪婪和堆成山的黄金迷惑了心窍，他 疯狂地搜寻象征王位的阿肯宝石，不仅撕毁了付给长湖镇报酬的约定，更拒绝了精灵王（李·佩斯 Lee Pace 饰）索要本族国宝的要求，为此导致三族的战争一触即发。与此同时，苍白半兽人阿索格率领大军浩浩荡荡向孤山逼近。得知消息的灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）从中调停斡旋，而被索林视为唯一朋友的霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）则掌握着中土命运的关键。五军会战，爆发在即！ 本片根据J.R.R·托尔金的同名原著改编，为霍比特人系列的最后一部。 ◎获奖情况 第17届美国青少年选择奖 (2015) 最佳科幻/奇幻电影(提名) 第87届奥斯卡金像奖 (2015) 最佳音效剪辑(提名) 霍比特人3.五军之战.国英双语中英双字The.Hobbit.The.Battle.of.the.Five.Armies.2014.EXTENDED.BluRay.1080p.x264.2Audios.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA3.%E4%BA%94%E5%86%9B%E4%B9%8B%E6%88%98.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.88GB%5D/"},{"title":"霍比特人2：史矛革之战蓝光加长版","text":"[2013][欧美][动作][BT下载][霍比特人2：史矛革之战蓝光加长版][BD-MKV/3.59GB][国英双语中英字幕][1080P][豆瓣8.1分好评奇幻冒险] ◎译 名 霍比特人2：史矛革之战/霍比特人2：史矛革荒漠/哈比人：荒谷魔龙(港)/哈比人：荒谷恶龙(台)/霍比特人2：斯毛戈荒漠/指环王前传：霍比特人(中) ◎片 名 The Hobbit: The Desolation of Smaug ◎年 代 2013 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2013-12-13(美国)/2014-02-21(中国大陆) ◎IMDb评分 8.0/10 from 413,210 users ◎IMDb链接 http://www.imdb.com/title/tt1170358/ ◎豆瓣评分 8.1/10 from 152,878 users ◎豆瓣链接 http://movie.douban.com/subject/11606328/ ◎片 长 161分钟/186分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 本尼迪克特·康伯巴奇 Benedict Cumberbatch 奥兰多·布鲁姆 Orlando Bloom 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 斯蒂芬·弗雷 Stephen Fry 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 约翰·贝尔 John Bell 马努·贝内特 Manu Bennett 杰德·布罗菲 Jed Brophy 亚当·布朗 Adam Brown 约翰·凯伦 John Callen 瑞安·盖奇 Ryan Gage 马克·哈德洛 Mark Hadlow 皮特·哈姆贝尔顿 Peter Hambleton 斯蒂芬·亨特 Stephen Hunter 威廉姆·吉尔切尔 William Kircher 西尔维斯特·迈可伊 Sylvester McCoy 格拉汉姆·麦克泰维什 Graham McTavish 迪恩·奥戈曼 Dean O’Gorman 米克尔·佩斯勃兰特 Mikael Persbrandt 艾丹·特纳 Aidan Turner ◎简 介 距离孤山越来越近，矮人远征军的道路却变得异常艰险。他们躲过了苍白半兽人的不懈追杀，在幽暗密林前和甘道夫（伊恩·麦凯伦 Ian McKellen 饰）兵分两路，后者前往多尔哥多探寻索伦的动向，而霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）和矮人们先是遭到巨大蜘蛛的袭击，随后又被精灵王子莱戈拉斯（奥兰多·布鲁姆 Orlando Bloom 饰）及其木精灵同伴捕获。比尔博急中生智，利用魔戒救出伙伴，继而引发了木精灵、半兽人和矮人远征军之间精彩纷呈的三方会战。借助巴德（卢克·伊万斯 Luke Evans 饰）的帮助，疲惫的矮人们暂时落脚长湖镇。近在咫尺的孤山城堡，沉睡在财宝中的巨龙即将醒来…… 本片根据J.R.R·托尔金的同名原著改编。 ◎获奖情况 第86届奥斯卡金像奖 (2014) 最佳视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 / Eric Reynolds 最佳音效剪辑(提名) Brent Burge 最佳混音(提名) 迈克·亨吉斯 / 托尼·约翰逊 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 第23届MTV电影奖 (2014) MTV电影奖 年度电影(提名) MTV电影奖 最佳打斗(提名) MTV电影奖 最佳银幕形象转变(提名) 奥兰多·布鲁姆 MTV电影奖 最佳英雄形象(提名) 马丁·弗瑞曼 第16届美国服装设计工会奖 (2014) 奇幻题材电影最佳服装设计(提名) 鲍勃·巴克 / 安·马斯克里 / 理查德·泰勒 第61届美国音效剪辑协会奖 (2014) 金卷轴奖 最佳电影音效剪辑(提名) David Farmer / Chris Ward / Hayden Collow / Craig Tomlinson / Justin Webster / Dave Whitehead / Melanie Graham / John Simpson 金卷轴奖 最佳配乐剪辑(提名) Jonathan Schultz / Steve Gallagher / Nigel Scott / Mark Willsher / Kirsty Whalley 第12届美国视觉效果协会奖 (2014) 最佳特效电影视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 最佳真人电影CG动画角色 大卫·克莱顿 / Eric Reynolds 最佳电影虚拟摄影(提名) Christian Rivers / Thelvin Cabezas 最佳真人电影模拟动画效果(提名) Areito Echevarria 最佳电影视觉效果合成(提名) Giuseppe Tagliavini / Charles Tait / Robin Hollander 第19届美国评论家选择电影奖 (2014) 最佳美术指导(提名) 丹·汉纳 / Ra Vincent 最佳服装设计(提名) 鲍勃·巴克 / Lesley Burkes-Harding / 安·马斯克里 / 理查德·泰勒 最佳化妆(提名) 最佳视觉效果(提名) 动作片最佳女主角(提名) 伊万杰琳·莉莉 第18届金卫星奖 (2014) 电影部门 最佳原创歌曲(提名) 第13届凤凰城影评人协会奖 (2013) 最佳原创配乐(提名) 霍华德·肖 霍比特人2.史矛革之战..国英双语中英字幕.The.Hobbit.2013.EXTENDED.1080p.BluRay.x264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA2%EF%BC%9A%E5%8F%B2%E7%9F%9B%E9%9D%A9%E4%B9%8B%E6%88%98%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.59GB%5D/"},{"title":"序列化面试题","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243面试相关1. 反序列化后的对象，需要调用构造函数重新构造吗 反序列化调用不会调用构造函数。以存储的二进制数据进行构造2. 序列前的对象与序列化后的对象是什么关系？是(&quot;==&quot;还是equal？是浅复制还是深复制？) 序列化前和序列化后 是两个不同的对象，对象地址发生了改变。调用equal 和 == 返回true。是一个深复制。3. Android里面为什么要设计出Bundle而不是直接用Map结构 Bundle中是使用的Parcel打包数据。Parcel可以实现跨进程通讯。 &lt;!-- more --&gt; Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数 据对应下标，一个对象数组 保存key和value，内部使用二分法对key进行排序，所以在添加、删 除、查找数据的时候，都会使用二分法查找，只适合于小数 据量操作，如果在数据量比较大的情况 下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候， HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据 量，我没见过在两个Activity之 间传递10个以上数据的场景，所以相比之下，在这种情况下使用 ArrayMap保存数据，在操作速度和内存占用上都具有优势， 因此使用Bundle来传递数据，可以保 证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话， 需要数据是基本类型或者是可 序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。 而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为 了更加快速的进行数据的序列化和反序列化， 系统封装了Bundle类，方便我们进行数据的传输。4. SerialVersionID的作用是什么？ 版本控制5. Android中Intent/Bundle的通信原理及大小限制 大小限制 bundle 在zgote在创建进程的时候，分配了binder的内存大小。binder申请匿名内存有限制。 binder在内核空间创建内存映射时，大小限制在 &lt; 4M intent 1M限制 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限 制的(有些手机是 2 M)， 而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区 就更小了( 有人以前做过测试，大约一个线程可以占用 128 KB)。 所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时， 你应 该知道怎么解决了6. 为何Intent不能直接在组件间传递对象而要通过序列化机制？ startActivity（intent），activity启动流程要和AMS交互，需要跨进程通讯。只有把数据序列化后，传递。7. 序列化与持久化的关系和区别是什么？ 序列化:跨进程传输数据时，需要使用序列化。 持久化:数据的存储。 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程 (intent.prepareToLeaveProcess())， 这也就意味着，Intent所携带的数据要能够在不同进程间 传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输， 所以我 们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间 传输。 而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel 容器 ，后者也是Android系统专门推出的用于进程间通信等的接口","link":"/2020/09/11/%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Android 基础知识总结","text":"​ Activity生命周期 img Fragment生命周期 Activity**四种启动模式** standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard**模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Service**的生命周期与启动方法由什么区别？** startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service**生命周期：** 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 广播**发送和接收的原理了解吗**？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。、 Android Handler机制是做什么的，原理了解吗 主要涉及的角色如下所示： 1.Message:消息,分为硬件产生的消息（例如:按钮、触摸）和软件产生的消息。 2. MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。 3. Looper：消息循环器，主要用来把消息分发给相应的处理者。 4. Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。 整个消息的循环流程还是比较清晰的，具体说来： 1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。 2. Looper通过loop()循环提取触发Message,并将Message交给对应的target handler来处理。 3. target handler调用自身的handleMessage()方法来处理Message。 如何自定义android控件 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure(int widthMeasureSpec, int heightMeasureSpec) 布局onLayout(boolean changed, int left, int top, int right, int bottom) 绘制onDraw(Canvas canvas) onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 描述一下**View的绘**制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。 ④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 requestLayout()**、invalidate()与postInvalidate()有什么区别？** requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定 会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 APK的打包流程 1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。 2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。 3. 通过Javac工具编译项目源码，生成Class文件。 4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。 5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。 6. 利用KeyStore对生成的APK文件进行签名。 7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件 的速度会更快。 APK的安装流程 1. 复制APK到/data/app目录下，解压并扫描安装包。 2. 资源管理器解析APK里的资源文件。 3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。 4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。 5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 6. 安装完成后，发送广播。 Android Binder**机制是做什么的，为什么选用Binder，原理了解吗？** Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。 为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种： 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息**队**列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \\6. 信号 : 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进 程等； 既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量： 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全 是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。","link":"/2020/09/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it&apos;s upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法：requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact MeQQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2019/10/11/Android%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%E4%BC%A0%E8%BE%93DEMO/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： | 搬瓦工配置 | 搬瓦工费用 | 优惠链接 || — | — | — || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $25.99/半年 | 点击进入 || SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 40 GB RAID-10RAM内存: 2048 MBCPU处理器: 1x Intel XeonTransfer流量: 2000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $27.99/季 | 点击进入 || SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 1x Intel XeonTransfer流量: 1000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $29.99 /半年 | 点击进入 || 80G KVM – PROMOSSD硬盘: 80 GB RAID-10RAM内存: 4 GBCPU处理器: 4x Intel XeonTransfer流量: 3 TB/mo连接速度: 1 GigabitMultiple locations | $19.99/月 | 点击进入 || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $49.99/年 | 点击进入 || 40G KVM – PROMOSSD硬盘: 40 GB RAID-10RAM内存: 2 GBCPU处理器: 3x Intel XeonTransfer流量: 2 TB/mo连接速度: 1 GigabitMultiple locations | $99.99/年 | 点击进入 || 160G KVM – PROMOSSD硬盘: 160 GB RAID-10RAM内存: 8 GBCPU处理器: 5x Intel XeonTransfer流量: 4 TB/mo连接速度: 1 GigabitMultiple locations | $39.99/月 | 点击进入 || 3200G KVM – PROMOSSD硬盘: 320 GB RAID-10RAM内存: 16 GBCPU处理器: 6x Intel XeonTransfer流量: 5 TB/mo连接速度: 1 GigabitMultiple locations | $79.99/月 | 点击进入 | 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：1yum install wget 执行安装ss：1wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限1chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限1chmod +x bbr.sh 启动BBR安装1./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2019/10/11/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%BF%AB%E9%80%9F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BASS(Shadowsocks)%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"注解相关知识","text":"注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解有一个属性value，是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，@Retention 注解指定标记注解的存储方式：RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略。 这是默认的生命周期；RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此运行时环境可以使用它。 @Target 注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：ElementType.ANNOTATION_TYP可以应用于注解类型。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.METHOD 可以应用于方法级注解。ElementType.PACKAGE 可以应用于包声明。ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。 package com.example.inject; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; 在Activity 中增加注解标注，通过注解+反射+动态代理等，来优化Activity中代码。省去 setContentView、findViewById、setOnClickListener等操作。Layout注解12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectLayout { @LayoutRes int value();} View注解12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface InjectView { @IdRes int value();} OnClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent(listenerSetter = &quot;setOnClickListener&quot;, listenerType = View.OnClickListener.class, methodName = &quot;onClick&quot;)public @interface OnClick { int[] value();} OnLongClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent( listenerSetter= &quot;setOnLongClickListener&quot;, listenerType= View.OnLongClickListener.class,methodName = &quot;onLongClick&quot;)public @interface OnLongClick { int[] value();} 元注解 标注 OnClick OnLongClick 的注解1234567@Target(ElementType.ANNOTATION_TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectEvent { String listenerSetter(); Class&lt;?&gt; listenerType(); String methodName();} 注解管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.example.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManage { public static void inJect(Activity activity) { injectLayout(activity); injectView(activity); injectEvent(activity); } /** * 依赖注入 layoutId布局 * 获取 Activity 上的注解 * * @param activity */ private static void injectLayout(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity是否为InjectLayout修饰 if (clazz.isAnnotationPresent(InjectLayout.class)) {// 3.获取InjectLayout注解 InjectLayout annotation = clazz.getAnnotation(InjectLayout.class); if (annotation != null) { try {// 4.通过反射获取 当前Activity 的 setContentView 方法 Method method = clazz.getMethod(&quot;setContentView&quot;, int.class);// 5.获取注解上的value layoutId int resourceId = annotation.value();// 6.调用setContentView method.invoke(activity, resourceId); } catch (Exception e) { e.printStackTrace(); } } } } /** * 依赖注入 获取View * * @param activity */ private static void injectView(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity中所有的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) {// 3. 判断字段是否为InjectView修饰 if (field.isAnnotationPresent(InjectView.class)) { InjectView injectView = field.getAnnotation(InjectView.class); if (injectView != null) { try {// 4.反射获取findViewById方法 Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);// 5.获取资源id int resourceId = injectView.value();// 6.获取View对象 View view = (View) method.invoke(activity, resourceId);// 7.设置访问权限 field.setAccessible(true);// 8.将反射获取到的view赋值到Activity上 field.set(activity, view); } catch (Exception e) { e.printStackTrace(); } } } } } /** * 依赖注入 获取 OnClick OnLongClick注解事件 * 注解 + 反射 + 动态代理 * * @param activity */ private static void injectEvent(Activity activity) { if (activity == null) { throw new NullPointerException(); } try {// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.获取Activity的所有成员方法 排除继承方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) {// 3.是否是自定义注解修饰 if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理 OnClick onClick = method.getAnnotation(OnClick.class); int[] value = onClick.value();// 4.获取注解上的注解 元注解 InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class); String listenerSetter = injectEvent.listenerSetter(); Class&lt;?&gt; listenerType = injectEvent.listenerType(); String methodName = injectEvent.methodName();// 5.动态代理 生成代理的listener ProxyHandler handler=new ProxyHandler(activity); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]{listenerType}, handler); handler.mapMethod(methodName,method);// 6.反射获取 findViewById方法的Method对象 Method findViewByIdMethod = clazz.getMethod(&quot;findViewById&quot;, int.class); findViewByIdMethod.setAccessible(true); for (int id : value) {// 7.通过findViewById获取view View btn = (View) findViewByIdMethod.invoke(activity, id);// 8.根据listenerSetter方法名和listenerType方法参数找到method Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType); listenerSetMethod.setAccessible(true); listenerSetMethod.invoke(btn, listener); } } } } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } }} ProxyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.inject;import android.app.Activity;import android.util.Log;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ProxyHandler implements InvocationHandler { private WeakReference&lt;Activity&gt; mHandlerRef; private HashMap&lt;String, Method&gt; mMethodHashMap; public ProxyHandler(Activity activity) { mHandlerRef = new WeakReference&lt;&gt;(activity); mMethodHashMap = new HashMap&lt;&gt;(); } public void mapMethod(String name, Method method) { mMethodHashMap.put(name, method); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { try { Object handler = mHandlerRef.get(); if (null == handler) return null; String name = method.getName(); //将onClick方法的调用映射到activity 中的注解标注的方法 Method realMethod = mMethodHashMap.get(name);// Log.i(&quot;injectEvent&quot;, &quot;proxy=&quot; + proxy + &quot;,method=&quot; + method.getName() + &quot;,realMethod=&quot; + realMethod); if (null != realMethod) { return realMethod.invoke(handler, args); } } catch (Exception e) { e.printStackTrace(); } return null; }} 12345678910111213141516171819202122232425262728293031323334@InjectLayout(value = R.layout.activity_network)public class NetworkActivity extends AppCompatActivity { @InjectView(R.id.get_data) Button button; @InjectView(R.id.get_data2) Button button2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); InjectManage.inJect(this);// setContentView();// button=findViewById(R.id.button)// button.setOnClickListener(new View.OnClickListener() {// @Override// public void onClick(View v) {// testNetWorkApi();// }// });// button.setOnLongClickListener(new View.OnLongClickListener() {// @Override// public boolean onLongClick(View v) {// return false;// }// }); } @OnClick({R.id.get_data,R.id.get_data2}) public void onClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onClick&quot;); } @OnLongClick(R.id.get_data) public void onLongClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onLongClick&quot;); } 期间遇到点小问题，就是动态代理这块，对这块理解不够深。首先 Activity中 使用OnClick注解修饰的方法onClick()是需要传入参数的，否则在动态代理里，动态代理回调这个方法就会出错。","link":"/2020/09/11/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"搭建 WordPress 博客教程（超详细）","text":"本文转自：Nonecy 的小黑屋*链接：http://blog.studymany.com/2018/07/29/create-wordpress-blog/* 需要 一台服务器 一个域名，直接通过ip访问好傻好傻的样子，哈哈。 linux知识 肯折腾 具体步骤第一步购买服务器，国内阿里云的云服务器挺不错的，国外的就更多了，这一步就不介绍了，不懂得的自己上网搜。接下来操作需要： 远程连接服务器Windows 用户 以Xshell为例。 下载安装Xshell，官网链接。 安装完成后新建会话（Alt+N）。依次填写图中信息。名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。 连接 点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） 用户身份验证 填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 Mac OS 用户 打开终端或者iTerm2等。 1ssh root@45.32.195.77 然后输入密码即可。 安装nginx，mysql，php建议使用lnmp一键安装包安装，方便快捷。如果不用一键安装包，我估计得研究这一块的东西大概一周吧。下面以一键安装包为例。 获取lnmp一键安装包链接 lnpm官网链接 找到下载页面选择最新的复制其链接。 写此文时最新版本信息如下： 1234LNMP 1.4 测试版http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz (131KB)MD5：bd851e151b2ba13c3a32c435efb1a76c最后更新: 2017年2月14日14:18 GMT+8 其中的http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz就是我们需要的链接，复制到剪贴板。 安装 12345678# 下载，后边的路径直接粘贴就好。XShell上面复制快捷键是ctrl+insert，粘贴快捷键是Shift+insert，mac上面是我们熟悉的 command+c，command+vwget http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz# 解压tar -zxvf lnmp1.4beta.tar.gz# 进入lnmp目录cd lnmp1.4# 执行install.sh进行安装./install.sh lnmp 依次输入你要安装的选项前的数字并回车即可下一步。 MYSQL 选项 123456789You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.53 (Default)3: Install MySQL 5.6.344: Install MySQL 5.7.165: Install MariaDB 5.5.536: Install MariaDB 10.0.287: Install MariaDB 10.1.190: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 此处根据所需选择，如果使用的上述服务器，请选择2或者直接回车。我选择默认。 注意：安装MySql时，如果选择太高的版本安装会被拒绝，提示信息如下 Memory less than 1GB, can't install MySQL 5.6, 5.7 or MairaDB 10!。根据个人手动安装MySql5.7的经验来看，此768MB内存的服务器在运行一个nginx，mysql，php时还好，倘若再运行一个tomcat，mysql将会不定期down掉。所以此处选择一个低版本的5.5MySql即可。 1234You will install MySQL 5.5.53===========================Please setup root password of MySQL.(Default password: root)Please enter: 输入密码回车或直接回车，直接回车默认密码为root。此处做实验我选择默认，个人实际使用请修改。 1234MySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: 输入Y或者n然后回车或直接回车，直接回车默认启用InnoDB存储引擎。我选择默认。 1234567891011No input,The InnoDB Storage Engine will enable.===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.306: Install PHP 7.0.157: Install PHP 7.1.1Enter your choice (1, 2, 3, 4, 5, 6 or 7): 输入选项然后回车或者直接回车，直接回车默认安装PHP5.5.38版本。我选择默认。 12345You will install PHP 7.1.1===========================You have 3 options for your Memory Allocator install.1: Don't install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMalloc 输入选项然后回车或者直接回车，直接回车默认不安装内存分配器。我选择默认。 此时出现 1Press any key to install...or Press Ctrl+c to cancel 当然是摁任意键啦，一般都是回车咯。 然后出现一大堆信息。前几行如下： 12345678910111213You will install lnmp stack.nginx-1.10.3mysql-5.5.53php-5.5.38Enable InnoDB: yPrint lnmp.conf infomation...Download Mirror: http://soft.vpser.netNginx Additional Modules: PHP Additional Modules: Database Directory: /usr/local/mysql/varDefault Website Directory: /home/wwwroot/defaultCentOS release 6.8 (Final)Kernel \\r on an \\m 这一堆东西你就不用管啦。本次实验的开始时间23:04……经过了漫长漫长漫长的等待之后……大概23:35结束。所以期间你去洗个澡看个电视剧都不是问题。然后我们看到屏幕上最后输出的信息如下。 1234The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.Add Startup and Starting LNMP...Add nginx service at system startup...Starting nginx... doneAdd mysql service at system startup...Starting MySQL... SUCCESS! Add php-fpm service at system startup...Starting php-fpm done============================== Check install ==============================Checking ...Nginx: OKMySQL: OKPHP: OKPHP-FPM: OKClean src directory...+------------------------------------------------------------------------+| LNMP V1.4 for CentOS Linux Server, Written by Licess |+------------------------------------------------------------------------+| For more information please visit https://lnmp.org |+------------------------------------------------------------------------+| lnmp status manage: lnmp {start|stop|reload|restart|kill|status} |+------------------------------------------------------------------------+| phpMyAdmin: http://IP/phpmyadmin/ || phpinfo: http://IP/phpinfo.php || Prober: http://IP/p.php |+------------------------------------------------------------------------+| Add VirtualHost: lnmp vhost add |+------------------------------------------------------------------------+| Default directory: /home/wwwroot/default |+------------------------------------------------------------------------+| MySQL/MariaDB root password: root |+------------------------------------------------------------------------++-------------------------------------------+| Manager for LNMP, Written by Licess |+-------------------------------------------+| https://lnmp.org |+-------------------------------------------+nginx (pid 715 713) is running...php-fpm is runing! SUCCESS! MySQL running (1247)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp6 0 0 :::22 :::* LISTEN Install lnmp V1.4 completed! enjoy it. 简单说明一下，此安装过程安装完成便也启动了nginx，mysql，php-fpm并加入了开机启动项。如果重启服务器，不需要再单独手动开启相关的服务了。总的来说相当方便的。 关于Linux服务，自己之前做的笔记分享给大家。Linux 服务管理 这时候你在浏览器输入http://IP 例如 http://45.32.195.77便可以访问了。看到的内容如下： 访问页面 网站根目录路径/home/wwwroot/default,如果只用来放一些静态页面，那么，现在就足够了，直接将你的html，js，css等文件丢进去即可。这不是本文重点，在此不赘述了。 退出使用ctrl+c 安装WordPress下载WordPress包 中文官方站点英文官方站点具体的根据自己的需求选择。下面以中文版为例。当前最新版本是4.7.2 为了方便，我们还是在用站点默认的路径，但是我们投机取巧一下。 1234567891011121314# 进入根目录上一级目录cd /home/wwwroot/# 将default重命名为oldmv default old# 下载WordPress包中文版wget https://cn.wordpress.org/wordpress-4.7.2-zh_CN.tar.gz# 解压WordPress包tar -zxvf wordpress-4.7.2-zh_CN.tar.gz # 查看解压后的文件夹名，此处是wordpress，估计应该都是吧，看看保险啊[root@vultr wwwroot]# lsold wordpress wordpress-4.7.2-zh_CN.tar.gz# 将wordpress重命名为defaultmv wordpress default# 再次查看检验[root@vultr wwwroot]# lsdefault old wordpress-4.7.2-zh_CN.tar.gz 给相应目录授权 12345# 目录以及目录下的文件授权[root@vultr wwwroot]# chown -R 755 /home/wwwrootchown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted# 将目录的所有者分给www组下的www用户。[root@vultr wwwroot]# chown -R www:www /home/wwwroot/chown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted 出现的提示大概是说有一个文件无法更改用户分组和权限。不会影响你的wordpress，忽略就好。 创建一个数据库wordpress 1234567891011121314151617181920212223242526# 登录数据库mysql -u root -p# 输入密码默认的话就是root，否则就是你自己之前设置的那个# 登录进来之后，看到这样一些东西Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.53-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respective owners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; # 不用理会上面的，创建我们的数据库，比如名字为wordpress。记得加分号。mysql&gt; create database wordpress;# 看一下，有没有我们创建的数据库mysql&gt; show databases;# 大概看到如下内容。意味着这一步也没问题。+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.01 sec)# 退出mysqlexit 配置WordPress 这时候在此通过浏览器访问 http://IP 例如 http://45.32.195.77，浏览器将自动跳转到http://45.32.195.77/wp-admin/setup-config.php，这就是wordpress的配置页面了，看到的内容如下： 访问页面 点击现在就开始。这时候我们看到如下页面: 数据库配置 按照之前设置的，输入如下信息。 12345数据库名：wordpress用户名：root密码：root数据库主机：localhost表前缀：wp_ 点击提交。 数据库连接完成 到这一步，基本上就意味着大功告成了，因为后边基本不会出错啦。 点击进行安装按钮。出现下图： wordpress 设置 按照自己的需求填写，比如我这里填写如下： wordpress 我的设置 点击安装WordPress按钮，然后登录设置啥的纯页面操作就不在这里过多介绍咯。 主页大概是这样的 后期问题解决有问题的反馈在此，我会进行补充。 主题只显示一个原因：php没有权限读取文件目录。 解决方案：编辑php.ini文件中的disable_functions字段，将其中的scandir去掉。 123456# 使用一键安装包安装的php的配置文件路径如下vi /usr/local/php/etc/php.ini# 查找disable_functions在当前的底行模式下输入 /disable_functions,便可以找到这样一行disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server# 删掉其中的scandir，此处很容易搞乱，所以有必要会使用编辑模式，摁i进入编辑模式。就可以输入删除了。# 退出编辑模式，并保存退出。esc退出编辑模式，:wq保存退出。 更多的指令看我之前的一个简单的入门笔记吧。Linux VIM 文本编辑器 然后记得重启php-fpm服务 1/etc/init.d/php-fpm restart 这样再刷新，就会发现主题不只有一个啦。 更多如果你使用MarkDown，那么请安装JetPack插件，如果你需要语法高亮，请安装Crayon Syntax Highlighter。 以后可能会深入研究一下，有机会的话会专门写一篇文章介绍WordPress主题与插件的哈。","link":"/2020/09/11/%E6%90%AD%E5%BB%BA%20WordPress%20%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"},{"title":"MacOS快捷键说明","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 聚焦快捷键 启动快捷键 iTunes 快捷键：从 iTunes 菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。","link":"/2020/09/11/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; } 在android 中配置 sourceSets { main { jni.srcDirs = [&apos;src/main/jni&apos;, &apos;src/main/jni/&apos;] } } externalNativeBuild { ndkBuild { path &apos;src/main/jni/Android.mk&apos; } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2019/10/11/SerialportManager/"},{"title":"各种学习资料，包括一些百度云视频链接还有pdf资料 --搬运工","text":"人生不如意事常八九 共勉 【0】Springboot微服务开发天气预报系统视频教程 https://pan.baidu.com/s/1joz7flyztCq8oklBlsz8dQ 提取密码：cpz7 【1】JAVA300集大型视频教程2018版发布 https://pan.baidu.com/s/1Bqy4mWSD1idd6JmIzS9ZLg 提取密码：llg2 【2】Vue2.5开发去旅游网站App从零基础入门到实战项目 https://pan.baidu.com/s/1DYCoIw_b893KXGkkYt_92Q 提取密码：bgoy 【3】opencv+tensorflow入门人工智能图像处理视频教程+源码下载 https://pan.baidu.com/s/10WefZkTQST094L5UQA7myg 提取密码：7b9w 【4】最新BAT面试真题讲解，想去大厂的别错过 https://pan.baidu.com/s/1ejf2Eh8ZA-T1bWbuT6gw0A 提取密码：mist 【5】Python3异步IO并发编程高级进阶视频教程下载 https://pan.baidu.com/s/1jiRwD5MNPmAKF98nXYzmKg 提取密码：hct4 【6】最新大数据数据分析与挖掘高级工程师第三期视频教程 https://pan.baidu.com/s/1g8xGPag9GiMA4_MEKbxePw 提取密码：z2v3 【7】姜承尧MYSQL,DBA视频课程(44天全)视频教程下载 https://pan.baidu.com/s/19NUjkkvdDZXhw1QG4yX21Q 提取密码：funf 【8】Python+AnsiblePlaybook+Django自动化运维项目实践课程 https://pan.baidu.com/s/1CfOHuaYi_TdPoAUzP9AW1w 提取密码：o3rc 【9】springcloud微服务实践-分布式与原理剖析链路追踪容器 https://pan.baidu.com/s/1g8QoqOnQwjI7N3zDSccr-w 提取密码：ygf5 【10】2018年最新Java高并发知识体系与高并发编程架构课程视频教程下载 https://pan.baidu.com/s/1E1NhSevRqwdnguiKSsOp5A 提取密码：mkh2 【11】2018年最新价值300Python人工智能TensorFlow框架应用实践视频课程下载 https://pan.baidu.com/s/1qYJjFz9aG6M5grMg311uRQ 提取密码：5hzp 【12】谭州学院价值1680元python视频教程12306网站案例vip特训班教程 https://pan.baidu.com/s/1yEQq5W1eSc3NA4XmyNmuJw 提取密码：cipi 【13】下载 https://pan.baidu.com/s/1D6hYdyi4ti2zpnKHVWWbEg 提取密码：glov 【14】Netty实战高性能分布式RPC视频教程下载 https://pan.baidu.com/s/1sDHh_g624MO08MTFIrwEDw 提取密码：mwa6 【15】2018年最新尚学堂Vue2全套学习视频教程下载 https://pan.baidu.com/s/147NvAV-Qse90xvTYDvHBcg 提取密码：wpfg 【16】最新2018疯狂SpringCloud微服务架构实战视频教程 https://pan.baidu.com/s/1jgC0lagtMG7tArATrAAHXg 提取密码：10kf 【17】kotlin高级教程从零开始开发完整安卓商城app https://pan.baidu.com/s/13F_C1aKuJ0ek5Kv-HWdygw 提取密码：krq2 【18】2018年最新疯狂Activiti6视频教程疯狂工作流讲义Activiti6.x视频教程 https://pan.baidu.com/s/1SriGV7tZAeSvYcYb6l_hdQ 提取密码：bzcu 【19】基于MyCat的MySQL高可用读写分离集群实战课程下载 https://pan.baidu.com/s/1DVCf57_O1iMDJkbOGxdnpw 提取密码：6a08 【20】2018年最新Webpack3由浅入深及搭载vue,react,angular框架多维度讲解 https://pan.baidu.com/s/1BYq5qb9fFMSyODlORBQCcw 提取密码：6wf3 【21】2018年最新Spark机器学习课程：智能客户系统项目实战视频教程 https://pan.baidu.com/s/12SrMtvLBlVJGOlOt5NQFjw 提取密码：uu9v 【22】最新离线数据分析平台实战驴妈妈项目实战培训视频教程 https://pan.baidu.com/s/129jhYGDLFzsM7BW5HYdg7Q 提取密码：vhjs 【23】2018年最新尚硅谷java9新特性视频教程下载 https://pan.baidu.com/s/1xC-xPm54rFMLAHYwis1Thg 提取密码：f0v6 【24】最新北风网人工智能+机器学习+深度学习+推荐系统实战第3期视频教程 https://pan.baidu.com/s/1E98ZYCtJ7Mom_tWZT6AM_g 提取密码：3abb 【25】[全栈开发]Vue+DjangoRESTframework打造生鲜电商项目视频教程 https://pan.baidu.com/s/1vFAkTEdydgL-GjdcpeEHGg 提取密码：k00f 【26】2018年最新node.js+ES+Koa2手把手教你开发一个短视频网站视频教程 https://pan.baidu.com/s/1jmxxQ88J_qWsovXkMNeDpQ 提取密码：46yh 【27】基于Java的微信平台开发教程视频下载 https://pan.baidu.com/s/1hMq-J7KFMuDezGSdzX35OA 提取密码：oycw 【28】最新精选蚂蚁-MySQL语句性能优化视频教程下载 https://pan.baidu.com/s/1miVf8Ze 提取密码：w5yt 【29】深度学习实战项目-利用RNN与LSTM网络原理进行唐诗生成视频课程 https://pan.baidu.com/s/1i6jyFtz 提取密码：vrzx 【30】2018年最新微信小游戏开发ES6+小游戏api开发视频教程下载 https://pan.baidu.com/s/1i7mwJCp 提取密码：ndl7 【31】最新甲骨论-Linux大数据及数据库存储视频教程下载 https://pan.baidu.com/s/1smi2oNj 提取密码：ypgn 【32】泰牛2017php基础班大牛班完整视频教程下载 https://pan.baidu.com/s/1ggKGo9d 提取密码：2tqk 【33】2018年最新Java微服务原理课程与改造房产销售平台视频教程 https://pan.baidu.com/s/1jKf8MMi 提取密码：i8ej 【34】使用dubbo、spring-boot等技术实现互联网后台服务项目架构视频教程 https://pan.baidu.com/s/1gg1JiBD 提取密码：1jtk 【35】最新区块链开发入门到精通视频教程下载 https://pan.baidu.com/s/1kW7FTwr 提取密码：hvep 【36】2018年最新价值1699元的深入大数据架构师之路，问鼎40万年薪视频教程下载 https://pan.baidu.com/s/1c3d1RbU 提取密码：22kw 【37】2018年最新java大数据基于storm开发实时流处理器视频教程 https://pan.baidu.com/s/1cOCHPk 提取密码：igw9 【38】2017年最新JAVA-ACE-架构师系列视频课程-RocketMQhttps://pan.baidu.com/s/1ghb9UAf 提取密码：sstz 【39】2017年深度学习项目实战视频课程-Seq2Seq序列生模型视频教程 https://pan.baidu.com/s/1dGEDwSp 提取密码：96eh 【40】2017年最新web前端工程师小白零基础入门到大神全套教程下载 https://pan.baidu.com/s/1dFQ8wgT 提取密码：7g4e 【41】2017年最新python高级模块matplotlib数据可视化分析视频教程 https://pan.baidu.com/s/1kWyRVmB 提取密码：qjaj 【42】价值1680元安卓特训班实战开发百思不得姐app项目教程下载 https://pan.baidu.com/s/1c3adHsc 提取密码：sxvg 【43】2018年最新价值799元Elasticsearch顶尖高手系列：高手进阶篇视频教程 https://pan.baidu.com/s/1mkkSBrU 提取密码：zmjn 【44】2017年最新深度学习框架Caffe使用案例视频课程下载 https://pan.baidu.com/s/1dGFsBnz 提取密码：q4dg 【45】炼数成精大数据的矩阵计算基础课程下载 https://pan.baidu.com/s/1mkaJbpY 提取密码：pnnc 【46】2018年最新redis从入门到精通与分布式架构视频教程下载 https://pan.baidu.com/s/1gggc7Fd 提取密码：img8 【47】2018年最新动力节点Java夜校视频教程下载 https://pan.baidu.com/s/1i6v7013 提取密码：dbnt 【48】全网最新基于ElasticSearch的找房网实战开发企业级房屋搜索网视频教程下载 https://pan.baidu.com/s/1bqUVrsF 提取密码：idjy 【49】Java高性能高并发秒杀系统实战视频教程下载 https://pan.baidu.com/s/1bqVBoqb 提取密码：ztqe 【50】2017最新最系统的PHP面试视频教程下载高薪无忧 https://pan.baidu.com/s/1o81Mu8q 提取密码：da2f 【51】2017年最新炼数成金机器读心术之神经网络与深度学习视频教程下载 https://pan.baidu.com/s/1mhJkQzI 提取密码：pvc6 【52】李兴华系列之Java8、Oracle、JavaScript、HTML5、Spring、Struts、Hibernate系列视频教程下载 https://pan.baidu.com/s/1o7O6ytc 提取密码：icgf 【53】2017年最新Python+scripy实现搜索引擎爬虫课程视频教程下载 https://pan.baidu.com/s/1mhLSFVy 提取密码：n333 【54】最新某某学院大数据工程师视频教程下载 https://pan.baidu.com/s/1o7Cvjwm 提取密码：ximb 【55】2017年Javaweb开发工程师成长之路全套视频教程附配套资料下载 https://pan.baidu.com/s/1qXJcyVa 提取密码：31di 【56】php高性能yii2框架开发高性能高可用负载均衡集群架构商城视频教程下载 https://pan.baidu.com/s/1jIKk70i 提取密码：b9bt 【57】2017最新兄弟连laravel入门到精通+博客实战开发教程下载 https://pan.baidu.com/s/1bZJAW2 提取密码：6p4c 【58】2017年最系统的PHP教程高薪就业视频教程下载 https://pan.baidu.com/s/1o7DG2pW 提取密码：rrds 【59】2017最新大数据10个小时快速入门hadoop3集群实战视频教程 https://pan.baidu.com/s/1hsgtagG 提取密码：dwin 【60】2017年最新Webpack+React全栈工程架构项目实战精讲视频教程下载 https://pan.baidu.com/s/1hsq2s64 提取密码：gprc 【61】2017年最新Uber车辆监控系统设计实战训练营高清视频教程全套附讲义代码 https://pan.baidu.com/s/1nv9Vm5b 提取密码：5bs8 【62】2017年最新DS206人脸识别与分析系统实战训练营硅谷讲师授课高清视频教程全套附讲义代码4周 https://pan.baidu.com/s/1c2LcBsc 提取密码：nv1h 【63】2017年最新React开发Native开发安卓与ios平台的GitHubApp视频教程 https://pan.baidu.com/s/1jI6DiXg 提取密码：7cyk 【64】2017年最新Google面试官亲授java校招面试视频讲解教程下载 https://pan.baidu.com/s/1nuDIkQ1 提取密码：hhnu 【65】Android传感器、无线传输与媒体硬件功能开发视频教程下载 https://pan.baidu.com/s/1bpoA4EV 提取密码：cvh9 【66】最新Kaggle神器之XGBoost从入门到精通高清精品视频教程附代码教程下载 https://pan.baidu.com/s/1nvj6fDR 提取密码：x493 【67】Oracle商业智能BI产品OBIEE11G深入浅出全套视频教程下载 https://pan.baidu.com/s/1o81KXPg 提取密码：f3sg 【68】2017年最新小象学院分布式爬虫第二期视频教程 https://pan.baidu.com/s/1geX7fKB 提取密码：2ac9 【69】mongodb从入门到精通高清视频教程下载 https://pan.baidu.com/s/1cpsdjC 提取密码：3ng4 【70】最新大数据快速数据挖掘平台RapidMiner数据分析视频教程下载 https://pan.baidu.com/s/1bpFE111 提取密码：3z6u 【71】最新Python自然语言分析视频课程下载 https://pan.baidu.com/s/1ge40FbP 提取密码：wa5r 【72】最新尚学堂redis视频教程下载 https://pan.baidu.com/s/1c35hRg 提取密码：gy5j 【73】最新oracle11gDBA开发和应用数据库视频教程下载 https://pan.baidu.com/s/1o7YE5Bk 提取密码：eu68 【74】2017vue2nodemongoKoa2Nuxt/VueSSR全栈开发小程序商城视频教程 https://pan.baidu.com/s/1jIw3lR4 提取密码：bmia 【75】最新python数据分析升级版视频教程下载 https://pan.baidu.com/s/1i5L7LdV 提取密码：bfk7 【76】Python数据分析(机器学习)经典案例视频教程 https://pan.baidu.com/s/1nuUCPlf 提取密码：3ytg 【77】DB2数据库性能优化视频教程下载 https://pan.baidu.com/s/1qYysRDE 提取密码：i1rx 【78】2017年node.js零基础入门到企业级全栈案例开发教程下载 https://pan.baidu.com/s/1eRBopRs 提取密码：ne2a 【79】Hadoop大数据视频教程：真实电商数据仓库全流程开发详解(共46讲)视频教程下载 https://pan.baidu.com/s/1bpMzOyr 提取密码：m3yt 【80】最新老男孩python全栈工程师第2期全套完整版视频教程下载 https://pan.baidu.com/s/1cIycbk 提取密码：cgfm 【81】价值2400元的python全栈开发系列FlaskPythonWeb网站编程视频教程 https://pan.baidu.com/s/1qXATJju 提取密码：huc3 【82】最新python从入门到精通到开发爬虫实例视频教程 https://pan.baidu.com/s/1mirFpeK 提取密码：9gmt 【83】极客学院VIP教程postgresql教程全集视频教程下载 https://pan.baidu.com/s/1i4DjPdF 提取密码：qgga 【84】最新angular4.x框架与redux开发大型企业级管理项目视频教程下载 https://pan.baidu.com/s/1nvEDQNB 提取密码：mqvu 【85】2017年数据分析与机器学习实战到经典案例全套高清视频教程（基于Python3.5anaconda4.2）15G https://pan.baidu.com/s/1nvqXoPN 提取密码：irdj 【86】2017年最新大数据实时分析Storm入门到精通学习路线视频教程 https://pan.baidu.com/s/1pL7OfvP 提取密码：2ze2 【87】使用php高可用webapp后端开发视频教程下载 https://pan.baidu.com/s/1qXTQ5FQ 提取密码：pybc 【88】2017年最新java算法详解与算法开发小游戏视频教程下载 https://pan.baidu.com/s/1dF0GWNn 提取密码：t6tk 【89】2017年9月最新pythonflask开发小视频网站视频教程 https://pan.baidu.com/s/1nuHfvZF 提取密码：pygf 【90】2017年5月炼数成金《MySQLDBA从小白到大神实战》视频教程 https://pan.baidu.com/s/1jHFP8sm 提取密码：qnmj 【91】Vue从入门到精通视频教程 https://pan.baidu.com/s/1pKCX6Wj 提取密码：h6hd 【92】北风网从C++起步到MFC实战VC++软件工程师高端培训(服务器端开发方向)332课全 https://pan.baidu.com/s/1c1SSWKg 提取密码：iw7p 【93】2017最新python3从零基础入门到精讲超清视频教程 https://pan.baidu.com/s/1c2Nd468 提取密码：h46d 【94】2017年最新使用MUI开发跨平台混合APP全套完整视频教程 https://pan.baidu.com/s/1dFxYZ0d 提取密码：9ury 【95】最新人脸识别深度学习项目实战视频教程 https://pan.baidu.com/s/1o8onm2m 提取密码：7aqr 【96】2017年最新Python网络爬虫实战案例视频教程下载共5章34课 https://pan.baidu.com/s/1micMg8w 提取密码：23gt 【97】基于Hadoop，Spark大数据技术的推荐系统算法实战教程 https://pan.baidu.com/s/1dFnP9K1 提取密码：djyk 【98】 https://pan.baidu.com/s/1gf0CGuB 提取密码：4tei 【99】2017年最新云知梦php全栈开发全套视频教程 https://pan.baidu.com/s/1qYPwSsW 提取密码：iv93 【100】Python编程高级进阶视频教程 https://pan.baidu.com/s/1bpnnEph 提取密码：y9sp 【101】2017年5月最新课程小象学院深度学习第四期视频教程 https://pan.baidu.com/s/1o7IzeXk 提取密码：kptc 【102】最新自动聊天机器人项目班实战视频课程下载 https://pan.baidu.com/s/1kU9bNev 提取密码：6p5z 【103】深度学习入门视频课程上篇+下篇下载 https://pan.baidu.com/s/1slG7qxv 提取密码：u2c4 【104】七月在线机器学习算法班9月在线班视频教程 https://pan.baidu.com/s/1nuLiXCl 提取密码：vdkz 【105】最新小象学院机器学习升级版III视频教程下载 https://pan.baidu.com/s/1gfeXSgb 提取密码：dt7t 【106】最新优达学城udacity无人驾驶工程师视频教程 https://pan.baidu.com/s/1c1UUEXi 提取密码：mjbs 【107】2017年深度学习项目实战之对抗生成网络视频课程 https://pan.baidu.com/s/1hs8chxU 提取密码：76mw 【108】2017年深度学习之Tensorflow项目实战视频课程-文本分类 https://pan.baidu.com/s/1c1Kf1wG 提取密码：dt52 【109】2017年kaggle案例实战班视频教程 https://pan.baidu.com/s/1boYu4FX 提取密码：4bhc 【110】深度学习实战决胜AI-强化学习实战系列视频课程 https://pan.baidu.com/s/1eRHZ1yq 提取密码：ifu2 【111】2017年最新从理论到实践机器学习视频教程 https://pan.baidu.com/s/1jHPsHSU 提取密码：xx9x 【112】2017最新基于springsecurity与spingmvc分布式权限管理系统 https://pan.baidu.com/s/1c13keOw 提取密码：xea9 【113】Java高并发程序设计实战视频教程 https://pan.baidu.com/s/1c1CDsnI 提取密码：xsic 【114】Sqoop、Flume、Oozie、Hue大数据工具视频教程 https://pan.baidu.com/s/1bo47OGR 提取密码：hxw7 【115】深入JVM内核—原理、诊断与优化视频教程 https://pan.baidu.com/s/1jIL46PK 提取密码：78yd 【116】Hadoop,Hbase,Hive源码解析与开发实战 https://pan.baidu.com/s/1hsznJsK 提取密码：dpmq 【117】传智播客黑马P2P金融项目网络借贷平台开发实战教程 https://pan.baidu.com/s/1pLieuzL 提取密码：gbxy 【118】2017年7月最新微服务架构的分布式事务解决视频教程 https://pan.baidu.com/s/1bo47p2R 提取密码：94hx 【119】亿级流量电商系统大型高并发与高可用缓存架构实战 https://pan.baidu.com/s/1pLmhZir 提取密码：6aj9 【120】2017Spark2.0大型项目实战：移动电商app交互式数据分析平台 https://pan.baidu.com/s/1o8EAk2Y 提取密码：gcsq 【121】NO89中移动大型分布式redis,solr,Linux,nginx,springmvc,mybatis电商项目 https://pan.baidu.com/s/1qY7K2SW 提取密码：cjj4 【122】SpringBoot从前端到后台打造企业级博客全栈实战视频 https://pan.baidu.com/s/1pKLc2BT 提取密码：8tjw 【123】（2017年）最新深度学习与机器学习 https://pan.baidu.com/s/1c76kgA 提取密码：5qyv 【124】SpringMvc+Spring+Mybatis整合视频教程 http://pan.baidu.com/s/1gfP90Pl 提取密码：kveg 【125】Struts2+Spring3+Hibernate4+Maven+EasyUI整合入门视频教程 http://pan.baidu.com/s/1bpztkOR 提取密码：krbn 【126】elk日志分析视频ELKStack视频教程以及Solr教程 http://pan.baidu.com/s/1qYwQOSc 提取密码：qr9u 【127】徐老师hadoophbasezookeepersparkkafka大数据视频教程 http://pan.baidu.com/s/1miLtQqO 提取密码：97tj 【128】2017年最新项目实战SpringBoot视频教程微服务整合Mybatis http://pan.baidu.com/s/1boMH2Cv 提取密码：gvt5 【129】传智播客最新大数据第3期实战培训完整版视频教程 http://pan.baidu.com/s/1miLZwwg 提取密码：56hs 【130】[大数据]极客学院大数据工程师全套视频代码课件 http://pan.baidu.com/s/1c160ug4 提取密码：6d28 【131】2017新版MySQL加强视频教程46课附课件源码 http://pan.baidu.com/s/1eSouP6U 提取密码：nh8i 【132】Python爬虫项目班从零开始实现爬虫系统 http://pan.baidu.com/s/1i5QiuzV 提取密码：2vpd 【133】Mongodb/Redis/HBaseNoSql视频教程2017数据库自学教程 http://pan.baidu.com/s/1kVytRIB 提取密码：mtnb 【134】Mahout零基础入门到精通实战视频教程（全套）下载 http://pan.baidu.com/s/1kUPNJaJ 提取密码：pvka 【135】2017年最新整理深度学习神经网络算法全套视频教程 http://pan.baidu.com/s/1pLsfdIb 提取密码：vy41 【136】阿里开源分布式框架dubbo&amp;mycat视频教程 https://pan.baidu.com/s/1geZwIYZ 提取密码：h7iw 【137】极客学院python开发工程师视频教程下载 https://pan.baidu.com/s/1miDOboc 提取密码：gwaa 【138】2017最新python教程老男孩Python14期视频教程下载 https://pan.baidu.com/s/1kVbWgzP 提取密码：9hk7 【139】达内2017Web前端全套最新价值2万元视频教程 http://pan.baidu.com/s/1jIA3oma 提取密码：rfqk 【140】达内Java全套最新价值2万元视频教程 https://pan.baidu.com/s/1sl545sx 提取密码：sa8i 【141】SparkMLlib机器学习算法与源码解析 https://pan.baidu.com/s/1pLptvMN 提取密码：ncek 【142】大数据开发之hadoop工程师成长之路零基础到精通下载 https://pan.baidu.com/s/1i4LciTf 提取密码：8z4m 【143】Kafka原理剖析及实战演练视频教程下载 https://pan.baidu.com/s/1mhAgeBA 提取密码：26ny","link":"/2020/09/28/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%80%E4%BA%9B%E7%99%BE%E5%BA%A6%E4%BA%91%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E8%BF%98%E6%9C%89pdf%E8%B5%84%E6%96%99%20--%E6%90%AC%E8%BF%90%E5%B7%A5/"},{"title":"热修复技术原理总结","text":"#1.什么是热修复 传统更新流程：版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;重新发版-&gt;用户安装 弊端:重新发版本代价高 :用户下载安装成本高 :bug修复不及时，体验差 解决方案 Hybrid方案:业务逻辑以H5方式加载 插件化方案:Atlas或者DroidPlugin方案 热修复方案:采用热修复技术，将更新补丁上传到云端，APP从云端下拉补丁直接应用生效 热修复更新流程:版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;打出补丁,推送给用户-&gt;自动拉取补丁修复 优势 1.无需重新发版，实时高效热修复 2.用户无感知修复，无需下载新应用,代价小 3.修复成功率高，把损失降到最低 ##2.热修复框架 腾讯QQ控件的超技补丁技术，微信的Tinker，饿了么的Amigo，美团的Robust 非侵入式Android热修复方案SophixSophix不支持四大组件的修复,如果要修复四大组件，必须在AndroidManifest里预先插入代理组件，并且声明所有权限。对app运行流程的侵入性太强。未作处理。 ##3.Android热修复的三大领域:代码修复,资源修复,So修复。 ###3.1代码修复 ###代码修复方案:一种是阿里系的底层替换方案，一种是腾讯系的类加载方案优劣: 底层替换方案限制多，但时效性好，加载快，立即见效。类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。 ###底层替换方案 底层替换方案是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改。因而无法实现对原有类进行方法和字段的增减，因为这样将破坏原有类结构。一旦补丁类中出现了方法的增加或减少，就会导致这个类以及整个Dex的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。更严重的问题是，如果在程序运行中间某各类突然增加了一个字段，那么对于原先已经产生的这个类的实例，他们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。传统的底层替换方式，不论是Dexposed、Andfix或者其他安全界的Hook方案，都是直接依赖修改虚拟机方法实体的具体字段，例如，改Dalvik方法的jni函数指针、修改类或者方法的访问权限。Android开源，各大厂商对代码进行改造，Andfix里的ArtMethod的结构是根据Android源码中的结构写死的。如果ArtMethod做修改，这种替换机制就会出问题。 Sophix是一种无视底层具体结构的替换方式，解决了兼容性问题。忽略了底层ArtMethod结构的差异，对于Android版本不需要区分，代码量大大减少。只要ArtMethod数组是以线性结构排列，就不会出现问题。 ###类加载方案类加载方案的原理是在app重新启动后让Classloader去加载新的类。因为app运行时，所有需要发生变更的类已经被加载过了，在Android上是无法对一个类进行卸载。如果不重新启动，原来的类还在虚拟机上，就无法加载新类。只有重新启动，在业务逻辑执行前，抢先加载补丁中的新类，当访问这个类时就会Resolve为新类，达到热修复目的。 ###底层替换原理 Andfix即时生效，其原理是，在已经加载的类中直接在native层替换掉原有方法，实在原有类基础上进行修改。其核心在于replaceMethod函数，这是一个native方法。 其参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的事需要被替换的原有方法。dest对应的就是新方法，新方法存在于补丁包中的新类中，也就是补丁方法。 Android的java运行环境，在4.4以下用的事dalvik虚拟机，而在4.4以上用的是art虚拟机。 我们以art为例，对于不同Android版本的art，底层Java对象的数据结构是不同的，因而会进一步区分不同的替换函数，这里我们以Android6.0为例，对应的就是replace_6_0. 每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等。 通过env-&gt;FromReflectedMethod，可以由Method对象得到这个方法对应的ArtMethod的真正起始地址。然后可以把它强转成ArtMethod指针，从而对其所有成员进行修改。这样全部替换完之后就完成了热修复逻辑，以后调用这个方法时就会直接走到新方法的实现中了。 为什么这样替换完就可以实现热修复了呢？需要从虚拟机调用方法的原理说起。 在Art虚拟机中ArtMethod结构中，包含两个重8_point_from_quick_compiled_code_了，他们是方法的执行入口。Java代码在Android中会被编译成DexCode。你也不 Art中可以采用解析模式或者AOT机器码模式执行。 解析模式，就是去除Dex Code，逐条解析执行，如果方法的调用者以解析模式运行，在调用方法时，就会取得这个方法的entry_point_from_interpreter_,然后他交转过去执行。AOT的方式，就会先预编译好Dex Code 对应的机器码，然后执行期直接执行机器码，不需要一条条解析执行Dex Code。如果方法的调用者是以AOT机器码方式执行的，在调用这个方法是，就是跳转到entry_point_from_quick_compiled_code执行。因此，当把一个旧方法的所有成员字段都换成新方法后，执行时所有数据就可以保持和新方法的一至。这样在所有执行到旧方法的地方，回取得新方法的执行入口、所属class、方法索引号及所属dex信息，然后想调用旧方法一样的执行到新方法的逻辑。 Native替换方案，比如Andfix和其他安全界的Hook方案，都是写死ArtMethod结构体，这样会带来兼容性问题。Native层替换思路，其实就是替换ArtMethod的所有成员 Sophix采取的是将ArtMethod的作为整体进行替换。 访问权限的问题 方法调用时的权限检查、同包名下的权限问题、反射调用非静态方法问题。 即时生效在什么情况下不适用？ 引起原有类中发生结构变化的修改 修复了的非静态方法会被反射调用 内部类编译 内部类会在编译器会被编译为跟外部类一样的顶级类。 冷启动类加载原理当类结构发生变化时，如新增减少类的method/field再热部署模式下会受到限制，但是冷部署能够达到修复目的。 ##冷启动实现方案 ##插桩实现的前因后果 如果仅仅把补丁类打入补丁包中而不做任何处理的话， 在运行时类加载的时候会异常退出。加载一个dex文件到本地内存时，如果不存在odex文件，首先会执行dexopt，dexopt 的入口在davilk/opt/OptMain.cpp的main方法，最后调用到verifyAndOptimizeClass执行真正的verify/optimize操作。 Apk第一次安装的时候，会对原dex执行dexopt,此时假如apk只存在一个dex，所以dvmVerifyClass(clazz)结果为true,所以apk中所有的类都会被打上CLASS_ISPREVERIFIED标识，接下来执行dvmOptimizeClass，类接着被打上CLASS_ISOPTIMIZED标识。 现在加入A类是补丁类，所以补丁A类在单独的dex中，类B中的某个方法引用到补丁类A，所以执行到该方法会尝试解析类A。 类B由于被打上了CLASS_ISPREVERIFIED标志，接下来referrer是类B，resClassCheck是补丁类A，他们属于不同的dex。所以会提示dvmThrowlllegalAccessError。为了解决这个问题，一个单独无关帮助类放到一个单独的dex中，原dex中所有类的构造函数都引用这个类，一般的实现方法都是侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。Art下冷启动实现 Dalvik下和Art下对DexFile.loadDex尝试把一个dex文件解析加载到native内存发生了什么？实际都是调用了DexFile.openDexFileNative这个native方法。Dalvik尝试加载一个压缩文件的时候只会去把classes.dex加载到内存中，如果此时内存文件中有多个dex，那么除了classes.dex之外的其他dex被直接忽略掉Art虚拟机方法调用链DexFile-&gt;openDexFileNative-&gt;OpenDexFilesFromat-&gt;LoadDexFilesArt下默认支持加载压缩文件中包含多个dex，首先肯定优先加载primary dex其实就是classes.dex，后续会加载其他的dex。所以补丁类只需要放到classes.dex即可，后续出现在其他dex中的“补丁类“是不会被重复加载的。 Art最终冷启动解决方案 把补丁dex命名为classes.dex。原apk中的dex一次命名为classes(2,3,4…).dex就好了，然后一起打包为一个压缩文件。然后DexFile.LoadDex得到DexFile对象，最后把该DexFile对象整个替换旧的dexElements数据就可以了。 Sophix 和 tinker 方案 补丁dex必须命名为classes.dex loadDex得到的DexFile完整替换掉dexElements数组而不是插入 DexFile.loadDex尝试把一个dex文件解析并加载到native内存，在加载到native内存之前，如果dex不存在对应的odex，那么Dalvik下回执行dexopt，Art下回执行dexoat，最后得到的都是一个优化后的odex，实际上最后虚拟机执行的事这个odex而不是dex。dex足够大那么dexopt/dexoat实际上是很好似的，Dalvik下实际影响比较下，因为loadDex仅仅是补丁包，Art下影响非常大，因为loadDex是补丁dex和apk中原dex合并成一个完整补丁压缩包，所以dexoat非常耗时。如果优化后的odex文件没生成或者没生成一个完整的odex文件，那么loadDex便不能在应用启动的时候进行的，因为会阻塞loadDex线程，一般是主线程。所以解决这个问题，Sophix把loadDex当做一个事务来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，那么重启另一子进程loadDex，重启之后在生效。 具体实施方案对Dalvik和Art下 Dalvik下采用自行研发的全量Dex方案 Art下本质上虚拟机已经支持多dex的加载，我们只需把补丁dex作为主dex(classes.dex)加载而已 冷启动方案限制？当新增一个publlic/protected/default方法，会出现方法调用错乱。 Google的dexmerge方案 把补丁dex和原dex合并一个完整的dex。 Dalvik下完整DEX方案的新探索 冷启动类加载修复 对于Android下的冷启动类加载修复，最早的实现方案是QQ空间提出的dex插入方案。主要思想是，把插入新dex插入到ClassLoader索引路径的最前面，这样在load一个class时，优先找到补丁中的。这类插入dex 的方案，会遇到一个主要的问题，就是如何解决Dalvik虚拟机下类的pre-verify问题。 如果一个类 中直接引用到的所有非系统类都和该类在同一个dex里的话，那么这个类就会被打上CLASS_ISPREVERIFIED,具体判定代码可见虚拟机中的verifyAndOptimizeClass函数。 腾讯的三大热修复方案是如何解决这个问题的： QQ控件的处理方式，是在每个类中插入一个来自其他dex的hack.class,由此让所有类里面都无法满足pre-verified条件。 Tinker的方式，是合成全量的dex文件，这样所有class的都在全量dex中解决，从而消除class重复而带来的冲突。 Qfix的方式，是取得虚拟机中的某些底层函数，提前resolve所有补丁类，以此绕过Pre-verify检查。Sophix的方式，补丁中已包含变动的类，主要在原先基线包中dex里边，去掉补丁中已有的class。这样，补丁+去除了补丁类的基线包=app中所有类。参考Android原生multi-dex的实现，是把一个apk所用到的所有类拆分到classes.dex、classes2.dex、classes.dex…之中，而每个dex都只包含了部分的类的定义，但单个dex也是可以加载的，因为只要把所有dex都load进去，本dex中不存在的类就可以在运行期间在其他dex中找到。 #资源热修复技术 ##3.2资源修复InstantRun资源热修复原理： 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManger中，这样就得到一个含有所有新资源的AssetManager。 找到所有之前引用到愿你有Assetmanager的地方，通过反射，把引用处替换成新的AssetManager。Sophix 资源热修复原理:构造一个package id 为0x66的资源包，其中包含改变了的资源项，然后直接在原有的AssetManager中addAssetPath这个包就可以了。由于补丁包的package id 为0x66,不与目前已经加载的0x7f冲突，因此直接加入到已有的AssetMananger中就可以直接使用。替换方式更加优雅，直接在原有的AssetManageer对象上进行析构和重构，原先AssetManager对象的引用没有发生改变，不用像InstantRun进行繁琐修改。 ###资源替换方案优势 不修改AssetManager的引用处，替换更快更安全。 不必下发完整包，补丁包中只包含有变动的资源 不要在运行时合成完整包。不占用运行时计算和内存资源。 一个Android进程只包含一个ResTable,ResTable的成员变量mPackageGroups就是所有解析过的资源包的集合。任何 一个资源包中都含有resources.arsc,他记录了所有资源的id分配情况以及资源中的所有字符串。这些信息是以二进制方式存储的。底层的AssetManager做的事就是解析这个文件，然后把相关信息存储到mPackageGroups里面。 资源信息主要是指每隔资源的名称以及他对应的编号。每隔资源，都有唯一编号。 编号是一个32位数字，用十六进制来标识就是0xPPTTEEEE。PP为package id，TT为type id，EEEE为entry id。 运行时资源的解析 默认由Android SDK编出来的apk，是由aapt工具进行打包的，其资源包的package id 是 0x7f。系统的资源包，也就是framework-res.jar，package id 为0x01。在走到app 的第一行代码之前，系统就已经帮我们构造好一个已经添加了安装包资源的AssetManager了。 因此，这个AssetManager里就已经包含了系统资源包以及app的安装包，就是package id 为0x01的framework-res.jar中的资源和package id为0x7f的app安装包资源。 如果此时直接在addAssetPath其实补丁包里的资源是不生效的。因为在getResTable已经执行很多次了。不会发生真正的解析。 ###Sophix资源解决方案 构造一个package id 为0x66的资源包，包含了改变的资源项，然后直接在原有AssetManager中addAssetPath这个包。不与已经加载的0x7f冲突。 而资源的改变包含增加、减少、修改这三种情况，分别是如何处理的呢？ 对于新增资源，直接加入补丁包，然后新代码里直接引用就可以了 对于减少资源，我们只要不使用他就行了，因此不用考虑这种情况，他也不影响补丁包 对于修改资源，比如替换了一张图片之类的情况。我们把它视为新增资源，在打补丁的时候，代码在引用处也会做响应修改，也就是直接把原来使用就资源id的地方变成新id。#3.3 So库修复So库修复本质上是对native方法的修复和替换。Sophix采用的是类似类修复反射注入方式。把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，达到加载so库时时补丁so库，而不是原来so库的目录，从而达到修复的目的。采用这种方案，完全由Sophix在启动期间反射注入patch中的so库。其他方案是手动替换系统的System.load来实现替换目的。Java Api提供一下两个接口加载一个so库 System.loadLibrary(String libName);传进去的参数 so库名称，表示的so库文件，位于apk压缩文件中的libs目录，最后复制到apk安装目录下。 System.load(String pathName)传进去的参数 so库在磁盘中的完整路径。加载一个自定义外部so库文件。两种方式加载一个so库，实际上最后都调用nativeLoad这个native方法去加载so库，这个方法的参数fileName so库在磁盘中的完整路径名。 JNI编程中，动态注册的natvie方法必须实现JNI_ONLoad方法，同时实现一个JNINativeMethod[]数组 ，静态注册的native方法必须是Java+类完整路径+方法名的格式。 ##3.1. SO库冷部署重启生效实现方案 SO库修复方案 接口调用替换方案，需要强制侵入用户接口调用 反射注入方案，重启生效 总结： 动态注册的native方法映射通过加载so库过程中调用JNI_OnLoad方法调用完成 静态注册的native方法映射是在该native方法第一次执行的时候才完成映射，当然前提是该so库已经load过。 ##3.2 SO库热部署实时生效分析 ###3.2.1动态注册native方法实时生效动态注册的native方法调用一次JNI_OnLoad方法都会重新完成一次映射，所以我们是否只要先加载原来的so库，然后在加载补丁so库，就完成Java层native方法到native层patch后的新方法映射，这样就完成动态注册native方法的patch实时修复。 实测发现art下这样是可以实时生效，但Dalvik下做不到试试生效。原因Dalvik第二次load补丁so库，执行的仍然是原来的so库的JNI_OnLoad方法，而不是补丁so库的JNI_OnLoad方法。Dalvik虚拟机下dlopen方法实现，底层方法会校验so库是否已经加载过，方法的判断依据是判断name,如果加载过直接返回该so库的句柄。如果so库从未加载过，则load_library执行加载。所以Dalvik下面加载修复后的补丁so拿到的还是原so库文件的句柄，所以执行的仍然是原so库的JNI_OnLoad方法，Art下不存在问题，因Art下该方法以name作为key去查找不是bname,所以art下重新load一遍补丁so库，拿到的是补丁so库的句柄，然后执行补丁so库的JNI_OnLoad。解决Dalvik下该问题，可对补丁so库进行改名。 ###3.2.2静态注册native方法实时生效静态注册native方法的映射实在native方法第一次执行的时候完成映射，如果native方法在加载补丁so库之前已经执行过，是否这个静态注册native方法一定得不到修复？幸运的是，系统JNI API提供了解注册的接口 UnregisterNatives（JNIEnv* env,jclass jclazz）函数回吧jclazz所在类的所有native方法都重新指向为dvmResolveNativeMethod，所以调用unregisterNatives之后不管是静态注册还是动态注册的native方法之前是否执行过在加载补丁so 的时候都会重新去做映射。所以我们只需要以下调用。 ##3.3 SO库冷部署重启生效实现方案 ###3.3.1.接口调用替换方案Sdk提供接口替换System默认加载so库接口 SOPatchManager。loadLibrary接口加载so库的时候有限尝试去加载sdk指定目录下的补丁so，加载策略如下： 如果存在则加载补丁so库而不会去加载安装apk安装目录下的so库。 如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的so库。 方案优缺点：优点：不需要对不同sdk版本进行兼容，因为所有的SDK版本都有System.loadLibrary这个接口。缺点：调用方需要替换掉System默认加载so库接口为sdk提供的接口，如果是已经编译混淆好的三方库的so库需要patch，那么是很难做到接口的替换。 ###3.3.2反射注入方案System.loadLibrary(“native-lib”)，加载so库的原理，其实native-lib这个 so库最终传给native方法执行的参数是so库在磁盘中的完整路径，比如/data/app-lib/com.taobao.jni-2/libnative-lib.so,so库会在DexPathList.nativeLibraryDirectories/nativeLibraryPathElements变量所表示的目录下去遍历搜索。 可以发现会遍历nativeLibraryDirectories数组，如果找到了IoUtils.canOpenReadOnly(path)返回true，那么就直接返回该path，IoUtils。canOpenReadOnly(path)返回true的前提肯定是需要path标识的so文件存在的。我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复的目的。 Sdk23以上findLibrary 实现已经发生变化，只需把补丁so库的完整路径违参数构建一个Element对象，然后再插入nativeLibraryPathElements数组的最前面就好了。 优点：可以修复三方库的so库。同事接入方不需要想方案1一样强制侵入用户接口调用。缺点：需要不断的对sdk进行适配，如上sdk23为分界线，findLibrary接口实现已发生变化。不管是补丁包还是apk中一个so库存在多种cpu架构的so文件，比如armeabi，arm64-v8a,x86等。加载可定是加载其中一个so库文件的，如何选择机型对应的so库文件将是重点所在。 虚拟机究竟如何选择哪个abis目录作为参数构建PathClassLoader对象，原理如图 实际上补丁so也存在类似的问题，我们的补丁so库文件放到补丁包的libs目录下，libs目录和.dex文件res资源文件一起打包成一个压缩文件作为最后的补丁包，libs目录可能也包含多种abis目录。所以我们需要选择手机最合适的primaryCpuAbi，然后从libs目录下选择这个primaryCpuAbi子目录插入到nativeLibraryDirectories/nativeLibraryPathElements数组。所以怎么选择primaryCpuAbi是关键，具体实现如图： 1.sdk&gt;=21时，直接反射拿到ApplicationInfo对象的primaryCpuAbi即可2.sdk&lt;21时，有雨此时不支持64位，所以直接吧Build.CPU_ABI,Build.CPU_ABI2作为primaryCpuAbi即可。","link":"/2019/10/11/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"title":"ADB命令大全(转)","text":"ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 Other languages: :gb: English 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: \"android.intent.action.MAIN\" Category: \"android.intent.category.LAUNCHER\" AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider} applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package{55f714c org.mazhuang.guanggoo} codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures{af09595 [53c7caa2]} installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es \"toast\" \"hello, world\" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令：1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed \"s/\\r$//\" &gt; sc.png Mac OS X 1adb shell screencap -p | gsed \"s/\\r$//\" &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network={ ssid=\"TP-LINK_9DFC\" scan_ssid=1 psk=\"123456789\" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893}network={ ssid=\"TP-LINK_F11E\" psk=\"987654321\" key_mgmt=WPA-PSK sim_num=1 priority=17293} ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server's $ADB_VENDOR_KEYS is not setTry 'adb kill-server' if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666，shawnlinboy，s-xq，lucky9322。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）","link":"/2019/10/11/README/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"壁纸路径","slug":"壁纸路径","link":"/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"name":"Mac系统","slug":"Mac系统","link":"/tags/Mac%E7%B3%BB%E7%BB%9F/"},{"name":"谷歌云","slug":"谷歌云","link":"/tags/%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/%E7%BF%BB%E5%A2%99/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"so文件","slug":"so文件","link":"/tags/so%E6%96%87%E4%BB%B6/"},{"name":"ndk","slug":"ndk","link":"/tags/ndk/"},{"name":"霍比特人","slug":"霍比特人","link":"/tags/%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA/"},{"name":"意外之旅","slug":"意外之旅","link":"/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"},{"name":"bt","slug":"bt","link":"/tags/bt/"},{"name":"指环王","slug":"指环王","link":"/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"},{"name":"比尔博·巴金斯","slug":"比尔博·巴金斯","link":"/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"},{"name":"甘道夫","slug":"甘道夫","link":"/tags/%E7%94%98%E9%81%93%E5%A4%AB/"},{"name":"索伦","slug":"索伦","link":"/tags/%E7%B4%A2%E4%BC%A6/"},{"name":"魔苟斯","slug":"魔苟斯","link":"/tags/%E9%AD%94%E8%8B%9F%E6%96%AF/"},{"name":"戒灵","slug":"戒灵","link":"/tags/%E6%88%92%E7%81%B5/"},{"name":"炎魔","slug":"炎魔","link":"/tags/%E7%82%8E%E9%AD%94/"},{"name":"精灵","slug":"精灵","link":"/tags/%E7%B2%BE%E7%81%B5/"},{"name":"魔戒","slug":"魔戒","link":"/tags/%E9%AD%94%E6%88%92/"},{"name":"咕噜","slug":"咕噜","link":"/tags/%E5%92%95%E5%99%9C/"},{"name":"阿拉贡","slug":"阿拉贡","link":"/tags/%E9%98%BF%E6%8B%89%E8%B4%A1/"},{"name":"魔多","slug":"魔多","link":"/tags/%E9%AD%94%E5%A4%9A/"},{"name":"史茅革","slug":"史茅革","link":"/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python3","slug":"Python3","link":"/tags/Python3/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"小游戏开发","slug":"小游戏开发","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"categories":[{"name":"Android基础","slug":"Android基础","link":"/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"Mac应用","slug":"Mac应用","link":"/categories/Mac%E5%BA%94%E7%94%A8/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"经典电影","slug":"经典电影","link":"/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"学习资料","slug":"学习资料","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"}]}