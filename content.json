{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 个人信息：90后计算机网络技术专业从事Android开发，坚信代码改变世界摄影爱好者QQ: 798774875Email: moruoyiming123@gmail.comJianShu: jianzeyicongGithub: moruoyimingYouTube: Jean RilenInstagram: jianzeyicong500px: moruoyiming 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志： –2020.09.29：增加相册、视频功能–2020.09.18：增加AdSense广告–2020.08.22：改版部分显示，优化速度–2020.06.18：icarus3.0主题适配–2019.12.16：增加不蒜子统计–2019.10.16：文章列表加上评论数显示–2019.03.13：改版评论–2017.12.16：icarus1.0主题适配–2017.08.12：搭建个人博客 本站推荐索引 技术知识点 Java教程 Python3教程 JavaScript教程 剑指Offer 免费学习资料 常用工具 图片压缩 在线转换工具 贝塞尔弧曲线 ProcessOn流程图 Youtube视频下载 免费翻墙 free-ss free-ss.site ss.pythonic.life 免费节点 软件下载 萌新网 麦氪派 福利 电影天堂 高清电影 BD电影 剧迷 高速车 持续更新~","link":"/about/index.html"},{"title":"","text":"风光 人像 动物 图片均为本人拍摄，有共同爱好的小伙伴可以约起来哦~~~ 留言 😊 😊 😊。","link":"/album/index.html"},{"title":"categories","text":"(adsbygoogle = window.adsbygoogle || []).push({});","link":"/categories/index.html"},{"title":"电影","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 -&gt;点击以下条目开始播放视频,向下滑动查看更多&lt;- (adsbygoogle = window.adsbygoogle || []).push({});","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"Android项目运行时丢失so文件","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 123456789101112defaultConfig { applicationId &quot;…&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' }} 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2020/09/11/Android%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%A2%E5%A4%B1so%E6%96%87%E4%BB%B6/"},{"title":"Mac 下移动硬盘的读写软件Mounty","text":"title: Mac下移动硬盘的读写软件Mountythumbnail: /gallery/thumbnails/sculpture.jpgcategories: Mac应用tags: 壁纸路径 Mounty Mac系统 终端运行: brew cask install mounty 官网地址:https://mounty.app/","link":"/2020/09/11/Mac%20%E4%B8%8B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E8%BD%AF%E4%BB%B6Mounty/"},{"title":"Mac系统壁纸路径","text":"在 Finder 中，菜单栏选取“前往”&gt;“前往文件夹”，弹出的框里输入/Library/Desktop Pictures/或/System/Library/Desktop Pictures/然后回车即可打开该文件夹。 系统壁纸默认路径存在两个地方，当时去了第一个路径上找未找到，后来通过命令行获取到路径发现System 下也有一个Desktop Pictures 文件夹。 终端命令：显示壁纸所在路径（路径显示在屏幕对应壁纸上）： defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE;killall Dock 终端命令：隐藏该路径： defaults delete com.apple.dock desktop-picture-show-debug-text;killall Dock","link":"/2020/09/11/Mac%20%E7%B3%BB%E7%BB%9F%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"title":"Mac下Google备份和同步问题","text":"1.下载并安装Google备份和同步 Google备份和同步（下载地址） 2.打开xx的http代理 在偏好设置中打开http代理服务器，配置默认即可 3.打开系统设置中的http代理 系统偏好设置→网络→高级→代理→网页代理(HTTP)，设置代理127.0.0.1:1087 4. 允许并登录Google账户 完全配置完成后即可食用 原文地址 https://www.fangpengjun.com/2017/09/08/%E8%A7%A3%E5%86%B3Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","link":"/2020/09/11/Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},{"title":"Mac下安装软件提示文件损坏解决办法","text":"1.打开应用程序-实用工具-终端；b2制以下代码（master注意是两个-）到终端中，回车（输入电脑密码）： 1sudo spctl --master-disable 3.打开应用程序-系统偏好设置-安全性和隐私-通用，消失的任何来源终于出现了（默认应该勾选了）；4.此时可以尽情使用第三方程序了如已经开启了任何来源，还无法安装当出现提示的时候，去系统偏好设置-安全和隐私那里允许下（会提示该软件的安装信息） 还提示损坏的，试试按住Control后，再次点击软件图标","link":"/2020/09/11/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Mac使用终端登录谷歌云","text":"1.网页SSH进入谷歌云，切换到root角色 sudo -i 2.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 3.给root用户设置密码 passwd root 4.重启SSH服务使修改生效 /etc/init.d/ssh restart 5.启动mac终端 ssh root@ip 输入密码即可进入SSH。","link":"/2020/09/11/Mac%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"title":"Mac安装oh-my-zsh出现TimeOut","text":"mac终端 安装 oh-my-zshsh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 提示错误 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 用这个连接wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh","link":"/2020/09/11/Mac%E5%AE%89%E8%A3%85oh-my-zsh%20%E5%87%BA%E7%8E%B0TimeOut/"},{"title":"Mac文件安装应用，打开提示文件已损坏，如何解决","text":"终端运行该命令:sudo xattr -d com.apple.quarantine /Applications/ColorFinale.app","link":"/2020/09/11/Mac%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%EF%BC%8C%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"},{"title":"Android 项目中so文件丢失","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 1234567891011121314151617defaultConfig { applicationId &quot;...&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2019/02/26/SO%E6%96%87%E4%BB%B6%E7%BC%BA%E5%A4%B1/"},{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2019/02/20/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"TensorFlow Mac安装教程","text":".安装Python 3.7.5 版本百度云盘:链接:https://pan.baidu.com/s/1lC7ZPFAIB8pYor1DbIOL8Q 密码:v6tj官网:https://www.python.org/ftp/python/3.7.5/python-3.7.5-macosx10.9.pkg 查看版本号。 123python3 --versionpip3 --versionvirtualenv --version 输入which python3 查看路径 2.如果已经安装，跳过这步：如果没用过brew，需要先下载，关于brew查看这里: https://brew.sh/ 123/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 1234/usr/bin/ruby -e &quot;PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 3.安装virtualenv虚拟环境创建一个新的虚拟环境通过选择一个Python解释器,创建./venv目录来保存它:可修改为其他目录。目录会出现在 user的子目录下。 1virtualenv --system-site-packages -p python3 ./venv 4.激活虚拟环境 1source ./venv/bin/activate # sh, bash, ksh, or zsh virtualenv活跃时,shell提示符前缀(venv)。 安装包在一个虚拟环境在不影响主机系统设置。先升级pip: 12pip install --upgrade pippip list # show packages installed within the virtual environment 5.退出虚拟环境 deactivate # don’t exit until you’re done using TensorFlow 如果提示权限不够时，需要在命令后添加 –user。 6.安装TensorFlow 1pip install --upgrade tensorflow 验证安装 1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 问题汇总 1pip install Keras-Applications ModuleNotFoundError: No module named ‘matplotlib’ 1pip install matplotlib ModuleNotFoundError: No module named ‘tensorflow_datasets’ 1pip install tensorflow_datasets ModuleNotFoundError: No module named ‘tensorflow_hub’ 1pip install tensorflow_hub seaborn 绘制矩阵图 (pairplot) 1pip install seaborn 引入类库 TensorFlow and tf.keras12import tensorflow as tffrom tensorflow import keras Helper librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as sns","link":"/2020/09/11/TensorFlow%20Mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"指环王1：魔戒再现.蓝光加长版","text":"[[2000-2010][欧美][奇幻][BT下载][指环王1：魔戒再现.蓝光加长版][BD-MKV/4.03GB][国语双语中英字幕][1080P][奇幻冒险史诗巨制] ◎译 名 指环王1：魔戒再现/魔戒首部曲：魔戒现身/指环王I：护戒使者/魔戒1：护戒联盟 ◎片 名 The Lord of the Rings：The Fellowship of the Ring ◎年 代 2001 ◎国 家 新西兰/美国 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 国英双语 ◎字 幕 中英双字 ◎上映日期 2002-04-04(中国大陆)/2001-12-19(美国) ◎豆瓣评分 8.9/10 from 292224 users ◎豆瓣链接 https://movie.douban.com/subject/1291571/ ◎文件格式 X264+AC3 ◎视频尺寸 1920×1080 ◎文件大小 11.6GB ◎片 长 228min ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 肖恩·宾 Sean Bean 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 伊安·霍姆 Ian Holm 多米尼克·莫纳汉 Dominic Monaghan 萨拉·贝克 Sala Baker 约翰·瑞斯-戴维斯 John Rhys-Davies 【电影简介】 比尔博·巴金斯是100多岁的哈比人，住在故乡夏尔，生性喜欢冒险，在年轻时的一次探险经历中，他从怪物咕噜手中得到了至尊魔戒，这枚戒指是黑暗魔君索伦打造的至尊魔戒，拥有奴役世界的邪恶力量，能够统领其他几枚力量之戒，在3000年前的人类联盟和半兽人大军的战役中，联盟取得了胜利，并得到了至尊魔戒，数千年的辗转后，魔戒落到咕噜手中，被比尔博碰巧得到。 因为和魔戒的朝夕相处，比尔博的心性也受到了影响，在他111岁的生日宴会上，他决定把一切都留给侄子佛罗多(伊莱贾·伍德 饰)，继续冒险。 比尔博的好朋友灰袍巫师甘道夫（伊恩·麦凯伦 饰）知道至尊魔戒的秘密，同时，黑暗魔君索伦已经知道他的魔戒落在哈比族的手中。索伦正在重新建造要塞巴拉多，集结无数的半兽人，准备以大军 夺取魔戒，并且征服全世界。 甘道夫说服佛罗多将魔戒护送到精灵王国瑞文希尔，佛罗多在好朋友山姆、皮平和梅利的陪同下，在跃马旅店得到了刚铎王子阿拉贡的帮助，历经艰难，终于到达了精灵王国。 然而，精灵族并不愿意保管这个邪恶的至尊魔戒，中土各国代表开会讨论，达成意见，准备将至尊魔戒送到末日山脉的烈焰中彻底销毁，佛罗多挺身而出接受了这个任务，这次，陪伴他的除了三个好朋友，还有甘道夫、阿拉贡、精灵莱戈拉斯（奥兰多·布鲁姆 饰）、人类博罗米尔、侏儒金利。 一路上，魔戒远征军除了要逃避索伦爪牙黑骑士和半兽人的追杀之外，更要抵抗至尊魔界本身的邪恶诱惑，前途困难重重。 【电影截图】 指环王1.魔戒再现.国语双语中英字幕.The.Lord.of.the.Rings.The.Fellowship.of.the.Ring.2001.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B1%EF%BC%9A%E9%AD%94%E6%88%92%E5%86%8D%E7%8E%B0.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.03GB%5D%5B%E5%9B%BD%5D/"},{"title":"指环王2：双塔奇兵.蓝光加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王2：双塔奇兵.蓝光加长版][BD-MKV/4.81GB][国语双语中英字幕][1080P][豆瓣9.1分史诗巨制] ◎译 名 指环王2：双塔奇兵 / 指环王II：双塔 / 魔戒2：双塔奇谋 / 魔戒二部曲：双城奇谋 ◎片 名 The Lord of the Rings: The Two Towers ◎年 代 2002 ◎产 地 美国 / 新西兰 ◎类 别 剧情 / 动作 / 奇幻 / 冒险 ◎语 言 英语 / 辛达林语 / 古代英语 ◎上映日期 2002-12-05(纽约首映) / 2002-12-18(美国) / 2003-04-25(中国大陆) ◎IMDb评分 8.7/10 from 1369619 users ◎IMDb链接 http://www.imdb.com/title/tt0167261 ◎豆瓣评分 9.1/10 from 410177 users ◎豆瓣链接 https://movie.douban.com/subject/1291572/ ◎片 长 179分钟 ◎导 演 彼得·杰克逊 Peter Jackson ◎编 剧 弗兰·威尔士 Fran Walsh / Philippa Boyens / Stephen Sinclair / 彼得·杰克逊 Peter Jackson / 托尔金 J.R.R. Tolkien ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 克里斯托弗·李 Christopher Lee 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 卡尔·厄本 Karl Urban 凯特·布兰切特 Cate Blanchett 多米尼克·莫纳汉 Dominic Monaghan 大卫·文翰 David Wenham 比利·博伊德 Billy Boyd 布拉德·道里夫 Brad Dourif 伯纳德·希尔 Bernard Hill 约翰·瑞斯-戴维斯 John Rhys-Davies 米兰达·奥图 Miranda Otto ◎标 签 魔幻 | 史诗 | 经典 | 美国 | 战争 | 大片 | 新西兰 | 2002 ◎简 介 第二部在延续第一部风格的同时，故事呈现出多线发展的格局，情节有了更高的观赏性。 第一部结尾，博罗米尔被强兽人杀死之后，两个哈比族人皮平和梅利也被强兽人绑架，阿拉贡、精灵莱戈拉斯（奥兰多?布鲁姆 饰）、侏儒金利一路追踪强兽人，营救皮平和梅利，遇到了“复活”的白袍巫师甘道夫（伊恩?麦凯伦 饰）。此时，投降索伦的白袍巫师萨鲁曼控制了人类洛汉王国的国王，并派出大量的强兽人军队，准备消灭人类。阿拉贡、莱戈拉斯和金利在甘道夫的带领下，帮助洛汉王国对抗邪恶力量的入侵。 幸运的皮平和梅利被会说话的树精救了出来，并且遇到“复活”的甘道夫，在甘道夫的授意下，树精保护了两人的安全，并且带他们参加树精大会，大会上，树精们讨论对待中土大战的态度：是继续当中立者，逆来顺受，还是奋起反抗？ 身负重任的佛罗多(伊莱贾?伍德 饰)和山姆继续向末日山脉前进，一路上被咕噜跟踪，弗罗多依靠至尊魔戒的力量，成为了咕噜的主人，在咕噜的带领下，他们到了末日山脉的入口，黑门。就在他们准备进入之时，博罗米尔的弟弟法莫尔出现，将他们带回了刚铎。弗罗多又遇上了新的危机：法莫尔想利用至尊魔戒的力量对抗萨鲁曼的攻击…… ◎获奖情况 第75届奥斯卡金像奖(2003) 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 最佳剪辑(提名) 迈克·霍顿 最佳视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 最佳音效剪辑 迈克·霍普金斯 / 伊桑·范德莱恩 最佳音响(提名) 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳艺术指导(提名) 格兰特·梅杰 / 丹·汉纳 / 艾伦·李 第56届英国电影学院奖(2003) 电影奖 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 电影奖 最佳导演(提名) 彼得·杰克逊 电影奖 最佳摄影(提名) 安德鲁·莱斯尼 电影奖 最佳剪辑(提名) 迈克·霍顿 / Jabez Olssen 电影奖 最佳化妆/发型(提名) Peter Owen / 彼得·金 / 理查德·泰勒 电影奖 最佳服装设计 恩吉拉·迪克森 / 理查德·泰勒 电影奖 最佳艺术指导(提名) 格兰特·梅杰 电影奖 最佳特殊视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 电影奖 最佳音效(提名) 迈克·亨吉斯 / 迈克·霍普金斯 / 迈克尔·斯曼内科 / 克里斯托弗·博伊斯 / 哈蒙德·匹克 / David Farmer / 伊桑·范德莱恩 电影奖 观众选择奖 第27届日本电影学院奖(2004) 最佳外语片(提名) 第3届美国电影学会奖(2002) 年度佳片 指环王2.双塔奇兵国语双语中英字幕.The.Lord.of.the.Rings.The.Two.Towers.2002.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B2%EF%BC%9A%E5%8F%8C%E5%A1%94%E5%A5%87%E5%85%B5.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.81GB%5D%5B%E5%9B%BD%5D/"},{"title":"指环王3：王者无敌.加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王3：王者无敌.加长版][BD-MKV/5.17GB][国英双语中字][1080P][豆瓣9.2高分魔幻巨制] ◎译 名 指环王3：王者无敌/魔戒三部曲：王者再临/指环王III：王者无敌/魔戒3：王者归来/指环王3：国王归来 ◎片 名 The Lord of the Rings: The Return of the King ◎年 代 2003 ◎国 家 美国/新西兰 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 英语/昆雅语/古英语/辛达林语 ◎上映日期 2003-12-01(新西兰首映)/2003-12-17(美国)/2004-03-15(中国大陆) ◎IMDb评分 8.9/10 from 1,064,793 users ◎IMDb链接 http://www.imdb.com/title/tt0167260/ ◎豆瓣评分 9.1/10 from 218,212 users ◎豆瓣链接 http://movie.douban.com/subject/1291552/ ◎片 长 201分钟/251分钟(加长版)/263分钟(蓝光加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 维果·莫腾森 Viggo Mortensen 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 丽芙·泰勒 Liv Tyler 伊恩·麦克莱恩 Ian McKellen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 米兰达·奥图 Miranda Otto 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 多米尼克·莫纳汉 Dominic Monaghan 比利·博伊德 Billy Boyd 马尔顿·索克斯 Marton Csokas 卡尔·厄本 Karl Urban 克里斯托弗·李 Christopher Lee 约翰·瑞斯-戴维斯 John Rhys-Davies ◎简 介 魔幻战争逐渐进入高潮阶段。霍比特人弗拉多（伊利亚·伍德 Elijah Wood 饰）携带着魔戒，与伙伴山姆（Sean Astin 饰）以及狡猾阴暗的咕噜等前往末日山，一路上艰难险阻不断，魔君索伦为阻止魔戒被销毁用尽全力阻挠。另一方面，白袍巫师甘道夫（伊安·麦克莱恩 Ian McKellen 饰）率中土勇士们镇守刚铎首都——白城米那斯提里斯。魔兽大军压境，黑暗与光明的决战即将来临…… 本片是“指环王三部曲”的终结篇，根据英国作家J.R.R.托尔金（J.R.R. Tolkien）同名魔幻巨著《指环王》（The Lord of the Rings）改编，并荣获2004年第76届奥斯卡最佳影片、最佳导演、最佳改编剧本、最佳剪辑、最佳艺术指导、最佳服装设计、最佳化妆、最佳视觉效果、最佳音效、最佳配乐和最佳歌曲等11项大奖。 ◎获奖情况 第76届奥斯卡金像奖 (2004) 最佳影片 Barrie M. Osborne / 弗兰·威尔士 / 彼得·杰克逊 最佳导演 彼得·杰克逊 最佳改编剧本 弗兰·威尔士 / 彼得·杰克逊 / 菲利帕·鲍恩斯 最佳剪辑 Jamie Selkirk 最佳视觉效果 Alex Funke / Jim Rygiel / 乔·莱特瑞 / Randall William Cook 最佳混音 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳美术指导 丹·汉纳 / 格兰特·梅杰 / 艾伦·李 最佳服装设计 Ngila Dickson / 理查德·泰勒 最佳化妆 理查德·泰勒 / 彼得·金 最佳原创配乐 霍华德·肖 最佳原创歌曲 霍华德·肖 / 安妮·蓝妮克丝 / 弗兰·威尔士 第28届日本电影学院奖 (2005) 最佳外语片(提名) 指环王3.王者无敌.国语双语中英字幕.The.Lord.of.the.Rings.The.Return.of.the.King.2003.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B3%EF%BC%9A%E7%8E%8B%E8%80%85%E6%97%A0%E6%95%8C.%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV5.17GB%5D%5B%E5%9B%BD%E8%8B%B1%E5%8F%8C%5D/"},{"title":"霍比特人1.意外之旅.蓝光加长版","text":"[2012] [欧美][奇幻][BT下载][霍比特人1.意外之旅.蓝光加长版][BD-MKV/3.58GB][国英双语中英字幕][1080P][特效史诗巨制] ◎译 名 霍比特人1：意外之旅/哈比人：不思议之旅(港)/哈比人：意外旅程(台)/指环王前传：霍比特人(上) ◎片 名 The Hobbit: An Unexpected Journey ◎年 代 2012 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2012-11-28(新西兰首映)/2012-12-14(美国)/2013-02-22(中国大陆) ◎IMDb评分 8.0/10 from 548,633 users ◎IMDb链接 http://www.imdb.com/title/tt0903624 ◎豆瓣评分 8.1/10 from 178,214 users ◎豆瓣链接 http://movie.douban.com/subject/1966182 ◎片 长 169分钟/182分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 肯·斯托特 Ken Stott 格拉汉姆·麦克泰维什 Graham McTavish 詹姆斯·内斯比特 James Nesbitt 迪恩·奥戈曼 Dean O’Gorman 艾丹·特纳 Aidan Turner 雨果·维文 Hugo Weaving 凯特·布兰切特 Cate Blanchett 安迪·瑟金斯 Andy Serkis 西尔维斯特·迈可伊 Sylvester McCoy 克里斯托弗·李 Christopher Lee 伊利亚·伍德 Elijah Wood 伊安·霍姆 Ian Holm 李·佩斯 Lee Pace ◎简 介 中土最后一座矮人王国埃尔波尔，巍峨壮丽，庄严雄伟。老国王索尔积聚大量财富，却引来恶龙史茅革的觊觎和荼毒，最终导致这座城池陷落。许多年后，灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）找到弗罗多的舅舅——霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰），邀请他加入由13名矮人组成的远征队伍。原来史茅革已多年不见声息，背负家国仇恨的矮人王子索林（理查德·阿米蒂奇 Richard Armitage 饰）希望借此机会收复故土。经过一番考虑，巴金斯决定加入。令他想不到的是，远征旅途多灾多难，与索林结下深仇大恨的苍白半兽人及其爪牙阴魂不散，更有食人鬼和石人制造的无数艰险。而在旅途中，巴金斯也意外得到了日后影响整个中土的重要宝物…… 本片根据J.R.R·托尔金的同名原著改编。 霍比特人1.意外之旅.国英双语中英字幕 The.Hobbit.2012.EXTENDED.1080p.BluRay.AC3. x264.mkv.torrent","link":"/2020/09/23/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA1.%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.58GB%5D/"},{"title":"霍比特人2：史矛革之战蓝光加长版","text":"[2013][欧美][动作][BT下载][霍比特人2：史矛革之战蓝光加长版][BD-MKV/3.59GB][国英双语中英字幕][1080P][豆瓣8.1分好评奇幻冒险] ◎译 名 霍比特人2：史矛革之战/霍比特人2：史矛革荒漠/哈比人：荒谷魔龙(港)/哈比人：荒谷恶龙(台)/霍比特人2：斯毛戈荒漠/指环王前传：霍比特人(中) ◎片 名 The Hobbit: The Desolation of Smaug ◎年 代 2013 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2013-12-13(美国)/2014-02-21(中国大陆) ◎IMDb评分 8.0/10 from 413,210 users ◎IMDb链接 http://www.imdb.com/title/tt1170358/ ◎豆瓣评分 8.1/10 from 152,878 users ◎豆瓣链接 http://movie.douban.com/subject/11606328/ ◎片 长 161分钟/186分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 本尼迪克特·康伯巴奇 Benedict Cumberbatch 奥兰多·布鲁姆 Orlando Bloom 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 斯蒂芬·弗雷 Stephen Fry 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 约翰·贝尔 John Bell 马努·贝内特 Manu Bennett 杰德·布罗菲 Jed Brophy 亚当·布朗 Adam Brown 约翰·凯伦 John Callen 瑞安·盖奇 Ryan Gage 马克·哈德洛 Mark Hadlow 皮特·哈姆贝尔顿 Peter Hambleton 斯蒂芬·亨特 Stephen Hunter 威廉姆·吉尔切尔 William Kircher 西尔维斯特·迈可伊 Sylvester McCoy 格拉汉姆·麦克泰维什 Graham McTavish 迪恩·奥戈曼 Dean O’Gorman 米克尔·佩斯勃兰特 Mikael Persbrandt 艾丹·特纳 Aidan Turner ◎简 介 距离孤山越来越近，矮人远征军的道路却变得异常艰险。他们躲过了苍白半兽人的不懈追杀，在幽暗密林前和甘道夫（伊恩·麦凯伦 Ian McKellen 饰）兵分两路，后者前往多尔哥多探寻索伦的动向，而霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）和矮人们先是遭到巨大蜘蛛的袭击，随后又被精灵王子莱戈拉斯（奥兰多·布鲁姆 Orlando Bloom 饰）及其木精灵同伴捕获。比尔博急中生智，利用魔戒救出伙伴，继而引发了木精灵、半兽人和矮人远征军之间精彩纷呈的三方会战。借助巴德（卢克·伊万斯 Luke Evans 饰）的帮助，疲惫的矮人们暂时落脚长湖镇。近在咫尺的孤山城堡，沉睡在财宝中的巨龙即将醒来…… 本片根据J.R.R·托尔金的同名原著改编。 ◎获奖情况 第86届奥斯卡金像奖 (2014) 最佳视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 / Eric Reynolds 最佳音效剪辑(提名) Brent Burge 最佳混音(提名) 迈克·亨吉斯 / 托尼·约翰逊 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 第23届MTV电影奖 (2014) MTV电影奖 年度电影(提名) MTV电影奖 最佳打斗(提名) MTV电影奖 最佳银幕形象转变(提名) 奥兰多·布鲁姆 MTV电影奖 最佳英雄形象(提名) 马丁·弗瑞曼 第16届美国服装设计工会奖 (2014) 奇幻题材电影最佳服装设计(提名) 鲍勃·巴克 / 安·马斯克里 / 理查德·泰勒 第61届美国音效剪辑协会奖 (2014) 金卷轴奖 最佳电影音效剪辑(提名) David Farmer / Chris Ward / Hayden Collow / Craig Tomlinson / Justin Webster / Dave Whitehead / Melanie Graham / John Simpson 金卷轴奖 最佳配乐剪辑(提名) Jonathan Schultz / Steve Gallagher / Nigel Scott / Mark Willsher / Kirsty Whalley 第12届美国视觉效果协会奖 (2014) 最佳特效电影视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 最佳真人电影CG动画角色 大卫·克莱顿 / Eric Reynolds 最佳电影虚拟摄影(提名) Christian Rivers / Thelvin Cabezas 最佳真人电影模拟动画效果(提名) Areito Echevarria 最佳电影视觉效果合成(提名) Giuseppe Tagliavini / Charles Tait / Robin Hollander 第19届美国评论家选择电影奖 (2014) 最佳美术指导(提名) 丹·汉纳 / Ra Vincent 最佳服装设计(提名) 鲍勃·巴克 / Lesley Burkes-Harding / 安·马斯克里 / 理查德·泰勒 最佳化妆(提名) 最佳视觉效果(提名) 动作片最佳女主角(提名) 伊万杰琳·莉莉 第18届金卫星奖 (2014) 电影部门 最佳原创歌曲(提名) 第13届凤凰城影评人协会奖 (2013) 最佳原创配乐(提名) 霍华德·肖 霍比特人2.史矛革之战..国英双语中英字幕.The.Hobbit.2013.EXTENDED.1080p.BluRay.x264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA2%EF%BC%9A%E5%8F%B2%E7%9F%9B%E9%9D%A9%E4%B9%8B%E6%88%98%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.59GB%5D/"},{"title":"霍比特人3.五军之战.蓝光加长版","text":"[2014][欧美][动作][BT下载][霍比特人3.五军之战.蓝光加长版][BD-MKV/3.88GB][国英双语中英双字][1080P][超视效史诗巨制必看] ※※※※※※※ 影片信息 ※※※※※※※ ◎译 名 霍比特人3：五军之战/哈比人：五军之战(港台)/哈比人：奇境再返(台) ◎片 名 The Hobbit: The Battle of the Five Armies ◎年 代 2014 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2014-12-17(美国)/2015-01-23(中国大陆) ◎IMDb评分 7.5/10 from 307,296 users ◎IMDb链接 http://www.imdb.com/title/tt2310332/ ◎片 长 144分钟/164分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 马丁·弗瑞曼 Martin Freeman 伊恩·麦克莱恩 Ian McKellen 理查德·阿米蒂奇 Richard Armitage 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 本尼迪克特·康伯巴奇 Benedict Cumberbatch 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 比利·康诺利 Billy Connolly 凯特·布兰切特 Cate Blanchett 伊安·霍姆 Ian Holm 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 奥兰多·布鲁姆 Orlando Bloom 马努·贝内特 Manu Bennett 艾丹·特纳 Aidan Turner 迪恩·奥戈曼 Dean O’Gorman 格拉汉姆·麦克泰维什 Graham McTavish 斯蒂芬·弗雷 Stephen Fry 米卡埃尔·佩斯布兰特 Mikael Persbrandt ◎简 介 被吵醒的史矛革大闹长湖镇，最终为人类巴德（卢克·伊万斯 Luke Evans 饰）射杀。索林·橡木盾（理查德·阿米蒂奇 Richard Armitage 饰）多年的夙愿终于实现，孤山埃尔波尔重新回到矮人手中。然而这位矮人王子仿佛被史矛革的贪婪和堆成山的黄金迷惑了心窍，他 疯狂地搜寻象征王位的阿肯宝石，不仅撕毁了付给长湖镇报酬的约定，更拒绝了精灵王（李·佩斯 Lee Pace 饰）索要本族国宝的要求，为此导致三族的战争一触即发。与此同时，苍白半兽人阿索格率领大军浩浩荡荡向孤山逼近。得知消息的灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）从中调停斡旋，而被索林视为唯一朋友的霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）则掌握着中土命运的关键。五军会战，爆发在即！ 本片根据J.R.R·托尔金的同名原著改编，为霍比特人系列的最后一部。 ◎获奖情况 第17届美国青少年选择奖 (2015) 最佳科幻/奇幻电影(提名) 第87届奥斯卡金像奖 (2015) 最佳音效剪辑(提名) 霍比特人3.五军之战.国英双语中英双字The.Hobbit.The.Battle.of.the.Five.Armies.2014.EXTENDED.BluRay.1080p.x264.2Audios.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA3.%E4%BA%94%E5%86%9B%E4%B9%8B%E6%88%98.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.88GB%5D/"},{"title":"android之HandlerThread","text":"HandlerThread是个什么东西？查看类的定义时有这样一段话： 1Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是说：这个类的作用是创建一个包含looper的线程。那么我们在什么时候需要用到它呢?加入在应用程序当中为了实现同时完成多个任务，所以我们会在应用程序当中创建多个线程。为了让多个线程之间能够方便的通信，我们会使用Handler实现线程间的通信。这个时候我们手动实现的多线程+Handler的简化版就是我们HandlerThrea所要做的事了。 下面我们首先看一下HandlerThread的基本用法： 12345678910111213141516171819202122232425HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThreand&quot;); mHandlerThread.start(); // 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; title = (TextView) findViewById(R.id.title); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Message msg = new Message(); msg.obj = &quot;11111&quot;; mHandler.sendMessage(msg); msg = new Message(); msg.obj = &quot;2222&quot;; mHandler.sendMessage(msg); } }); 我们首先定义了一个HandlerThread对象，是直接通过new的方式产生的，查看其构造方法： 1234public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; }可以知道HandlerThread继承于Thread，所以说HandlerThread本质上是一个线程，其构造方法主要是做一些初始化的操作。 然后我们调用了mHandlerThread.start()方法，由上我们知道了HandlerThread类其实就是一个Thread，一个线程，所以其start方法内部调用的肯定是Thread的run方法，我们查看一下其run方法的具体实现： 12345678910111213@Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } 我们发现其内部调用了Looper.prepate()方法和Loop.loop()方法，熟悉android异步消息机制的童鞋应当知道，在android体系中一个线程其实是对应着一个Looper对象、一个MessageQueue对象，以及N个Handler对象，具体可参考： android源码解析之（二）–&gt;异步消息机制 所以通过run方法，我们可以知道在我们创建的HandlerThread线程中我们创建了该线程的Looper与MessageQueue； 这里需要注意的是其在调用Looper.loop()方法之前调用了一个空的实现方法：onLooperPrepared(),我们可以实现自己的onLooperPrepared（）方法，做一些Looper的初始化操作； run方法里面当mLooper创建完成后有个notifyAll()，getLooper()中有个wait()，这是为什么呢？因为的mLooper在一个线程中执行，而我们的handler是在UI线程初始化的，也就是说，我们必须等到mLooper创建完成，才能正确的返回getLooper();wait(),notify()就是为了解决这两个线程的同步问题 然后我们调用了： 1234567// 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; 该Handler的构造方法中传入了HandlerThread的Looper对象，所以Handler对象就相当于含有了HandlerThread线程中Looper对象的引用。 然后我们调用handler的sendMessage方法发送消息，在Handler的handleMessge方法中就可以接收到消息了。 最后需要注意的是在我们不需要这个looper线程的时候需要手动停止掉； 1234protected void onDestroy() { super.onDestroy(); mHandlerThread.quit(); } 相对来说HandlerThread还是比较简单的，这里总结一下： HandlerThread本质上是一个Thread对象，只不过其内部帮我们创建了该线程的Looper和MessageQueue； 通过HandlerThread我们不但可以实现UI线程与子线程的通信同样也可以实现子线程与子线程之间的通信； HandlerThread在不需要使用的时候需要手动的回收掉； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E4%B9%8BHandlerThread/"},{"title":"Android 项目构建流程","text":"平时开发过程中我们通过android studio编写完成android项目之后直接点击 Run ‘app’就可以在build/outputs/apk生成可以在android设备中安装的apk文件了，那么整个android源码的构建过程是怎么样的呢？ 我们可以根据Google官方提供的流程图来具体了解构建的过程： 通常的构建过程就是如上图所示，下面是具体描述： 1.AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。 2.AIDL工具会将所有的aidl接口转化为java接口。 3.所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。 4.Dex工具会将上述产生的.class文件及第三库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。 5.ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。 6.生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。 7.如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会减少内存的开销。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程","link":"/2020/09/11/android%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"序列化面试题","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243面试相关1. 反序列化后的对象，需要调用构造函数重新构造吗 反序列化调用不会调用构造函数。以存储的二进制数据进行构造2. 序列前的对象与序列化后的对象是什么关系？是(&quot;==&quot;还是equal？是浅复制还是深复制？) 序列化前和序列化后 是两个不同的对象，对象地址发生了改变。调用equal 和 == 返回true。是一个深复制。3. Android里面为什么要设计出Bundle而不是直接用Map结构 Bundle中是使用的Parcel打包数据。Parcel可以实现跨进程通讯。 &lt;!-- more --&gt; Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数 据对应下标，一个对象数组 保存key和value，内部使用二分法对key进行排序，所以在添加、删 除、查找数据的时候，都会使用二分法查找，只适合于小数 据量操作，如果在数据量比较大的情况 下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候， HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据 量，我没见过在两个Activity之 间传递10个以上数据的场景，所以相比之下，在这种情况下使用 ArrayMap保存数据，在操作速度和内存占用上都具有优势， 因此使用Bundle来传递数据，可以保 证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话， 需要数据是基本类型或者是可 序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。 而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为 了更加快速的进行数据的序列化和反序列化， 系统封装了Bundle类，方便我们进行数据的传输。4. SerialVersionID的作用是什么？ 版本控制5. Android中Intent/Bundle的通信原理及大小限制 大小限制 bundle 在zgote在创建进程的时候，分配了binder的内存大小。binder申请匿名内存有限制。 binder在内核空间创建内存映射时，大小限制在 &lt; 4M intent 1M限制 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限 制的(有些手机是 2 M)， 而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区 就更小了( 有人以前做过测试，大约一个线程可以占用 128 KB)。 所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时， 你应 该知道怎么解决了6. 为何Intent不能直接在组件间传递对象而要通过序列化机制？ startActivity（intent），activity启动流程要和AMS交互，需要跨进程通讯。只有把数据序列化后，传递。7. 序列化与持久化的关系和区别是什么？ 序列化:跨进程传输数据时，需要使用序列化。 持久化:数据的存储。 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程 (intent.prepareToLeaveProcess())， 这也就意味着，Intent所携带的数据要能够在不同进程间 传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输， 所以我 们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间 传输。 而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel 容器 ，后者也是Android系统专门推出的用于进程间通信等的接口","link":"/2020/09/11/%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"Android 基础知识总结","text":"​ Activity生命周期 img Fragment生命周期 Activity**四种启动模式** standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard**模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Service**的生命周期与启动方法由什么区别？** startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service**生命周期：** 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 广播**发送和接收的原理了解吗**？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。、 Android Handler机制是做什么的，原理了解吗 主要涉及的角色如下所示： 1.Message:消息,分为硬件产生的消息（例如:按钮、触摸）和软件产生的消息。 2. MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。 3. Looper：消息循环器，主要用来把消息分发给相应的处理者。 4. Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。 整个消息的循环流程还是比较清晰的，具体说来： 1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。 2. Looper通过loop()循环提取触发Message,并将Message交给对应的target handler来处理。 3. target handler调用自身的handleMessage()方法来处理Message。 如何自定义android控件 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure(int widthMeasureSpec, int heightMeasureSpec) 布局onLayout(boolean changed, int left, int top, int right, int bottom) 绘制onDraw(Canvas canvas) onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 描述一下**View的绘**制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。 ④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 requestLayout()**、invalidate()与postInvalidate()有什么区别？** requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定 会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 APK的打包流程 1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。 2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。 3. 通过Javac工具编译项目源码，生成Class文件。 4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。 5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。 6. 利用KeyStore对生成的APK文件进行签名。 7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件 的速度会更快。 (adsbygoogle = window.adsbygoogle || []).push({}); APK的安装流程 1. 复制APK到/data/app目录下，解压并扫描安装包。 2. 资源管理器解析APK里的资源文件。 3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。 4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。 5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 6. 安装完成后，发送广播。 Android Binder**机制是做什么的，为什么选用Binder，原理了解吗？** Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。 为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种： 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息**队**列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \\6. 信号 : 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进 程等； 既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量： 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全 是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。","link":"/2020/09/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it&apos;s upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法：requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact MeQQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2019/10/11/Android%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%E4%BC%A0%E8%BE%93DEMO/"},{"title":"8 Zygote进程启动流程","text":"大家都知道android系统的Zygote进程是所有的android进程的父进程，包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的，而Zygote进程则是通过linux系统的init进程启动的，也就是说，android系统中各种进程的启动方式 init进程 –&gt; Zygote进程 –&gt; SystemServer进程 –&gt;各种应用进程 init进程：linux的根进程，android系统是基于linux系统的，因此可以算作是整个android操作系统的第一个进程； Zygote进程：android系统的根进程，主要作用：可以作用Zygote进程fork出SystemServer进程和各种应用进程； SystemService进程：主要是在这个进程中启动系统的各项服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务等等； 各种应用进程：启动自己编写的客户端应用时，一般都是重新启动一个应用进程，有自己的虚拟机与运行环境； 本文主要介绍一下Zygote进程的启动流程，关于SystenServer进程和各种应用进程的启动方式会在以后的文章中介绍。 init进程在启动Zygote进程时一般都会调用ZygoteInit类的main方法，因此我们这里看一下该方法的具体实现(基于android23源码)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String argv[]) { try { RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = &quot;zygote&quot;; String abiList = null; for (int i = 1; i &lt; argv.length; i++) { if (&quot;start-system-server&quot;.equals(argv[i])) { startSystemServer = true; } else if (argv[i].startsWith(ABI_LIST_ARG)) { abiList = argv[i].substring(ABI_LIST_ARG.length()); } else if (argv[i].startsWith(SOCKET_NAME_ARG)) { socketName = argv[i].substring(SOCKET_NAME_ARG.length()); } else { throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); } } if (abiList == null) { throw new RuntimeException(&quot;No ABI list supplied.&quot;); } registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) { startSystemServer(abiList, socketName); } Log.i(TAG, &quot;Accepting command socket connections&quot;); runSelectLoop(abiList); closeServerSocket(); } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; } } 第一行主要是调用enableDdms()，设置DDMS可用，可以发现DDMS启动的时机还是比较早的，在整个Zygote进程刚刚开始要启动额时候就设置可用了。 下面的循环主要是解析main方法的参数获取是否需要启动SystemService进程，获取abi列表，获取scoket连接名称（这里需要注意的是：android系统中进程之间通讯的方式是Binder，但是有一个例外是SystemService进程与Zygote进程之间是通过Socket的方式进行通讯的） 然后调用registerZygoteSocket（String socketName）为Zygote进程注册socket： 123456789101112131415161718192021private static void registerZygoteSocket(String socketName) { if (sServerSocket == null) { int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex); } try { FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); sServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException( &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex); } } } 接着调用系统方法preLoad() 123456789101112static void preload() { Log.d(TAG, &quot;begin preload&quot;); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, &quot;end preload&quot;); } 这其中：preloadClasses()用于初始化Zygote中需要的class类；preloadResources()用于初始化系统资源；preloadOpenGL()用于初始化OpenGL；preloadSharedLibraries()用于初始化系统libraries；preloadTextResources()用于初始化文字资源；prepareWebViewInZygote()用于初始化webview; 然后调用startSystemServer(abiList, socket); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;com.android.server.SystemServer&quot;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } /* For child process */ if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); } return true; } 可以看到这段逻辑的执行逻辑就是通过Zygote fork出SystemServer进程。 总结：Zygote进程mian方法主要执行逻辑： 初始化DDMS； 注册Zygote进程的socket通讯； 初始化Zygote中的各种类，资源文件，OpenGL，类库，Text资源等等； 初始化完成之后fork出SystemServer进程； fork出SystemServer进程之后，关闭socket连接； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCache","link":"/2020/09/11/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"android之IntentService","text":"什么是IntentService？简单来说IntentService就是一个含有自身消息循环的Service，首先它是一个service，所以service相关具有的特性他都有，同时他还有一些自身的属性，其内部封装了一个消息队列和一个HandlerThread，在其具体的抽象方法：onHandleIntent方法是运行在其消息队列线程中，废话不多说，我们来看其简单的使用方法： 定义一个IntentService 123456789101112public class MIntentService extends IntentService{ public MIntentService() { super(&quot;&quot;); } @Override protected void onHandleIntent(Intent intent) { Log.i(&quot;tag&quot;, intent.getStringExtra(&quot;params&quot;) + &quot; &quot; + Thread.currentThread().getId()); }} 在androidManifest.xml中定义service 123&lt;service android:name=&quot;.MIntentService&quot; /&gt; 启动这个service 12345678title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, MIntentService.class); intent.putExtra(&quot;params&quot;, &quot;ceshi&quot;); startService(intent); } }); 可以发现当点击title组件的时候，service接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，这是为什么呢？ 下面我们来看一下service的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class IntentService extends Service { private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) { super(); mName = name; } /** * Sets intent redelivery preferences. Usually called from the constructor * with your preferred semantics. * * &lt;p&gt;If enabled is true, * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_REDELIVER_INTENT}, so if this process dies before * {@link #onHandleIntent(Intent)} returns, the process will be restarted * and the intent redelivered. If multiple Intents have been sent, only * the most recent one is guaranteed to be redelivered. * * &lt;p&gt;If enabled is false (the default), * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent * dies along with it. */ public void setIntentRedelivery(boolean enabled) { mRedelivery = enabled; } @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } /** * You should not override this method for your IntentService. Instead, * override {@link #onHandleIntent}, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } @Override public void onDestroy() { mServiceLooper.quit(); } /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override public IBinder onBind(Intent intent) { return null; } /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call {@link #stopSelf}. * * @param intent The value passed to {@link * android.content.Context#startService(Intent)}. */ @WorkerThread protected abstract void onHandleIntent(Intent intent);} 怎么样，代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。 下面看一下其onCreate方法： 12345678910111213@Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } 我们可以发现其内部定义一个HandlerIThread（本质上是一个含有消息队列的线程）具体可参考：android源码解析之（四）–&gt;HandlerThread然后用成员变量维护其Looper和Handler，由于其Handler关联着这个HandlerThread的Looper对象，所以Handler的handMessage方法在HandlerThread线程中执行。 然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法： 1234567@Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 很简单就是就是讲startId和启动时接受到的intent对象传递到消息队列中处理，那么我们具体看一下其消息队列的处理逻辑： 1234567891011private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } 可以看到起handleMessage方法内部执行了两个逻辑一个是调用了其onHandlerIntent抽象方法，通过分析其onCreate方法handler对象的创建过程我们知道其handler对象是依附于HandlerThread线程的，所以其handeMessage方法也是在HandlerThread线程中执行的，从而证实了我们刚刚例子中的一个结论，onHandlerIntent在子线程中执行。然后调用了stopSelf方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，参考其他文章我们知道，由于service可以启动N次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，只有当消息队列中最后一个消息被执行完成时才会真正的stop自身。 通过上面的例子与相关说明，我们可以知道： IntentService是一个service，也是一个抽象类； 继承IntentService需要实现其onHandlerIntent抽象方法； onHandlerIntent在子线程中执行； IntentService内部保存着一个HandlerThread、Looper与Handler等成员变量，维护这自身的消息队列； 每次IntentService后台任务执行完成之后都会尝试关闭自身，但是当且仅当IntentService消息队列中最后一个消息被执行完成之后才会真正的stop自身； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThread","link":"/2020/09/11/android%E4%B9%8BIntentService/"},{"title":"6 android之Log日志","text":"首先说点题外话，对于想学android framework源码的同学，其实可以在github中fork一份，具体地址：platform_frameworks_base这里面基本都是android framework层的源码了。而且最近发现了一个比较不错的github插件：OctoTree，它 是一个浏览器插件，它可以让你在Github 看代码时，左边栏会出现一个树状结构，就像我们在IDE 一样。当我们看一个项目的结构，或者想看具体的某个文件，这样就会很方便。 怎么样这样查看源代码的话是不是很方面？ 好了说一下我们今天需要介绍的Log对象，它位于android framework层utils包下，是一个final class类：查看其具体定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public final class Log { /** * Priority constant for the println method; use Log.v. */ public static final int VERBOSE = 2; /** * Priority constant for the println method; use Log.d. */ public static final int DEBUG = 3; /** * Priority constant for the println method; use Log.i. */ public static final int INFO = 4; /** * Priority constant for the println method; use Log.w. */ public static final int WARN = 5; /** * Priority constant for the println method; use Log.e. */ public static final int ERROR = 6; /** * Priority constant for the println method. */ public static final int ASSERT = 7; private Log() { } /** * Send a {@link #VERBOSE} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int v(String tag, String msg) { return println(LOG_ID_MAIN, VERBOSE, tag, msg); } /** * Send a {@link #VERBOSE} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int v(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, VERBOSE, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #DEBUG} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int d(String tag, String msg) { return println(LOG_ID_MAIN, DEBUG, tag, msg); } /** * Send a {@link #DEBUG} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int d(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, DEBUG, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send an {@link #INFO} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int i(String tag, String msg) { return println(LOG_ID_MAIN, INFO, tag, msg); } /** * Send a {@link #INFO} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int i(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #WARN} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int w(String tag, String msg) { return println(LOG_ID_MAIN, WARN, tag, msg); } /** * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int w(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, msg + '\\n' + getStackTraceString(tr)); } /* * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param tr An exception to log */ public static int w(String tag, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr)); } /** * Send an {@link #ERROR} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int e(String tag, String msg) { return println(LOG_ID_MAIN, ERROR, tag, msg); } /** * Send a {@link #ERROR} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int e(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, ERROR, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Handy function to get a loggable stack trace from a Throwable * @param tr An exception to log */ public static String getStackTraceString(Throwable tr) { if (tr == null) { return &quot;&quot;; } // This is to reduce the amount of log spew that apps do in the non-error // condition of the network being unavailable. Throwable t = tr; while (t != null) { if (t instanceof UnknownHostException) { return &quot;&quot;; } t = t.getCause(); } StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); tr.printStackTrace(pw); pw.flush(); return sw.toString(); } /** * Low-level logging call. * @param priority The priority/type of this log message * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } /** @hide */ public static final int LOG_ID_MAIN = 0; /** @hide */ public static final int LOG_ID_RADIO = 1; /** @hide */ public static final int LOG_ID_EVENTS = 2; /** @hide */ public static final int LOG_ID_SYSTEM = 3; /** @hide */ public static final int LOG_ID_CRASH = 4; /** @hide */ @SuppressWarnings(&quot;unused&quot;) public static int println(int bufID, int priority, String tag, String msg) { return 0; }}可以看到其实final 类，所以我们不能通过继承Log类的方式实现自身的日志工具类，一般的我们可以通过定义Log成员变量的方式，封装Log工具方法； 在Log类中我们定义了六种日志级别，分别是：VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT等六种级别，但是我们平时使用的只有前五种，即VERBOSE,DEBUG,INFO,WARN,ERROR。 通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在github的源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志； 我们暂时只是分析到这里，至于底层的c++日志输出的具体实现不作分析，总结一下： Log.java是一个final类，所以我们不可以继承Log类来实现自己的日志框架，但是可以通过关联（保存Log成员变量）的方式实现自己的Log工具类； Log.java中定义了六种日志级别，但是我们通常只是使用其中的五种日志级别，分别对应着VERBOSE、DEBUG、INFO、WARN、ERROR，在具体的使用场景下具体分析； 有些同学对android自带的日志框架不太满意，主要是无法定位日志位置，这里可以查看我写的一篇实现自定义日志框架的文章：github项目解析（五）–&gt;android日志框架 日志可以个性化的展示相关信息： 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentService","link":"/2020/09/11/android%E4%B9%8BLog%E6%97%A5%E5%BF%97/"},{"title":"24 onSaveInstanceState执行时机","text":"我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍： This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}. 可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。 通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。 Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考: android源码解析之（十四）–&gt;Activity启动流程，文章中有对Activity生命周期的详细讲解。 好吧，先具体看一下ActivityThread.handlePauseActivity的源码： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; }可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { callCallActivityOnSaveInstanceState(r); } ... } 可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的： 1performPauseActivity(token, finished, r.isPreHoneycomb()); 可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的： 1234567public boolean isPreHoneycomb() { if (activity != null) { return activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB; } return false; } 可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法： 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 这里方法体中又回调了Activity的performSaveInstanceState方法。。。 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。 这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。 然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现： 12345678910111213141516171819private void handleStopActivity(IBinder token, boolean show, int configChanges) { ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; StopInfo info = new StopInfo(); performStopActivityInner(r, info, show, true); if (localLOGV) Slog.v( TAG, &quot;Finishing stop of &quot; + r + &quot;: show=&quot; + show + &quot; win=&quot; + r.window); updateVisibility(r, show); info.activity = r; info.state = r.state; info.persistentState = r.persistentState; mH.post(info); mSomeActivitiesChanged = true; } 然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现： 12345678910private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } ... } 可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码： 1performStopActivityInner(r, info, show, true); 好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。 总结 onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。 当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。 当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程","link":"/2020/09/11/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： | 搬瓦工配置 | 搬瓦工费用 | 优惠链接 || — | — | — || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $25.99/半年 | 点击进入 || SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 40 GB RAID-10RAM内存: 2048 MBCPU处理器: 1x Intel XeonTransfer流量: 2000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $27.99/季 | 点击进入 || SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 1x Intel XeonTransfer流量: 1000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $29.99 /半年 | 点击进入 || 80G KVM – PROMOSSD硬盘: 80 GB RAID-10RAM内存: 4 GBCPU处理器: 4x Intel XeonTransfer流量: 3 TB/mo连接速度: 1 GigabitMultiple locations | $19.99/月 | 点击进入 || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $49.99/年 | 点击进入 || 40G KVM – PROMOSSD硬盘: 40 GB RAID-10RAM内存: 2 GBCPU处理器: 3x Intel XeonTransfer流量: 2 TB/mo连接速度: 1 GigabitMultiple locations | $99.99/年 | 点击进入 || 160G KVM – PROMOSSD硬盘: 160 GB RAID-10RAM内存: 8 GBCPU处理器: 5x Intel XeonTransfer流量: 4 TB/mo连接速度: 1 GigabitMultiple locations | $39.99/月 | 点击进入 || 3200G KVM – PROMOSSD硬盘: 320 GB RAID-10RAM内存: 16 GBCPU处理器: 6x Intel XeonTransfer流量: 5 TB/mo连接速度: 1 GigabitMultiple locations | $79.99/月 | 点击进入 | 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：1yum install wget 执行安装ss：1wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限1chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限1chmod +x bbr.sh 启动BBR安装1./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2019/10/11/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%BF%AB%E9%80%9F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BASS(Shadowsocks)%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"搭建 WordPress 博客教程（超详细）","text":"本文转自：Nonecy 的小黑屋*链接：http://blog.studymany.com/2018/07/29/create-wordpress-blog/* 需要 一台服务器 一个域名，直接通过ip访问好傻好傻的样子，哈哈。 linux知识 肯折腾 具体步骤第一步购买服务器，国内阿里云的云服务器挺不错的，国外的就更多了，这一步就不介绍了，不懂得的自己上网搜。接下来操作需要： 远程连接服务器Windows 用户 以Xshell为例。 下载安装Xshell，官网链接。 安装完成后新建会话（Alt+N）。依次填写图中信息。名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。 连接 点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） 用户身份验证 填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 Mac OS 用户 打开终端或者iTerm2等。 1ssh root@45.32.195.77 然后输入密码即可。 安装nginx，mysql，php建议使用lnmp一键安装包安装，方便快捷。如果不用一键安装包，我估计得研究这一块的东西大概一周吧。下面以一键安装包为例。 获取lnmp一键安装包链接 lnpm官网链接 找到下载页面选择最新的复制其链接。 写此文时最新版本信息如下： 1234LNMP 1.4 测试版http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz (131KB)MD5：bd851e151b2ba13c3a32c435efb1a76c最后更新: 2017年2月14日14:18 GMT+8 其中的http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz就是我们需要的链接，复制到剪贴板。 安装 12345678# 下载，后边的路径直接粘贴就好。XShell上面复制快捷键是ctrl+insert，粘贴快捷键是Shift+insert，mac上面是我们熟悉的 command+c，command+vwget http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz# 解压tar -zxvf lnmp1.4beta.tar.gz# 进入lnmp目录cd lnmp1.4# 执行install.sh进行安装./install.sh lnmp 依次输入你要安装的选项前的数字并回车即可下一步。 MYSQL 选项 123456789You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.53 (Default)3: Install MySQL 5.6.344: Install MySQL 5.7.165: Install MariaDB 5.5.536: Install MariaDB 10.0.287: Install MariaDB 10.1.190: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 此处根据所需选择，如果使用的上述服务器，请选择2或者直接回车。我选择默认。 注意：安装MySql时，如果选择太高的版本安装会被拒绝，提示信息如下 Memory less than 1GB, can't install MySQL 5.6, 5.7 or MairaDB 10!。根据个人手动安装MySql5.7的经验来看，此768MB内存的服务器在运行一个nginx，mysql，php时还好，倘若再运行一个tomcat，mysql将会不定期down掉。所以此处选择一个低版本的5.5MySql即可。 1234You will install MySQL 5.5.53===========================Please setup root password of MySQL.(Default password: root)Please enter: 输入密码回车或直接回车，直接回车默认密码为root。此处做实验我选择默认，个人实际使用请修改。 1234MySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: 输入Y或者n然后回车或直接回车，直接回车默认启用InnoDB存储引擎。我选择默认。 1234567891011No input,The InnoDB Storage Engine will enable.===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.306: Install PHP 7.0.157: Install PHP 7.1.1Enter your choice (1, 2, 3, 4, 5, 6 or 7): 输入选项然后回车或者直接回车，直接回车默认安装PHP5.5.38版本。我选择默认。 12345You will install PHP 7.1.1===========================You have 3 options for your Memory Allocator install.1: Don't install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMalloc 输入选项然后回车或者直接回车，直接回车默认不安装内存分配器。我选择默认。 此时出现 1Press any key to install...or Press Ctrl+c to cancel 当然是摁任意键啦，一般都是回车咯。 然后出现一大堆信息。前几行如下： 12345678910111213You will install lnmp stack.nginx-1.10.3mysql-5.5.53php-5.5.38Enable InnoDB: yPrint lnmp.conf infomation...Download Mirror: http://soft.vpser.netNginx Additional Modules: PHP Additional Modules: Database Directory: /usr/local/mysql/varDefault Website Directory: /home/wwwroot/defaultCentOS release 6.8 (Final)Kernel \\r on an \\m 这一堆东西你就不用管啦。本次实验的开始时间23:04……经过了漫长漫长漫长的等待之后……大概23:35结束。所以期间你去洗个澡看个电视剧都不是问题。然后我们看到屏幕上最后输出的信息如下。 1234The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.Add Startup and Starting LNMP...Add nginx service at system startup...Starting nginx... doneAdd mysql service at system startup...Starting MySQL... SUCCESS! Add php-fpm service at system startup...Starting php-fpm done============================== Check install ==============================Checking ...Nginx: OKMySQL: OKPHP: OKPHP-FPM: OKClean src directory...+------------------------------------------------------------------------+| LNMP V1.4 for CentOS Linux Server, Written by Licess |+------------------------------------------------------------------------+| For more information please visit https://lnmp.org |+------------------------------------------------------------------------+| lnmp status manage: lnmp {start|stop|reload|restart|kill|status} |+------------------------------------------------------------------------+| phpMyAdmin: http://IP/phpmyadmin/ || phpinfo: http://IP/phpinfo.php || Prober: http://IP/p.php |+------------------------------------------------------------------------+| Add VirtualHost: lnmp vhost add |+------------------------------------------------------------------------+| Default directory: /home/wwwroot/default |+------------------------------------------------------------------------+| MySQL/MariaDB root password: root |+------------------------------------------------------------------------++-------------------------------------------+| Manager for LNMP, Written by Licess |+-------------------------------------------+| https://lnmp.org |+-------------------------------------------+nginx (pid 715 713) is running...php-fpm is runing! SUCCESS! MySQL running (1247)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp6 0 0 :::22 :::* LISTEN Install lnmp V1.4 completed! enjoy it. 简单说明一下，此安装过程安装完成便也启动了nginx，mysql，php-fpm并加入了开机启动项。如果重启服务器，不需要再单独手动开启相关的服务了。总的来说相当方便的。 关于Linux服务，自己之前做的笔记分享给大家。Linux 服务管理 这时候你在浏览器输入http://IP 例如 http://45.32.195.77便可以访问了。看到的内容如下： 访问页面 网站根目录路径/home/wwwroot/default,如果只用来放一些静态页面，那么，现在就足够了，直接将你的html，js，css等文件丢进去即可。这不是本文重点，在此不赘述了。 退出使用ctrl+c 安装WordPress下载WordPress包 中文官方站点英文官方站点具体的根据自己的需求选择。下面以中文版为例。当前最新版本是4.7.2 为了方便，我们还是在用站点默认的路径，但是我们投机取巧一下。 1234567891011121314# 进入根目录上一级目录cd /home/wwwroot/# 将default重命名为oldmv default old# 下载WordPress包中文版wget https://cn.wordpress.org/wordpress-4.7.2-zh_CN.tar.gz# 解压WordPress包tar -zxvf wordpress-4.7.2-zh_CN.tar.gz # 查看解压后的文件夹名，此处是wordpress，估计应该都是吧，看看保险啊[root@vultr wwwroot]# lsold wordpress wordpress-4.7.2-zh_CN.tar.gz# 将wordpress重命名为defaultmv wordpress default# 再次查看检验[root@vultr wwwroot]# lsdefault old wordpress-4.7.2-zh_CN.tar.gz 给相应目录授权 12345# 目录以及目录下的文件授权[root@vultr wwwroot]# chown -R 755 /home/wwwrootchown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted# 将目录的所有者分给www组下的www用户。[root@vultr wwwroot]# chown -R www:www /home/wwwroot/chown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted 出现的提示大概是说有一个文件无法更改用户分组和权限。不会影响你的wordpress，忽略就好。 创建一个数据库wordpress 1234567891011121314151617181920212223242526# 登录数据库mysql -u root -p# 输入密码默认的话就是root，否则就是你自己之前设置的那个# 登录进来之后，看到这样一些东西Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.53-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respective owners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; # 不用理会上面的，创建我们的数据库，比如名字为wordpress。记得加分号。mysql&gt; create database wordpress;# 看一下，有没有我们创建的数据库mysql&gt; show databases;# 大概看到如下内容。意味着这一步也没问题。+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.01 sec)# 退出mysqlexit 配置WordPress 这时候在此通过浏览器访问 http://IP 例如 http://45.32.195.77，浏览器将自动跳转到http://45.32.195.77/wp-admin/setup-config.php，这就是wordpress的配置页面了，看到的内容如下： 访问页面 点击现在就开始。这时候我们看到如下页面: 数据库配置 按照之前设置的，输入如下信息。 12345数据库名：wordpress用户名：root密码：root数据库主机：localhost表前缀：wp_ 点击提交。 数据库连接完成 到这一步，基本上就意味着大功告成了，因为后边基本不会出错啦。 点击进行安装按钮。出现下图： wordpress 设置 按照自己的需求填写，比如我这里填写如下： wordpress 我的设置 点击安装WordPress按钮，然后登录设置啥的纯页面操作就不在这里过多介绍咯。 主页大概是这样的 后期问题解决有问题的反馈在此，我会进行补充。 主题只显示一个原因：php没有权限读取文件目录。 解决方案：编辑php.ini文件中的disable_functions字段，将其中的scandir去掉。 123456# 使用一键安装包安装的php的配置文件路径如下vi /usr/local/php/etc/php.ini# 查找disable_functions在当前的底行模式下输入 /disable_functions,便可以找到这样一行disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server# 删掉其中的scandir，此处很容易搞乱，所以有必要会使用编辑模式，摁i进入编辑模式。就可以输入删除了。# 退出编辑模式，并保存退出。esc退出编辑模式，:wq保存退出。 更多的指令看我之前的一个简单的入门笔记吧。Linux VIM 文本编辑器 然后记得重启php-fpm服务 1/etc/init.d/php-fpm restart 这样再刷新，就会发现主题不只有一个啦。 更多如果你使用MarkDown，那么请安装JetPack插件，如果你需要语法高亮，请安装Crayon Syntax Highlighter。 以后可能会深入研究一下，有机会的话会专门写一篇文章介绍WordPress主题与插件的哈。","link":"/2020/09/11/%E6%90%AD%E5%BB%BA%20WordPress%20%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"},{"title":"注解相关知识","text":"注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解有一个属性value，是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，@Retention 注解指定标记注解的存储方式：RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略。 这是默认的生命周期；RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此运行时环境可以使用它。 @Target 注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：ElementType.ANNOTATION_TYP可以应用于注解类型。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.METHOD 可以应用于方法级注解。ElementType.PACKAGE 可以应用于包声明。ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。 package com.example.inject; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; 在Activity 中增加注解标注，通过注解+反射+动态代理等，来优化Activity中代码。省去 setContentView、findViewById、setOnClickListener等操作。Layout注解12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectLayout { @LayoutRes int value();} View注解12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface InjectView { @IdRes int value();} OnClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent(listenerSetter = &quot;setOnClickListener&quot;, listenerType = View.OnClickListener.class, methodName = &quot;onClick&quot;)public @interface OnClick { int[] value();} OnLongClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent( listenerSetter= &quot;setOnLongClickListener&quot;, listenerType= View.OnLongClickListener.class,methodName = &quot;onLongClick&quot;)public @interface OnLongClick { int[] value();} 元注解 标注 OnClick OnLongClick 的注解1234567@Target(ElementType.ANNOTATION_TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectEvent { String listenerSetter(); Class&lt;?&gt; listenerType(); String methodName();} 注解管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.example.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManage { public static void inJect(Activity activity) { injectLayout(activity); injectView(activity); injectEvent(activity); } /** * 依赖注入 layoutId布局 * 获取 Activity 上的注解 * * @param activity */ private static void injectLayout(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity是否为InjectLayout修饰 if (clazz.isAnnotationPresent(InjectLayout.class)) {// 3.获取InjectLayout注解 InjectLayout annotation = clazz.getAnnotation(InjectLayout.class); if (annotation != null) { try {// 4.通过反射获取 当前Activity 的 setContentView 方法 Method method = clazz.getMethod(&quot;setContentView&quot;, int.class);// 5.获取注解上的value layoutId int resourceId = annotation.value();// 6.调用setContentView method.invoke(activity, resourceId); } catch (Exception e) { e.printStackTrace(); } } } } /** * 依赖注入 获取View * * @param activity */ private static void injectView(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity中所有的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) {// 3. 判断字段是否为InjectView修饰 if (field.isAnnotationPresent(InjectView.class)) { InjectView injectView = field.getAnnotation(InjectView.class); if (injectView != null) { try {// 4.反射获取findViewById方法 Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);// 5.获取资源id int resourceId = injectView.value();// 6.获取View对象 View view = (View) method.invoke(activity, resourceId);// 7.设置访问权限 field.setAccessible(true);// 8.将反射获取到的view赋值到Activity上 field.set(activity, view); } catch (Exception e) { e.printStackTrace(); } } } } } /** * 依赖注入 获取 OnClick OnLongClick注解事件 * 注解 + 反射 + 动态代理 * * @param activity */ private static void injectEvent(Activity activity) { if (activity == null) { throw new NullPointerException(); } try {// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.获取Activity的所有成员方法 排除继承方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) {// 3.是否是自定义注解修饰 if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理 OnClick onClick = method.getAnnotation(OnClick.class); int[] value = onClick.value();// 4.获取注解上的注解 元注解 InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class); String listenerSetter = injectEvent.listenerSetter(); Class&lt;?&gt; listenerType = injectEvent.listenerType(); String methodName = injectEvent.methodName();// 5.动态代理 生成代理的listener ProxyHandler handler=new ProxyHandler(activity); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]{listenerType}, handler); handler.mapMethod(methodName,method);// 6.反射获取 findViewById方法的Method对象 Method findViewByIdMethod = clazz.getMethod(&quot;findViewById&quot;, int.class); findViewByIdMethod.setAccessible(true); for (int id : value) {// 7.通过findViewById获取view View btn = (View) findViewByIdMethod.invoke(activity, id);// 8.根据listenerSetter方法名和listenerType方法参数找到method Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType); listenerSetMethod.setAccessible(true); listenerSetMethod.invoke(btn, listener); } } } } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } }} ProxyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.inject;import android.app.Activity;import android.util.Log;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ProxyHandler implements InvocationHandler { private WeakReference&lt;Activity&gt; mHandlerRef; private HashMap&lt;String, Method&gt; mMethodHashMap; public ProxyHandler(Activity activity) { mHandlerRef = new WeakReference&lt;&gt;(activity); mMethodHashMap = new HashMap&lt;&gt;(); } public void mapMethod(String name, Method method) { mMethodHashMap.put(name, method); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { try { Object handler = mHandlerRef.get(); if (null == handler) return null; String name = method.getName(); //将onClick方法的调用映射到activity 中的注解标注的方法 Method realMethod = mMethodHashMap.get(name);// Log.i(&quot;injectEvent&quot;, &quot;proxy=&quot; + proxy + &quot;,method=&quot; + method.getName() + &quot;,realMethod=&quot; + realMethod); if (null != realMethod) { return realMethod.invoke(handler, args); } } catch (Exception e) { e.printStackTrace(); } return null; }} 12345678910111213141516171819202122232425262728293031323334@InjectLayout(value = R.layout.activity_network)public class NetworkActivity extends AppCompatActivity { @InjectView(R.id.get_data) Button button; @InjectView(R.id.get_data2) Button button2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); InjectManage.inJect(this);// setContentView();// button=findViewById(R.id.button)// button.setOnClickListener(new View.OnClickListener() {// @Override// public void onClick(View v) {// testNetWorkApi();// }// });// button.setOnLongClickListener(new View.OnLongClickListener() {// @Override// public boolean onLongClick(View v) {// return false;// }// }); } @OnClick({R.id.get_data,R.id.get_data2}) public void onClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onClick&quot;); } @OnLongClick(R.id.get_data) public void onLongClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onLongClick&quot;); } 期间遇到点小问题，就是动态代理这块，对这块理解不够深。首先 Activity中 使用OnClick注解修饰的方法onClick()是需要传入参数的，否则在动态代理里，动态代理回调这个方法就会出错。","link":"/2020/09/11/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"20 Dialog取消绘制流程","text":"上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。 有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。 还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码： 123456789101112131415161718title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this.getApplication()); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.cannel(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。 好吧，看一下Dialog的cannel方法的具体实现： 12345678public void cancel() { if (!mCanceled &amp;&amp; mCancelMessage != null) { mCanceled = true; // Obtain a new message so this dialog can be re-used Message.obtain(mCancelMessage).sendToTarget(); } dismiss(); } 可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑： 123456789101112public void setOnCancelListener(final OnCancelListener listener) { if (mCancelAndDismissTaken != null) { throw new IllegalStateException( &quot;OnCancelListener is already taken by &quot; + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;); } if (listener != null) { mCancelMessage = mListenersHandler.obtainMessage(CANCEL, listener); } else { mCancelMessage = null; } }可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。 这样，我们来看一下dismiss方法的实现逻辑： 1234567public void dismiss() { if (Looper.myLooper() == mHandler.getLooper()) { dismissDialog(); } else { mHandler.post(mDismissAction); } } 可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义：12345private final Runnable mDismissAction = new Runnable() { public void run() { dismissDialog(); } };好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。 所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。123456789101112131415161718192021222324void dismissDialog() { if (mDecor == null || !mShowing) { return; } if (mWindow.isDestroyed()) { Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog's window was already destroyed!&quot;); return; } try { mWindowManager.removeViewImmediate(mDecor); } finally { if (mActionMode != null) { mActionMode.finish(); } mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); } }好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。 然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。 然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现： 1234@Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } 可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑: 1234567891011121314151617public void removeView(View view, boolean immediate) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView); } } 可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑： 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。 1234567891011121314151617boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, &quot;Attempting to destroy the window while drawing!\\n&quot; + &quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } 可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839void doDie() { checkThread(); if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface); synchronized (this) { if (mRemoved) { return; } mRemoved = true; if (mAdded) { dispatchDetachedFromWindow(); } if (mAdded &amp;&amp; !mFirst) { destroyHardwareRenderer(); if (mView != null) { int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) { // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try { if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) { mWindowSession.finishDrawing(mWindow); } } catch (RemoteException e) { } } mSurface.release(); } } mAdded = false; } WindowManagerGlobal.getInstance().doRemoveView(this); } 可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void dispatchDetachedFromWindow() { if (mView != null &amp;&amp; mView.mAttachInfo != null) { mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); mView.dispatchDetachedFromWindow(); } mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) { mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; } if (mInputEventReceiver != null) { mInputEventReceiver.dispose(); mInputEventReceiver = null; } try { mWindowSession.remove(mWindow); } catch (RemoteException e) { } // Dispose the input channel after removing the window so the Window Manager // doesn't interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) { mInputChannel.dispose(); mInputChannel = null; } mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals(); } 可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940void dispatchDetachedFromWindow() { AttachInfo info = mAttachInfo; if (info != null) { int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(GONE); } } onDetachedFromWindow(); onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) { imm.onViewDetachedFromWindow(this); } ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewDetachedFromWindow(this); } } if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) { mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; } mAttachInfo = null; if (mOverlay != null) { mOverlay.getOverlayView().dispatchDetachedFromWindow(); } } 其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法： 12345678910111213141516171819protected void onDetachedFromWindowInternal() { mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT; mPrivateFlags3 &amp;= ~PFLAG3_IS_LAID_OUT; removeUnsetPressCallback(); removeLongPressCallback(); removePerformClickCallback(); removeSendViewScrolledAccessibilityEventCallback(); stopNestedScroll(); // Anything that started animating right before detach should already // be in its final state when re-attached. jumpDrawablesToCurrentState(); destroyDrawingCache(); cleanupDraw(); mCurrentAnimation = null; } onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现： 12345678910public void destroyDrawingCache() { if (mDrawingCache != null) { mDrawingCache.recycle(); mDrawingCache = null; } if (mUnscaledDrawingCache != null) { mUnscaledDrawingCache.recycle(); mUnscaledDrawingCache = null; } } 这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。 这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。 而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。 这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：android源码解析之（十五）–&gt;Activity销毁流程当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现： 123456private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... wm.removeViewImmediate(v); ... } 可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。 总结： 窗口的取消绘制流程是相似的，包括Activity和Dialog等； 通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程； Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程","link":"/2020/09/11/Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"27 HOME事件流程","text":"上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。 好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } if (DEBUG_INPUT) { if (fallbackEvent == null) { Slog.d(TAG, &quot;No fallback.&quot;); } else { Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent); } } return fallbackEvent; } 通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现： 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) { ... // First we always handle the home key here, so applications // can never break it, although if keyguard is on, we do let // it handle it, because that gives us the correct 5 second // timeout. if (keyCode == KeyEvent.KEYCODE_HOME) { // If we have released the home key, and didn't do anything else // while it was pressed, then it is time to go home! if (!down) { cancelPreloadRecentApps(); mHomePressed = false; if (mHomeConsumed) { mHomeConsumed = false; return -1; } if (canceled) { Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;); return -1; } // If an incoming call is ringing, HOME is totally disabled. // (The user is already on the InCallUI at this point, // and his ONLY options are to answer or reject the call.) TelecomManager telecomManager = getTelecommService(); if (telecomManager != null &amp;&amp; telecomManager.isRinging()) { Log.i(TAG, &quot;Ignoring HOME; there's a ringing incoming call.&quot;); return -1; } // Delay handling home if a double-tap is possible. if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) { mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); // just in case mHomeDoubleTapPending = true; mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout()); return -1; } handleShortPressOnHome(); return -1; } // If a system window has focus, then it doesn't make sense // right now to interact with applications. WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null; if (attrs != null) { final int type = attrs.type; if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0) { // the &quot;app&quot; is keyguard, so give it the key return 0; } final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length; for (int i=0; i&lt;typeCount; i++) { if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) { // don't do anything, but also don't pass it to the app return -1; } } } // Remember that home is pressed and handle special actions. if (repeatCount == 0) { mHomePressed = true; if (mHomeDoubleTapPending) { mHomeDoubleTapPending = false; mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); handleDoubleTapOnHome(); } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) { preloadRecentApps(); } } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) { if (!keyguardOn) { handleLongPressOnHome(event.getDeviceId()); } } return -1; } // Let the application handle the key. return 0; } 这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。 1234567891011121314private void handleShortPressOnHome() { // Turn on the connected TV and switch HDMI input if we're a HDMI playback device. getHdmiControl().turnOnTv(); // If there's a dream running then use home to escape the dream // but don't actually go home. if (mDreamManagerInternal != null &amp;&amp; mDreamManagerInternal.isDreaming()) { mDreamManagerInternal.stopDream(false /*immediate*/); return; } // Go home! launchHomeFromHotKey(); } 可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现： 123void launchHomeFromHotKey() { launchHomeFromHotKey(true /* awakenFromDreams */, true /*respectKeyguard*/); } 可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) { if (respectKeyguard) { if (isKeyguardShowingAndNotOccluded()) { // don't launch home if keyguard showing return; } if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) { // when in keyguard restricted mode, must first verify unlock // before launching home mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() { @Override public void onKeyguardExitResult(boolean success) { if (success) { try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } }); return; } } // no keyguard stuff to worry about, just launch home! try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } if (mRecentsVisible) { // Hide Recents and notify it to launch Home if (awakenFromDreams) { awakenDreams(); } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); hideRecentApps(false, true); } else { // Otherwise, just launch Home sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } 可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。 1234567891011121314151617@Override public void stopAppSwitches() { if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(&quot;Requires permission &quot; + android.Manifest.permission.STOP_APP_SWITCHES); } synchronized(this) { mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME; mDidAppSwitch = false; mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG); Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG); mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME); } } 可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义： 123// Amount of time after a call to stopAppSwitches() during which we will // prevent further untrusted switches from happening. static final long APP_SWITCH_DELAY_TIME = 5*1000; 然后我们可以看一下mHander的handleMessage方法的具体实现： 12345case DO_PENDING_ACTIVITY_LAUNCHES_MSG: { synchronized (ActivityManagerService.this) { mStackSupervisor.doPendingActivityLaunchesLocked(true); } } break; 可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。 1234567final void doPendingActivityLaunchesLocked(boolean doResume) { while (!mPendingActivityLaunches.isEmpty()) { PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); } } 可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：android源码解析之（十四）–&gt;Activity启动流程 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行… 然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。 123void sendCloseSystemWindows(String reason) { PhoneWindow.sendCloseSystemWindows(mContext, reason); } 可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。 12345678public static void sendCloseSystemWindows(Context context, String reason) { if (ActivityManagerNative.isSystemReady()) { try { ActivityManagerNative.getDefault().closeSystemDialogs(reason); } catch (RemoteException e) { } } } 看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。 12345678910111213141516171819202122232425262728@Override public void closeSystemDialogs(String reason) { enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;); final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try { synchronized (this) { // Only allow this from foreground processes, so that background // applications can't abuse it to prevent system UI from being shown. if (uid &gt;= Process.FIRST_APPLICATION_UID) { ProcessRecord proc; synchronized (mPidsSelfLocked) { proc = mPidsSelfLocked.get(pid); } if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason + &quot; from background process &quot; + proc); return; } } closeSystemDialogsLocked(reason); } } finally { Binder.restoreCallingIdentity(origId); } } 可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。 123456789101112131415void closeSystemDialogsLocked(String reason) { Intent intent = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); if (reason != null) { intent.putExtra(&quot;reason&quot;, reason); } mWindowManager.closeSystemDialogs(reason); mStackSupervisor.closeSystemDialogsLocked(); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, -1, Process.SYSTEM_UID, UserHandle.USER_ALL); } 可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等： 12345678910111213141516171819@Override public void closeSystemDialogs(String reason) { synchronized(mWindowMap) { final int numDisplays = mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) { final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList(); final int numWindows = windows.size(); for (int winNdx = 0; winNdx &lt; numWindows; ++winNdx) { final WindowState w = windows.get(winNdx); if (w.mHasSurface) { try { w.mClient.closeSystemDialogs(reason); } catch (RemoteException e) { } } } } } } 讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。 12345678910111213141516171819202122232425262728void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) { if (awakenFromDreams) { awakenDreams(); } Intent dock = createHomeDockIntent(); if (dock != null) { try { if (fromHomeKey) { dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } startActivityAsUser(dock, UserHandle.CURRENT); return; } catch (ActivityNotFoundException e) { } } Intent intent; if (fromHomeKey) { intent = new Intent(mHomeIntent); intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } else { intent = mHomeIntent; } startActivityAsUser(intent, UserHandle.CURRENT); } 可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。 总结： 系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理； 系统监听到HOME按键之后会首先关闭相应的系统弹窗； 通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程","link":"/2020/09/11/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"10 Launcher启动流程","text":"Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。 不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。 通过上一篇文章，我们知道SystemServer进程主要用于启动系统的各种服务，二者其中就包含了负责启动Launcher的服务，LauncherAppService。具体关于SystenServer的启动流程可以参见： android源码解析之（九）–&gt;SystemServer进程启动流程 在SystemServer进程的启动过程中会调用其main静态方法，开始执行整个SystemServer的启动流程，在其中通过调用三个内部方法分别启动boot service、core service和other service。在调用startOtherService方法中就会通过调用mActivityManagerService.systemReady()方法，那么我们看一下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. mActivityManagerService.systemReady(new Runnable() { @Override public void run() { Slog.i(TAG, &quot;Making services ready&quot;); mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); try { mActivityManagerService.startObservingNativeCrashes(); } catch (Throwable e) { reportWtf(&quot;observing native crashes&quot;, e); } Slog.i(TAG, &quot;WebViewFactory preparation&quot;); WebViewFactory.prepareWebViewInSystemServer(); try { startSystemUi(context); } catch (Throwable e) { reportWtf(&quot;starting System UI&quot;, e); } try { if (networkScoreF != null) networkScoreF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Score Service ready&quot;, e); } try { if (networkManagementF != null) networkManagementF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Managment Service ready&quot;, e); } try { if (networkStatsF != null) networkStatsF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Stats Service ready&quot;, e); } try { if (networkPolicyF != null) networkPolicyF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Policy Service ready&quot;, e); } try { if (connectivityF != null) connectivityF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Connectivity Service ready&quot;, e); } try { if (audioServiceF != null) audioServiceF.systemReady(); } catch (Throwable e) { reportWtf(&quot;Notifying AudioService running&quot;, e); } Watchdog.getInstance().start(); // It is now okay to let the various system services start their // third party code... mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); try { if (wallpaperF != null) wallpaperF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying WallpaperService running&quot;, e); } try { if (immF != null) immF.systemRunning(statusBarF); } catch (Throwable e) { reportWtf(&quot;Notifying InputMethodService running&quot;, e); } try { if (locationF != null) locationF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying Location Service running&quot;, e); } try { if (countryDetectorF != null) countryDetectorF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying CountryDetectorService running&quot;, e); } try { if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying NetworkTimeService running&quot;, e); } try { if (commonTimeMgmtServiceF != null) { commonTimeMgmtServiceF.systemRunning(); } } catch (Throwable e) { reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e); } try { if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e); } try { if (atlasF != null) atlasF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying AssetAtlasService running&quot;, e); } try { // TODO(BT) Pass parameter to input manager if (inputManagerF != null) inputManagerF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying InputManagerService running&quot;, e); } try { if (telephonyRegistryF != null) telephonyRegistryF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e); } try { if (mediaRouterF != null) mediaRouterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MediaRouterService running&quot;, e); } try { if (mmsServiceF != null) mmsServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MmsService running&quot;, e); } } });可以发现这个方法传递了一个Runnable参数，里面执行了各种其他服务的systemReady方法，这里不是我们关注的重点，我们看一下在ActivityManagerService中systemReady方法的具体实现，方法体比较长，我就不在这里贴出代码了，主要的逻辑就是做一些ActivityManagerService的ready操作 1234567public void systemReady(final Runnable goingCallback) { ... // Start up initial activity. mBooting = true; startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); ... } 重点是在这个方法体中调用了startHomeActivityLocked方法，看其名字就是说开始执行启动homeActivity的操作，好了，既然如此，我们再看一下startHomeActivityLocked的具体实现： 12345678910111213141516171819202122232425262728boolean startHomeActivityLocked(int userId, String reason) { if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) { // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don't try to start anything. return false; } Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) { intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) { intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); mStackSupervisor.startHomeActivity(intent, aInfo, reason); } } return true; } 首先是调用getHomeIntent()方法，看一下getHomeIntent是如何实现构造Intent对象的： 12345678Intent getHomeIntent() { Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) { intent.addCategory(Intent.CATEGORY_HOME); } return intent; } 可以发现，启动Launcher的Intent对象中添加了Intent.CATEGORY_HOME常量，这个其实是一个launcher的标志，一般系统的启动页面Activity都会在androidmanifest.xml中配置这个标志。比如我们在github中的android launcher源码中查看其androidmanifest.xml文件：可以发现其Activity的定义intentfilter中就是定义了这样的category。不同的手机厂商可能会修改Launcher的源码，但是这个category一般是不会更改的。 继续回到我们的startHomeActivityLocked方法，我们发现经过一系列的判断逻辑之后最后调用了mStackSupervisor.startHomeActivity方法，然后我们可以查看一下该方法的具体实现逻辑： 12345678910111213141516void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) { moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); startActivityLocked(null /* caller */, intent, null /* resolvedType */, aInfo, null /* voiceSession */, null /* voiceInteractor */, null /* resultTo */, null /* resultWho */, 0 /* requestCode */, 0 /* callingPid */, 0 /* callingUid */, null /* callingPackage */, 0 /* realCallingPid */, 0 /* realCallingUid */, 0 /* startFlags */, null /* options */, false /* ignoreTargetSecurity */, false /* componentSpecified */, null /* outActivity */, null /* container */, null /* inTask */); if (inResumeTopActivity) { // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. scheduleResumeTopActivities(); } } 发现其调用的是scheduleResumeTopActivities()方法，这个方法其实是关于Activity的启动流程的逻辑了，这里我们不在详细的说明，关于Activity的启动流程我们在下面的文章中会介绍。 因为我们的Launcher启动的Intent是一个隐士的Intent，所以我们会启动在androidmanifest.xml中配置了相同catogory的activity，android M中配置的这个catogory就是LauncherActivity。 LauncherActivity继承与ListActivity，我们看一下其Layout布局文件： 12345678910111213141516171819202122&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;TextView android:id=&quot;@android:id/empty&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/activity_list_empty&quot; android:visibility=&quot;gone&quot; android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt;&lt;/FrameLayout&gt; 可以看到我们现实的桌面其实就是一个ListView控件，然后看一下其onCreate方法： 12345678910111213141516171819202122232425262728@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPackageManager = getPackageManager(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); setProgressBarIndeterminateVisibility(true); } onSetContentView(); mIconResizer = new IconResizer(); mIntent = new Intent(getTargetIntent()); mIntent.setComponent(null); mAdapter = new ActivityAdapter(mIconResizer); setListAdapter(mAdapter); getListView().setTextFilterEnabled(true); updateAlertTitle(); updateButtonText(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { setProgressBarIndeterminateVisibility(false); } } 可以看到在LauncherActivity的onCreate方法中初始化了一个PackageManager，其主要作用就是从中查询出系统所有已经安装的应用列表，应用包名，应用图标等信息。然后将这些信息注入到Adapter中，这样就可以将系统应用图标和名称显示出来了。在系统的回调方法onListItemClick中 12345@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } 这也就是为什么我们点击了某一个应用图标之后可以启动某一项应用的原因了，我们看一下这里的intentForPosition是如何实现的。 1234protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); } 这里又调用了adapter的intentForPosition方法： 12345678910111213public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以看到由于adapter的每一项中都保存了应用的包名可启动Activity名称，所以这里在初始化Intent的时候，直接将这些信息注入到Intent中，然后调用startActivity，就将这些应用启动了（关于startActivity是如何启动的下面的文章中我将介绍）。 总结： Launcher的启动流程 Zygote进程 –&gt; SystemServer进程 –&gt; startOtherService方法 –&gt; ActivityManagerService的systemReady方法 –&gt; startHomeActivityLocked方法 –&gt; ActivityStackSupervisor的startHomeActivity方法 –&gt; 执行Activity的启动逻辑，执行scheduleResumeTopActivities()方法。。。。 因为是隐士的启动Activity，所以启动的Activity就是在AndroidManifest.xml中配置catogery的值为： 1public static final String CATEGORY_HOME = &quot;android.intent.category.HOME&quot;; 可以发现android M中在androidManifest.xml中配置了这个catogory的activity是LauncherActivity，所以我们就可以将这个Launcher启动起来了 LauncherActivity中是以ListView来显示我们的应用图标列表的，并且为每个Item保存了应用的包名和启动Activity类名，这样点击某一项应用图标的时候就可以根据应用包名和启动Activity名称启动我们的App了。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程","link":"/2020/09/11/Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"MacOS快捷键说明","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 聚焦快捷键 启动快捷键 iTunes 快捷键：从 iTunes 菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。","link":"/2020/09/11/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"},{"title":"21 PopupWindow加载绘制流程","text":"在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。 在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明： A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. 一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。 在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。 1234567891011121314151617181920212223public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) { LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(layoutId, null); popupWindow = new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg)); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); int[] location = new int[2]; anchorView.getLocationOnScreen(location); popupWindow.setAnimationStyle(R.style.popwin_anim_style); popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12), location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10)); popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() { @Override public void onDismiss() { popupWindow = null; } }); return view; } 可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。 这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现： 123public PopupWindow(View contentView, int width, int height) { this(contentView, width, height, false); }可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑： 1234567891011public PopupWindow(View contentView, int width, int height, boolean focusable) { if (contentView != null) { mContext = contentView.getContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } setContentView(contentView); setWidth(width); setHeight(height); setFocusable(focusable); } 这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。 我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑： 123public void showAtLocation(View parent, int gravity, int x, int y) { showAtLocation(parent.getWindowToken(), gravity, x, y); } 可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式： 12345678910111213141516171819202122232425public void showAtLocation(IBinder token, int gravity, int x, int y) { if (isShowing() || mContentView == null) { return; } TransitionManager.endTransitions(mDecorView); unregisterForScrollChanged(); mIsShowing = true; mIsDropdown = false; final WindowManager.LayoutParams p = createPopupLayoutParams(token); preparePopup(p); // Only override the default if some gravity was specified. if (gravity != Gravity.NO_GRAVITY) { p.gravity = gravity; } p.x = x; p.y = y; invokePopup(p); } 可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637private void preparePopup(WindowManager.LayoutParams p) { if (mContentView == null || mContext == null || mWindowManager == null) { throw new IllegalStateException(&quot;You must specify a valid content view by &quot; + &quot;calling setContentView() before attempting to show the popup.&quot;); } // The old decor view may be transitioning out. Make sure it finishes // and cleans up before we try to create another one. if (mDecorView != null) { mDecorView.cancelTransitions(); } // When a background is available, we embed the content view within // another view that owns the background drawable. if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } mDecorView = createDecorView(mBackgroundView); // The background owner should be elevated so that it casts a shadow. mBackgroundView.setElevation(mElevation); // We may wrap that in another view, so we'll need to manually specify // the surface insets. final int surfaceInset = (int) Math.ceil(mBackgroundView.getZ() * 2); p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset); p.hasManualSurfaceInsets = true; mPopupViewInitialLayoutDirectionInherited = (mContentView.getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT); mPopupWidth = p.width; mPopupHeight = p.height; } preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程： 123456if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } 可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑： 12345678910111213141516private PopupBackgroundView createBackgroundView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupBackgroundView backgroundView = new PopupBackgroundView(mContext); final PopupBackgroundView.LayoutParams listParams = new PopupBackgroundView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height); backgroundView.addView(contentView, listParams); return backgroundView; } 可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。 继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现： 12345678910111213141516private PopupDecorView createDecorView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView; } 可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现： 12345678910111213141516@Override public boolean onTouchEvent(MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); if ((event.getAction() == MotionEvent.ACTION_DOWN) &amp;&amp; ((x &lt; 0) || (x &gt;= getWidth()) || (y &lt; 0) || (y &gt;= getHeight()))) { dismiss(); return true; } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) { dismiss(); return true; } else { return super.onTouchEvent(event); } } 可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。 好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑： 12345678910111213141516private void invokePopup(WindowManager.LayoutParams p) { if (mContext != null) { p.packageName = mContext.getPackageName(); } final PopupDecorView decorView = mDecorView; decorView.setFitsSystemWindows(mLayoutInsetDecor); setLayoutDirectionFromAnchor(); mWindowManager.addView(decorView, p); if (mEnterTransition != null) { decorView.requestEnterTransition(mEnterTransition); } } 我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是： 123if (mWindowManager == null &amp;&amp; mContentView != null) { mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } 而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现： 1234@Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。 1234public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } 这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下： 123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() { @Override public WindowManager createService(ContextImpl ctx) { return new WindowManagerImpl(ctx.getDisplay()); }}); 好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。 这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。 好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。 总结： PopupWindow的界面加载绘制流程也是通过Window对象实现的； PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象； PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程","link":"/2020/09/11/PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; } 在android 中配置 sourceSets { main { jni.srcDirs = [&apos;src/main/jni&apos;, &apos;src/main/jni/&apos;] } } externalNativeBuild { ndkBuild { path &apos;src/main/jni/Android.mk&apos; } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2019/10/11/SerialportManager/"},{"title":"22 Toast加载绘制流程","text":"前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。 其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。 Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。 下面我们来具体看一下Toast窗口的简单使用。 1Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); 上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。 下面我们来看一下makeText方法的具体实现： 1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) { Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; } 方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。 12345678public Toast(Context context) { mContext = context; mTN = new TN(); mTN.mY = context.getResources().getDimensionPixelSize( com.android.internal.R.dimen.toast_y_offset); mTN.mGravity = context.getResources().getInteger( com.android.internal.R.integer.config_toastDefaultGravity); }可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？ 1private static class TN extends ITransientNotification.Stub 从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件： 123LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); 这里我们可以看一下布局文件的具体代码： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。 然后我们通过调用： 1234567TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; 初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。 然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现： 12345678910111213141516public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } 首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。 然后我们执行了： 1INotificationManager service = getService(); 这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式： 1234567static private INotificationManager getService() { if (sService != null) { return sService; } sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; } 这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。 好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) { ... synchronized (mToastQueue) { int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try { ToastRecord record; int index = indexOfToastLocked(pkg, callback); // If it's already in the queue, we update it in place, we don't // move it to the end of the queue. if (index &gt;= 0) { record = mToastQueue.get(index); record.update(duration); } else { // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; } } } } record = new ToastRecord(callingPid, pkg, callback, duration); mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid); } // If it's at index 0, it's the current toast. It doesn't matter if it's // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don't // assume that it's valid after this. if (index == 0) { showNextToastLocked(); } } finally { Binder.restoreCallingIdentity(callingId); } } } 可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。 12345678910111213141516171819202122232425void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } 这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。 1234567private void scheduleTimeoutLocked(ToastRecord r) { mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); } 可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。 12345678910private void handleTimeout(ToastRecord record) { if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) { int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) { cancelToastLocked(index); } } } 好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现： 12345678910111213141516171819void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don't worry about this, we're about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); } } 好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了: 1mToastQueue.remove(index); 清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。 这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现： 12345@Override public void show() { if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); } 好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。 123456final Runnable mShow = new Runnable() { @Override public void run() { handleShow(); } }; 可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738public void handleShow() { if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) { // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) { context = mView.getContext(); } mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) { mParams.horizontalWeight = 1.0f; } if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) { mParams.verticalWeight = 1.0f; } mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); } } 好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章 android源码解析（十八）–&gt;Activity布局绘制流程&nbsp;&nbsp; android源码解析（十七）–&gt;Activity布局加载流程）通过这个方法就实现了Toast窗口的显示逻辑。 继续看一下TN的hide方法： 12345@Override public void hide() { if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); } 好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义： 12345678final Runnable mHide = new Runnable() { @Override public void run() { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; } }; 可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑： 1234567891011121314public void handleHide() { if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) { // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } mView = null; } } 可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。 总结： Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现） Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。 NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。 Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。 NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程","link":"/2020/09/11/Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"15 activity销毁流程","text":"继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？ 这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是： onPause(b)onRestart(a)onStart(a)onResume(a)onStop(b)onDestory(b) 好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。 一：请求销毁当前Activity MyActivity.finish()Activity.finish()ActivityManagerNative.getDefault().finishActivity()ActivityManagerService.finishActivity()ActivityStack.requestFinishActivityLocked()ActivityStack.finishActivityLocked()ActivityStack.startPausingLocked() 首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法： 123public void finish() { finish(false);}然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值： 123456789101112131415161718192021222324private void finish(boolean finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, &quot;Finishing self: token=&quot; + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(); } if (ActivityManagerNative.getDefault() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } 好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。 123456@Overridepublic final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) { ... res = tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true); ...} 这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。 1234567891011121314final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) { ActivityRecord r = isInStackLocked(token); if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES, &quot;Finishing activity token=&quot; + token + &quot; r=&quot; + &quot;, result=&quot; + resultCode + &quot;, data=&quot; + resultData + &quot;, reason=&quot; + reason); if (r == null) { return false; } finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true; } 这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现： 1234567final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) { ... startPausingLocked(false, false, false, false); ... return false; } 好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现： 123456789101112131415161718final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。 二：执行当前Activity的onPause方法 IApplicationThread.schedulePauseActivity()ActivityThread.schedulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused()ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked() 在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现： 123456public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges);} 然后调用了ActivityThread的sendMessage方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 然后又回调了sendMessage的重载方法。。 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码： performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause() 这样我们就回调了第一个生命周期方法：onPause。。。 在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法： 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 这样，我们继续看一下activityPausedLocked方法的实现： 12345final void activityPausedLocked(IBinder token, boolean timeout) { ... completePauseLocked(true); ...} 里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法： 1234private void completePauseLocked(boolean resumeNext) { ... mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); ... } 这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。 三：执行上一个Activity的onResume操作这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程： ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopInnerLocked()IApplicationThread.scheduleResumeActivity()ActivityThread.scheduleResumeActivity()ActivityThread.sendMessage()ActivityTherad.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.H.handleResumeMessage()Activity.performResume()Activity.performRestart()Instrumentation.callActivityOnRestart()Activity.onRestart()Activity.performStart()Instrumentation.callActivityOnStart()Activity.onStart()Instrumentation.callActivityOnResume()Activity.onResume() 好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。 四：执行栈顶Activity的销毁操作 Looper.myQueue().addIdleHandler(new Idler())ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.destroyActivityLocked()IApplicationThread.scheduleDestoryActivity()ActivityThread.scheduleDestoryActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleDestoryActivity()ActivityThread.performDestoryActivity()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop()Instrumentation.callActivityOnDestory()Activity.performDestory()Acitivity.onDestory()ActivityManagerNative.getDefault().activityDestoryed()ActivityManagerService.activityDestoryed()ActivityStack.activityDestoryedLocked() 我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现： 12345final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { .... stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;); .... } 可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现： 12345final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) { ... r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags); ... } 好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现： 1234public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) { sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0, configChanges);} 这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance); if (r != null) { cleanUpPendingRemoveWindows(r); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) { if (r.activity.mVisibleFromServer) { mNumVisibleActivities--; } IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) { if (r.onlyLocalRequest) { // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = v; r.mPendingRemoveWindowManager = wm; } else { wm.removeViewImmediate(v); } } if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) { WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), &quot;Activity&quot;); } r.activity.mDecor = null; } if (r.mPendingRemoveWindow == null) { // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), &quot;Activity&quot;); } // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) { ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), &quot;Activity&quot;); } } if (finishing) { try { ActivityManagerNative.getDefault().activityDestroyed(token); } catch (RemoteException ex) { // If the system process has died, it's game over for everyone. } } mSomeActivitiesChanged = true; } 可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法： 12345678private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... r.activity.performStop(); ... mInstrumentation.callActivityOnDestroy(r.activity); ... } 然后调用了Activity.performStop()方法，查看performStop方法： 12345final void performStop() { ... mInstrumentation.callActivityOnStop(this); ...} 然后调用了Instrumentation.callActivityOnStop()方法： 123public void callActivityOnStop(Activity activity) { activity.onStop(); } 好吧，终于调用了Activity的onStop方法。。。 我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法： 12345public void callActivityOnDestroy(Activity activity) { ... activity.performDestroy(); ...} 然后看一下Activity的performDestroy()方法的实现： 12345678910final void performDestroy() { mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) { mVoiceInteractor.detachActivity(); } } O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。 总结： Activity的销毁流程是从finish方法开始的 Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程","link":"/2020/09/11/activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/"},{"title":"7 android之LruCache","text":"android开发过程中经常会用到缓存，现在主流的app中图片等资源的缓存策略一般是分两级，一个是内存级别的缓存，一个是磁盘级别的缓存。 作为android系统的维护者google也开源了其缓存方案，LruCache和DiskLruCache。从android3.1开始LruCache已经作为android源码的一部分维护在android系统中，为了兼容以前的版本android的support-v4包也提供了LruCache的维护，如果App需要兼容到android3.1之前的版本就需要使用support-v4包中的LruCache，如果不需要兼容到android3.1则直接使用android源码中的LruCache即可，这里需要注意的是DiskLruCache并不是android源码的一部分。 在LruCache的源码中，关于LruCache有这样的一段介绍： 1A cache that holds strong references to a limited number of values. Each time a value is accessed, it is moved to the head of a queue. When a value is added to a full cache, the value at the end of that queue is evicted and may become eligible for garbage collection. cache对象通过一个强引用来访问内容。每次当一个item被访问到的时候，这个item就会被移动到一个队列的队首。当一个item被添加到已经满了的队列时，这个队列的队尾的item就会被移除。 其实这个实现的过程就是LruCache的缓存策略，即Lru–&gt;(Least recent used)最少最近使用算法。 下面我们具体看一下LruCache的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319public class LruCache&lt;K, V&gt; { private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override {@link #sizeOf}, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); } /** * Sets the size of the cache. * * @param maxSize The new maximum size. */ public void resize(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } synchronized (this) { this.maxSize = maxSize; } trimToSize(maxSize); } /** * Returns the value for {@code key} if it exists in the cache or can be * created by {@code #create}. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } /** * Caches {@code value} for {@code key}. The value is moved to the head of * the queue. * * @return the previous value mapped by {@code key}. */ public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } /** * Removes the entry for {@code key} if it exists. * * @return the previous value mapped by {@code key}. */ public final V remove(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V previous; synchronized (this) { previous = map.remove(key); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, null); } return previous; } /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * {@link #remove}, or replaced by a call to {@link #put}. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a {@link #put} or {@link #remove}. * @param newValue the new value for {@code key}, if it exists. If non-null, * this removal was caused by a {@link #put}. Otherwise it was caused by * an eviction or a {@link #remove}. */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {} /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for {@code key} exists in the cache when this method * returns, the created value will be released with {@link #entryRemoved} * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls {@link #put} while another is creating a value for the same * key. */ protected V create(K key) { return null; } private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); } return result; } /** * Returns the size of the entry for {@code key} and {@code value} in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * * &lt;p&gt;An entry's size must not change while it is in the cache. */ protected int sizeOf(K key, V value) { return 1; } /** * Clear the cache, calling {@link #entryRemoved} on each removed entry. */ public final void evictAll() { trimToSize(-1); // -1 will evict 0-sized elements } /** * For caches that do not override {@link #sizeOf}, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. */ public synchronized final int size() { return size; } /** * For caches that do not override {@link #sizeOf}, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() { return maxSize; } /** * Returns the number of times {@link #get} returned a value that was * already present in the cache. */ public synchronized final int hitCount() { return hitCount; } /** * Returns the number of times {@link #get} returned null or required a new * value to be created. */ public synchronized final int missCount() { return missCount; } /** * Returns the number of times {@link #create(Object)} returned a value. */ public synchronized final int createCount() { return createCount; } /** * Returns the number of times {@link #put} was called. */ public synchronized final int putCount() { return putCount; } /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() { return evictionCount; } /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() { return new LinkedHashMap&lt;K, V&gt;(map); } @Override public synchronized final String toString() { int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); }}可以看到LruCache初始化的时候需要使用泛型，一般的我们这样初始化LruCache对象： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 这里我们假设通过String作为key保存bitmap对象，同时需要传递一个int型的maxSize数值，主要用于设置LruCache链表的最大值。 查看其构造方法： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 可以看到其主要的是初始化了maxSize和map链表对象。 然后查看put方法： 12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } 需要传递两个参数：K和V，首先做了一下参数的判断，然后定义一个保存前一个Value值得临时变量，让putCount（put执行的次数）自增，让map的size大小自增。需要注意的是这里的 1previous = map.put(key, value); 我们看一下这里的map.put（）的具体实现： 1234567891011121314151617181920212223242526@Override public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { if (e.hash == hash &amp;&amp; key.equals(e.key)) { preModify(e); V oldValue = e.value; e.value = value; return oldValue; } } // No entry for (non-null) key is present; create one modCount++; if (size++ &gt; threshold) { tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } 将Key与Value的值压入Map中，这里判断了一下如果map中已经存在该key，value键值对，则不再压入map，并将Value值返回，否则将该键值对压入Map中，并返回null； 返回继续put方法： 1234previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } 可以看到这里我们判断map.put方法的返回值是否为空，如果不为空的话，则说明我们刚刚并没有将我么你的键值对压入Map中，所以这里的size需要自减； 然后下面： 123if (previous != null) { entryRemoved(false, key, previous, value); } 这里判断previous是否为空，如果不为空的话，调用了一个空的实现方法entryRemoved()，也就是说我们可以实现自己的LruCache并在添加缓存的时候若存在该缓存可以重写这个方法； 下面调用了trimToSize(maxSize)方法： 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } 该方法主要是判断该Map的大小是否已经达到阙值，若达到，则将Map队尾的元素（最不常使用的元素）remove掉。 总结：LruCache put方法，将键值对压入Map数据结构中，若这是Map的大小已经大于LruCache中定义的最大值，则将Map中最早压入的元素remove掉； 查看get方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } 可以看到参数值为Key，简单的理解就是通过key值从map中取出Value值。具体来说，判断map中是否含有key值value值，若存在，则hitCount（击中元素数量）自增，并返回Value值，若没有击中，则执行create(key)方法，这里看到create方法是一个空的实现方法，返回值为null，所以我们可以重写该方法，在调用get（key）的时候若没有找到value值，则自动创建一个value值并压入map中。 总结： LruCache，内部使用Map保存内存级别的缓存 LruCache使用泛型可以设配各种类型 LruCache使用了Lru算法保存数据（最短最少使用least recent use） LruCache只用使用put和get方法压入数据和取出数据 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Log","link":"/2020/09/11/android%E4%B9%8BLruCache/"},{"title":"Android异步任务AsyncTask","text":"android的异步任务体系中还有一个非常重要的操作类：AsyncTask，其内部主要使用的是java的线程池和Handler来实现异步任务以及与UI线程的交互。本文主要解析AsyncTask的的使用与源码。 首先我们来看一下AsyncTask的基本使用： 12345678910111213141516171819class MAsyncTask extends AsyncTask&lt;Integer, Integer, Integer&gt; { @Override protected void onPreExecute() { super.onPreExecute(); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } @Override protected void onPostExecute(Integer i) { super.onPostExecute(i); Log.i(&quot;TAG&quot;, &quot;onPostExecute...(开始执行后台任务之后)&quot;); } @Override protected Integer doInBackground(Integer... params) { Log.i(TAG, &quot;doInBackground...(开始执行后台任务)&quot;); return 0; } } 我们定义了自己的MAsyncTask并继承自AsyncTask；并重写了其中的是哪个回调方法：onPreExecute()，onPostExecute（），doInBackground();然后开始调用异步任务： 1new MAsyncTask().execute(); 好了，下面我们开始分析异步任务的执行过程，首先查看一下异步任务的构造方法： 1234567891011121314151617181920212223242526272829303132/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 咋一看AsyncTask的构造方法代码量还是比较多的，但是仔细一看其实这里面只是初始化了两个成员变量：mWorker和mFuture他们分别是：WorkerRunnable和FutureTask，熟悉java的童鞋应该知道这两个类其实是java里面线程池先关的概念。其具体用法大家可以在网上查询，这里具体的细节不在表述，重点是对异步任务整体流程的把握。 总结：异步任务的构造方法主要用于初始化线程池先关的成员变量。 接下来我们看一下execute方法： 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 这里发现该方法中添加一个@MainThread的注解，通过该注解，可以知道我们在执行AsyncTask的execute方法时，只能在主线程中执行，这里可以实验一下： 12345678new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); new MAsyncTask().execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); 然后执行，但是并没有什么区别，程序还是可以正常执行，我的手机的Android系统是Android5.0，具体原因尚未找到，欢迎有知道答案的童鞋可以相互沟通哈。但是这里需要主要的一个问题是：onPreExecute方法是与开始执行的execute方法是在同一个线程中的，所以如果在子线程中执行execute方法，一定要确保onPreExecute方法不执行刷新UI的方法，否则： 123456@Override protected void onPreExecute() { super.onPreExecute(); title.setText(&quot;########&quot;); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } 12345678910111213141516171819Process: com.example.aaron.helloworld, PID: 659 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6981) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1034) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.widget.RelativeLayout.requestLayout(RelativeLayout.java:380) at android.view.View.requestLayout(View.java:17704) at android.widget.TextView.checkForRelayout(TextView.java:7109) at android.widget.TextView.setText(TextView.java:4082) at android.widget.TextView.setText(TextView.java:3940) at android.widget.TextView.setText(TextView.java:3915) at com.example.aaron.helloworld.MainActivity$MAsyncTask.onPreExecute(MainActivity.java:53) at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:587) at android.os.AsyncTask.execute(AsyncTask.java:535) at com.example.aaron.helloworld.MainActivity$1$1.run(MainActivity.java:40) at java.lang.Thread.run(Thread.java:818) 若在子线程中执行execute方法，那么这时候如果在onPreExecute方法中刷新UI，会报错，即子线程中不能更新UI。 继续看刚才的execute方法，我们可以发现其内部调用了executeOnExecutor方法： 123456789101112131415161718192021222324@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } 可以看到其具体的内部实现方法里：首先判断当前异步任务的状态，其内部保存异步任务状态的成员变量mStatus的默认值为Status.PENDING,所以第一次执行的时候并不抛出这两个异常，那么什么时候回进入这个if判断并抛出异常呢，通过查看源代码可以知道，当我们执行了execute方法之后，如果再次执行就会进入这里的if条件判断并抛出异常，这里可以尝试一下： 123456789101112131415161718192021final MAsyncTask mAsyncTask = new MAsyncTask(); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { /*MLog.e(&quot;you have clicked the title textview!!!&quot;); Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent, 101);*/ new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); mAsyncTask .execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); } }); 这里我们可以看到我们定义了一个AsyncTask的对象，并且每次执行点击事件的回调方法都会执行execute方法，当我们点击第一次的时候程序正常执行，但是当我们执行第二次的时候，程序就崩溃了。若这时候第一次执行的异步任务尚未执行完成则会抛出异常： 1Cannot execute task:the task is already running. 若第一次执行的异步任务已经执行完成，则会抛出异常： 1Cannot execute task:the task has already been executed (a task can be executed only once) 继续往下看，在executeOnExecutor中若没有进入异常分之，则将当前异步任务的状态更改为Running，然后回调onPreExecute()方法，这里可以查看一下onPreExecute方法其实是一个空方法，主要就是为了用于我们的回调实现，同时这里也说明了onPreExecute（）方法是与execute方法的执行在同一线程中。 然后将execute方法的参数赋值给mWorker对象那个，最后执行exec.execute(mFuture)方法，并返回自身。 这里我们重点看一下exec.execute(mFuture)的具体实现，这里的exec其实是AsyncTask定义的一个默认的Executor对象： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 那么，SERIAL_EXECUTOR又是什么东西呢？ 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 继续查看SerialExecutor的具体实现： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 可以发现其继承Executor类其内部保存着一个Runnable列表，即任务列表，在刚刚的execute方法中执行的exec.execute(mFuture)方法就是执行的这里的execute方法。这里具体看一下execute方法的实现：1）首先调用的是mTasks的offer方法，即将异步任务保存至任务列表的队尾2）判断mActive对象是不是等于null，第一次运行是null，然后调用scheduleNext()方法3）在scheduleNext()这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。4）在这之后如果再有新的任务被执行时就等待上一个任务执行完毕后才会得到执行，所以说同一时刻只会有一个线程正在执行。5）这里的THREAD_POOL_EXECUTOR其实是一个线程池对象。 然后我们看一下执行过程中mWorker的执行逻辑： 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; 可以看到在执行线程池的任务时，我们回调了doInBackground方法，这也就是我们重写AsyncTask时重写doInBackground方法是后台线程的原因。 然后在任务执行完毕之后会回调我们的done方法： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; 这里我们具体看一下postResultIfNotInvoked方法： 123456private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 其内部还是调用了postResult方法： 1234567private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 这里可以看到起调用了内部的Handler对象的sendToTarget方法，发送异步消息，具体handler相关的内容可以参考： android源码解析之（二）–&gt;异步消息机制 追踪代码，可以查看AsyncTask内部定义了一个Handler对象： 1234567891011121314151617181920private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 可以看到起内部的handleMessage方法，有两个处理逻辑，分别是：更新进入条和执行完成，这里的更新进度的方法就是我们重写AsyncTask方法时重写的更新进度的方法，这里的异步任务完成的消息会调用finish方法： 12345678private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 这里AsyncTask首先会判断当前任务是否被取消，若被取消的话则直接执行取消的方法，否则执行onPostExecute方法，也就是我们重写AsyncTask时需要重写的异步任务完成时回调的方法。 其实整个异步任务的大概流程就是这样子的，其中涉及的知识点比较多，这里总结一下： 异步任务内部使用线程池执行后台任务，使用Handler传递消息； onPreExecute方法主要用于在异步任务执行之前做一些操作，它所在线程与异步任务的execute方法所在的线程一致，这里若需要更新UI等操作，则execute方法不能再子线程中执行。 通过刚刚的源码分析可以知道异步任务一般是顺序执行的，即一个任务执行完成之后才会执行下一个任务。 doInBackground这个方法所在的进程为任务所执行的进程，在这里可以进行一些后台操作。 异步任务执行完成之后会通过一系列的调用操作，最终回调我们的onPostExecute方法 异步任务对象不能执行多次，即不能创建一个对象执行多次execute方法。（通过execute方法的源码可以得知） 所有源码基于android23，中间有什么疏漏欢迎指正。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1AsyncTask/"},{"title":"25 onLowMemory执行流程","text":"上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：android源码解析（二十四）–&gt;onSaveInstanceState执行时机 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。 这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。 通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考： android源码解析之（九）–&gt;SystemServer进程启动流程）其中在SystemServer的startBootService方法中我们调用了： 12// Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); 方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this)); ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this)); ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this)); } ServiceManager.addService(&quot;permission&quot;, new PermissionController(this)); ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) { ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) { mPidsSelfLocked.put(app.pid, app); } updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } } catch (PackageManager.NameNotFoundException e) { throw new RuntimeException( &quot;Unable to find android system package&quot;, e); } } 这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑： 12345678910111213141516171819static class MemBinder extends Binder { ActivityManagerService mActivityManagerService; MemBinder(ActivityManagerService activityManagerService) { mActivityManagerService = activityManagerService; } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { if (mActivityManagerService.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) { pw.println(&quot;Permission Denial: can't dump meminfo from from pid=&quot; + Binder.getCallingPid() + &quot;, uid=&quot; + Binder.getCallingUid() + &quot; without permission &quot; + android.Manifest.permission.DUMP); return; } mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, &quot; &quot;, args, false, null); } }查看源码，我们可以发现MemBinder类继承于Binder类也就是说其实一个Binder类型的服务，并且有一个成员方法dump，该方法主要用于执行shell命令，当系统可用内存比较低的时候就会执行了该方法，然后回调到ActivityManagerService中的killAllBackground方法，下面我们重点看一下killAllBackground方法的具体实现： 123456789@Override public void killAllBackgroundProcesses() { ... doLowMemReportIfNeededLocked(null); ... } finally { Binder.restoreCallingIdentity(callingId); } } 可以看到这个方法体中会执行doLowMemReportIfNeededLocked方法，该方法是做什么的呢?我们继续看一下doLowMemReportIfNeededLoced方法的实现： 12345final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) { ... scheduleAppGcsLocked(); ... } 好吧，在这个方法中我们又调用了scheduleAppGcsLocked方法，这样我们就继续看一下scheduleAppGcsLocked方法的实现逻辑： 12345678910111213141516171819/** * Schedule the execution of all pending app GCs. */ final void scheduleAppGcsLocked() { mHandler.removeMessages(GC_BACKGROUND_PROCESSES_MSG); if (mProcessesToGc.size() &gt; 0) { // Schedule a GC for the time to the next process. ProcessRecord proc = mProcessesToGc.get(0); Message msg = mHandler.obtainMessage(GC_BACKGROUND_PROCESSES_MSG); long when = proc.lastRequestedGc + GC_MIN_INTERVAL; long now = SystemClock.uptimeMillis(); if (when &lt; (now+GC_TIMEOUT)) { when = now + GC_TIMEOUT; } mHandler.sendMessageAtTime(msg, when); } } 可以发现这里执行的逻辑就是通过mHandler发送一个msg.what为GC_BACKGROUND_PROCESSES_MSG的异步消息，这样消息体最终会被mHandler的handleMessage方法所执行，继续看一下mHandler的handleMessage方法的执行逻辑： 12345case GC_BACKGROUND_PROCESSES_MSG: { synchronized (ActivityManagerService.this) { performAppGcsIfAppropriateLocked(); } } break; 在mHandler的handleMessage方法中，首先会判断msg的what是否为GC_BACKGROUND_PROCESSES_MSG，然后会执行performAppGcsIfAppropriateLocked方法，这样我们继续看一下performAppGcsIfAppropriateLocked方法的实现： 1234567891011/** * If all looks good, perform GCs on all processes waiting for them. */ final void performAppGcsIfAppropriateLocked() { if (canGcNowLocked()) { performAppGcsLocked(); return; } // Still not idle, wait some more. scheduleAppGcsLocked(); } 可以发现这里首先判断是否能够执行gc操作，若不能继续执行上面的scheduleAppGcsLocked方法，然后继续执行发送异步消息的逻辑，直到变量canGcNowLocked为true，并执行performAppGcsLocked方法，然后return掉，这样我们继续跟踪代码，看一下performAppGcsLocked方法的执行逻辑： 1234567891011121314151617181920212223242526272829303132/** * Perform GCs on all processes that are waiting for it, but only * if things are idle. */ final void performAppGcsLocked() { final int N = mProcessesToGc.size(); if (N &lt;= 0) { return; } if (canGcNowLocked()) { while (mProcessesToGc.size() &gt; 0) { ProcessRecord proc = mProcessesToGc.remove(0); if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) { if ((proc.lastRequestedGc+GC_MIN_INTERVAL) &lt;= SystemClock.uptimeMillis()) { // To avoid spamming the system, we will GC processes one // at a time, waiting a few seconds between each. performAppGcLocked(proc); scheduleAppGcsLocked(); return; } else { // It hasn't been long enough since we last GCed this // process... put it in the list to wait for its time. addProcessToGcListLocked(proc); break; } } } scheduleAppGcsLocked(); } } 可以发现该方法经过一系列的逻辑判断之后会执行performAppGcLocked方法，我们继续看一下该方法的实现： 123456789101112131415161718/** * Ask a given process to GC right now. */ final void performAppGcLocked(ProcessRecord app) { try { app.lastRequestedGc = SystemClock.uptimeMillis(); if (app.thread != null) { if (app.reportLowMemory) { app.reportLowMemory = false; app.thread.scheduleLowMemory(); } else { app.thread.processInBackground(); } } } catch (Exception e) { // whatever. } } 可以发现最终执行的是app.thread.scheduleLowMemory方法，而这里的app.thread是ActivityThread.ApplicationThread对象，所以这里最终是通过Binder进程间通讯，执行的是ActivityThread.ApplicationThread的scheduleLowMemory方法，好吧让我们看一下ActivityThread.ApplicationThread的scheduleLowMemory方法的实现逻辑… 1234@Override public void scheduleLowMemory() { sendMessage(H.LOW_MEMORY, null); } 在ActivityThread中的scheduleLowMemory方法中并没有执行额外逻辑，而是直接调用了sendMessage方法，继续跟踪方法的执行： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现在sendMessage方法中最终通过一个Handler类型的mH成员变量发送一个异步消息，这样异步消息最终会被mH的handleMessage方法执行。。。。，经过查看源代码我们知道在mH的handleMessage方法中最终调用的是handleLowMemory方法： 12345678910111213141516171819202122final void handleLowMemory() { ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(true, null); final int N = callbacks.size(); for (int i=0; i&lt;N; i++) { callbacks.get(i).onLowMemory(); } // Ask SQLite to free up as much memory as it can, mostly from its page caches. if (Process.myUid() != Process.SYSTEM_UID) { int sqliteReleased = SQLiteDatabase.releaseMemory(); EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased); } // Ask graphics to free up as much as possible (font/image caches) Canvas.freeCaches(); // Ask text layout engine to free also as much as possible Canvas.freeTextLayoutCaches(); BinderInternal.forceGc(&quot;mem&quot;); } 可以发现这里通过遍历ComponentCallbacks2并执行了其onLowMemory方法，那么这里的ComponentCallBacks2是什么呢？这里我们查看一下collectComponentCallbacks方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks( boolean allActivities, Configuration newConfig) { ArrayList&lt;ComponentCallbacks2&gt; callbacks = new ArrayList&lt;ComponentCallbacks2&gt;(); synchronized (mResourcesManager) { final int NAPP = mAllApplications.size(); for (int i=0; i&lt;NAPP; i++) { callbacks.add(mAllApplications.get(i)); } final int NACT = mActivities.size(); for (int i=0; i&lt;NACT; i++) { ActivityClientRecord ar = mActivities.valueAt(i); Activity a = ar.activity; if (a != null) { Configuration thisConfig = applyConfigCompatMainThread( mCurDefaultDisplayDpi, newConfig, ar.packageInfo.getCompatibilityInfo()); if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) { // If the activity is currently resumed, its configuration // needs to change right now. callbacks.add(a); } else if (thisConfig != null) { // Otherwise, we will tell it about the change // the next time it is resumed or shown. Note that // the activity manager may, before then, decide the // activity needs to be destroyed to handle its new // configuration. if (DEBUG_CONFIGURATION) { Slog.v(TAG, &quot;Setting activity &quot; + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig); } ar.newConfig = thisConfig; } } } final int NSVC = mServices.size(); for (int i=0; i&lt;NSVC; i++) { callbacks.add(mServices.valueAt(i)); } } synchronized (mProviderMap) { final int NPRV = mLocalProviders.size(); for (int i=0; i&lt;NPRV; i++) { callbacks.add(mLocalProviders.valueAt(i).mLocalProvider); } } return callbacks; } 可以发现该方法最终返回类型为ArrayList类型的callBacks而我们的callBacks中保存的是我们应用进程中的Activity，Service，Provider已经Application等。咦？Activity，Service，Provider，Application都是ComponentCallBacks2类型的么？我们看一看一下具体的定义： Actvity的类定义： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback Service的类定义： 1public abstract class Service extends ContextWrapper implements ComponentCallbacks2 ContentProvider的类定义： 1public abstract class ContentProvider implements ComponentCallbacks2 Application的类定义： 1public class Application extends ContextWrapper implements ComponentCallbacks2 可以发现其都是继承与ComponentCalbacks2，所以其都可以被当做是ComponentCallbacks2类型的变量。而同样是四大组件的BroadcastReceiver，我们可以下其类定义： 1public abstract class BroadcastReceiver 可以看到其并未继承与ComponentCallbacks2，所以并未执行，所以通过这样的分析，我们知道了，最终应用程序中的Activity，Servier，ContentProvider，Application的onLowMemory方法会被执行。而由于我们是在系统内存紧张的时候会执行killAllBackground方法进而通过层层条用执行Activity、Service、ContentProvider、Application的onLowMemory方法，所以我们可以在这些组件的onLowMemory方法中执行了一些清理资源的操作，释放一些内存，尽量保证自身的应用进程不被杀死。 总结： 系统在JNI层会时时检测内存变量，当内存过低时会通过kiilbackground的方法清理后台进程。 经过层层的调用过程最终会执行Activity、Service、ContentProvider、Application的onLowMemory方法。 可以在组件的onLowMemory方法中执行一些清理资源的操作，释放内存防止进程被杀死。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机","link":"/2020/09/11/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"各种学习资料，包括一些百度云视频链接还有pdf资料 --搬运工","text":"人生不如意事常八九 共勉 【0】Springboot微服务开发天气预报系统视频教程 https://pan.baidu.com/s/1joz7flyztCq8oklBlsz8dQ 提取密码：cpz7 【1】JAVA300集大型视频教程2018版发布 https://pan.baidu.com/s/1Bqy4mWSD1idd6JmIzS9ZLg 提取密码：llg2 【2】Vue2.5开发去旅游网站App从零基础入门到实战项目 https://pan.baidu.com/s/1DYCoIw_b893KXGkkYt_92Q 提取密码：bgoy 【3】opencv+tensorflow入门人工智能图像处理视频教程+源码下载 https://pan.baidu.com/s/10WefZkTQST094L5UQA7myg 提取密码：7b9w 【4】最新BAT面试真题讲解，想去大厂的别错过 https://pan.baidu.com/s/1ejf2Eh8ZA-T1bWbuT6gw0A 提取密码：mist 【5】Python3异步IO并发编程高级进阶视频教程下载 https://pan.baidu.com/s/1jiRwD5MNPmAKF98nXYzmKg 提取密码：hct4 【6】最新大数据数据分析与挖掘高级工程师第三期视频教程 https://pan.baidu.com/s/1g8xGPag9GiMA4_MEKbxePw 提取密码：z2v3 【7】姜承尧MYSQL,DBA视频课程(44天全)视频教程下载 https://pan.baidu.com/s/19NUjkkvdDZXhw1QG4yX21Q 提取密码：funf 【8】Python+AnsiblePlaybook+Django自动化运维项目实践课程 https://pan.baidu.com/s/1CfOHuaYi_TdPoAUzP9AW1w 提取密码：o3rc 【9】springcloud微服务实践-分布式与原理剖析链路追踪容器 https://pan.baidu.com/s/1g8QoqOnQwjI7N3zDSccr-w 提取密码：ygf5 【10】2018年最新Java高并发知识体系与高并发编程架构课程视频教程下载 https://pan.baidu.com/s/1E1NhSevRqwdnguiKSsOp5A 提取密码：mkh2 【11】2018年最新价值300Python人工智能TensorFlow框架应用实践视频课程下载 https://pan.baidu.com/s/1qYJjFz9aG6M5grMg311uRQ 提取密码：5hzp 【12】谭州学院价值1680元python视频教程12306网站案例vip特训班教程 https://pan.baidu.com/s/1yEQq5W1eSc3NA4XmyNmuJw 提取密码：cipi 【13】下载 https://pan.baidu.com/s/1D6hYdyi4ti2zpnKHVWWbEg 提取密码：glov 【14】Netty实战高性能分布式RPC视频教程下载 https://pan.baidu.com/s/1sDHh_g624MO08MTFIrwEDw 提取密码：mwa6 【15】2018年最新尚学堂Vue2全套学习视频教程下载 https://pan.baidu.com/s/147NvAV-Qse90xvTYDvHBcg 提取密码：wpfg 【16】最新2018疯狂SpringCloud微服务架构实战视频教程 https://pan.baidu.com/s/1jgC0lagtMG7tArATrAAHXg 提取密码：10kf 【17】kotlin高级教程从零开始开发完整安卓商城app https://pan.baidu.com/s/13F_C1aKuJ0ek5Kv-HWdygw 提取密码：krq2 【18】2018年最新疯狂Activiti6视频教程疯狂工作流讲义Activiti6.x视频教程 https://pan.baidu.com/s/1SriGV7tZAeSvYcYb6l_hdQ 提取密码：bzcu 【19】基于MyCat的MySQL高可用读写分离集群实战课程下载 https://pan.baidu.com/s/1DVCf57_O1iMDJkbOGxdnpw 提取密码：6a08 【20】2018年最新Webpack3由浅入深及搭载vue,react,angular框架多维度讲解 https://pan.baidu.com/s/1BYq5qb9fFMSyODlORBQCcw 提取密码：6wf3 【21】2018年最新Spark机器学习课程：智能客户系统项目实战视频教程 https://pan.baidu.com/s/12SrMtvLBlVJGOlOt5NQFjw 提取密码：uu9v 【22】最新离线数据分析平台实战驴妈妈项目实战培训视频教程 https://pan.baidu.com/s/129jhYGDLFzsM7BW5HYdg7Q 提取密码：vhjs 【23】2018年最新尚硅谷java9新特性视频教程下载 https://pan.baidu.com/s/1xC-xPm54rFMLAHYwis1Thg 提取密码：f0v6 【24】最新北风网人工智能+机器学习+深度学习+推荐系统实战第3期视频教程 https://pan.baidu.com/s/1E98ZYCtJ7Mom_tWZT6AM_g 提取密码：3abb 【25】[全栈开发]Vue+DjangoRESTframework打造生鲜电商项目视频教程 https://pan.baidu.com/s/1vFAkTEdydgL-GjdcpeEHGg 提取密码：k00f 【26】2018年最新node.js+ES+Koa2手把手教你开发一个短视频网站视频教程 https://pan.baidu.com/s/1jmxxQ88J_qWsovXkMNeDpQ 提取密码：46yh 【27】基于Java的微信平台开发教程视频下载 https://pan.baidu.com/s/1hMq-J7KFMuDezGSdzX35OA 提取密码：oycw 【28】最新精选蚂蚁-MySQL语句性能优化视频教程下载 https://pan.baidu.com/s/1miVf8Ze 提取密码：w5yt 【29】深度学习实战项目-利用RNN与LSTM网络原理进行唐诗生成视频课程 https://pan.baidu.com/s/1i6jyFtz 提取密码：vrzx 【30】2018年最新微信小游戏开发ES6+小游戏api开发视频教程下载 https://pan.baidu.com/s/1i7mwJCp 提取密码：ndl7 【31】最新甲骨论-Linux大数据及数据库存储视频教程下载 https://pan.baidu.com/s/1smi2oNj 提取密码：ypgn 【32】泰牛2017php基础班大牛班完整视频教程下载 https://pan.baidu.com/s/1ggKGo9d 提取密码：2tqk 【33】2018年最新Java微服务原理课程与改造房产销售平台视频教程 https://pan.baidu.com/s/1jKf8MMi 提取密码：i8ej 【34】使用dubbo、spring-boot等技术实现互联网后台服务项目架构视频教程 https://pan.baidu.com/s/1gg1JiBD 提取密码：1jtk 【35】最新区块链开发入门到精通视频教程下载 https://pan.baidu.com/s/1kW7FTwr 提取密码：hvep 【36】2018年最新价值1699元的深入大数据架构师之路，问鼎40万年薪视频教程下载 https://pan.baidu.com/s/1c3d1RbU 提取密码：22kw 【37】2018年最新java大数据基于storm开发实时流处理器视频教程 https://pan.baidu.com/s/1cOCHPk 提取密码：igw9 【38】2017年最新JAVA-ACE-架构师系列视频课程-RocketMQhttps://pan.baidu.com/s/1ghb9UAf 提取密码：sstz 【39】2017年深度学习项目实战视频课程-Seq2Seq序列生模型视频教程 https://pan.baidu.com/s/1dGEDwSp 提取密码：96eh 【40】2017年最新web前端工程师小白零基础入门到大神全套教程下载 https://pan.baidu.com/s/1dFQ8wgT 提取密码：7g4e 【41】2017年最新python高级模块matplotlib数据可视化分析视频教程 https://pan.baidu.com/s/1kWyRVmB 提取密码：qjaj 【42】价值1680元安卓特训班实战开发百思不得姐app项目教程下载 https://pan.baidu.com/s/1c3adHsc 提取密码：sxvg 【43】2018年最新价值799元Elasticsearch顶尖高手系列：高手进阶篇视频教程 https://pan.baidu.com/s/1mkkSBrU 提取密码：zmjn 【44】2017年最新深度学习框架Caffe使用案例视频课程下载 https://pan.baidu.com/s/1dGFsBnz 提取密码：q4dg 【45】炼数成精大数据的矩阵计算基础课程下载 https://pan.baidu.com/s/1mkaJbpY 提取密码：pnnc 【46】2018年最新redis从入门到精通与分布式架构视频教程下载 https://pan.baidu.com/s/1gggc7Fd 提取密码：img8 【47】2018年最新动力节点Java夜校视频教程下载 https://pan.baidu.com/s/1i6v7013 提取密码：dbnt 【48】全网最新基于ElasticSearch的找房网实战开发企业级房屋搜索网视频教程下载 https://pan.baidu.com/s/1bqUVrsF 提取密码：idjy 【49】Java高性能高并发秒杀系统实战视频教程下载 https://pan.baidu.com/s/1bqVBoqb 提取密码：ztqe 【50】2017最新最系统的PHP面试视频教程下载高薪无忧 https://pan.baidu.com/s/1o81Mu8q 提取密码：da2f 【51】2017年最新炼数成金机器读心术之神经网络与深度学习视频教程下载 https://pan.baidu.com/s/1mhJkQzI 提取密码：pvc6 【52】李兴华系列之Java8、Oracle、JavaScript、HTML5、Spring、Struts、Hibernate系列视频教程下载 https://pan.baidu.com/s/1o7O6ytc 提取密码：icgf 【53】2017年最新Python+scripy实现搜索引擎爬虫课程视频教程下载 https://pan.baidu.com/s/1mhLSFVy 提取密码：n333 【54】最新某某学院大数据工程师视频教程下载 https://pan.baidu.com/s/1o7Cvjwm 提取密码：ximb 【55】2017年Javaweb开发工程师成长之路全套视频教程附配套资料下载 https://pan.baidu.com/s/1qXJcyVa 提取密码：31di 【56】php高性能yii2框架开发高性能高可用负载均衡集群架构商城视频教程下载 https://pan.baidu.com/s/1jIKk70i 提取密码：b9bt 【57】2017最新兄弟连laravel入门到精通+博客实战开发教程下载 https://pan.baidu.com/s/1bZJAW2 提取密码：6p4c 【58】2017年最系统的PHP教程高薪就业视频教程下载 https://pan.baidu.com/s/1o7DG2pW 提取密码：rrds 【59】2017最新大数据10个小时快速入门hadoop3集群实战视频教程 https://pan.baidu.com/s/1hsgtagG 提取密码：dwin 【60】2017年最新Webpack+React全栈工程架构项目实战精讲视频教程下载 https://pan.baidu.com/s/1hsq2s64 提取密码：gprc 【61】2017年最新Uber车辆监控系统设计实战训练营高清视频教程全套附讲义代码 https://pan.baidu.com/s/1nv9Vm5b 提取密码：5bs8 【62】2017年最新DS206人脸识别与分析系统实战训练营硅谷讲师授课高清视频教程全套附讲义代码4周 https://pan.baidu.com/s/1c2LcBsc 提取密码：nv1h 【63】2017年最新React开发Native开发安卓与ios平台的GitHubApp视频教程 https://pan.baidu.com/s/1jI6DiXg 提取密码：7cyk 【64】2017年最新Google面试官亲授java校招面试视频讲解教程下载 https://pan.baidu.com/s/1nuDIkQ1 提取密码：hhnu 【65】Android传感器、无线传输与媒体硬件功能开发视频教程下载 https://pan.baidu.com/s/1bpoA4EV 提取密码：cvh9 【66】最新Kaggle神器之XGBoost从入门到精通高清精品视频教程附代码教程下载 https://pan.baidu.com/s/1nvj6fDR 提取密码：x493 【67】Oracle商业智能BI产品OBIEE11G深入浅出全套视频教程下载 https://pan.baidu.com/s/1o81KXPg 提取密码：f3sg 【68】2017年最新小象学院分布式爬虫第二期视频教程 https://pan.baidu.com/s/1geX7fKB 提取密码：2ac9 【69】mongodb从入门到精通高清视频教程下载 https://pan.baidu.com/s/1cpsdjC 提取密码：3ng4 【70】最新大数据快速数据挖掘平台RapidMiner数据分析视频教程下载 https://pan.baidu.com/s/1bpFE111 提取密码：3z6u 【71】最新Python自然语言分析视频课程下载 https://pan.baidu.com/s/1ge40FbP 提取密码：wa5r 【72】最新尚学堂redis视频教程下载 https://pan.baidu.com/s/1c35hRg 提取密码：gy5j 【73】最新oracle11gDBA开发和应用数据库视频教程下载 https://pan.baidu.com/s/1o7YE5Bk 提取密码：eu68 【74】2017vue2nodemongoKoa2Nuxt/VueSSR全栈开发小程序商城视频教程 https://pan.baidu.com/s/1jIw3lR4 提取密码：bmia 【75】最新python数据分析升级版视频教程下载 https://pan.baidu.com/s/1i5L7LdV 提取密码：bfk7 【76】Python数据分析(机器学习)经典案例视频教程 https://pan.baidu.com/s/1nuUCPlf 提取密码：3ytg 【77】DB2数据库性能优化视频教程下载 https://pan.baidu.com/s/1qYysRDE 提取密码：i1rx 【78】2017年node.js零基础入门到企业级全栈案例开发教程下载 https://pan.baidu.com/s/1eRBopRs 提取密码：ne2a 【79】Hadoop大数据视频教程：真实电商数据仓库全流程开发详解(共46讲)视频教程下载 https://pan.baidu.com/s/1bpMzOyr 提取密码：m3yt 【80】最新老男孩python全栈工程师第2期全套完整版视频教程下载 https://pan.baidu.com/s/1cIycbk 提取密码：cgfm 【81】价值2400元的python全栈开发系列FlaskPythonWeb网站编程视频教程 https://pan.baidu.com/s/1qXATJju 提取密码：huc3 【82】最新python从入门到精通到开发爬虫实例视频教程 https://pan.baidu.com/s/1mirFpeK 提取密码：9gmt 【83】极客学院VIP教程postgresql教程全集视频教程下载 https://pan.baidu.com/s/1i4DjPdF 提取密码：qgga 【84】最新angular4.x框架与redux开发大型企业级管理项目视频教程下载 https://pan.baidu.com/s/1nvEDQNB 提取密码：mqvu 【85】2017年数据分析与机器学习实战到经典案例全套高清视频教程（基于Python3.5anaconda4.2）15G https://pan.baidu.com/s/1nvqXoPN 提取密码：irdj 【86】2017年最新大数据实时分析Storm入门到精通学习路线视频教程 https://pan.baidu.com/s/1pL7OfvP 提取密码：2ze2 【87】使用php高可用webapp后端开发视频教程下载 https://pan.baidu.com/s/1qXTQ5FQ 提取密码：pybc 【88】2017年最新java算法详解与算法开发小游戏视频教程下载 https://pan.baidu.com/s/1dF0GWNn 提取密码：t6tk 【89】2017年9月最新pythonflask开发小视频网站视频教程 https://pan.baidu.com/s/1nuHfvZF 提取密码：pygf 【90】2017年5月炼数成金《MySQLDBA从小白到大神实战》视频教程 https://pan.baidu.com/s/1jHFP8sm 提取密码：qnmj 【91】Vue从入门到精通视频教程 https://pan.baidu.com/s/1pKCX6Wj 提取密码：h6hd 【92】北风网从C++起步到MFC实战VC++软件工程师高端培训(服务器端开发方向)332课全 https://pan.baidu.com/s/1c1SSWKg 提取密码：iw7p 【93】2017最新python3从零基础入门到精讲超清视频教程 https://pan.baidu.com/s/1c2Nd468 提取密码：h46d 【94】2017年最新使用MUI开发跨平台混合APP全套完整视频教程 https://pan.baidu.com/s/1dFxYZ0d 提取密码：9ury 【95】最新人脸识别深度学习项目实战视频教程 https://pan.baidu.com/s/1o8onm2m 提取密码：7aqr 【96】2017年最新Python网络爬虫实战案例视频教程下载共5章34课 https://pan.baidu.com/s/1micMg8w 提取密码：23gt 【97】基于Hadoop，Spark大数据技术的推荐系统算法实战教程 https://pan.baidu.com/s/1dFnP9K1 提取密码：djyk 【98】 https://pan.baidu.com/s/1gf0CGuB 提取密码：4tei 【99】2017年最新云知梦php全栈开发全套视频教程 https://pan.baidu.com/s/1qYPwSsW 提取密码：iv93 【100】Python编程高级进阶视频教程 https://pan.baidu.com/s/1bpnnEph 提取密码：y9sp 【101】2017年5月最新课程小象学院深度学习第四期视频教程 https://pan.baidu.com/s/1o7IzeXk 提取密码：kptc 【102】最新自动聊天机器人项目班实战视频课程下载 https://pan.baidu.com/s/1kU9bNev 提取密码：6p5z 【103】深度学习入门视频课程上篇+下篇下载 https://pan.baidu.com/s/1slG7qxv 提取密码：u2c4 【104】七月在线机器学习算法班9月在线班视频教程 https://pan.baidu.com/s/1nuLiXCl 提取密码：vdkz 【105】最新小象学院机器学习升级版III视频教程下载 https://pan.baidu.com/s/1gfeXSgb 提取密码：dt7t 【106】最新优达学城udacity无人驾驶工程师视频教程 https://pan.baidu.com/s/1c1UUEXi 提取密码：mjbs 【107】2017年深度学习项目实战之对抗生成网络视频课程 https://pan.baidu.com/s/1hs8chxU 提取密码：76mw 【108】2017年深度学习之Tensorflow项目实战视频课程-文本分类 https://pan.baidu.com/s/1c1Kf1wG 提取密码：dt52 【109】2017年kaggle案例实战班视频教程 https://pan.baidu.com/s/1boYu4FX 提取密码：4bhc 【110】深度学习实战决胜AI-强化学习实战系列视频课程 https://pan.baidu.com/s/1eRHZ1yq 提取密码：ifu2 【111】2017年最新从理论到实践机器学习视频教程 https://pan.baidu.com/s/1jHPsHSU 提取密码：xx9x 【112】2017最新基于springsecurity与spingmvc分布式权限管理系统 https://pan.baidu.com/s/1c13keOw 提取密码：xea9 【113】Java高并发程序设计实战视频教程 https://pan.baidu.com/s/1c1CDsnI 提取密码：xsic 【114】Sqoop、Flume、Oozie、Hue大数据工具视频教程 https://pan.baidu.com/s/1bo47OGR 提取密码：hxw7 【115】深入JVM内核—原理、诊断与优化视频教程 https://pan.baidu.com/s/1jIL46PK 提取密码：78yd 【116】Hadoop,Hbase,Hive源码解析与开发实战 https://pan.baidu.com/s/1hsznJsK 提取密码：dpmq 【117】传智播客黑马P2P金融项目网络借贷平台开发实战教程 https://pan.baidu.com/s/1pLieuzL 提取密码：gbxy 【118】2017年7月最新微服务架构的分布式事务解决视频教程 https://pan.baidu.com/s/1bo47p2R 提取密码：94hx 【119】亿级流量电商系统大型高并发与高可用缓存架构实战 https://pan.baidu.com/s/1pLmhZir 提取密码：6aj9 【120】2017Spark2.0大型项目实战：移动电商app交互式数据分析平台 https://pan.baidu.com/s/1o8EAk2Y 提取密码：gcsq 【121】NO89中移动大型分布式redis,solr,Linux,nginx,springmvc,mybatis电商项目 https://pan.baidu.com/s/1qY7K2SW 提取密码：cjj4 【122】SpringBoot从前端到后台打造企业级博客全栈实战视频 https://pan.baidu.com/s/1pKLc2BT 提取密码：8tjw 【123】（2017年）最新深度学习与机器学习 https://pan.baidu.com/s/1c76kgA 提取密码：5qyv 【124】SpringMvc+Spring+Mybatis整合视频教程 http://pan.baidu.com/s/1gfP90Pl 提取密码：kveg 【125】Struts2+Spring3+Hibernate4+Maven+EasyUI整合入门视频教程 http://pan.baidu.com/s/1bpztkOR 提取密码：krbn 【126】elk日志分析视频ELKStack视频教程以及Solr教程 http://pan.baidu.com/s/1qYwQOSc 提取密码：qr9u 【127】徐老师hadoophbasezookeepersparkkafka大数据视频教程 http://pan.baidu.com/s/1miLtQqO 提取密码：97tj 【128】2017年最新项目实战SpringBoot视频教程微服务整合Mybatis http://pan.baidu.com/s/1boMH2Cv 提取密码：gvt5 【129】传智播客最新大数据第3期实战培训完整版视频教程 http://pan.baidu.com/s/1miLZwwg 提取密码：56hs 【130】[大数据]极客学院大数据工程师全套视频代码课件 http://pan.baidu.com/s/1c160ug4 提取密码：6d28 【131】2017新版MySQL加强视频教程46课附课件源码 http://pan.baidu.com/s/1eSouP6U 提取密码：nh8i 【132】Python爬虫项目班从零开始实现爬虫系统 http://pan.baidu.com/s/1i5QiuzV 提取密码：2vpd 【133】Mongodb/Redis/HBaseNoSql视频教程2017数据库自学教程 http://pan.baidu.com/s/1kVytRIB 提取密码：mtnb 【134】Mahout零基础入门到精通实战视频教程（全套）下载 http://pan.baidu.com/s/1kUPNJaJ 提取密码：pvka 【135】2017年最新整理深度学习神经网络算法全套视频教程 http://pan.baidu.com/s/1pLsfdIb 提取密码：vy41 【136】阿里开源分布式框架dubbo&amp;mycat视频教程 https://pan.baidu.com/s/1geZwIYZ 提取密码：h7iw 【137】极客学院python开发工程师视频教程下载 https://pan.baidu.com/s/1miDOboc 提取密码：gwaa 【138】2017最新python教程老男孩Python14期视频教程下载 https://pan.baidu.com/s/1kVbWgzP 提取密码：9hk7 【139】达内2017Web前端全套最新价值2万元视频教程 http://pan.baidu.com/s/1jIA3oma 提取密码：rfqk 【140】达内Java全套最新价值2万元视频教程 https://pan.baidu.com/s/1sl545sx 提取密码：sa8i 【141】SparkMLlib机器学习算法与源码解析 https://pan.baidu.com/s/1pLptvMN 提取密码：ncek 【142】大数据开发之hadoop工程师成长之路零基础到精通下载 https://pan.baidu.com/s/1i4LciTf 提取密码：8z4m 【143】Kafka原理剖析及实战演练视频教程下载 https://pan.baidu.com/s/1mhAgeBA 提取密码：26ny","link":"/2020/09/28/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%80%E4%BA%9B%E7%99%BE%E5%BA%A6%E4%BA%91%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E8%BF%98%E6%9C%89pdf%E8%B5%84%E6%96%99%20--%E6%90%AC%E8%BF%90%E5%B7%A5/"},{"title":"29 应用程序返回按键执行流程","text":"从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。android系统的事件分发流程分为很多部分： Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层 所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。 在Native层android系统的事件流程： Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。 在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。 将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。 Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。 Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。 可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。 在ViewRootImpl层android系统的事件流程 在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现： 123private void dispatchInputEventFinished(int seq, boolean handled) { onInputEventFinished(seq, handled); }在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中： 12345678910private final class ImeInputEventSender extends InputEventSender { public ImeInputEventSender(InputChannel inputChannel, Looper looper) { super(inputChannel, looper); } @Override public void onInputEventFinished(int seq, boolean handled) { finishedInputEvent(seq, handled, false); } } 可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。 12345678910111213141516171819202122void finishedInputEvent(int seq, boolean handled, boolean timeout) { final PendingEvent p; synchronized (mH) { int index = mPendingEvents.indexOfKey(seq); if (index &lt; 0) { return; // spurious, event already finished or timed out } p = mPendingEvents.valueAt(index); mPendingEvents.removeAt(index); Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size()); if (timeout) { Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot; + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId); } else { mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p); } } invokeFinishedInputEventCallback(p, handled); } 在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。 1234567891011121314void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) { p.mHandled = handled; if (p.mHandler.getLooper().isCurrentThread()) { // Already running on the callback handler thread so we can send the // callback immediately. p.run(); } else { // Post the event to the callback handler thread. // In this case, the callback will be responsible for recycling the event. Message msg = Message.obtain(p.mHandler, p); msg.setAsynchronous(true); msg.sendToTarget(); } } 可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。 12345678@Override public void run() { mCallback.onFinishedInputEvent(mToken, mHandled); synchronized (mH) { recyclePendingEventLocked(this); } } 可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。 12345678910111213final class ImeInputStage extends AsyncInputStage implements InputMethodManager.FinishedInputEventCallback { ... @Override public void onFinishedInputEvent(Object token, boolean handled) { QueuedInputEvent q = (QueuedInputEvent)token; if (handled) { finish(q, true); return; } forward(q); } } 这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法： 12345678910111213141516171819202122at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141) 这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。 12345678private int processKeyEvent(QueuedInputEvent q) { ... // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) { return FINISH_HANDLED; } ...} 可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。 在DecorView层android系统的事件流程 从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean dispatchKeyEvent(KeyEvent event) { final int keyCode = event.getKeyCode(); final int action = event.getAction(); final boolean isDown = action == KeyEvent.ACTION_DOWN; if (isDown &amp;&amp; (event.getRepeatCount() == 0)) { // First handle chording of panel key: if a panel key is held // but not released, try to execute a shortcut in it. if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey != keyCode)) { boolean handled = dispatchKeyShortcutEvent(event); if (handled) { return true; } } // If a panel is open, perform a shortcut on it without the // chorded panel key if ((mPreparedPanel != null) &amp;&amp; mPreparedPanel.isOpen) { if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) { return true; } } } if (!isDestroyed()) { final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) { return true; } } return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event); } 从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。 在Activity层android系统的事件流程 所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法： 12345678910111213141516171819public boolean dispatchKeyEvent(KeyEvent event) { onUserInteraction(); // Let action bars open menus in response to the menu key prioritized over // the window handling it if (event.getKeyCode() == KeyEvent.KEYCODE_MENU &amp;&amp; mActionBar != null &amp;&amp; mActionBar.onMenuKeyEvent(event)) { return true; } Window win = getWindow(); if (win.superDispatchKeyEvent(event)) { return true; } View decor = mDecor; if (decor == null) decor = win.getDecorView(); return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this); } 从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。 123456789101112131415public final boolean dispatch(Callback receiver, DispatcherState state, Object target) { switch (mAction) { ... case ACTION_UP: if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state + &quot;: &quot; + this); if (state != null) { state.handleUpEvent(this); } return receiver.onKeyUp(mKeyCode, this); ... } return false; } 这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。 1234567891011public boolean onKeyUp(int keyCode, KeyEvent event) { if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) { onBackPressed(); return true; } } return false; } 看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。 123456789public void onBackPressed() { if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) { return; } if (!mFragments.getFragmentManager().popBackStackImmediate()) { finishAfterTransition(); } } 可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。 12345public void finishAfterTransition() { if (!mActivityTransitionState.startExitBackTransition(this)) { finish(); } } O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。 总结： 本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程； 事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"11 应用进程启动流程","text":"转载请标明出处：一片枫叶的专栏 在android guide中有这样的一段关于android应用程序进程的描述： 1By default, every application runs in its own Linux process. Android starts the process when any of the application's components need to be executed, then shuts down the process when it's no longer needed or when the system must recover memory for other applications. 每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。 本节主要是通过分析Activity的启动过程介绍应用程序进程的启动流程。 在上一篇文章中我们简要的介绍了Launcher的启动流程，在SystemServer进程执行完成，各种系统服务启动完成之后，会调用ActivityManagerService中的systemReady()方法，在systemReady（）方法中会执行Launcher启动的相关逻辑了，具体可以参考： android源码解析之（十）–&gt;Launcher启动流程 Launcher应用程序在启动过程中会通过PackageManagerService服务请求查询系统所有的已安装应用的包名，图标和应用名称等信息，然后填充到Launcher中的Adapter中，这样点击某一项应用图标的时候就可以根据该图标的包名和启动Activity的类名初始化Intent对象，然后调用startActivity(Intent)启动相关的应用程序了。 其实android中应用进程可以通过许多方式启动，比如启动一个Activity，启动一个Service，启动一个ContentProvider或者是一个BroadcastReceiver，也就是说我们可以通过启动四大组件的方式启动应用进程，在应用进程没有启动的时候，如果我们通过启动这些组件，这时候系统会判断当前这些组件所需要的应用进程是否已经启动，若没有的话，则会启动应用进程。 这里我们通过Launcher简单分析一下应用进程的启动流程。通过上一篇Launcher启动流程，我们知道每一个launcher中的图标对应着一个应用报名和启动activity类名，查看LauncherActivity中的图标点击事件: 1234protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }在通过应用包名和启动activity类名构造完成Intent之后，我们调用了startActivity方法来启动这个activity，很明显的，当前这个应用并没有启动，也就是说我们调用的startActivity方法不单单为我们启动了这个activity也同时在启动activity之前启动了这个应用进程，好了，那我们这里就以这个方法为入口分析一下应用进程的启动流程。 跟踪代码到Activity，发现其调用了startActivity的重载方法： 1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); } 继续跟进： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 很明显的我们此时传递的options为空： 123public void startActivityForResult(Intent intent, int requestCode) { startActivityForResult(intent, requestCode, null); } 好吧，最后调用的还是这个重载方法： 123456789101112131415161718192021222324252627public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现这里调用了mInstrumentation.execStartActivity方法，这里先简单介绍一下Instrumentation对象，他是Android系统中应用程序端操作Activity的具体操作类，这里的操作段是相对于ActivityManagerService服务端来说的。也就是说当我们在执行对Activity的具体操作时，比如回调生命周期的各个方法都是借助于Instrumentation类来实现的。 好了，下面我们继续看一下Instrumentation的execStartActivity方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 这里主要关注这个代码： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这断代码实际上是进程间通讯，我们可以发现ActivityManagerNative继承于Binder接口，所以ActivityManagerNative就是一个Binder对象，然后上面一节我们介绍SystemServer进程的时候对ActivityManagerService有过了解，发现其继承于ActivityManagerNative，好吧，了解过Binder机制的童鞋就知道了，ActivityManagerService就是这个Binder机制的服务器端而ActivityManagerNative就是这个Binder机制的客户端，所以我们这里调用的startActivity实际上是讲参数传递给ActivityManagerService并执行ActivityManagerService的startActivity方法。 既然这样，我们看一下ActivityManagerService的startActivity方法： 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 调用了startActivityAsUser方法，然后我们继续看一下startActivityAsUser方法： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 继续查看startActivityMayWait方法： 1234567891011121314151617181920final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } } 这个方法的逻辑比较多，我们重点关注的是其调用了startActivityLocked方法，也就是说在初始化其他逻辑之后，这个方法会调用startActivityLocked方法： 12err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); 代码量也是比较大的，在方法体中调用了startActivityUncheckedLocked方法，然后我们继续跟进startActivityUncheckedLocked方法： 1targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); 然后我们查看startActivityLocked方法的实现： 123if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } 可以发现其调用了resumeTopActivitiesLocked方法： 1stack.resumeTopActivityLocked(null); 继续跟进： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后我们看一下resumeTopActivityLocked方法的实现： 1result = resumeTopActivityInnerLocked(prev, options); 继续查看resumeTopActivityInnerLocked方法的实现： 1mStackSupervisor.startSpecificActivityLocked(next, true, true); 可以发现在方法体中执行了相关逻辑判断与初始化操作之后调用了startSpecificActivityLocked方法： 12mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); 可以发现在方法体中调用了startProcessLocked方法，从名字可以看出来这个方法就是启动进程的。 123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); } 查看startProcessLocked方法的实现： 1234checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;); startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, &quot;startProcess: done starting proc!&quot;); 查看startProcessLocked方法的具体实现； 123456checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); 查看关键代码，这里调用了Process.start方法： 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 这里的processClass就是要启动的进程的名称，这里传递的就是ActivityThread： 1&quot;android.app.ActivityThread&quot; 具体的Process启动进程的Native层代码这里不做过多的分析，这个方法就是启动了AcitivtyThread进程并执行了ActivityThread的main方法，所以我们经常说的进程的启动方法就是ActivityThread的main方法就是这里体现的。 总结： android应用进程会在需要启动其组件的时候启动，当没有任何组件运行或者是系统内存较低的时候应用进程会被杀死。 在启动应用四大组件的时候若发现当前应用的进程没有启动，则会首先启动应用程序的进程。 我们可以为应用程序配置多个进程，每个进程都有自己的JVM和运行环境，各个进程之间的通讯需要通过Binder机制。 Launcher启动的过程也是先启动Launcher进程再启动其Activity组件。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"热修复技术原理总结","text":"#1.什么是热修复 传统更新流程：版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;重新发版-&gt;用户安装 弊端:重新发版本代价高 :用户下载安装成本高 :bug修复不及时，体验差 解决方案 Hybrid方案:业务逻辑以H5方式加载 插件化方案:Atlas或者DroidPlugin方案 热修复方案:采用热修复技术，将更新补丁上传到云端，APP从云端下拉补丁直接应用生效 热修复更新流程:版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;打出补丁,推送给用户-&gt;自动拉取补丁修复 优势 1.无需重新发版，实时高效热修复 2.用户无感知修复，无需下载新应用,代价小 3.修复成功率高，把损失降到最低 ##2.热修复框架 腾讯QQ控件的超技补丁技术，微信的Tinker，饿了么的Amigo，美团的Robust 非侵入式Android热修复方案SophixSophix不支持四大组件的修复,如果要修复四大组件，必须在AndroidManifest里预先插入代理组件，并且声明所有权限。对app运行流程的侵入性太强。未作处理。 ##3.Android热修复的三大领域:代码修复,资源修复,So修复。 ###3.1代码修复 ###代码修复方案:一种是阿里系的底层替换方案，一种是腾讯系的类加载方案优劣: 底层替换方案限制多，但时效性好，加载快，立即见效。类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。 ###底层替换方案 底层替换方案是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改。因而无法实现对原有类进行方法和字段的增减，因为这样将破坏原有类结构。一旦补丁类中出现了方法的增加或减少，就会导致这个类以及整个Dex的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。更严重的问题是，如果在程序运行中间某各类突然增加了一个字段，那么对于原先已经产生的这个类的实例，他们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。传统的底层替换方式，不论是Dexposed、Andfix或者其他安全界的Hook方案，都是直接依赖修改虚拟机方法实体的具体字段，例如，改Dalvik方法的jni函数指针、修改类或者方法的访问权限。Android开源，各大厂商对代码进行改造，Andfix里的ArtMethod的结构是根据Android源码中的结构写死的。如果ArtMethod做修改，这种替换机制就会出问题。 Sophix是一种无视底层具体结构的替换方式，解决了兼容性问题。忽略了底层ArtMethod结构的差异，对于Android版本不需要区分，代码量大大减少。只要ArtMethod数组是以线性结构排列，就不会出现问题。 ###类加载方案类加载方案的原理是在app重新启动后让Classloader去加载新的类。因为app运行时，所有需要发生变更的类已经被加载过了，在Android上是无法对一个类进行卸载。如果不重新启动，原来的类还在虚拟机上，就无法加载新类。只有重新启动，在业务逻辑执行前，抢先加载补丁中的新类，当访问这个类时就会Resolve为新类，达到热修复目的。 ###底层替换原理 Andfix即时生效，其原理是，在已经加载的类中直接在native层替换掉原有方法，实在原有类基础上进行修改。其核心在于replaceMethod函数，这是一个native方法。 其参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的事需要被替换的原有方法。dest对应的就是新方法，新方法存在于补丁包中的新类中，也就是补丁方法。 Android的java运行环境，在4.4以下用的事dalvik虚拟机，而在4.4以上用的是art虚拟机。 我们以art为例，对于不同Android版本的art，底层Java对象的数据结构是不同的，因而会进一步区分不同的替换函数，这里我们以Android6.0为例，对应的就是replace_6_0. 每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等。 通过env-&gt;FromReflectedMethod，可以由Method对象得到这个方法对应的ArtMethod的真正起始地址。然后可以把它强转成ArtMethod指针，从而对其所有成员进行修改。这样全部替换完之后就完成了热修复逻辑，以后调用这个方法时就会直接走到新方法的实现中了。 为什么这样替换完就可以实现热修复了呢？需要从虚拟机调用方法的原理说起。 在Art虚拟机中ArtMethod结构中，包含两个重8_point_from_quick_compiled_code_了，他们是方法的执行入口。Java代码在Android中会被编译成DexCode。你也不 Art中可以采用解析模式或者AOT机器码模式执行。 解析模式，就是去除Dex Code，逐条解析执行，如果方法的调用者以解析模式运行，在调用方法时，就会取得这个方法的entry_point_from_interpreter_,然后他交转过去执行。AOT的方式，就会先预编译好Dex Code 对应的机器码，然后执行期直接执行机器码，不需要一条条解析执行Dex Code。如果方法的调用者是以AOT机器码方式执行的，在调用这个方法是，就是跳转到entry_point_from_quick_compiled_code执行。因此，当把一个旧方法的所有成员字段都换成新方法后，执行时所有数据就可以保持和新方法的一至。这样在所有执行到旧方法的地方，回取得新方法的执行入口、所属class、方法索引号及所属dex信息，然后想调用旧方法一样的执行到新方法的逻辑。 Native替换方案，比如Andfix和其他安全界的Hook方案，都是写死ArtMethod结构体，这样会带来兼容性问题。Native层替换思路，其实就是替换ArtMethod的所有成员 Sophix采取的是将ArtMethod的作为整体进行替换。 访问权限的问题 方法调用时的权限检查、同包名下的权限问题、反射调用非静态方法问题。 即时生效在什么情况下不适用？ 引起原有类中发生结构变化的修改 修复了的非静态方法会被反射调用 内部类编译 内部类会在编译器会被编译为跟外部类一样的顶级类。 冷启动类加载原理当类结构发生变化时，如新增减少类的method/field再热部署模式下会受到限制，但是冷部署能够达到修复目的。 ##冷启动实现方案 ##插桩实现的前因后果 如果仅仅把补丁类打入补丁包中而不做任何处理的话， 在运行时类加载的时候会异常退出。加载一个dex文件到本地内存时，如果不存在odex文件，首先会执行dexopt，dexopt 的入口在davilk/opt/OptMain.cpp的main方法，最后调用到verifyAndOptimizeClass执行真正的verify/optimize操作。 Apk第一次安装的时候，会对原dex执行dexopt,此时假如apk只存在一个dex，所以dvmVerifyClass(clazz)结果为true,所以apk中所有的类都会被打上CLASS_ISPREVERIFIED标识，接下来执行dvmOptimizeClass，类接着被打上CLASS_ISOPTIMIZED标识。 现在加入A类是补丁类，所以补丁A类在单独的dex中，类B中的某个方法引用到补丁类A，所以执行到该方法会尝试解析类A。 类B由于被打上了CLASS_ISPREVERIFIED标志，接下来referrer是类B，resClassCheck是补丁类A，他们属于不同的dex。所以会提示dvmThrowlllegalAccessError。为了解决这个问题，一个单独无关帮助类放到一个单独的dex中，原dex中所有类的构造函数都引用这个类，一般的实现方法都是侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。Art下冷启动实现 Dalvik下和Art下对DexFile.loadDex尝试把一个dex文件解析加载到native内存发生了什么？实际都是调用了DexFile.openDexFileNative这个native方法。Dalvik尝试加载一个压缩文件的时候只会去把classes.dex加载到内存中，如果此时内存文件中有多个dex，那么除了classes.dex之外的其他dex被直接忽略掉Art虚拟机方法调用链DexFile-&gt;openDexFileNative-&gt;OpenDexFilesFromat-&gt;LoadDexFilesArt下默认支持加载压缩文件中包含多个dex，首先肯定优先加载primary dex其实就是classes.dex，后续会加载其他的dex。所以补丁类只需要放到classes.dex即可，后续出现在其他dex中的“补丁类“是不会被重复加载的。 Art最终冷启动解决方案 把补丁dex命名为classes.dex。原apk中的dex一次命名为classes(2,3,4…).dex就好了，然后一起打包为一个压缩文件。然后DexFile.LoadDex得到DexFile对象，最后把该DexFile对象整个替换旧的dexElements数据就可以了。 Sophix 和 tinker 方案 补丁dex必须命名为classes.dex loadDex得到的DexFile完整替换掉dexElements数组而不是插入 DexFile.loadDex尝试把一个dex文件解析并加载到native内存，在加载到native内存之前，如果dex不存在对应的odex，那么Dalvik下回执行dexopt，Art下回执行dexoat，最后得到的都是一个优化后的odex，实际上最后虚拟机执行的事这个odex而不是dex。dex足够大那么dexopt/dexoat实际上是很好似的，Dalvik下实际影响比较下，因为loadDex仅仅是补丁包，Art下影响非常大，因为loadDex是补丁dex和apk中原dex合并成一个完整补丁压缩包，所以dexoat非常耗时。如果优化后的odex文件没生成或者没生成一个完整的odex文件，那么loadDex便不能在应用启动的时候进行的，因为会阻塞loadDex线程，一般是主线程。所以解决这个问题，Sophix把loadDex当做一个事务来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，那么重启另一子进程loadDex，重启之后在生效。 具体实施方案对Dalvik和Art下 Dalvik下采用自行研发的全量Dex方案 Art下本质上虚拟机已经支持多dex的加载，我们只需把补丁dex作为主dex(classes.dex)加载而已 冷启动方案限制？当新增一个publlic/protected/default方法，会出现方法调用错乱。 Google的dexmerge方案 把补丁dex和原dex合并一个完整的dex。 Dalvik下完整DEX方案的新探索 冷启动类加载修复 对于Android下的冷启动类加载修复，最早的实现方案是QQ空间提出的dex插入方案。主要思想是，把插入新dex插入到ClassLoader索引路径的最前面，这样在load一个class时，优先找到补丁中的。这类插入dex 的方案，会遇到一个主要的问题，就是如何解决Dalvik虚拟机下类的pre-verify问题。 如果一个类 中直接引用到的所有非系统类都和该类在同一个dex里的话，那么这个类就会被打上CLASS_ISPREVERIFIED,具体判定代码可见虚拟机中的verifyAndOptimizeClass函数。 腾讯的三大热修复方案是如何解决这个问题的： QQ控件的处理方式，是在每个类中插入一个来自其他dex的hack.class,由此让所有类里面都无法满足pre-verified条件。 Tinker的方式，是合成全量的dex文件，这样所有class的都在全量dex中解决，从而消除class重复而带来的冲突。 Qfix的方式，是取得虚拟机中的某些底层函数，提前resolve所有补丁类，以此绕过Pre-verify检查。Sophix的方式，补丁中已包含变动的类，主要在原先基线包中dex里边，去掉补丁中已有的class。这样，补丁+去除了补丁类的基线包=app中所有类。参考Android原生multi-dex的实现，是把一个apk所用到的所有类拆分到classes.dex、classes2.dex、classes.dex…之中，而每个dex都只包含了部分的类的定义，但单个dex也是可以加载的，因为只要把所有dex都load进去，本dex中不存在的类就可以在运行期间在其他dex中找到。 #资源热修复技术 ##3.2资源修复InstantRun资源热修复原理： 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManger中，这样就得到一个含有所有新资源的AssetManager。 找到所有之前引用到愿你有Assetmanager的地方，通过反射，把引用处替换成新的AssetManager。Sophix 资源热修复原理:构造一个package id 为0x66的资源包，其中包含改变了的资源项，然后直接在原有的AssetManager中addAssetPath这个包就可以了。由于补丁包的package id 为0x66,不与目前已经加载的0x7f冲突，因此直接加入到已有的AssetMananger中就可以直接使用。替换方式更加优雅，直接在原有的AssetManageer对象上进行析构和重构，原先AssetManager对象的引用没有发生改变，不用像InstantRun进行繁琐修改。 ###资源替换方案优势 不修改AssetManager的引用处，替换更快更安全。 不必下发完整包，补丁包中只包含有变动的资源 不要在运行时合成完整包。不占用运行时计算和内存资源。 一个Android进程只包含一个ResTable,ResTable的成员变量mPackageGroups就是所有解析过的资源包的集合。任何 一个资源包中都含有resources.arsc,他记录了所有资源的id分配情况以及资源中的所有字符串。这些信息是以二进制方式存储的。底层的AssetManager做的事就是解析这个文件，然后把相关信息存储到mPackageGroups里面。 资源信息主要是指每隔资源的名称以及他对应的编号。每隔资源，都有唯一编号。 编号是一个32位数字，用十六进制来标识就是0xPPTTEEEE。PP为package id，TT为type id，EEEE为entry id。 运行时资源的解析 默认由Android SDK编出来的apk，是由aapt工具进行打包的，其资源包的package id 是 0x7f。系统的资源包，也就是framework-res.jar，package id 为0x01。在走到app 的第一行代码之前，系统就已经帮我们构造好一个已经添加了安装包资源的AssetManager了。 因此，这个AssetManager里就已经包含了系统资源包以及app的安装包，就是package id 为0x01的framework-res.jar中的资源和package id为0x7f的app安装包资源。 如果此时直接在addAssetPath其实补丁包里的资源是不生效的。因为在getResTable已经执行很多次了。不会发生真正的解析。 ###Sophix资源解决方案 构造一个package id 为0x66的资源包，包含了改变的资源项，然后直接在原有AssetManager中addAssetPath这个包。不与已经加载的0x7f冲突。 而资源的改变包含增加、减少、修改这三种情况，分别是如何处理的呢？ 对于新增资源，直接加入补丁包，然后新代码里直接引用就可以了 对于减少资源，我们只要不使用他就行了，因此不用考虑这种情况，他也不影响补丁包 对于修改资源，比如替换了一张图片之类的情况。我们把它视为新增资源，在打补丁的时候，代码在引用处也会做响应修改，也就是直接把原来使用就资源id的地方变成新id。#3.3 So库修复So库修复本质上是对native方法的修复和替换。Sophix采用的是类似类修复反射注入方式。把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，达到加载so库时时补丁so库，而不是原来so库的目录，从而达到修复的目的。采用这种方案，完全由Sophix在启动期间反射注入patch中的so库。其他方案是手动替换系统的System.load来实现替换目的。Java Api提供一下两个接口加载一个so库 System.loadLibrary(String libName);传进去的参数 so库名称，表示的so库文件，位于apk压缩文件中的libs目录，最后复制到apk安装目录下。 System.load(String pathName)传进去的参数 so库在磁盘中的完整路径。加载一个自定义外部so库文件。两种方式加载一个so库，实际上最后都调用nativeLoad这个native方法去加载so库，这个方法的参数fileName so库在磁盘中的完整路径名。 JNI编程中，动态注册的natvie方法必须实现JNI_ONLoad方法，同时实现一个JNINativeMethod[]数组 ，静态注册的native方法必须是Java+类完整路径+方法名的格式。 ##3.1. SO库冷部署重启生效实现方案 SO库修复方案 接口调用替换方案，需要强制侵入用户接口调用 反射注入方案，重启生效 总结： 动态注册的native方法映射通过加载so库过程中调用JNI_OnLoad方法调用完成 静态注册的native方法映射是在该native方法第一次执行的时候才完成映射，当然前提是该so库已经load过。 ##3.2 SO库热部署实时生效分析 ###3.2.1动态注册native方法实时生效动态注册的native方法调用一次JNI_OnLoad方法都会重新完成一次映射，所以我们是否只要先加载原来的so库，然后在加载补丁so库，就完成Java层native方法到native层patch后的新方法映射，这样就完成动态注册native方法的patch实时修复。 实测发现art下这样是可以实时生效，但Dalvik下做不到试试生效。原因Dalvik第二次load补丁so库，执行的仍然是原来的so库的JNI_OnLoad方法，而不是补丁so库的JNI_OnLoad方法。Dalvik虚拟机下dlopen方法实现，底层方法会校验so库是否已经加载过，方法的判断依据是判断name,如果加载过直接返回该so库的句柄。如果so库从未加载过，则load_library执行加载。所以Dalvik下面加载修复后的补丁so拿到的还是原so库文件的句柄，所以执行的仍然是原so库的JNI_OnLoad方法，Art下不存在问题，因Art下该方法以name作为key去查找不是bname,所以art下重新load一遍补丁so库，拿到的是补丁so库的句柄，然后执行补丁so库的JNI_OnLoad。解决Dalvik下该问题，可对补丁so库进行改名。 ###3.2.2静态注册native方法实时生效静态注册native方法的映射实在native方法第一次执行的时候完成映射，如果native方法在加载补丁so库之前已经执行过，是否这个静态注册native方法一定得不到修复？幸运的是，系统JNI API提供了解注册的接口 UnregisterNatives（JNIEnv* env,jclass jclazz）函数回吧jclazz所在类的所有native方法都重新指向为dvmResolveNativeMethod，所以调用unregisterNatives之后不管是静态注册还是动态注册的native方法之前是否执行过在加载补丁so 的时候都会重新去做映射。所以我们只需要以下调用。 ##3.3 SO库冷部署重启生效实现方案 ###3.3.1.接口调用替换方案Sdk提供接口替换System默认加载so库接口 SOPatchManager。loadLibrary接口加载so库的时候有限尝试去加载sdk指定目录下的补丁so，加载策略如下： 如果存在则加载补丁so库而不会去加载安装apk安装目录下的so库。 如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的so库。 方案优缺点：优点：不需要对不同sdk版本进行兼容，因为所有的SDK版本都有System.loadLibrary这个接口。缺点：调用方需要替换掉System默认加载so库接口为sdk提供的接口，如果是已经编译混淆好的三方库的so库需要patch，那么是很难做到接口的替换。 ###3.3.2反射注入方案System.loadLibrary(“native-lib”)，加载so库的原理，其实native-lib这个 so库最终传给native方法执行的参数是so库在磁盘中的完整路径，比如/data/app-lib/com.taobao.jni-2/libnative-lib.so,so库会在DexPathList.nativeLibraryDirectories/nativeLibraryPathElements变量所表示的目录下去遍历搜索。 可以发现会遍历nativeLibraryDirectories数组，如果找到了IoUtils.canOpenReadOnly(path)返回true，那么就直接返回该path，IoUtils。canOpenReadOnly(path)返回true的前提肯定是需要path标识的so文件存在的。我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复的目的。 Sdk23以上findLibrary 实现已经发生变化，只需把补丁so库的完整路径违参数构建一个Element对象，然后再插入nativeLibraryPathElements数组的最前面就好了。 优点：可以修复三方库的so库。同事接入方不需要想方案1一样强制侵入用户接口调用。缺点：需要不断的对sdk进行适配，如上sdk23为分界线，findLibrary接口实现已发生变化。不管是补丁包还是apk中一个so库存在多种cpu架构的so文件，比如armeabi，arm64-v8a,x86等。加载可定是加载其中一个so库文件的，如何选择机型对应的so库文件将是重点所在。 虚拟机究竟如何选择哪个abis目录作为参数构建PathClassLoader对象，原理如图 实际上补丁so也存在类似的问题，我们的补丁so库文件放到补丁包的libs目录下，libs目录和.dex文件res资源文件一起打包成一个压缩文件作为最后的补丁包，libs目录可能也包含多种abis目录。所以我们需要选择手机最合适的primaryCpuAbi，然后从libs目录下选择这个primaryCpuAbi子目录插入到nativeLibraryDirectories/nativeLibraryPathElements数组。所以怎么选择primaryCpuAbi是关键，具体实现如图： 1.sdk&gt;=21时，直接反射拿到ApplicationInfo对象的primaryCpuAbi即可2.sdk&lt;21时，有雨此时不支持64位，所以直接吧Build.CPU_ABI,Build.CPU_ABI2作为primaryCpuAbi即可。","link":"/2019/10/11/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"title":"23 Android异常处理流程 Android 项目构建流程","text":"前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。 这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~ 开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息： 那么这里的force close弹窗是如何弹出的呢？ 还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考： 在Android中自定义捕获Application全局异常） 带着这两个问题，我们开始今天的异常流程分析。 在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：Android应用程序进程启动过程的源代码分析） 而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现： 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller { if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader); } 可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现： 12345private static final void commonInit() { ... Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); ... }可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。 看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考： 在Android中自定义捕获Application全局异常所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现： 123456789101112131415161718192021222324252627282930313233343536private static class UncaughtHandler implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread t, Throwable e) { try { // Don't re-enter -- avoid infinite loops if crash-reporting crashes. if (mCrashing) return; mCrashing = true; if (mApplicationObject == null) { Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e); } else { StringBuilder message = new StringBuilder(); message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\\n&quot;); final String processName = ActivityThread.currentProcessName(); if (processName != null) { message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;); } message.append(&quot;PID: &quot;).append(Process.myPid()); Clog_e(TAG, message.toString(), e); } // Bring up crash dialog, wait for it to be dismissed ActivityManagerNative.getDefault().handleApplicationCrash( mApplicationObject, new ApplicationErrorReport.CrashInfo(e)); } catch (Throwable t2) { try { Clog_e(TAG, &quot;Error reporting crash&quot;, t2); } catch (Throwable t3) { // Even Clog_e() fails! Oh well. } } finally { // Try everything to make sure this process goes away. Process.killProcess(Process.myPid()); System.exit(10); } } } 这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。 然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？ 123static public IActivityManager getDefault() { return gDefault.get(); } 可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑： 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。 12345678910111213public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app); crashInfo.writeToParcel(data, 0); mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0); reply.readException(); reply.recycle(); data.recycle(); } 这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。 1234567public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) { ProcessRecord r = findAppProcess(app, &quot;Crash&quot;); final String processName = app == null ? &quot;system_server&quot; : (r == null ? &quot;unknown&quot; : r.processName); handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo); } 可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。 1234567891011121314void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) { EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber); addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo); crashApplication(r, crashInfo); } 可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File logFile, final ApplicationErrorReport.CrashInfo crashInfo) { // NOTE -- this must never acquire the ActivityManagerService lock, // otherwise the watchdog may be prevented from resetting the system. final String dropboxTag = processClass(process) + &quot;_&quot; + eventType; final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE); // Exit early if the dropbox isn't configured to accept this report type. if (dbox == null || !dbox.isTagEnabled(dropboxTag)) return; final StringBuilder sb = new StringBuilder(1024); appendDropBoxProcessHeaders(process, processName, sb); if (activity != null) { sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid != process.pid) { sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent != activity) { sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\\n&quot;); } if (subject != null) { sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\\n&quot;); } sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\\n&quot;); if (Debug.isDebuggerConnected()) { sb.append(&quot;Debugger: Connected\\n&quot;); } sb.append(&quot;\\n&quot;); // Do the rest in a worker thread to avoid blocking the caller on I/O // (After this point, we shouldn't access AMS internal data structures.) Thread worker = new Thread(&quot;Error dump: &quot; + dropboxTag) { @Override public void run() { if (report != null) { sb.append(report); } if (logFile != null) { try { sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE, &quot;\\n\\n[[TRUNCATED]]&quot;)); } catch (IOException e) { Slog.e(TAG, &quot;Error reading &quot; + logFile, e); } } if (crashInfo != null &amp;&amp; crashInfo.stackTrace != null) { sb.append(crashInfo.stackTrace); } String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag; int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0); if (lines &gt; 0) { sb.append(&quot;\\n&quot;); // Merge several logcat streams, and take the last N lines InputStreamReader input = null; try { java.lang.Process logcat = new ProcessBuilder(&quot;/system/bin/logcat&quot;, &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;, &quot;-b&quot;, &quot;crash&quot;, &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start(); try { logcat.getOutputStream().close(); } catch (IOException e) {} try { logcat.getErrorStream().close(); } catch (IOException e) {} input = new InputStreamReader(logcat.getInputStream()); int num; char[] buf = new char[8192]; while ((num = input.read(buf)) &gt; 0) sb.append(buf, 0, num); } catch (IOException e) { Slog.e(TAG, &quot;Error running logcat&quot;, e); } finally { if (input != null) try { input.close(); } catch (IOException e) {} } } dbox.addText(dropboxTag, sb.toString()); } }; if (process == null) { // If process is null, we are being called from some internal code // and may be about to die -- run this synchronously. worker.run(); } else { worker.start(); } } 可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。 继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { long timeMillis = System.currentTimeMillis(); String shortMsg = crashInfo.exceptionClassName; String longMsg = crashInfo.exceptionMessage; String stackTrace = crashInfo.stackTrace; if (shortMsg != null &amp;&amp; longMsg != null) { longMsg = shortMsg + &quot;: &quot; + longMsg; } else if (shortMsg != null) { longMsg = shortMsg; } AppErrorResult result = new AppErrorResult(); synchronized (this) { if (mController != null) { try { String name = r != null ? r.processName : null; int pid = r != null ? r.pid : Binder.getCallingPid(); int uid = r != null ? r.info.uid : Binder.getCallingUid(); if (!mController.appCrashed(name, pid, shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) { if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;)) &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) { Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name + &quot;(&quot; + pid + &quot;) during testing&quot;); } else { Slog.w(TAG, &quot;Force-killing crashed app &quot; + name + &quot; at watcher's request&quot;); if (r != null) { r.kill(&quot;crash&quot;, true); } else { // Huh. Process.killProcess(pid); killProcessGroup(uid, pid); } } return; } } catch (RemoteException e) { mController = null; Watchdog.getInstance().setActivityController(null); } } final long origId = Binder.clearCallingIdentity(); // If this process is running instrumentation, finish it. if (r != null &amp;&amp; r.instrumentationClass != null) { Slog.w(TAG, &quot;Error in app &quot; + r.processName + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;); if (shortMsg != null) Slog.w(TAG, &quot; &quot; + shortMsg); if (longMsg != null) Slog.w(TAG, &quot; &quot; + longMsg); Bundle info = new Bundle(); info.putString(&quot;shortMsg&quot;, shortMsg); info.putString(&quot;longMsg&quot;, longMsg); finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info); Binder.restoreCallingIdentity(origId); return; } // Log crash in battery stats. if (r != null) { mBatteryStatsService.noteProcessCrash(r.processName, r.uid); } // If we can't identify the process or it's already exceeded its crash quota, // quit right away without showing a crash dialog. if (r == null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) { Binder.restoreCallingIdentity(origId); return; } Message msg = Message.obtain(); msg.what = SHOW_ERROR_MSG; HashMap data = new HashMap(); data.put(&quot;result&quot;, result); data.put(&quot;app&quot;, r); msg.obj = data; mUiHandler.sendMessage(msg); Binder.restoreCallingIdentity(origId); } int res = result.get(); Intent appErrorIntent = null; synchronized (this) { if (r != null &amp;&amp; !r.isolated) { // XXX Can't keep track of crash time for isolated processes, // since they don't have a persistent identity. mProcessCrashTimes.put(r.info.processName, r.uid, SystemClock.uptimeMillis()); } if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) { appErrorIntent = createAppErrorIntentLocked(r, timeMillis, crashInfo); } } if (appErrorIntent != null) { try { mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId)); } catch (ActivityNotFoundException e) { Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e); } } } 可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。 在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243case SHOW_ERROR_MSG: { HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) msg.obj; boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0; synchronized (ActivityManagerService.this) { ProcessRecord proc = (ProcessRecord)data.get(&quot;app&quot;); AppErrorResult res = (AppErrorResult) data.get(&quot;result&quot;); if (proc != null &amp;&amp; proc.crashDialog != null) { Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc); if (res != null) { res.set(0); } return; } boolean isBackground = (UserHandle.getAppId(proc.uid) &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; proc.pid != MY_PID); for (int userId : mCurrentProfileIds) { isBackground &amp;= (proc.userId != userId); } if (isBackground &amp;&amp; !showBackground) { Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;); if (res != null) { res.set(0); } return; } if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) { Dialog d = new AppErrorDialog(mContext, ActivityManagerService.this, res, proc); d.show(); proc.crashDialog = d; } else { // The device is asleep, so just pretend that the user // saw a crash dialog and hit &quot;force quit&quot;. if (res != null) { res.set(0); } } } ensureBootCompleted(); } 可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: …. O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码： 1234// After the timeout, pretend the user clicked the quit button mHandler.sendMessageDelayed( mHandler.obtainMessage(FORCE_QUIT), DISMISS_TIMEOUT); 这里的常量DISMISS_TIME = 5 60 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。 好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。 这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~ 总结： App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。 默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。 自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。 force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程","link":"/2020/09/11/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"title":"19 Dialog加载绘制流程","text":"前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。 可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码） 好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。 12345678910111213141516171819title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。 一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。 那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法： 123public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); }好吧，这里调用的是Builder的重载构造方法： 1234public Builder(Context context, int themeResId) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); } 那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。 12345public AlertParams(Context context) { mContext = context; mCancelable = true; mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); } 可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码： 1AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); 就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现： 1234public Builder setIcon(@DrawableRes int iconId) { P.mIconId = iconId; return this; } 可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。 然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现： 1234public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } 好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。 再看一下builder.setTitle方法： 1234public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } 可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。 然后我们看一下builder.setView方法： 123456public Builder setView(int layoutResId) { P.mView = null; P.mViewLayoutResId = layoutResId; P.mViewSpacingSpecified = false; return this; } 可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。 然后我们调用了builder.setPositiveButton方法： 123456builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); 好吧，这里我们看一下builder的setPositiveButton的源码： 12345public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } 好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。 上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行： 1builder.setIcon().setMessage().setTitle().setView().setPositiveButton()... 这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。 然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。 123456789101112131415public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } 可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现： 1234567AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } 可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法： 1234567891011121314151617181920212223Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == 0) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); } else { mContext = context; } mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法： 1mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法： 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了： 1mAlert = new AlertController(getContext(), this, getWindow()); 相当于初始化了AlertDiaog的成员变量mAlert。 继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ublic void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId != 0) { dialog.setIcon(mIconId); } if (mIconAttrId != 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } else if (mViewLayoutResId != 0) { dialog.setView(mViewLayoutResId); } } 看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。 继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了： 1dialog.setCancelable(P.mCancelable); 可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void show() { if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; if (!mCreated) { dispatchOnCreate(null); } onStart(); mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; } try { mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); } finally { } } 方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看： 123if (!mCreated) { dispatchOnCreate(null); } mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑： 123456void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { onCreate(savedInstanceState); mCreated = true; } } 好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent(); } 可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。 12345678public void installContent() { /* We use a custom title so never request a window title */ mWindow.requestFeature(Window.FEATURE_NO_TITLE); int contentView = selectContentView(); mWindow.setContentView(contentView); setupView(); setupDecor(); } 可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。 12345678910private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } // TODO: use layout hint side for long messages/lists return mAlertDialogLayout; } 可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（android源码解析（十七）–&gt;Activity布局加载流程）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。 12mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~ 继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。 然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。 O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。 最后我们调用了sendShowMessage方法，可以看一下这个方法的实现： 123456private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); } } 这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？ 123456alertDialog.setOnShowListener(new DialogInterface.OnShowListener() { @Override public void onShow(DialogInterface dialog) { } }); 这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现： 1234567public void setOnShowListener(OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; } } 这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。 注：这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出： 12345678910111213141516Process: com.example.aaron.helloworld, PID: 11948 android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an applicationat android.view.ViewRootImpl.setView(ViewRootImpl.java:690)at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)at android.app.Dialog.show(Dialog.java:298)at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)at android.view.View.performClick(View.java:4811)at android.view.View$PerformClick.run(View.java:20136)at android.os.Handler.handleCallback(Handler.java:815)at android.os.Handler.dispatchMessage(Handler.java:104)at android.os.Looper.loop(Looper.java:194)at android.app.ActivityThread.main(ActivityThread.java:5552)at java.lang.reflect.Method.invoke(Native Method)at java.lang.reflect.Method.invoke(Method.java:372)at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。 总结： Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑； Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象； Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类； 构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程","link":"/2020/09/11/Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"9 SystemServer进程启动流程","text":"转载请标明出处：一片枫叶的专栏 上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，具体可参见： android源码解析之（八）–&gt;Zygote进程启动流程那么SystemServer进程是做什么用的呢？ 其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。 由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑： 123456/** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } 这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。 然后我们查看run方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private void run() { // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } // If the system has &quot;persist.sys.language&quot; and friends set, replace them with // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } // Here we go! Slog.i(TAG, &quot;Entered the Android system server!&quot;); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis()); // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) { SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() { @Override public void run() { SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null); } }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); } // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit(); // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper(); // Initialize native services. System.loadLibrary(&quot;android_servers&quot;); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) { Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); } // Loop forever. Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 好吧，代码比较多，慢慢看。。。 1234if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } 首先判断系统当前时间，若当前时间小于1970年1月1日，则一些初始化操作可能会处所，所以当系统的当前时间小于1970年1月1日的时候，设置系统当前时间为该时间点。 然后代码： 12345678if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } 主要是设置系统的语言环境等；下面的主要是设置虚拟机运行内存，加载运行库，设置SystemServer的异步消息，具体的异步消息机制可参见： android源码解析之（二）–&gt;异步消息机制 然后下面的代码是： 1234567891011121314151617// Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 首先调用createSystemContext()方法： 12345private void createSystemContext() { ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); } 可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。 然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。 然后调用： 1LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); 是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。 最后开始执行： 12345678910// Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 里面主要涉及了是三个方法：startBootstrapServices() 主要用于启动系统Boot级服务startCoreServices() 主要用于启动系统核心的服务startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务 下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。 首先看一下startBootstrapServices方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void startBootstrapServices() { // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // Power manager needs to be started early because other services need it. // Native daemons may be watching for it to be registered so it must be ready // to handle incoming binder calls immediately (including being able to verify // the permissions for those calls). mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // Now that the power manager has been started, let the activity manager // initialize power management features. mActivityManagerService.initPowerManagement(); // Manages LEDs and display backlight so we need it to bring up the display. mSystemServiceManager.startService(LightsService.class); // Display manager is needed to provide display metrics before package manager // starts up. mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // Only run &quot;core&quot; apps if we're encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; } // Start the package manager. Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Slog.i(TAG, &quot;User Service&quot;); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); // Initialize attribute cache used to cache resources from packages. AttributeCache.init(mSystemContext); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); // The sensor service needs access to package manager service, app ops // service, and permissions service, therefore we start it after them. startSensorService(); } 首先执行： 1Installer installer = mSystemServiceManager.startService(Installer.class); mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); } final T service; try { Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service constructor threw an exception&quot;, ex); } // Register it. mServices.add(service); // Start it. try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); } return service; } 可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法： 12345@Override public void onStart() { Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;); mInstaller.waitForConnection(); } 很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。然后查看waitForConnection（）方法： 123456789public void waitForConnection() { for (;;) { if (execute(&quot;ping&quot;) &gt;= 0) { return; } Slog.w(TAG, &quot;installd not ready&quot;); SystemClock.sleep(1000); } } 通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）； 总结：在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。 继续来看startBootstrapServices方法： 12345// Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); 这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。 首先看一下Lifecycle类的定义： 1234567891011121314151617public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; public Lifecycle(Context context) { super(context); mService = new ActivityManagerService(context); } @Override public void onStart() { mService.start(); } public ActivityManagerService getService() { return mService; } } 可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现： 123456789private void start() { Process.removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); } 由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。 然后是启动PowerManagerService服务： 1mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); 启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。 然后是启动LightsService服务 1mSystemServiceManager.startService(LightsService.class); 主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法； 然后是启动DisplayManagerService服务 1mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); 主要是手机显示方面的服务； 然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。 12345Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); 可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; } 可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。 然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。 然后查看startCoreServices方法： 1234567891011121314private void startCoreServices() { // Tracks the battery level. Requires LightService. mSystemServiceManager.startService(BatteryService.class); // Tracks application usage stats. mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // Update after UsageStatsService is available, needed before performBootDexOpt. mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); // Tracks whether the updatable WebView is in a ready state and watches for update installs. mSystemServiceManager.startService(WebViewUpdateService.class); } 可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。 最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。 总结： SystemServer进程是android中一个很重要的进程由Zygote进程启动； SystemServer进程主要用于启动系统中的服务； SystemServer进程启动服务的启动函数为main函数； SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务； SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动 SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务； 创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量； 服务对象都有自己的异步消息对象，并运行在单独的线程中； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程","link":"/2020/09/11/SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"Handler异步休息机制","text":"知乎上看了一篇非常不错的博文：有没有必要阅读ANDROID源码痛定思过，为了更好的深入android体系，决定学习android framework层源码，就从最简单的android异步消息机制开始吧。 （一）Handler的常规使用方式 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity { public static final String TAG = MainActivity.class.getSimpleName(); private TextView texttitle = null; /** * 在主线程中定义Handler，并实现对应的handleMessage方法 */ public static Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;接收到handler消息...&quot;); } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); texttitle = (TextView) findViewById(R.id.texttitle); texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { // 在子线程中发送异步消息 mHandler.sendEmptyMessage(101); } }.start(); } }); }} 可以看出，一般handler的使用方式都是在主线程中定义Handler，然后在子线程中调用mHandler.sendEmptyMessage();方法，然么这里有一个疑问了，我们可以在子线程中定义Handler么？ （二）如何在子线程中定义Handler？ 我们在子线程中定义Handler，看看结果: 123456789101112131415161718texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 点击按钮并运行这段代码： 可以看出来在子线程中定义Handler对象出错了，难道Handler对象的定义或者是初始化只能在主线程中？其实不是这样的，错误信息中提示的已经很明显了，在初始化Handler对象之前需要调用Looper.prepare()方法，那么好了，我们添加这句代码再次执行一次： 12345678910111213141516171819texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Looper.prepare(); Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 再次点击按钮执行该段代码之后，程序已经不会报错了，那么这说明初始化Handler对象的时候我们是需要调用Looper.prepare()的，那么主线程中为什么可以直接初始化Handler呢？ 其实不是这样的，在App初始化的时候会执行ActivityThread的main方法： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 可以看到原来Looper.prepare()方法在这里调用了，所以在其他地方我们就可以直接初始化Handler了。 并且我们可以看到还调用了：Looper.loop()方法，通过参考阅读其他文章我们可以知道一个Handler的标准写法其实是这样的： 12345678910Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); （三）查看Handler源码1）查看Looper.prepare()方法 12345678910111213141516171819// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}. */ public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 可以看到Looper中有一个ThreadLocal成员变量，熟悉JDK的同学应该知道，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。具体参考：彻底理解ThreadLocal由此可以看出在每个线程中Looper.prepare()能且只能调用一次，这里我们可以尝试一下调用两次的情况。 1234567891011121314/** * 这里Looper.prepare()方法调用了两次*/Looper.prepare();Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); 再次运行程序，点击按钮，执行该段代码：可以看到程序出错，并提示prepare中的Excetion信息。 我们继续看Looper对象的构造方法，可以看到在其构造方法中初始化了一个MessageQueue对象： 1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 综上小结（1）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。 2）查看Handler对象的构造方法 12345678910111213141516171819public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 可以看出在Handler的构造方法中，主要初始化了一下变量，并判断Handler对象的初始化不应再内部类，静态类，匿名类中，并且保存了当前线程中的Looper对象。综上小结（2）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。而Handler的构造方法则在Handler内部维护了当前线程的Looper对象 3）查看handler.sendMessage(msg)方法一般的，我们发送异步消息的时候会这样调用： 1mHandler.sendMessage(new Message()); 通过不断的跟进源代码，其最后会调用： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 原来msg.target就是Handler对象本身；而这里的queue对象就是我们的Handler内部维护的Looper对象关联的MessageQueue对象。查看messagequeue对象的enqueueMessage方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 可以看到这里MessageQueue并没有使用列表将所有的Message保存起来，而是使用Message.next保存下一个Message，从而按照时间将所有的Message排序； 4）查看Looper.Loop()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 可以看到方法的内容还是比较多的。可以看到Looper.loop()方法里起了一个死循环，不断的判断MessageQueue中的消息是否为空，如果为空则直接return掉，然后执行queue.next()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 可以看到其大概的实现逻辑就是Message的出栈操作，里面可能对线程，并发控制做了一些限制等。获取到栈顶的Message对象之后开始执行：1msg.target.dispatchMessage(msg); 那么msg.target是什么呢？通过追踪可以知道就是我们定义的Handler对象，然后我们查看一下Handler类的dispatchMessage方法： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 可以看到，如果我们设置了callback（Runnable对象）的话，则会直接调用handleCallback方法： 123private static void handleCallback(Message message) { message.callback.run(); } 即，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。比如我们经常写的runOnUiThread方法： 123456runOnUiThread(new Runnable() { @Override public void run() { } }); 看其内部实现： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 而如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。由于Handler对象是在主线程中创建的，所以handler的handlerMessage方法的执行也会在主线程中。 综上可以知道：1）主线程中定义Handler，直接执行： 123456Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); }}; 而如果想要在子线程中定义Handler，则标准的写法为： 1234567891011// 初始化该线程Looper，MessageQueue，执行且只能执行一次 Looper.prepare(); // 初始化Handler对象，内部关联Looper对象 Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; // 启动消息队列出栈死循环 Looper.loop(); 2）一个线程中只存在一个Looper对象，只存在一个MessageQueue对象，可以存在N个Handler对象，Handler对象内部关联了本线程中唯一的Looper对象，Looper对象内部关联着唯一的一个MessageQueue对象。 3）MessageQueue消息队列不是通过列表保存消息（Message）列表的，而是通过Message对象的next属性关联下一个Message从而实现列表的功能，同时所有的消息都是按时间排序的。 4）android中两个子线程相互交互同样可以通过Handler的异步消息机制实现，可以在线程a中定义Handler对象，而在线程b中获取handler的引用并调用sendMessage方法。 5）activity内部默认存在一个handler的成员变量，android中一些其他的异步消息机制的实现方法：Handler的post方法： 123456mHandler.post(new Runnable() { @Override public void run() { } }); 查看其内部实现： 1234public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 可以发现其内部调用就是sendMessage系列方法。。。 view的post方法： 123456789public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true; } 可以发现其调用的就是activity中默认保存的handler对象的post方法。 activity的runOnUiThread方法： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 判断当前线程是否是UI线程，如果不是，则调用handler的post方法，否则直接执行run方法。 参考文章：Android异步消息处理机制完全解析，带你从源码的角度彻底理解 Android异步消息处理机制详解及源码分析 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"title":"16 应用进程Context创建流程","text":"今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？ 这个问题的答案是Application + N个Activity + N个Service。 还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章： Android Context 是什么？ 好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？ android源码解析之（十一）–&gt;应用进程启动流程最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧， 由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。 首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。 123456public static void main(String[] args) { ... ActivityThread thread = new ActivityThread(); thread.attach(false); ... }这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ViewRootImpl.addFirstDrawHandler(new Runnable() { @Override public void run() { ensureJitEnabled(); } }); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { mgr.releaseSomeActivities(mAppThread); } catch (RemoteException e) { } } } }); } else { ... } } 这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 然后这里面又调用了attachApplicationLocked方法： 12345678private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,getCommonServicesLocked(app.isolated),mCoreSettingsObserver.getCoreSettingsLocked()); ... 可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) { if (services != null) { // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); } setCoreSettings(coreSettings); /* * Two possible indications that this package could be * sharing its runtime with other packages: * * 1.) the sharedUserId attribute is set in the manifest, * indicating a request to share a VM with other * packages with the same sharedUserId. * * 2.) the application element of the manifest has an * attribute specifying a non-default process name, * indicating the desire to run in another packages VM. * * If sharing is enabled we do not have a unique application * in a process and therefore cannot rely on the package * name inside the runtime. */ IPackageManager pm = getPackageManager(); android.content.pm.PackageInfo pi = null; try { pi = pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId()); } catch (RemoteException e) { } if (pi != null) { boolean sharedUserIdSet = (pi.sharedUserId != null); boolean processNameNotDefault = (pi.applicationInfo != null &amp;&amp; !appInfo.packageName.equals(pi.applicationInfo.processName)); boolean sharable = (sharedUserIdSet || processNameNotDefault); // Tell the VMRuntime about the application, unless it is shared // inside a process. if (!sharable) { VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir, appInfo.processName); } } AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data); } 好吧，最后调用了ActivityThread.sendMessage()… 123private void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } 然后我们看一下其sendMessage的重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void handleBindApplication(AppBindData data) { ... // 创建Instrumentation if (data.instrumentationName != null) { InstrumentationInfo ii = null; try { ii = appContext.getPackageManager(). getInstrumentationInfo(data.instrumentationName, 0); } catch (PackageManager.NameNotFoundException e) { } if (ii == null) { throw new RuntimeException( &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName); } mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = ii.nativeLibraryDir; mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); ApplicationInfo instrApp = new ApplicationInfo(); instrApp.packageName = ii.packageName; instrApp.sourceDir = ii.sourceDir; instrApp.publicSourceDir = ii.publicSourceDir; instrApp.splitSourceDirs = ii.splitSourceDirs; instrApp.splitPublicSourceDirs = ii.splitPublicSourceDirs; instrApp.dataDir = ii.dataDir; instrApp.nativeLibraryDir = ii.nativeLibraryDir; LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); ContextImpl instrContext = ContextImpl.createAppContext(this, pi); try { java.lang.ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } mInstrumentation.init(this, instrContext, appContext, new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) { mProfiler.handlingProfiling = true; File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); } } else { mInstrumentation = new Instrumentation(); } ... / If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try { mInstrumentation.onCreate(data.instrumentationArgs); } catch (Exception e) { throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } finally { StrictMode.setThreadPolicy(savedPolicy); } } 这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = &quot;android.app.Application&quot;; } try { java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) { initializeJavaContextClassLoader(); } ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); } catch (Exception e) { if (!mActivityThread.mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); } } mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) { try { instrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!instrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) { final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) { continue; } rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); } return app; } 可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。 继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现： 123public void callApplicationOnCreate(Application app) { app.onCreate(); } 咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。 这样我们整个Application的创建执行流程就讲解完了。 总结： 应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象； ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application； 每个应用进程对应一个Instrumentation，对应一个Application； Instrumentation与Application都是通过java反射机制创建； Application创建过程中会同时创建一个ContextImpl对象，并建立关联； 接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见： android源码解析之（十四）–&gt;Activity启动流程，这里我们看一下其具体的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ... return activity; } 这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。 123456789101112131415161718192021222324252627282930private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) { int displayId = Display.DEFAULT_DISPLAY; try { displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token); } catch (RemoteException e) { } ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); // For debugging purposes, if the activity's package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) { for (int id : dm.getDisplayIds()) { if (id != Display.DEFAULT_DISPLAY) { Display display = dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id)); baseContext = appContext.createDisplayContext(display); break; } } } return baseContext; } 可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。 总结： Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中； Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用； 创建Activity –&gt; 创建Activity相关ContextImpl对象； 创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"26 截屏事件流程","text":"今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。 在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** {@inheritDoc} */ @Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { ... final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理： 123456789101112131415161718192021222324252627282930313233343536@Override public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { if (!mSystemBooted) { // If we have not yet booted, don't let key events do anything. return 0; } ... // Handle special keys. switch (keyCode) { case KeyEvent.KEYCODE_VOLUME_DOWN: case KeyEvent.KEYCODE_VOLUME_UP: case KeyEvent.KEYCODE_VOLUME_MUTE: { if (mUseTvRouting) { // On TVs volume keys never go to the foreground app result &amp;= ~ACTION_PASS_TO_USER; } if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { if (down) { if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } } else { mScreenshotChordVolumeDownKeyTriggered = false; cancelPendingScreenshotChordAction(); } } ... return result; } 可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。 回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行： 12345678if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } 可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。 123456789101112131415private void interceptScreenshotChord() { if (mScreenshotChordEnabled &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) { final long now = SystemClock.uptimeMillis(); if (now &lt;= mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS &amp;&amp; now &lt;= mScreenshotChordPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) { mScreenshotChordVolumeDownKeyConsumed = true; cancelPendingPowerKeyAction(); mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay()); } } } 在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。 12345678private long getScreenshotChordLongPressDelay() { if (mKeyguardDelegate.isShowing()) { // Double the time it takes to take a screenshot from the keyguard return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER * ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout(); } 回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：android源码解析之（二）–&gt;异步消息机制 这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现: 123456private final Runnable mScreenshotRunnable = new Runnable() { @Override public void run() { takeScreenshot(); } }; 好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void takeScreenshot() { synchronized (mScreenshotLock) { if (mScreenshotConnection != null) { return; } ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;, &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;); Intent intent = new Intent(); intent.setComponent(cn); ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { synchronized (mScreenshotLock) { if (mScreenshotConnection != this) { return; } Messenger messenger = new Messenger(service); Message msg = Message.obtain(null, 1); final ServiceConnection myConn = this; Handler h = new Handler(mHandler.getLooper()) { @Override public void handleMessage(Message msg) { synchronized (mScreenshotLock) { if (mScreenshotConnection == myConn) { mContext.unbindService(mScreenshotConnection); mScreenshotConnection = null; mHandler.removeCallbacks(mScreenshotTimeout); } } } }; msg.replyTo = new Messenger(h); msg.arg1 = msg.arg2 = 0; if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; try { messenger.send(msg); } catch (RemoteException e) { } } } @Override public void onServiceDisconnected(ComponentName name) {} }; if (mContext.bindServiceAsUser( intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) { mScreenshotConnection = conn; mHandler.postDelayed(mScreenshotTimeout, 10000); } } } 可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。 1234567891011121314151617181920212223242526272829303132public class TakeScreenshotService extends Service { private static final String TAG = &quot;TakeScreenshotService&quot;; private static GlobalScreenshot mScreenshot; private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 1: final Messenger callback = msg.replyTo; if (mScreenshot == null) { mScreenshot = new GlobalScreenshot(TakeScreenshotService.this); } mScreenshot.takeScreenshot(new Runnable() { @Override public void run() { Message reply = Message.obtain(null, 1); try { callback.send(reply); } catch (RemoteException e) { } } }, msg.arg1 &gt; 0, msg.arg2 &gt; 0); } } }; @Override public IBinder onBind(Intent intent) { return new Messenger(mHandler).getBinder(); }} 可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Takes a screenshot of the current display and shows an animation. */ void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) { // We need to orient the screenshot correctly (and the Surface api seems to take screenshots // only in the natural orientation of the device :!) mDisplay.getRealMetrics(mDisplayMetrics); float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels}; float degrees = getDegreesForRotation(mDisplay.getRotation()); boolean requiresRotation = (degrees &gt; 0); if (requiresRotation) { // Get the dimensions of the device in its native orientation mDisplayMatrix.reset(); mDisplayMatrix.preRotate(-degrees); mDisplayMatrix.mapPoints(dims); dims[0] = Math.abs(dims[0]); dims[1] = Math.abs(dims[1]); } // Take the screenshot mScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } // Optimizations mScreenBitmap.setHasAlpha(false); mScreenBitmap.prepareToDraw(); // Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); } 可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的： 1234if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; 可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了： 12// Take the screenshotmScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); 方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。 1234567public static Bitmap screenshot(int width, int height) { // TODO: should take the display as a parameter IBinder displayToken = SurfaceControl.getBuiltInDisplay( SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN); return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true, false, Surface.ROTATION_0); } 好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功： 12345if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } 若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。 123456789101112131415161718192021static void notifyScreenshotError(Context context, NotificationManager nManager) { Resources r = context.getResources(); // Clear all existing notification, compose the new notification and show it Notification.Builder b = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_failed_title)) .setContentTitle(r.getString(R.string.screenshot_failed_title)) .setContentText(r.getString(R.string.screenshot_failed_text)) .setSmallIcon(R.drawable.stat_notify_image_error) .setWhen(System.currentTimeMillis()) .setVisibility(Notification.VISIBILITY_PUBLIC) // ok to show outside lockscreen .setCategory(Notification.CATEGORY_ERROR) .setAutoCancel(true) .setColor(context.getColor( com.android.internal.R.color.system_notification_accent_color)); Notification n = new Notification.BigTextStyle(b) .bigText(r.getString(R.string.screenshot_failed_text)) .build(); nManager.notify(R.id.notification_screenshot, n); } 然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像： 1234567891011121314if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } 在takeScreenshot方法的最后若截屏成功，我们调用了： 123// Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); 开始截屏的动画，好吧，看一下动画效果的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Starts the animation after taking the screenshot */ private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible, boolean navBarVisible) { // Add the view for the animation mScreenshotView.setImageBitmap(mScreenBitmap); mScreenshotLayout.requestFocus(); // Setup the animation with the screenshot just taken if (mScreenshotAnimation != null) { mScreenshotAnimation.end(); mScreenshotAnimation.removeAllListeners(); } mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams); ValueAnimator screenshotDropInAnim = createScreenshotDropInAnimation(); ValueAnimator screenshotFadeOutAnim = createScreenshotDropOutAnimation(w, h, statusBarVisible, navBarVisible); mScreenshotAnimation = new AnimatorSet(); mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim); mScreenshotAnimation.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Save the screenshot once we have a bit of time now saveScreenshotInWorkerThread(finisher); mWindowManager.removeView(mScreenshotLayout); // Clear any references to the bitmap mScreenBitmap = null; mScreenshotView.setImageBitmap(null); } }); mScreenshotLayout.post(new Runnable() { @Override public void run() { // Play the shutter sound to notify that we've taken a screenshot mCameraSound.play(MediaActionSound.SHUTTER_CLICK); mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null); mScreenshotView.buildLayer(); mScreenshotAnimation.start(); } }); } 好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现： 1234567891011121314151617/** * Creates a new worker thread and saves the screenshot to the media store. */ private void saveScreenshotInWorkerThread(Runnable finisher) { SaveImageInBackgroundData data = new SaveImageInBackgroundData(); data.context = mContext; data.image = mScreenBitmap; data.iconSize = mNotificationIconSize; data.finisher = finisher; data.previewWidth = mPreviewWidth; data.previewheight = mPreviewHeight; if (mSaveInBgTask != null) { mSaveInBgTask.cancel(false); } mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, R.id.notification_screenshot).execute(data); } 好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data, NotificationManager nManager, int nId) { ... // Show the intermediate notification mTickerAddSpace = !mTickerAddSpace; mNotificationId = nId; mNotificationManager = nManager; final long now = System.currentTimeMillis(); mNotificationBuilder = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;)) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setWhen(now) .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color)); mNotificationStyle = new Notification.BigPictureStyle() .bigPicture(picture.createAshmemBitmap()); mNotificationBuilder.setStyle(mNotificationStyle); // For &quot;public&quot; situations we want to show all the same info but // omit the actual screenshot image. mPublicNotificationBuilder = new Notification.Builder(context) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setCategory(Notification.CATEGORY_PROGRESS) .setWhen(now) .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color)); mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build()); Notification n = mNotificationBuilder.build(); n.flags |= Notification.FLAG_NO_CLEAR; mNotificationManager.notify(nId, n); // On the tablet, the large icon makes the notification appear as if it is clickable (and // on small devices, the large icon is not shown) so defer showing the large icon until // we compose the final post-save notification below. mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap()); // But we still don't set it for the expanded view, allowing the smallIcon to show here. mNotificationStyle.bigLargeIcon((Bitmap) null); } 可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。 总结： 在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键 通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。 具体的截屏代码是在native层实现的。 截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。 截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程","link":"/2020/09/11/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"17 Activity布局加载流程","text":"好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？ 要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。 其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。 废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考： android源码解析之（十四）–&gt;Activity启动流程 ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try { r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) { r.state = oldState; } if (!r.activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPause()&quot;); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to pause activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.paused = true; } } else { // If there was an error, for any reason, tell the activity // manager to stop us. try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { // Ignore } } }可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... return activity; } 从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了： 1mInstrumentation.callActivityOnCreate(activity, r.state); 这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现： 12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现： 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } 原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。 至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法： 123456789101112131415161718192021222324protected void onCreate(@Nullable Bundle savedInstanceState) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (mLastNonConfigurationInstances != null) { mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); } if (mActivityInfo.parentActivityName != null) { if (mActionBar == null) { mEnableDefaultActionBarUp = true; } else { mActionBar.setDefaultDisplayHomeAsUpEnabled(true); } } if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(this, savedInstanceState); if (mVoiceInteractor != null) { mVoiceInteractor.attachActivity(this); } mCalled = true; } 可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。 1FATAL EXCEPTION: main Process: com.example.aaron.helloworld, PID: 18001 android.util.SuperNotCalledException: Activity {com.example.aaron.helloworld/com.example.aaron.helloworld.SecondActivity} did not call through to super.onCreate() at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5552) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。 1234567891011activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } 在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。 然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现： 1234public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。 123456789101112131415161718192021222324@Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现： 1234567891011private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } ... } 这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现： 123protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法： 12if (mContentParent == null) { mContentParent = generateLayout(mDecor); 这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122protected ViewGroup generateLayout(DecorView decor) { ... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { layoutResource = R.layout.screen_swipe_dismiss; } else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) { if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_title_icons; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println(&quot;Title Icons!&quot;); } else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) { // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println(&quot;Progress!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) { // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_custom_title; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) { // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) { layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); } else { layoutResource = R.layout.screen_title; } // System.out.println(&quot;Title!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) { layoutResource = R.layout.screen_simple_overlay_action_mode; } else { // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); } mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) { throw new RuntimeException(&quot;Window couldn't find content container view&quot;); } if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) { ProgressBar progress = getCircularProgressBar(false); if (progress != null) { progress.setIndeterminate(true); } } if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { registerSwipeCallbacks(); } // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } mDecor.finishChanging(); return contentParent; } 可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系mDector –&gt; mContentRoot –&gt; mContentParent（包含）并且我们来看一下典型的布局文件： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。 然后我们具体看一下LayoutInflater.inflater方法： 123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null); } 这里调用了inflate的重载方法。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // Empty } if (type != XmlPullParser.START_TAG) { throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); } final String name = parser.getName(); if (DEBUG) { System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); } if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) { if (DEBUG) { System.out.println(&quot;Creating params from root: &quot; + root); } // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) { // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); } } if (DEBUG) { System.out.println(&quot;-----&gt; start inflating children&quot;); } // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) { System.out.println(&quot;-----&gt; done inflating children&quot;); } // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; } catch (Exception e) { InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; } finally { // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; } Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; } } 通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了： 1mLayoutInflater.inflate(layoutResID, mContentParent); 这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。 总结： Activity的展示界面的特性是通过Window对象来控制的； 每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前； 每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view； Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中； 典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。 好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"},{"title":"30 触摸事件分发流程","text":"前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。 123456789101112131415161718192021at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)at android.view.View.dispatchPointerEvent(View.java:8698)at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185) 这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。 在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明： Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device. 然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？ 12public void onUserInteraction() { }可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍： Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. 理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。 回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。 1234567private final class DecorView extends FrameLayout implements RootViewSurfaceTaker { ... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } ...} 在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。 好了，这里先暂时说一下Acitivty中的事件分发流程 ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法； Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。 若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。 下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。 然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。 123public boolean onInterceptTouchEvent(MotionEvent ev) { return false; } 一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。 123456789101112131415161718public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } } 比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。 然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。 然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？ 在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; }然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。 但这里大概分析了一下ViewGroup的事件分发流程 首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。 在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。 下面我们继续看一下View的dispatchTouchEvent方法。12345678910111213141516171819public boolean dispatchTouchEvent(MotionEvent event) { ... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; }View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。 123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l; } 可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。 所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; } 在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。 1234567891011121314public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; } 所以View组件分发触摸事件的时候： View控件会首先执行dispatchTouchEvent方法。 View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。 View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。 View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。 如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。 参考：http://blog.csdn.net/xiaanming/article/details/21696315http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程android源码解析（二十九）–&gt;应用程序返回按键执行流程","link":"/2020/09/11/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"title":"12 系统启动并解析Manifest的流程","text":"最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢? 其实android系统启动过程中解析Manifest的流程是通过PackageManagerService服务来实现的。这里我们重点分析一下PackageManagerService服务是如何解析Manifest的。 首先看一下在SystemServer进程启动过程中是如何启动PackageManagerService服务的： 123456789private void startBootstrapServices() { ... mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); ... } 在SystemServer进程启动过程中会调用SystemServer类的startBootstrapServices方法（主要用于启动ActivityManagerService服务和PackageManagerService服务），然后会在这个方法中会调用PackageManagerService.main静态方法，这个方法主要是用来初始化PackageManagerService服务并执行相关逻辑的。下面我来看一下main方法的具体逻辑： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; }可以发现main方法的实现逻辑主要是创建了一个PackageManagerService对象，并将这个对象添加到ServierManager中为其他组件提供服务。好吧，看来PackageManagerService的初始化操作主要是在PackageManagerService的构造方法中了，下面我们来看一下其构造方法的实现逻辑： 1234567File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, &quot;data&quot;); mAppInstallDir = new File(dataDir, &quot;app&quot;); mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;); mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath(); mUserAppDataDir = new File(dataDir, &quot;user&quot;); mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); PackageManagerService的构造方法代码量比较大，这里就不贴出所有的代码了，我们主要和解析Manifest相关的主要代码，在构造方法中有这样几段代码。可以发现在构造方法中，解析了系统中几个apk的安装目录，这几个目录就是系统中安装apk的目录，android系统会默认解析这几个目录下apk文件，也就是说如果我们android手机在其他的目录下存在apk文件系统是不会默认解析的，反过来说，如果我们把我们的apk文件移动到这几个目录下，那么重新启动操作系统，该apk文件就会被系统解析并执行相关的逻辑操作，具体做什么操作呢？我们看下面的实现。 123456789101112131415161718192021222324252627282930313233343536/ overlay packages if they reside in VENDOR_OVERLAY_DIR. File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0); // Find base frameworks (resource packages without code). scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try { vendorAppDir = vendorAppDir.getCanonicalFile(); } catch (IOException e) { // failed to look up canonical path, continue with original one } scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 在我们刚刚的PackageManagerService.mani方法中，解析完刚刚的几个系统目录之后系统会调用scanDirLI方法，那么这个方法主要是做什么用的呢？看它的名字应该是遍历这个系统目录。好吧，这个方法主要就是用于解析上面几个目录下的apk文件的。不信？我们看一下scanDirLI方法的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) { final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) { Log.d(TAG, &quot;No files in app dir &quot; + dir); return; } if (DEBUG_PACKAGE_SCANNING) { Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags + &quot; flags=0x&quot; + Integer.toHexString(parseFlags)); } for (File file : files) { final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) { // Ignore entries which are not packages continue; } try { scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); } catch (PackageManagerException e) { Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage()); // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) { logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file); if (file.isDirectory()) { mInstaller.rmPackageDir(file.getAbsolutePath()); } else { file.delete(); } } } } } 可以放下其首先会遍历该目录下的所有文件，并判断是否是apk文件，如果是apk文件则调用scanPackageLI方法，scanPackageLI方法的名字很明显，就是用于解析这个apk文件的。 继续看一下scanPakcageLI方法的实现： 123456789101112131415161718192021private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile); parseFlags |= mDefParseFlags; PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) { parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY; } final PackageParser.Package pkg; try { pkg = pp.parsePackage(scanFile, parseFlags); } catch (PackageParserException e) { throw PackageManagerException.from(e); } ...} 好吧，这个方法也比较复杂，这里只是列出重点相关的代码，我们可以发现在这个方法中创建了一个PackagerParser对象，并调用了parsePackage方法，这个方法其实就是解析Manifest的主要方法，我们可以看一下其具体的实现： 1234567public Package parsePackage(File packageFile, int flags) throws PackageParserException { if (packageFile.isDirectory()) { return parseClusterPackage(packageFile, flags); } else { return parseMonolithicPackage(packageFile, flags); } } 可以发现，若我们解析的File对象是一个文件夹则执行调用parseClusterPackage方法，否则调用执行parseMonolithicPackage方法，很明显的因为我们这里解析的是apk文件（在上一方法中我们循环遍历得到了apk文件，这里的File对象就代表了一个个的apk文件信息），所以这里会执行parseMonolithicPackage方法，然后我们来看一下parseMonolithicPackage方法： 123456789101112131415161718public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException { if (mOnlyCoreApps) { final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (!lite.coreApp) { throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, &quot;Not a coreApp: &quot; + apkFile); } } final AssetManager assets = new AssetManager(); try { final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.codePath = apkFile.getAbsolutePath(); return pkg; } finally { IoUtils.closeQuietly(assets); } } 可以看出，这里又调用了parseBaseApk方法： 12345private Package parseBaseApk(File apkFile, AssetManager assets, int flags) ... final Package pkg = parseBaseApk(res, parser, flags, outError); ... } 可以看出，这个parseBaseApk方法调用了其重载的parseBaseApk方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;application&quot;)) { if (foundApp) { if (RIGID_PARSER) { outError[0] = &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;); XmlUtils.skipCurrentTag(parser); continue; } } foundApp = true; if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) { return null; } } else if (tagName.equals(&quot;overlay&quot;)) { pkg.mTrustedOverlay = trustedOverlay; sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestResourceOverlay); pkg.mOverlayTarget = sa.getString( com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage); pkg.mOverlayPriority = sa.getInt( com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority, -1); sa.recycle(); if (pkg.mOverlayTarget == null) { outError[0] = &quot;&lt;overlay&gt; does not specify a target package&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) { outError[0] = &quot;&lt;overlay&gt; priority must be between 0 and 9999&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;key-sets&quot;)) { if (!parseKeySets(pkg, res, parser, attrs, outError)) { return null; } } else if (tagName.equals(&quot;permission-group&quot;)) { if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission&quot;)) { if (parsePermission(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission-tree&quot;)) { if (parsePermissionTree(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;uses-permission&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-permission-sdk-m&quot;) || tagName.equals(&quot;uses-permission-sdk-23&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-configuration&quot;)) { ConfigurationInfo cPref = new ConfigurationInfo(); sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesConfiguration); cPref.reqTouchScreen = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen, Configuration.TOUCHSCREEN_UNDEFINED); cPref.reqKeyboardType = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType, Configuration.KEYBOARD_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD; } cPref.reqNavigation = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation, Configuration.NAVIGATION_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV; } sa.recycle(); pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-feature&quot;)) { FeatureInfo fi = parseUsesFeature(res, attrs); pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi); if (fi.name == null) { ConfigurationInfo cPref = new ConfigurationInfo(); cPref.reqGlEsVersion = fi.reqGlEsVersion; pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;feature-group&quot;)) { FeatureGroupInfo group = new FeatureGroupInfo(); ArrayList&lt;FeatureInfo&gt; features = null; final int innerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } final String innerTagName = parser.getName(); if (innerTagName.equals(&quot;uses-feature&quot;)) { FeatureInfo featureInfo = parseUsesFeature(res, attrs); // FeatureGroups are stricter and mandate that // any &lt;uses-feature&gt; declared are mandatory. featureInfo.flags |= FeatureInfo.FLAG_REQUIRED; features = ArrayUtils.add(features, featureInfo); } else { Slog.w(TAG, &quot;Unknown element under &lt;feature-group&gt;: &quot; + innerTagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); } XmlUtils.skipCurrentTag(parser); } if (features != null) { group.features = new FeatureInfo[features.size()]; group.features = features.toArray(group.features); } pkg.featureGroups = ArrayUtils.add(pkg.featureGroups, group); } else if (tagName.equals(&quot;uses-sdk&quot;)) { if (SDK_VERSION &gt; 0) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesSdk); int minVers = 0; String minCode = null; int targetVers = 0; String targetCode = null; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = minVers = val.data; } } val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = val.data; } } sa.recycle(); if (minCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (minCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } } else if (minVers &gt; SDK_VERSION) { outError[0] = &quot;Requires newer sdk version #&quot; + minVers + &quot; (current version is #&quot; + SDK_VERSION + &quot;)&quot;; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } if (targetCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (targetCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } // If the code matches, it definitely targets this SDK. pkg.applicationInfo.targetSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; } else { pkg.applicationInfo.targetSdkVersion = targetVers; } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;supports-screens&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestSupportsScreens); pkg.applicationInfo.requiresSmallestWidthDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp, 0); pkg.applicationInfo.compatibleWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp, 0); pkg.applicationInfo.largestWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp, 0); // This is a trick to get a boolean and still able to detect // if a value was actually set. supportsSmallScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens, supportsSmallScreens); supportsNormalScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens, supportsNormalScreens); supportsLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens, supportsLargeScreens); supportsXLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens, supportsXLargeScreens); resizeable = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable, resizeable); anyDensity = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity, anyDensity); sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;protected-broadcast&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestProtectedBroadcast); // Note: don't allow this value to be a reference to a resource // that may change. String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name); sa.recycle(); if (name != null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) != 0) { if (pkg.protectedBroadcasts == null) { pkg.protectedBroadcasts = new ArrayList&lt;String&gt;(); } if (!pkg.protectedBroadcasts.contains(name)) { pkg.protectedBroadcasts.add(name.intern()); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;instrumentation&quot;)) { if (parseInstrumentation(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;original-package&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) { if (pkg.mOriginalPackages == null) { pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; } pkg.mOriginalPackages.add(orig); } sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;adopt-permissions&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) { if (pkg.mAdoptPermissions == null) { pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); } pkg.mAdoptPermissions.add(name); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-gl-texture&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;compatible-screens&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;supports-input&quot;)) { XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;eat-comment&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (RIGID_PARSER) { outError[0] = &quot;Bad element under &lt;manifest&gt;: &quot; + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;Unknown element under &lt;manifest&gt;: &quot; + parser.getName() + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } } 在这个parseBaseApk方法中有一个while循环，该循环主要就是用于解析AndroidManifest.xml文件中的节点信息。在开始解析application节点的时候，同时调用了parseBaseApplication方法，该方法解析了application节点下的activity，service，broadcast，contentprovier等组件的定义信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;activity&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (tagName.equals(&quot;receiver&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.receivers.add(a); } else if (tagName.equals(&quot;service&quot;)) { Service s = parseService(owner, res, parser, attrs, flags, outError); if (s == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.services.add(s); } else if (tagName.equals(&quot;provider&quot;)) { Provider p = parseProvider(owner, res, parser, attrs, flags, outError); if (p == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.providers.add(p); } else if (tagName.equals(&quot;activity-alias&quot;)) { Activity a = parseActivityAlias(owner, res, parser, attrs, flags, outError); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (parser.getName().equals(&quot;meta-data&quot;)) { // note: application meta-data is stored off to the side, so it can // remain null in the primary copy (we like to avoid extra copies because // it can be large) if ((owner.mAppMetaData = parseMetaData(res, parser, attrs, owner.mAppMetaData, outError)) == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } else if (tagName.equals(&quot;library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestLibrary_name); sa.recycle(); if (lname != null) { lname = lname.intern(); if (!ArrayUtils.contains(owner.libraryNames, lname)) { owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); if (lname != null) { lname = lname.intern(); if (req) { owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); } else { owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-package&quot;)) { // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); } else { if (!RIGID_PARSER) { Slog.w(TAG, &quot;Unknown element under &lt;application&gt;: &quot; + tagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } else { outError[0] = &quot;Bad element under &lt;application&gt;: &quot; + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } } 这样，经过这里循环遍历，整个androidManifest的节点信息就被解析并保存在了Package对象中。可以看到我们平时在Manifest中定义的各种节点，其实都是在这里有所体现。当androidManifest.xml文件被解析完成之后会调用我们刚刚介绍的scanPackageLI的重载方法，将解析完成的Package对象信息保存的Setting对象中，这个对象用于保存app的安装信息，具体实现是在方法： 12private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException 当解析完成manifest文件之后会调用其重载方法： 123// Note that we invoke the following method only if we are about to unpack an application PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); 这样，解析的manifest文件信息就会被保存到Settings中，并持久化，然后执行安装apk的操作，我们可以看一下该重载方法的具体实现： 1234567891011121314private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { boolean success = false; try { final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user); success = true; return res; } finally { if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) { removeDataDirsLI(pkg.volumeUuid, pkg.packageName); } } } 可以发现其内部调用了scanPackageDirtyLI方法，这个方法就是实际实现持久化manifest信息并安装APK操作的： 12345678private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { ... // And now re-install the app. ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo); ...} 可以发现其内部调用了createDataDirLI，该方法主要实现安装apk的操作。 1234567891011121314151617private int createDataDirsLI(String volumeUuid, String packageName, int uid, String seinfo) { int[] users = sUserManager.getUserIds(); int res = mInstaller.install(volumeUuid, packageName, uid, uid, seinfo); if (res &lt; 0) { return res; } for (int user : users) { if (user != 0) { res = mInstaller.createUserData(volumeUuid, packageName, UserHandle.getUid(user, uid), user, seinfo); if (res &lt; 0) { return res; } } } return res; } 查看该方法的实现：1234567891011121314public int install(String uuid, String name, int uid, int gid, String seinfo) { StringBuilder builder = new StringBuilder(&quot;install&quot;); builder.append(' '); builder.append(escapeNull(uuid)); builder.append(' '); builder.append(name); builder.append(' '); builder.append(uid); builder.append(' '); builder.append(gid); builder.append(' '); builder.append(seinfo != null ? seinfo : &quot;!&quot;); return mInstaller.execute(builder.toString()); }怎么样？很熟悉吧，这里的Installer其实调用的就是我们平时运行android项目很熟悉的install命令，原来android系统安装apk文件底层都是调用的adb命令。 总结： android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作； 解析Manifest流程：Zygote进程 –&gt; SystemServer进程 –&gt; PackgeManagerService服务 –&gt; scanDirLI方法 –&gt; scanPackageLI方法 –&gt; PackageParser.parserPackage方法； 解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程","link":"/2020/09/11/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/"},{"title":"28 电源开关机按键事件流程","text":"前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。 下面首先看一下dispatchUnhandledKey方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 通过前面两篇文章的分析（ android源码解析（二十六）–&gt;截屏事件流程&nbsp;&nbsp;android源码解析（二十七）–&gt;HOME事件流程）我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。 12345678910111213141516public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { ... case KeyEvent.KEYCODE_POWER: { result &amp;= ~ACTION_PASS_TO_USER; isWakeKey = false; // wake-up will be handled separately if (down) { interceptPowerKeyDown(event, interactive); } else { interceptPowerKeyUp(event, interactive, canceled); } break; } ... return result; } 这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void interceptPowerKeyDown(KeyEvent event, boolean interactive) { ... // Latch power key state to detect screenshot chord. if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordPowerKeyTriggered = true; mScreenshotChordPowerKeyTime = event.getDownTime(); interceptScreenshotChord(); } // Stop ringing or end call if configured to do so when power is pressed. TelecomManager telecomManager = getTelecommService(); boolean hungUp = false; if (telecomManager != null) { if (telecomManager.isRinging()) { // Pressing Power while there's a ringing incoming // call should silence the ringer. telecomManager.silenceRinger(); } else if ((mIncallPowerBehavior &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) { // Otherwise, if &quot;Power button ends call&quot; is enabled, // the Power button will hang up any current active call. hungUp = telecomManager.endCall(); } } // If the power key has still not yet been handled, then detect short // press, long press, or multi press and decide what to do. mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered; if (!mPowerKeyHandled) { if (interactive) { // When interactive, we're already awake. // Wait for a long press or for the button to be released to decide what to do. if (hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } } else { wakeUpFromPowerKey(event.getDownTime()); if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); mBeganFromNonInteractive = true; } else { final int maxCount = getMaxMultiPressPowerCount(); if (maxCount &lt;= 1) { mPowerKeyHandled = true; } else { mBeganFromNonInteractive = true; } } } } } 这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。 123case MSG_POWER_LONG_PRESS: powerLongPress(); break; 我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。 123456789101112131415161718192021private void powerLongPress() { final int behavior = getResolvedLongPressOnPowerBehavior(); switch (behavior) { case LONG_PRESS_POWER_NOTHING: break; case LONG_PRESS_POWER_GLOBAL_ACTIONS: mPowerKeyHandled = true; if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) { performAuditoryFeedbackForAccessibilityIfNeed(); } showGlobalActionsInternal(); break; case LONG_PRESS_POWER_SHUT_OFF: case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM: mPowerKeyHandled = true; performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false); sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF); break; } } 可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面： 然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。 12345678910111213void showGlobalActionsInternal() { sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); if (mGlobalActions == null) { mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs); } final boolean keyguardShowing = isKeyguardShowingAndNotOccluded(); mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned()); if (keyguardShowing) { // since it took two seconds of long press to bring this up, // poke the wake lock so they have some time to see the dialog. mPowerManager.userActivity(SystemClock.uptimeMillis(), false); } } 可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（android源码解析（二十七）–&gt;HOME事件流程）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法： 12345678910111213141516171819202122232425262728293031public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { mContext = context; mWindowManagerFuncs = windowManagerFuncs; mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); mDreamManager = IDreamManager.Stub.asInterface( ServiceManager.getService(DreamService.DREAM_SERVICE)); // receive broadcasts IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED); context.registerReceiver(mBroadcastReceiver, filter); ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE); // get notified of phone state changes TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE); mContext.getContentResolver().registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE); mHasVibrator = vibrator != null &amp;&amp; vibrator.hasVibrator(); mShowSilentToggle = SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean( com.android.internal.R.bool.config_useFixedVolume); } 可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。 123456789101112public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) { mKeyguardShowing = keyguardShowing; mDeviceProvisioned = isDeviceProvisioned; if (mDialog != null) { mDialog.dismiss(); mDialog = null; // Show delayed, so that the dismiss of the previous dialog completes mHandler.sendEmptyMessage(MESSAGE_SHOW); } else { handleShow(); } } 可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。 1234567891011121314151617private void handleShow() { awakenIfNecessary(); mDialog = createDialog(); prepareDialog(); // If we only have 1 item and it's a simple press action, just do this action. if (mAdapter.getCount() == 1 &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) { ((SinglePressAction) mAdapter.getItem(0)).onPress(); } else { WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes(); attrs.setTitle(&quot;GlobalActions&quot;); mDialog.getWindow().setAttributes(attrs); mDialog.show(); mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND); } 在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private GlobalActionsDialog createDialog() { ... mAirplaneModeOn = new ToggleAction( R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) { void onToggle(boolean on) { if (mHasTelephony &amp;&amp; Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) { mIsWaitingForEcmExit = true; // Launch ECM exit dialog Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null); ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(ecmDialogIntent); } else { changeAirplaneModeSystemSetting(on); } } @Override protected void changeStateFromPress(boolean buttonOn) { if (!mHasTelephony) return; // In ECM mode airplane state cannot be changed if (!(Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) { mState = buttonOn ? State.TurningOn : State.TurningOff; mAirplaneState = mState; } } public boolean showDuringKeyguard() { return true; } public boolean showBeforeProvisioning() { return false; } }; onAirplaneModeChanged(); mItems = new ArrayList&lt;Action&gt;(); String[] defaultActions = mContext.getResources().getStringArray( com.android.internal.R.array.config_globalActionsList); ArraySet&lt;String&gt; addedKeys = new ArraySet&lt;String&gt;(); for (int i = 0; i &lt; defaultActions.length; i++) { String actionKey = defaultActions[i]; if (addedKeys.contains(actionKey)) { // If we already have added this, don't add it again. continue; } if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) { mItems.add(new PowerAction()); } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) { mItems.add(mAirplaneModeOn); } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) { if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 &amp;&amp; isCurrentUserOwner()) { mItems.add(getBugReportAction()); } } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) { if (mShowSilentToggle) { mItems.add(mSilentModeAction); } } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) { if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) { addUsersToMenu(mItems); } } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) { mItems.add(getSettingsAction()); } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) { mItems.add(getLockdownAction()); } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) { mItems.add(getVoiceAssistAction()); } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) { mItems.add(getAssistAction()); } else { Log.e(TAG, &quot;Invalid global action key &quot; + actionKey); } // Add here so we don't add more than one. addedKeys.add(actionKey); } mAdapter = new MyAdapter(); AlertParams params = new AlertParams(mContext); params.mAdapter = mAdapter; params.mOnClickListener = this; params.mForceInverseBackground = true; GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params); dialog.setCanceledOnTouchOutside(false); // Handled by the custom class. dialog.getListView().setItemsCanFocus(true); dialog.getListView().setLongClickable(true); dialog.getListView().setOnItemLongClickListener( new AdapterView.OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { final Action action = mAdapter.getItem(position); if (action instanceof LongPressAction) { return ((LongPressAction) action).onLongPress(); } return false; } }); dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); dialog.setOnDismissListener(this); return dialog; } 方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面： 好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了： 1mItems.add(new PowerAction()); 这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。 1234567891011121314151617181920212223242526272829303132private final class PowerAction extends SinglePressAction implements LongPressAction { private PowerAction() { super(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off); } @Override public boolean onLongPress() { UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE); if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) { mWindowManagerFuncs.rebootSafeMode(true); return true; } return false; } @Override public boolean showDuringKeyguard() { return true; } @Override public boolean showBeforeProvisioning() { return true; } @Override public void onPress() { // shutdown by making sure radio and power are handled accordingly. mWindowManagerFuncs.shutdown(false /* confirm */); } } 可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。 12345public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { ... mWindowManagerFuncs = windowManagerFuncs; ...} 好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。 经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。 12345678910private void initPolicy() { UiThread.getHandler().runWithScissors(new Runnable() { @Override public void run() { WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper()); mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this); } }, 0); } 这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。 然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false / confirm /);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。 1234@Override public void shutdown(boolean confirm) { ShutdownThread.shutdown(mContext, confirm); } 好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。 12345public static void shutdown(final Context context, boolean confirm) { mReboot = false; mRebootSafeMode = false; shutdownInner(context, confirm); } 可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void shutdownInner(final Context context, boolean confirm) { // ensure that only one thread is trying to power down. // any additional calls are just returned synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;); return; } } final int longPressBehavior = context.getResources().getInteger( com.android.internal.R.integer.config_longPressOnPowerBehavior); final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm); Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior); if (confirm) { final CloseDialogReceiver closer = new CloseDialogReceiver(context); if (sConfirmDialog != null) { sConfirmDialog.dismiss(); } sConfirmDialog = new AlertDialog.Builder(context) .setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off) .setMessage(resourceId) .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { beginShutdownSequence(context); } }) .setNegativeButton(com.android.internal.R.string.no, null) .create(); closer.dialog = sConfirmDialog; sConfirmDialog.setOnDismissListener(closer); sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); sConfirmDialog.show(); } else { beginShutdownSequence(context); } } 可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static void beginShutdownSequence(Context context) { synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;); return; } sIsStarted = true; } ... if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) { mRebootUpdate = new File(UNCRYPT_PACKAGE_FILE).exists(); if (mRebootUpdate) { pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_update_prepare)); pd.setMax(100); pd.setProgressNumberFormat(null); pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); pd.setProgress(0); pd.setIndeterminate(false); } else { // Factory reset path. Set the dialog message accordingly. pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_reset_message)); pd.setIndeterminate(true); } } else { pd.setTitle(context.getText(com.android.internal.R.string.power_off)); pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress)); pd.setIndeterminate(true); } pd.setCancelable(false); pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); pd.show(); sInstance.mProgressDialog = pd; sInstance.mContext = context; sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE); // make sure we never fall asleep again sInstance.mCpuWakeLock = null; try { sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;); sInstance.mCpuWakeLock.setReferenceCounted(false); sInstance.mCpuWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mCpuWakeLock = null; } // also make sure the screen stays on for better user experience sInstance.mScreenWakeLock = null; if (sInstance.mPowerManager.isScreenOn()) { try { sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;); sInstance.mScreenWakeLock.setReferenceCounted(false); sInstance.mScreenWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mScreenWakeLock = null; } } // start the thread that initiates shutdown sInstance.mHandler = new Handler() { }; sInstance.start(); } 在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。 总结： 电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中； 在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等； 当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程","link":"/2020/09/11/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"13 apk安装流程","text":"上一篇文章中给大家分析了一下android系统启动之后调用PackageManagerService服务并解析系统特定目录，解析apk文件并安装的过程，这个安装过期实际上是没有图形界面的，底层调用的是我们平时比较熟悉的adb命令，那么我们平时安装apk文件的时候大部分是都过图形界面安装的，那么这种方式安装apk具体的流程是怎样的呢？ 下面我们就来具体看一下apk的具体安装过程，相信大家都知道如果我们想在代码里执行apk的安装，那么一般都是这样： 1234Intent intent = new Intent(Intent.ACTION_VIEW);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setDataAndType(Uri.parse(&quot;file://&quot; + path),&quot;application/vnd.android.package-archive&quot;);context.startActivity(intent); 这样，我们就会打开安装apk文件的程序并执行安装逻辑了，那么这段代码具体是打开那个activity呢？好吧，从这个问题开始，我们来解析apk的安装流程… 这里跟大姐简单介绍一下android的源码，平时我们使用的android.jar里面的java源码只是android系统源码的一部分，还有好多源码并没有打入到android.jar中，这里为大家推荐一个android源码的地址：https://github.com/android里面根据android系统的不同模块包含了许多android模块的源码。 这里我们找到platform_packages_apps_packageinstaller库，这里面就是android系统安装程序的源码了。 这里我们找到其androidManifest.xml，然后我们来看一下其具体的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.packageinstaller&quot; coreApp=&quot;true&quot;&gt; &lt;original-package android:name=&quot;com.android.packageinstaller&quot; /&gt; ... &lt;application android:label=&quot;@string/app_name&quot; android:allowBackup=&quot;false&quot; android:theme=&quot;@style/Theme.DialogWhenLarge&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.InstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.UninstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/Theme.AlertDialogActivity&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.DELETE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.UNINSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.UninstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.GrantPermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/GrantPermissions&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.ManagePermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:label=&quot;@string/app_permissions&quot; android:theme=&quot;@style/Settings&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.OverlayWarningDialog&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@android:style/Theme.DeviceDefault.Light.Dialog.NoActionBar&quot; /&gt; &lt;provider android:name=&quot;.wear.WearPackageIconProvider&quot; android:authorities=&quot;com.google.android.packageinstaller.wear.provider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.wear.WarningConfirmationActivity&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot; android:theme=&quot;@style/Settings&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt;好吧，这里我们大概看一下Activity的定义，这里我们重点看一下PackageInstallerActivity的定义： 123456789101112131415161718192021&lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 恩？这里不就是我们刚刚定义的启动安装Apk activity的intent filter？好吧，所以说一开始我们调用的startActivity其实启动的就是PackageInstallerActivity，那么下面我们就看一下PackageInstellerActivity的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 这里我们主要先看一下PackageInstallerActivity的onCreate方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 可以发现，在onCreate方法中，首先执行一些初始化操作，获取PackageManager和Installer、UserManager等对象，然后会根据当前Intent的信息最一些逻辑判断并弹出消息弹窗，我们可以看一下具体的消息弹窗类型： 12345678private static final int DLG_BASE = 0; private static final int DLG_UNKNOWN_SOURCES = DLG_BASE + 1; private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2; private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3; private static final int DLG_INSTALL_ERROR = DLG_BASE + 4; private static final int DLG_ALLOW_SOURCE = DLG_BASE + 5; private static final int DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES = DLG_BASE + 6; private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7; 可以发现当分析Intent对象的时候，如果可以得到这样几种结果：不知道apk的来源，package信息错误，存储空间不够，安装时报，来源正确，允许未知来源的apk文件，在wear上不支持等，这样根据不同的消息类型会弹出不同的消息弹窗： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Override public Dialog onCreateDialog(int id, Bundle bundle) { switch (id) { case DLG_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_dlg_text) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Finishing off activity so that user can navigate to settings manually&quot;); finish(); }}) .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Launching settings&quot;); launchSecuritySettings(); } }) .setOnCancelListener(this) .create(); case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_admin_dlg_text) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_PACKAGE_ERROR : return new AlertDialog.Builder(this) .setTitle(R.string.Parse_error_dlg_title) .setMessage(R.string.Parse_error_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_OUT_OF_SPACE: // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText = getString(R.string.out_of_space_dlg_text, appTitle.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.out_of_space_dlg_title) .setMessage(dlgText) .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { //launch manage applications Intent intent = new Intent(&quot;android.intent.action.MANAGE_PACKAGE_STORAGE&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); } }) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Canceling installation&quot;); finish(); } }) .setOnCancelListener(this) .create(); case DLG_INSTALL_ERROR : // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle1 = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText1 = getString(R.string.install_failed_msg, appTitle1.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.install_failed) .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setMessage(dlgText1) .setOnCancelListener(this) .create(); case DLG_ALLOW_SOURCE: CharSequence appTitle2 = mPm.getApplicationLabel(mSourceInfo); String dlgText2 = getString(R.string.allow_source_dlg_text, appTitle2.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.allow_source_dlg_title) .setMessage(dlgText2) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_CANCELED); finish(); }}) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { SharedPreferences prefs = getSharedPreferences(PREFS_ALLOWED_SOURCES, Context.MODE_PRIVATE); prefs.edit().putBoolean(mSourceInfo.packageName, true).apply(); startInstallConfirm(); } }) .setOnCancelListener(this) .create(); case DLG_NOT_SUPPORTED_ON_WEAR: return new AlertDialog.Builder(this) .setTitle(R.string.wear_not_allowed_dlg_title) .setMessage(R.string.wear_not_allowed_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_OK); finish(); } }) .setOnCancelListener(this) .create(); } return null; } 消息弹窗的主要作用，用于提示用户当前安装apk文件的特性。都知道android系统在android apk文件之前会解析器manifest文件，这个操作也是早onCreate方法中执行的： 1PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); 我们具体看一下getPackageInfo方法的实现： 12345678910public static PackageParser.Package getPackageInfo(File sourceFile) { final PackageParser parser = new PackageParser(); try { PackageParser.Package pkg = parser.parseMonolithicPackage(sourceFile, 0); parser.collectManifestDigest(pkg); return pkg; } catch (PackageParserException e) { return null; } } 好吧，到了这里是不是代码变得很熟悉了？parseMonolithicPackage就是我们上一节分析的android系统解析manifest文件的过程，具体的可参考：http://blog.csdn.net/qq_23547831/article/details/51203482 而collectManifestDigest方法，我们这里简单的介绍一下，其主要是要争apk的签名是否正确。好吧通过这两部我们就把apk文件的manifest和签名信息都解析完成并保存在了Package中。 接着往下走，在所有的解析完成之后我们会在onCreate方法中执行initiateInstall();方法，刚方法的主要作用是初始化安装。 123456789101112131415161718192021222324252627282930313233343536private void initiateInstall() { String pkgName = mPkgInfo.packageName; // Check if there is already a package on the device with this name // but it has been renamed to something else. String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // Check if package is already installed. display confirmation dialog if replacing pkg try { // This is a little convoluted because we want to get all uninstalled // apps, but this may include apps with just data, and if it is just // data we still want to count it as &quot;installed&quot;. mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.GET_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } mInstallFlowAnalytics.setReplace(mAppInfo != null); mInstallFlowAnalytics.setSystemApp( (mAppInfo != null) &amp;&amp; ((mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0)); // If we have a session id, we're invoked to verify the permissions for the given // package. Otherwise, we start the install process. if (mSessionId != -1) { startInstallConfirm(); } else { startInstall(); } } 好吧，这里面有调用了startInstallConfirm方法，然后我们看一下startInstallConfirm方法的实现: 12345private void startInstallConfirm() { ... //初始化安装确认界面 ...} 好吧，这个方法的实现比较简单，主要的实现逻辑就是现实该activity的用户界面，平时我们安装某一个应用的时候会弹出一个安装确认页面，还有一个确认和取消按钮，有印象么？其实就是在这里执行的界面初始化操作。 好吧，一般情况下在apk安装确认页面，我们会点击确认按钮执行安装逻辑吧？那么这里我们找一下确认按钮的点击事件： 1234567891011121314151617181920212223242526272829public void onClick(View v) { if (v == mOk) { if (mOkCanInstall || mScrollView == null) { mInstallFlowAnalytics.setInstallButtonClicked(); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); // We're only confirming permissions, so we don't really know how the // story ends; assume success. mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult( PackageManager.INSTALL_SUCCEEDED); finish(); } else { startInstall(); } } else { mScrollView.pageScroll(View.FOCUS_DOWN); } } else if (v == mCancel) { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_CANCELLED_BY_USER); finish(); } } 很明显了，这里当我们点击确认按钮的时候会执行startInstall方法，也就是开始执行安装逻辑： 123456789101112131415161718192021222324252627282930313233private void startInstall() { // Start subactivity to actually install the application Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallAppProgress.class); newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest); newIntent.putExtra( InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics); String installerPackageName = getIntent().getStringExtra( Intent.EXTRA_INSTALLER_PACKAGE_NAME); if (mOriginatingURI != null) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI); } if (mReferrerURI != null) { newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI); } if (mOriginatingUid != VerificationParams.NO_UID) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid); } if (installerPackageName != null) { newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); } if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); } if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish(); } 可以发现，点击确认按钮之后我们调用启用了一个新的Activity–&gt;InstallAppProgress，这个Activity主要用于执行apk的安装逻辑了。 123456789101112131415161718192021222324252627@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); Intent intent = getIntent(); mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mInstallFlowAnalytics = intent.getParcelableExtra(EXTRA_INSTALL_FLOW_ANALYTICS); mInstallFlowAnalytics.setContext(this); mPackageURI = intent.getData(); final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); throw new IllegalArgumentException(&quot;unexpected scheme &quot; + scheme); } mInstallThread = new HandlerThread(&quot;InstallThread&quot;); mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver( mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null /*scheduler*/); initView(); } 可以发现InstallAppProcess这个Activity的onCreate方法中主要初始化了一些成员变量，并调用initView方法，我们在iniTView方法中可以看到： 12345678910void initView() { ... mInstallHandler.post(new Runnable() { @Override public void run() { doPackageStage(pm, params); } }); ...} 经过一些view的初始化操作之后调用了doPackageStage方法，该方法主要是通过调用PackageInstaller执行apk文件的安装，这里就不在详细的介绍了，在apk文件安装完成之后PackageInstaller会发送一个安装完成的广播，刚刚我们在onCreate方法中注册了一个广播接收器，其可以用来接收apk安装完成的广播： 123456789101112private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final int statusCode = intent.getIntExtra( PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (statusCode == PackageInstaller.STATUS_PENDING_USER_ACTION) { context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT)); } else { onPackageInstalled(statusCode); } } }; 这样apk安装完成之后，这里的广播接收器会接收到广播并执行onPackageInstalled方法，执行后续的处理逻辑，那么我们来看一下onPackageInstalled方法的具体实现逻辑： 12345void onPackageInstalled(int statusCode) { Message msg = mHandler.obtainMessage(INSTALL_COMPLETE); msg.arg1 = statusCode; mHandler.sendMessage(msg); } 好吧，这里是发送Handler异步消息，我们来看一下异步消息的处理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case INSTALL_COMPLETE: mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(msg.arg1); if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1); setResult(msg.arg1 == PackageInstaller.STATUS_SUCCESS ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); finish(); return; } // Update the status text mProgressBar.setVisibility(View.INVISIBLE); // Show the ok button int centerTextLabel; int centerExplanationLabel = -1; LevelListDrawable centerTextDrawable = (LevelListDrawable) getDrawable(R.drawable.ic_result_status); if (msg.arg1 == PackageInstaller.STATUS_SUCCESS) { mLaunchButton.setVisibility(View.VISIBLE); centerTextDrawable.setLevel(0); centerTextLabel = R.string.install_done; // Enable or disable launch button mLaunchIntent = getPackageManager().getLaunchIntentForPackage( mAppInfo.packageName); boolean enabled = false; if(mLaunchIntent != null) { List&lt;ResolveInfo&gt; list = getPackageManager(). queryIntentActivities(mLaunchIntent, 0); if (list != null &amp;&amp; list.size() &gt; 0) { enabled = true; } } if (enabled) { mLaunchButton.setOnClickListener(InstallAppProgress.this); } else { mLaunchButton.setEnabled(false); } } else if (msg.arg1 == PackageInstaller.STATUS_FAILURE_STORAGE){ showDialogInner(DLG_OUT_OF_SPACE); return; } else { // Generic error handling for all other error codes. centerTextDrawable.setLevel(1); centerExplanationLabel = getExplanationFromErrorCode(msg.arg1); centerTextLabel = R.string.install_failed; mLaunchButton.setVisibility(View.INVISIBLE); } if (centerTextDrawable != null) { centerTextDrawable.setBounds(0, 0, centerTextDrawable.getIntrinsicWidth(), centerTextDrawable.getIntrinsicHeight()); mStatusTextView.setCompoundDrawablesRelative(centerTextDrawable, null, null, null); } mStatusTextView.setText(centerTextLabel); if (centerExplanationLabel != -1) { mExplanationTextView.setText(centerExplanationLabel); mExplanationTextView.setVisibility(View.VISIBLE); } else { mExplanationTextView.setVisibility(View.GONE); } mDoneButton.setOnClickListener(InstallAppProgress.this); mOkPanel.setVisibility(View.VISIBLE); break; default: break; } } }; 可以发现，当apk安装完成之后，我们会更新UI，显示完成和打开按钮，是不是和我们平时安装apk的逻辑对应上了？这时候我们可以看一下这两个按钮的点击事件。 1234567891011public void onClick(View v) { if(v == mDoneButton) { if (mAppInfo.packageName != null) { Log.i(TAG, &quot;Finished installing &quot;+mAppInfo.packageName); } finish(); } else if(v == mLaunchButton) { startActivity(mLaunchIntent); finish(); } } 好吧，比较简单，点击完成按钮，直接finish掉这个activity，点击打开，则直接调用startActivity启动安装的应用，然后直接finish自身。 总结： 代码中执行intent.setDataAndType(Uri.parse(“file://“ + path),”application/vnd.android.package-archive”);可以调起PackageInstallerActivity； PackageInstallerActivity主要用于执行解析apk文件，解析manifest，解析签名等操作； InstallAppProcess主要用于执行安装apk逻辑，用于初始化安装界面，用于初始化用户UI。并调用PackageInstaller执行安装逻辑； InstallAppProcess内注册有广播，当安装完成之后接收广播，更新UI。显示apk安装完成界面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程","link":"/2020/09/11/apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"title":"18 Activity布局绘制流程","text":"这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。 顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。 前面有一篇文章中我们介绍过Activity的启动流程，可参考：android源码解析之（十四）–&gt;Activity启动流程在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } ... // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } ... } 可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑： 12345678void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } 首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。 这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现: 123public WindowManager getWindowManager() { return mWindowManager; } 好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程： 1mWindowManager = mWindow.getWindowManager(); 好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？ 123public WindowManager getWindowManager() { return mWindowManager; } 那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？ 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？ 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } 好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到： WindowManagerImpl –&gt; WindowManager –&gt; ViewManager; 继续往下看： 1wm.addView(mDecor, getWindow().getAttributes()); 这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } 然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } int index = findViewLocked(view, false); if (index &gt;= 0) { if (mDyingViews.contains(view)) { // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); } else { throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; } } 可以发现在WindowManagerGlobal中存在着三个数据列表： 1234private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。 最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现： 12345public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { ... requestLayout(); ... } 可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现： 12345678@Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } 可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。 继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现： 12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义： 123456final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } 在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑： 1234567891011121314151617void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } 好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private void performTraversals() { ... // 执行View组件的onMeasure方法，主要用于测量View if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let's measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } layoutRequested = true; } } } ... // 主要用于测量View组件的位置 ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) { // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) { mTranslator.translateRegionInWindowToScreen(mTransparentRegion); } if (!mTransparentRegion.equals(mPreviousTransparentRegion)) { mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try { mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); } catch (RemoteException e) { } } } if (DBG) { System.out.println(&quot;======================================&quot;); System.out.println(&quot;performTraversals -- after setFrame&quot;); host.debug(); } } ... // 主要用于View的绘制过程 ... if (!cancelDraw &amp;&amp; !newSurface) { if (!skipDraw || mReportNextDraw) { if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).startChangingAnimations(); } mPendingTransitions.clear(); } performDraw(); } } else { if (viewVisibility == View.VISIBLE) { // Try again scheduleTraversals(); } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).endChangingAnimations(); } mPendingTransitions.clear(); } } mIsInTraversal = false; } 可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件； 即：测量大小 –&gt; 测量位置 –&gt; 绘制组件 好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现： 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法： 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... } 在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到这个方法中调用了setMeasuredDimension方法： 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 好吧，方法体里面又调用了setMeasuredDimensionRaw方法： 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。 继续回到我们的performTransles方法，然后我们继续看performLayout方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during layout: running second layout pass&quot;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during second layout pass: posting in next frame&quot;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false; } 可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现： 我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现： 1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */); } 可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } } } 跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。 好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。 12345private void performDraw() { ... draw(fullRedrawNeeded); ... } 可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现： 1234567private void draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } ... } 可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法： 12345678private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { ... mView.draw(canvas); ... return true; } 可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; } /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) { paddingLeft += getLeftPaddingOffset(); } int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) { right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); } final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) { length = (bottom - top) / 2; } // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) { length = (right - left) / 2; } if (verticalEdges) { topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; } if (horizontalEdges) { leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; } saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } if (drawBottom) { canvas.saveLayer(left, bottom - length, right, bottom, null, flags); } if (drawLeft) { canvas.saveLayer(left, top, left + length, bottom, null, flags); } if (drawRight) { canvas.saveLayer(right - length, top, right, bottom, null, flags); } } else { scrollabilityCache.setFadeColor(solidColor); } // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) { matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); } if (drawBottom) { matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); } if (drawLeft) { matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); } if (drawRight) { matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); } canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); } 整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。 总结： Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。 View的绘制流程包含了测量大小，测量位置，绘制三个流程； Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程； View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的； View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法; View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法； View的绘制流程：onDraw等方法； View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑； Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"14 activity启动流程","text":"好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍： An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture. 英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。 在介绍Activity的启动流程之前，我们先介绍几个概念： Activity的生命周期 protected void onCreate(Bundle savedInstanceState);protected void onRestart();protected void onStart();protected void onResume();protected void onPause();protected void onStop();protected void onDestory();以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。关于Activity生命周期的详细介绍可以参考： Android activity的生命周期 Activity的启动模式 activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。关于Activity启动模式的详细介绍，可以参考： Android任务和返回栈完全解析 Activity的启动进程 在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。 Intent启动Activity的方式 Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。 Android Framework层的CS模式通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑： Zygote进程 --&gt; SystemServer进程 --&gt; 各种系统服务 --&gt; 应用进程 在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。 Android系统进程间通讯Binder机制Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍： 好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。 还记得前面我们讲过的Launcher启动流程么？可以参考：android源码解析之（十）–&gt;Launcher启动流程在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法： 123456789101112131415161718192021222324@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); }public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？ 这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。 继续，我们查看startActivity方法的具体实现： 一:开始请求执行启动Activity MyActivity.startActivity()Activity.startActivity()Activity.startActivityForResultInstrumentation.execStartActivtyActivityManagerNative.getDefault().startActivityAsUser() 在我们的Activity中调用startActivity方法，会执行Activity中的startActivity1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); }然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1. 注意：通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。 好吧，我们继续往下看，startActivityForResult方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑： 123if (requestCode &gt;= 0) { mStartedActivity = true;} 通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。 然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。 可以发现execStartActivity方法传递的几个参数：this，为启动Activity的对象；contextThread，为Binder对象，是主进程的context对象；token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；target，为启动的Activity；intent，启动的Intent对象；requestCode，请求码；options，参数； 这样就调用了Imstrument.execStartActivity方法了： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现： 123static public IActivityManager getDefault() { return gDefault.get(); } 好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？ 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现： 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService； 这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。 好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。 继续往下卡，我们调用的是： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法： 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) { data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { data.writeInt(0); } if (options != null) { data.writeInt(1); options.writeToParcel(data, 0); } else { data.writeInt(0); } mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; } 这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。 以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。 二：ActivityManagerService接收启动Activity的请求 ActivityManagerService.startActivity()ActvityiManagerService.startActivityAsUser()ActivityStackSupervisor.startActivityMayWait()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.startActivityUncheckedLocked()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.resumeTopActivitiesLocked()ActivityStackSupervisor.resumeTopActivityInnerLocked() 好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现； 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现： 1234567891011121314151617final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } 这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法： 1234567891011121314151617final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) { int err = ActivityManager.START_SUCCESS; ... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); ... return err; } 这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法： 12345678910111213final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) { ... ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) { // Don't set focus on an activity that's going to the back. mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;); } return ActivityManager.START_SUCCESS; } startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法： 1234567final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) { ... if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } } 这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法： 1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) { if (targetStack == null) { targetStack = mFocusedStack; } // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) { result = targetStack.resumeTopActivityLocked(target, targetOptions); } for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) { // Already started above. continue; } if (isFrontStack(stack)) { stack.resumeTopActivityLocked(null); } } } return result; } 可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后调用： 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) { mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); } result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 继续调用resumeTopActivityInnerLocked方法： 12345678910private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) { ... if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); } ... return true; } 经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。 三：执行栈顶Activity的onPause方法 ActivityStack.startPausingLocked()IApplicationThread.schudulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage();ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused(token)ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked()ActivityStack.resumeTopActivitiesLocked()ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopActivityInnerLocked()ActivityStack.startSpecificActivityLocked 好吧，方法比较多也比较乱，首先来看startPausingLocked方法： 1234567891011121314151617181920212223242526final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev); try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。 这里的ApplicationThread可以和ActivityManagerNative对于一下：通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯 然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现： 12345678public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges); } 发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 调用了其重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现： 123456789101112public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { ... case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...} 可以发现其调用了handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; } 然后调用其重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... mInstrumentation.callActivityOnPause(r.activity); ... return !r.activity.mFinished &amp;&amp; saveState ? r.state : null; } 这样回到了mInstrumentation的callActivityOnPuase方法： 123public void callActivityOnPause(Activity activity) { activity.performPause(); } 呵呵，原来最终回调到了Activity的performPause方法： 1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onPause()&quot;); } mResumed = false; } 终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。 然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现： 1234567final void activityPausedLocked(IBinder token, boolean timeout) { ... if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;)); completePauseLocked(true); ... } 然后执行了completePauseLocked方法： 12345678910111213141516171819202122private void completePauseLocked(boolean resumeNext) { ... if (resumeNext) { final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) { mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); } else { mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(null); if (top == null || (prev != null &amp;&amp; top != prev)) { // If there are no more activities available to run, // do resume anyway to start something. Also if the top // activity on the stack is not the just paused activity, // we need to go ahead and resume it to ensure we complete // an in-flight app switch. mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); } } } ... } 经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过resumeTopActivitiesLocked –&gt;ActivityStack.resumeTopActivityLocked() –&gt;resumeTopActivityInnerLocked –&gt;startSpecificActivityLocked好吧，我们看一下startSpecificActivityLocked的具体实现： 123456789101112131415161718192021222324252627282930313233void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. } mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); } 可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。 四：启动Activity所属的应用进程 关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考： android源码解析之（十一）–&gt;应用进程启动流程 这里在简单的介绍一下 ActivityManagerService.startProcessLocked()Process.start()ActivityThread.main()ActivityThread.attach()ActivityManagerNative.getDefault().attachApplication()ActivityManagerService.attachApplication() 好吧，首先看一下startProcessLocked()方法的具体实现： 12345private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */); } 然后回调了其重载的startProcessLocked方法： 123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ... boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; + app.processName); checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); ... } 可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”: 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 然后调用了startViaZygote方法： 123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(Process.class) { ... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); } } 继续查看一下zygoteSendArgsAndGetResult方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx( &quot;embedded newlines not allowed&quot;); } writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } result.usingWrapper = inputStream.readBoolean(); return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } } 可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。 为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。 好了，这时候我们看一下ActivityThread的main方法的实现逻辑。 123456789101112131415161718192021222324public static void main(String[] args) { ... Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。 12345678910private void attach(boolean system) { ... final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } ...} 刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的： 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。 12345678910111213141516171819private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... // See if the top visible activity is waiting to run in this process... if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; } } ... return true; } 该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~ 五：执行启动Acitivity ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked()IApplicationThread.scheduleLauncherActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()Instrumentation.callActivityOnCreate()Activity.onCreate()ActivityThread.handleResumeActivity()ActivityThread.performResumeActivity()Activity.performResume()Instrumentation.callActivityOnResume()Activity.onResume()ActivityManagerNative.getDefault().activityResumed(token) 首先看一下attachApplicationLocked方法的实现： 1234567891011121314151617181920212223242526272829303132boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) { continue; } ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) { if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) { try { if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; } } } } } if (!didSomething) { ensureActivitiesVisibleLocked(null, 0); } return didSomething; } 可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑： 1234567891011121314final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... return true; } 可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现： 1234567891011121314151617181920212223242526272829303132333435@Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); } 好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法： 1234567891011121314private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); } ... } 可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。 12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } ... if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } ... return activity; } 可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。 123456public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 然后执行activity的performCreate方法。。。。好吧，都转晕了。。。 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。 在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式： 123456789101112131415final void performStart() { mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStart()&quot;); } mFragments.dispatchStart(); mFragments.reportLoaderStart(); mActivityTransitionState.enterReady(this); } 好吧，还是通过Instrumentation调用callActivityOnStart方法： 123public void callActivityOnStart(Activity activity) { activity.onStart(); } 然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~ 还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) { final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } } else { // If an exception was thrown when trying to resume, then // just end this activity. try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { } } } 可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) { ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r + &quot; finished=&quot; + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) { if (clearHide) { r.hideForNow = false; r.activity.mStartedActivity = false; } try { r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) { deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; } if (r.pendingResults != null) { deliverResults(r, r.pendingResults); r.pendingResults = null; } r.activity.performResume(); EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to resume activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } } return r; } 在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现： 12345final void performResume() { ... mInstrumentation.callActivityOnResume(this); ... } 好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。 1234567891011121314public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。 终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。 有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。 好吧，具体的逻辑我们下一步再说 六：栈顶Activity执行onStop方法 Looper.myQueue().addIdleHandler(new Idler())Idler.queueIdle()ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.stopActivityLocked()IApplicationThread.scheduleStopActivity()ActivityThread.scheduleStopActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleStopActivity()ActivityThread.performStopActivityInner()ActivityThread.callCallActivityOnSaveInstanceState()Instrumentation.callActivityOnSaveInstanceState()Activity.performSaveInstanceState()Activity.onSaveInstanceState()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop() 回到我们的handleResumeActivity方法，在方法体最后有这样的一代码： 1Looper.myQueue().addIdleHandler(new Idler()); 这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法： 12345678910111213141516171819202122final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { ... // Stop any activities that are scheduled to do so but have been // waiting for the next one to start. for (int i = 0; i &lt; NS; i++) { r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) { if (r.finishing) { stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); } else { stack.stopActivityLocked(r); } } } ... return r; } 可以发现在其中又调用了ActivityStack.stopActivityLocked方法： 123456789final void stopActivityLocked(ActivityRecord r) { if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r); if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) { ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... } } 好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) { sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); } 然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。 12345private void handleStopActivity(IBinder token, boolean show, int configChanges) { ... performStopActivityInner(r, info, show, true); ... } 然后我们看一下performStopActivityInner的实现逻辑： 1234567891011121314151617181920212223242526private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } if (!keepShown) { try { // Now we are idle. r.activity.performStop(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.stopped = true; } } } 好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 好吧，又是通过Instrumentation来执行。。。 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 又间接调用了Activity的performSaveInstanceState方法： 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。 然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法： 1234567891011121314151617181920212223242526272829303132333435363738final void performStop() { mDoReportFullyDrawn = false; mFragments.doLoaderStop(mChangingConfigurations /*retain*/); if (!mStopped) { if (mWindow != null) { mWindow.closeAllPanels(); } if (mToken != null &amp;&amp; mParent == null) { WindowManagerGlobal.getInstance().setStoppedState(mToken, true); } mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStop()&quot;); } synchronized (mManagedCursors) { final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) { ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) { mc.mCursor.deactivate(); mc.mReleased = true; } } } mStopped = true; } mResumed = false; } 还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。 123public void callActivityOnStop(Activity activity) { activity.onStop(); } O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()….. 总结： Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的 startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0 Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯 ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。 ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。 ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法； ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发； ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作； ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程； ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法； 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作； ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作； ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法； ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法； ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread； ActivityThread执行真正的onStop方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程","link":"/2020/09/11/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"ADB命令大全(转)","text":"ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 Other languages: :gb: English 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: \"android.intent.action.MAIN\" Category: \"android.intent.category.LAUNCHER\" AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider} applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package{55f714c org.mazhuang.guanggoo} codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures{af09595 [53c7caa2]} installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es \"toast\" \"hello, world\" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令：1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed \"s/\\r$//\" &gt; sc.png Mac OS X 1adb shell screencap -p | gsed \"s/\\r$//\" &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network={ ssid=\"TP-LINK_9DFC\" scan_ssid=1 psk=\"123456789\" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893}network={ ssid=\"TP-LINK_F11E\" psk=\"987654321\" key_mgmt=WPA-PSK sim_num=1 priority=17293} ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server's $ADB_VENDOR_KEYS is not setTry 'adb kill-server' if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666，shawnlinboy，s-xq，lucky9322。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）","link":"/2019/10/11/README/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"壁纸路径","slug":"壁纸路径","link":"/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"name":"Mac系统","slug":"Mac系统","link":"/tags/Mac%E7%B3%BB%E7%BB%9F/"},{"name":"谷歌云","slug":"谷歌云","link":"/tags/%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"name":"so文件","slug":"so文件","link":"/tags/so%E6%96%87%E4%BB%B6/"},{"name":"ndk","slug":"ndk","link":"/tags/ndk/"},{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/%E7%BF%BB%E5%A2%99/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"霍比特人","slug":"霍比特人","link":"/tags/%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA/"},{"name":"意外之旅","slug":"意外之旅","link":"/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"},{"name":"bt","slug":"bt","link":"/tags/bt/"},{"name":"指环王","slug":"指环王","link":"/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"},{"name":"比尔博·巴金斯","slug":"比尔博·巴金斯","link":"/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"},{"name":"甘道夫","slug":"甘道夫","link":"/tags/%E7%94%98%E9%81%93%E5%A4%AB/"},{"name":"索伦","slug":"索伦","link":"/tags/%E7%B4%A2%E4%BC%A6/"},{"name":"魔苟斯","slug":"魔苟斯","link":"/tags/%E9%AD%94%E8%8B%9F%E6%96%AF/"},{"name":"戒灵","slug":"戒灵","link":"/tags/%E6%88%92%E7%81%B5/"},{"name":"炎魔","slug":"炎魔","link":"/tags/%E7%82%8E%E9%AD%94/"},{"name":"精灵","slug":"精灵","link":"/tags/%E7%B2%BE%E7%81%B5/"},{"name":"魔戒","slug":"魔戒","link":"/tags/%E9%AD%94%E6%88%92/"},{"name":"咕噜","slug":"咕噜","link":"/tags/%E5%92%95%E5%99%9C/"},{"name":"阿拉贡","slug":"阿拉贡","link":"/tags/%E9%98%BF%E6%8B%89%E8%B4%A1/"},{"name":"魔多","slug":"魔多","link":"/tags/%E9%AD%94%E5%A4%9A/"},{"name":"史茅革","slug":"史茅革","link":"/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"},{"name":"AAPT","slug":"AAPT","link":"/tags/AAPT/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"ApkBuilder","slug":"ApkBuilder","link":"/tags/ApkBuilder/"},{"name":"Dex工具","slug":"Dex工具","link":"/tags/Dex%E5%B7%A5%E5%85%B7/"},{"name":"zipalign工具","slug":"zipalign工具","link":"/tags/zipalign%E5%B7%A5%E5%85%B7/"},{"name":"keystore","slug":"keystore","link":"/tags/keystore/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python3","slug":"Python3","link":"/tags/Python3/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"小游戏开发","slug":"小游戏开发","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"categories":[{"name":"Android基础","slug":"Android基础","link":"/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"Mac应用","slug":"Mac应用","link":"/categories/Mac%E5%BA%94%E7%94%A8/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"经典电影","slug":"经典电影","link":"/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"},{"name":"精品美文","slug":"精品美文","link":"/categories/%E7%B2%BE%E5%93%81%E7%BE%8E%E6%96%87/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"学习资料","slug":"学习资料","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"}]}