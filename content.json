{"pages":[{"title":"","text":"风光 人像 动物 图片均为本人拍摄，有共同爱好的小伙伴可以约起来哦~~~ 留言 😊 😊 😊。","link":"/album/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 个人信息：90后计算机网络技术专业从事Android开发，坚信代码改变世界摄影爱好者QQ: 798774875Email: moruoyiming123@gmail.comJianShu: jianzeyicongGithub: moruoyimingYouTube: Jean RilenInstagram: jianzeyicong500px: moruoyiming 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志： –2020.09.29：增加相册、视频功能–2020.09.18：增加AdSense广告–2020.08.22：改版部分显示，优化速度–2020.06.18：icarus3.0主题适配–2019.12.16：增加不蒜子统计–2019.10.16：文章列表加上评论数显示–2019.03.13：改版评论–2017.12.16：icarus1.0主题适配–2017.08.12：搭建个人博客 本站推荐索引 技术知识点 Java教程 Python3教程 JavaScript教程 剑指Offer 免费学习资料 常用工具 图片压缩 在线转换工具 贝塞尔弧曲线 ProcessOn流程图 Youtube视频下载 免费翻墙 free-ss free-ss.site ss.pythonic.life 免费节点 软件下载 萌新网 麦氪派 福利 电影天堂 高清电影 BD电影 剧迷 高速车 持续更新~","link":"/about/index.html"},{"title":"电影","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 -&gt;点击以下条目开始播放视频,向下滑动查看更多&lt;- (adsbygoogle = window.adsbygoogle || []).push({});","link":"/media/index.html"},{"title":"categories","text":"(adsbygoogle = window.adsbygoogle || []).push({});","link":"/categories/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"}],"posts":[{"title":"CoordinatorLayout 与viewpage 使用 viewpager 内如何空出子布局高度","text":"在子布局中使用 添加NestedScrollView并添加 android:fillViewport=”true” android:fitsSystemWindows=”true” &lt;android.support.v4.widget.NestedScrollView android:id=”@+id/nest_scrollview” android:layout_width=”match_parent” android:layout_height=”match_parent” android:layout_gravity=”fill_vertical” android:fillViewport=”true” android:fitsSystemWindows=”true” app:layout_behavior=”@string/appbar_scrolling_view_behavior”&gt; &lt;your layout&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;","link":"/2021/01/22/CoordinatorLayout%20%E4%B8%8Eviewpage%20%E4%BD%BF%E7%94%A8%20viewpager%20%E5%86%85%E5%A6%82%E4%BD%95%E7%A9%BA%E5%87%BA%20%E9%AB%98%E5%BA%A6/"},{"title":"Android项目运行时丢失so文件","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 123456789101112defaultConfig { applicationId &quot;…&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' }} 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2020/09/11/Android%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%A2%E5%A4%B1so%E6%96%87%E4%BB%B6/"},{"title":"C语言编程十大面试题及答案","text":"无论学习何种编程语言不能只停留在看的层面上，最后还是得要自己去实际敲写代码才能成长，下面是编程狮整理的c语言编程得十大面试题目及其答案。 1.变量/函数的声明和定义之间有什么区别 答案：变量/函数的声明仅声明变量/函数存在于程序中的某个位置，但未为其分配内存。但是变量/函数的声明起着重要的作用。这就是变量/函数的类型。因此，在声明变量时，程序会知道该变量的数据类型。在声明函数的情况下，程序会知道该函数的参数是什么，它们的数据类型，参数的顺序以及函数的返回类型。这就是声明。关于定义，当我们定义变量/函数时，除了声明的作用外，它还为该变量/函数分配内存。因此，我们可以将定义视为声明的超集。（或声明作为定义的子集）。 2.C中有哪些不同的存储类说明符？ 答案：auto, register, static, extern 3.变量的范围是什么？变量在C中的作用域怎样？ 答案：变量的范围是程序的一部分，可以直接访问该变量。在C语言中，所有标识符都在词法（或静态）范围内。 4.没有分号，您将如何打印“ Hello World”？ #include &lt;stdio.h&gt; int main(void) { if (printf(“Hello World”)) { } } 5.什么时候应该在C程序中使用指针？ 答案： 1.获取变量的地址 2.为了在C中实现引用传递：指针允许不同的函数共享和修改其局部变量。 3.通过大型结构，以便避免完整复制结构。 4.实现“链接”数据结构，例如链接列表和二进制树。 6.什么是NULL指针？ 答案： NULL用于指示指针未指向有效位置。理想情况下，如果在声明时不知道指针的值，则应将指针初始化为NULL。另外，当由它指向的内存在程序中间被释放时，我们应该使指针为NULL。 7.什么是悬空指针？ 答案：悬空指针是没有指向有效内存位置的指针。当删除或释放对象时，如果不修改指针的值，就会出现悬空指针，因此指针仍然指向释放后的内存的存储位置。以下是示例。 // 示例1 int ptr = (int)malloc(sizeof(int)); ……………………..free(ptr); // ptr 是一个悬空指针，以下操作无效 *ptr = 10; // 示例2 int* ptr = NULL { int x = 10; ptr = &x; } //x超出范围，并且分配给x的内存现在可用 //所以ptr现在是悬空指针 8.什么是内存泄漏？为何应避免使用它 答案：程序员在堆中创建内存而忘记删除它时，就会发生内存泄漏。对于诸如守护程序和服务器之类的程序而言，内存泄漏是特别严重的问题，根据定义它们永远不会终止。 9.什么是局部静态变量？它们有什么用？ 答案：局部静态变量是一个变量，其生存期并不以声明它的函数调用结尾。它延长了整个程序的寿命。所有对该函数的调用都共享局部静态变量的相同副本。静态变量可用于计算调用函数的次数。另外，静态变量的默认值为0。例如，以下程序输出“ 0 1” #include &lt;stdio.h&gt; void fun() { // 静态变量的默认值为0 static int x; printf(“%d “, x); x = x + 1; } int main() { fun(); fun(); return 0; } // 输出: 0 1 10.什么是静态函数？它们有什么用？ 答案：在C语言中，默认情况下函数是全局的。函数名称前的“ static”关键字使其变为静态。与C中的全局函数不同，对静态函数的访问仅限于声明它们的文件。因此，当我们想限制对函数的访问时，我们将它们设为静态。使函数成为静态的另一个原因可能是在其他文件中重用了相同的函数名。","link":"/2021/02/25/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E5%8D%81%E5%A4%A7%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"},{"title":"git常用命令","text":"一、常用命令 切换到master分支：git checkout master 查看已有本地及远程分支：git branch -a（先git pull拉下全部数据） 查看远程分支：git branch -r 查看所有分支：git branch -a 查看本地分支：git branch 删除远程dev分支：git push origin –delete dev 删除本地dev分支：git branch -d dev 从远程的origin仓库的master分支下载到本地，并新建一个test分支：git fetch origin master:test 本地从当前所在分支上创建一个新分支： git checkout -b 新分支名 查看test分支与本地原有分支的不同：git diff test 将test分支和当前分支合并：git merge test 将远程git仓库里的指定分支拉取到本地（本地不存在的分支）：git checkout -b 本地分支 origin/远程分支，或者 git pull origin dev(remote):dev(local) 将本地master分支提交到远程dev分支：git push origin master:dev 二、常见报错处理 1、导致报错:error: You have not concluded your merge (MERGE_HEAD exists).的原因可能是在以前pull下来的代码自动合并失败。 解决方案一：保留本地的更改，中止合并-&gt;重新合并-&gt;重新拉取 $:git merge –abort$:git reset –merge$:git pull git pull之后然后重新解决冲突，再push，（记得需要稍微跟自己push的要有一点区别，要不然又会造成这样的情况） 解决方案二：舍弃本地代码，远端版本覆盖本地版本（慎重） $:git fetch –all$:git reset –hard origin/master$:git fetch2、Git fetch和git pull的区别 都可以从远程获取最新版本到本地 git fetch：只是从远程获取最新版本到本地，不会merge(合并) $:git fetch origin master //从远程的origin的master主分支上获取最新版本到origin/master分支上$:git log -p master..origin/master //比较本地的master分支和origin/master分支的区别$:git merge origin/master //合并 Git pull：从远程获取最新版本并merge(合并)到本地 $:git pull origin master //相当于进行了 git fetch 和 git merge两部操作3、本地删除无效的远程分支：清理远程分支，把本地不存在的远程分支删除 git remote prune origin Git 本地分支 关联 远程分支 git branch –set-upstream-to=origin/develop_userflow hegui","link":"/2021/08/05/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Gradle编译Build output乱码","text":"IDEA 打开 HELP-&gt;Edit Custom VM OPtions中加 -Dfile.encoding=utf-8 重启idea 。 Edit Custom VM Options -Dfile.encoding=UTF-8","link":"/2020/12/22/Gradle%E7%BC%96%E8%AF%91%20Build%20output%20%E4%B9%B1%E7%A0%81/"},{"title":"Gradle插件开发no repositories are defined错误解决","text":"Gralde 插件开发时需要使用AppPlugin.class ，所以在buildSrc中添加build.gradle文件并依赖gralde 插件 完整build.gradle如下：如果 123456789101112131415apply plugin: 'java-library'repositories {//如果未引入库 会提示下方错误 jcenter() google()}dependencies { //引入AppPlugin implementation 'com.android.tools.build:gradle:4.1.0'}java { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8} 如果未引入repositories会提示下方错误： Execution failed for task ‘:buildSrc:compileJava’. Could not resolve all files for configuration ‘:buildSrc:compileClasspath’.Cannot resolve external dependency com.android.tools.build:gradle:4.1.0 because no repositories are defined.Required by: project :buildSrc","link":"/2020/12/22/Gralde%20%E6%8F%92%E4%BB%B6%E6%8F%90%E7%A4%BAbecause%20no%20repositories%20are%20defined%E9%94%99%E8%AF%AF/"},{"title":"Java应该掌握的知识","text":"以Java工程师应该掌握的知识，按重要程度排出六个梯度： 第一梯度：计算机组成原理、数据结构和算法、网络通信原理、操作系统原理；第二梯度：Java基础、JVM内存模型和GC算法、JVM性能调优、JDK工具、设计模式；第三梯度：Spring系列、Mybatis、Dubbo等主流框架的运用和原理；第四梯度：MySQL(含SQL编程)、Redis、RabbitMQ/RocketMQ/Kafka、ZooKeeper等数据库或者中间件的运用和原理；第五梯度：CAP理论、BASE理论、Paxos和Raft算法等其他分布式理论；第六梯度：容器化、大数据、AI、区块链等等前沿技术理论；","link":"/2021/01/25/Java%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8A%80%E6%9C%AF/"},{"title":"MAC系统Charles破解版","text":"1，环境： mac ---10.12.6 charles---4.2最新的版本都可以 2，安装： 官方地址：https://www.charlesproxy.com 3，破解： 可以参考CSDN博客上面的破解教程，比如修改charles.jar文件或者替换掉原来的软件。 我的方法是—注册码！！！ 按照常规安装好charles软件之后，打开软件，点击工具栏中的help –&gt; register 输入如下信息： Registered Name: https://zhile.ioLicense Key: 48891cf209c6d32bf4","link":"/2021/08/05/MAC%E7%B3%BB%E7%BB%9FCharles%E7%A0%B4%E8%A7%A3%E7%89%88/"},{"title":"MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug)","text":"MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug) 第一步 退出android studio第二步 打开终端,敲入上面的代码 defaults write com.google.android.studio AppleWindowTabbingMode manual第三步 再打开android studio 原文地址https://www.reddit.com/r/androiddev/comments/jtbl4m/has_anyone_updated_to_macos_big_sur_and_is/","link":"/2021/01/26/MAC%20OS%20Big%20Sur%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%B8%8B%20Android%20Studio%20%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E5%8D%A1(bug)/"},{"title":"Mac系统壁纸路径","text":"在 Finder 中，菜单栏选取“前往”&gt;“前往文件夹”，弹出的框里输入/Library/Desktop Pictures/或/System/Library/Desktop Pictures/然后回车即可打开该文件夹。 系统壁纸默认路径存在两个地方，当时去了第一个路径上找未找到，后来通过命令行获取到路径发现System 下也有一个Desktop Pictures 文件夹。 终端命令：显示壁纸所在路径（路径显示在屏幕对应壁纸上）： defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE;killall Dock 终端命令：隐藏该路径： defaults delete com.apple.dock desktop-picture-show-debug-text;killall Dock","link":"/2020/09/11/Mac%20%E7%B3%BB%E7%BB%9F%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"title":"Mac 下移动硬盘的读写软件Mounty","text":"title: Mac下移动硬盘的读写软件Mountythumbnail: /gallery/thumbnails/sculpture.jpgcategories: Mac应用tags: 壁纸路径 Mounty Mac系统 终端运行: brew cask install mounty 官网地址:https://mounty.app/","link":"/2020/09/11/Mac%20%E4%B8%8B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E8%BD%AF%E4%BB%B6Mounty/"},{"title":"Mac下Google备份和同步问题","text":"1.下载并安装Google备份和同步 Google备份和同步（下载地址） 2.打开xx的http代理 在偏好设置中打开http代理服务器，配置默认即可 3.打开系统设置中的http代理 系统偏好设置→网络→高级→代理→网页代理(HTTP)，设置代理127.0.0.1:1087 4. 允许并登录Google账户 完全配置完成后即可食用 原文地址 https://www.fangpengjun.com/2017/09/08/%E8%A7%A3%E5%86%B3Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","link":"/2020/09/11/Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},{"title":"Mac下安装软件提示文件损坏解决办法","text":"1.打开应用程序-实用工具-终端；b2制以下代码（master注意是两个-）到终端中，回车（输入电脑密码）： 1sudo spctl --master-disable 3.打开应用程序-系统偏好设置-安全性和隐私-通用，消失的任何来源终于出现了（默认应该勾选了）；4.此时可以尽情使用第三方程序了如已经开启了任何来源，还无法安装当出现提示的时候，去系统偏好设置-安全和隐私那里允许下（会提示该软件的安装信息） 还提示损坏的，试试按住Control后，再次点击软件图标","link":"/2020/09/11/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Mac使用终端登录谷歌云","text":"1.网页SSH进入谷歌云，切换到root角色 sudo -i 2.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 3.给root用户设置密码 passwd root 4.重启SSH服务使修改生效 /etc/init.d/ssh restart 5.启动mac终端 ssh root@ip 输入密码即可进入SSH。","link":"/2020/09/11/Mac%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"title":"Mac安装oh-my-zsh出现TimeOut","text":"mac终端 安装 oh-my-zshsh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 提示错误 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 用这个连接wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh","link":"/2020/09/11/Mac%E5%AE%89%E8%A3%85oh-my-zsh%20%E5%87%BA%E7%8E%B0TimeOut/"},{"title":"Mac文件安装应用，打开提示文件已损坏，如何解决","text":"终端运行该命令:sudo xattr -d com.apple.quarantine /Applications/ColorFinale.app","link":"/2020/09/11/Mac%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%EF%BC%8C%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"},{"title":"Android 项目中so文件丢失","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 1234567891011121314151617defaultConfig { applicationId &quot;...&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2019/02/26/SO%E6%96%87%E4%BB%B6%E7%BC%BA%E5%A4%B1/"},{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2019/02/20/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"指环王1：魔戒再现.蓝光加长版","text":"[[2000-2010][欧美][奇幻][BT下载][指环王1：魔戒再现.蓝光加长版][BD-MKV/4.03GB][国语双语中英字幕][1080P][奇幻冒险史诗巨制] ◎译 名 指环王1：魔戒再现/魔戒首部曲：魔戒现身/指环王I：护戒使者/魔戒1：护戒联盟 ◎片 名 The Lord of the Rings：The Fellowship of the Ring ◎年 代 2001 ◎国 家 新西兰/美国 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 国英双语 ◎字 幕 中英双字 ◎上映日期 2002-04-04(中国大陆)/2001-12-19(美国) ◎豆瓣评分 8.9/10 from 292224 users ◎豆瓣链接 https://movie.douban.com/subject/1291571/ ◎文件格式 X264+AC3 ◎视频尺寸 1920×1080 ◎文件大小 11.6GB ◎片 长 228min ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 肖恩·宾 Sean Bean 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 伊安·霍姆 Ian Holm 多米尼克·莫纳汉 Dominic Monaghan 萨拉·贝克 Sala Baker 约翰·瑞斯-戴维斯 John Rhys-Davies 【电影简介】 比尔博·巴金斯是100多岁的哈比人，住在故乡夏尔，生性喜欢冒险，在年轻时的一次探险经历中，他从怪物咕噜手中得到了至尊魔戒，这枚戒指是黑暗魔君索伦打造的至尊魔戒，拥有奴役世界的邪恶力量，能够统领其他几枚力量之戒，在3000年前的人类联盟和半兽人大军的战役中，联盟取得了胜利，并得到了至尊魔戒，数千年的辗转后，魔戒落到咕噜手中，被比尔博碰巧得到。 因为和魔戒的朝夕相处，比尔博的心性也受到了影响，在他111岁的生日宴会上，他决定把一切都留给侄子佛罗多(伊莱贾·伍德 饰)，继续冒险。 比尔博的好朋友灰袍巫师甘道夫（伊恩·麦凯伦 饰）知道至尊魔戒的秘密，同时，黑暗魔君索伦已经知道他的魔戒落在哈比族的手中。索伦正在重新建造要塞巴拉多，集结无数的半兽人，准备以大军 夺取魔戒，并且征服全世界。 甘道夫说服佛罗多将魔戒护送到精灵王国瑞文希尔，佛罗多在好朋友山姆、皮平和梅利的陪同下，在跃马旅店得到了刚铎王子阿拉贡的帮助，历经艰难，终于到达了精灵王国。 然而，精灵族并不愿意保管这个邪恶的至尊魔戒，中土各国代表开会讨论，达成意见，准备将至尊魔戒送到末日山脉的烈焰中彻底销毁，佛罗多挺身而出接受了这个任务，这次，陪伴他的除了三个好朋友，还有甘道夫、阿拉贡、精灵莱戈拉斯（奥兰多·布鲁姆 饰）、人类博罗米尔、侏儒金利。 一路上，魔戒远征军除了要逃避索伦爪牙黑骑士和半兽人的追杀之外，更要抵抗至尊魔界本身的邪恶诱惑，前途困难重重。 【电影截图】 指环王1.魔戒再现.国语双语中英字幕.The.Lord.of.the.Rings.The.Fellowship.of.the.Ring.2001.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B1%EF%BC%9A%E9%AD%94%E6%88%92%E5%86%8D%E7%8E%B0.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.03GB%5D%5B%E5%9B%BD%5D/"},{"title":"ShadowRocket-小火箭🚀🚀购买教程","text":"研究了几天试了几种方法想白嫖小火箭感觉难得一批，最后决定自己入手。分享一下最简单的方式；1.登录appstore修改地区为美国，关于账户的一些设置信息可以参考地址 美国 Old Harbor, AK 邮编 99643电话(430) 558-8829 2.某宝上买充值卡（记得买美区的） 购买成功，会发一个卡图 3.Appstore上进入个人中心进入Redeem Gift Card or Code进入页面点击use camera 扫一下 成功后，回到首页购买；4.操作前最好也挂下vp恩，自己定位看看是不是美国地区的。网上说有可能会充值失败，账号被锁啥的。我也不懂。如果对你有帮助记得赞下哦！我的个人博客：https://www.errorcode.xyz/","link":"/2020/10/23/ShadowRocket-%E5%B0%8F%E7%81%AB%E7%AE%AD%F0%9F%9A%80%F0%9F%9A%80%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"title":"Mac下TensorFlow安装教程","text":".安装Python 3.7.5 版本百度云盘:链接:https://pan.baidu.com/s/1lC7ZPFAIB8pYor1DbIOL8Q 密码:v6tj官网:https://www.python.org/ftp/python/3.7.5/python-3.7.5-macosx10.9.pkg 查看版本号。 123python3 --versionpip3 --versionvirtualenv --version 输入which python3 查看路径 2.如果已经安装，跳过这步：如果没用过brew，需要先下载，关于brew查看这里: https://brew.sh/ 123/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 1234/usr/bin/ruby -e &quot;PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 3.安装virtualenv虚拟环境创建一个新的虚拟环境通过选择一个Python解释器,创建./venv目录来保存它:可修改为其他目录。目录会出现在 user的子目录下。 1virtualenv --system-site-packages -p python3 ./venv 4.激活虚拟环境 1source ./venv/bin/activate # sh, bash, ksh, or zsh virtualenv活跃时,shell提示符前缀(venv)。 安装包在一个虚拟环境在不影响主机系统设置。先升级pip: 12pip install --upgrade pippip list # show packages installed within the virtual environment 5.退出虚拟环境 deactivate # don’t exit until you’re done using TensorFlow 如果提示权限不够时，需要在命令后添加 –user。 6.安装TensorFlow 1pip install --upgrade tensorflow 验证安装 1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 问题汇总 1pip install Keras-Applications ModuleNotFoundError: No module named ‘matplotlib’ 1pip install matplotlib ModuleNotFoundError: No module named ‘tensorflow_datasets’ 1pip install tensorflow_datasets ModuleNotFoundError: No module named ‘tensorflow_hub’ 1pip install tensorflow_hub seaborn 绘制矩阵图 (pairplot) 1pip install seaborn 引入类库 TensorFlow and tf.keras12import tensorflow as tffrom tensorflow import keras Helper librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as sns","link":"/2020/09/11/TensorFlow%20Mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"指环王3：王者无敌.加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王3：王者无敌.加长版][BD-MKV/5.17GB][国英双语中字][1080P][豆瓣9.2高分魔幻巨制] ◎译 名 指环王3：王者无敌/魔戒三部曲：王者再临/指环王III：王者无敌/魔戒3：王者归来/指环王3：国王归来 ◎片 名 The Lord of the Rings: The Return of the King ◎年 代 2003 ◎国 家 美国/新西兰 ◎类 别 剧情/动作/奇幻/冒险 ◎语 言 英语/昆雅语/古英语/辛达林语 ◎上映日期 2003-12-01(新西兰首映)/2003-12-17(美国)/2004-03-15(中国大陆) ◎IMDb评分 8.9/10 from 1,064,793 users ◎IMDb链接 http://www.imdb.com/title/tt0167260/ ◎豆瓣评分 9.1/10 from 218,212 users ◎豆瓣链接 http://movie.douban.com/subject/1291552/ ◎片 长 201分钟/251分钟(加长版)/263分钟(蓝光加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 维果·莫腾森 Viggo Mortensen 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 丽芙·泰勒 Liv Tyler 伊恩·麦克莱恩 Ian McKellen 奥兰多·布鲁姆 Orlando Bloom 凯特·布兰切特 Cate Blanchett 米兰达·奥图 Miranda Otto 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 多米尼克·莫纳汉 Dominic Monaghan 比利·博伊德 Billy Boyd 马尔顿·索克斯 Marton Csokas 卡尔·厄本 Karl Urban 克里斯托弗·李 Christopher Lee 约翰·瑞斯-戴维斯 John Rhys-Davies ◎简 介 魔幻战争逐渐进入高潮阶段。霍比特人弗拉多（伊利亚·伍德 Elijah Wood 饰）携带着魔戒，与伙伴山姆（Sean Astin 饰）以及狡猾阴暗的咕噜等前往末日山，一路上艰难险阻不断，魔君索伦为阻止魔戒被销毁用尽全力阻挠。另一方面，白袍巫师甘道夫（伊安·麦克莱恩 Ian McKellen 饰）率中土勇士们镇守刚铎首都——白城米那斯提里斯。魔兽大军压境，黑暗与光明的决战即将来临…… 本片是“指环王三部曲”的终结篇，根据英国作家J.R.R.托尔金（J.R.R. Tolkien）同名魔幻巨著《指环王》（The Lord of the Rings）改编，并荣获2004年第76届奥斯卡最佳影片、最佳导演、最佳改编剧本、最佳剪辑、最佳艺术指导、最佳服装设计、最佳化妆、最佳视觉效果、最佳音效、最佳配乐和最佳歌曲等11项大奖。 ◎获奖情况 第76届奥斯卡金像奖 (2004) 最佳影片 Barrie M. Osborne / 弗兰·威尔士 / 彼得·杰克逊 最佳导演 彼得·杰克逊 最佳改编剧本 弗兰·威尔士 / 彼得·杰克逊 / 菲利帕·鲍恩斯 最佳剪辑 Jamie Selkirk 最佳视觉效果 Alex Funke / Jim Rygiel / 乔·莱特瑞 / Randall William Cook 最佳混音 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳美术指导 丹·汉纳 / 格兰特·梅杰 / 艾伦·李 最佳服装设计 Ngila Dickson / 理查德·泰勒 最佳化妆 理查德·泰勒 / 彼得·金 最佳原创配乐 霍华德·肖 最佳原创歌曲 霍华德·肖 / 安妮·蓝妮克丝 / 弗兰·威尔士 第28届日本电影学院奖 (2005) 最佳外语片(提名) 指环王3.王者无敌.国语双语中英字幕.The.Lord.of.the.Rings.The.Return.of.the.King.2003.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B3%EF%BC%9A%E7%8E%8B%E8%80%85%E6%97%A0%E6%95%8C.%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV5.17GB%5D%5B%E5%9B%BD%E8%8B%B1%E5%8F%8C%5D/"},{"title":"指环王2：双塔奇兵.蓝光加长版","text":"[2000-2010][欧美][奇幻][BT下载][指环王2：双塔奇兵.蓝光加长版][BD-MKV/4.81GB][国语双语中英字幕][1080P][豆瓣9.1分史诗巨制] ◎译 名 指环王2：双塔奇兵 / 指环王II：双塔 / 魔戒2：双塔奇谋 / 魔戒二部曲：双城奇谋 ◎片 名 The Lord of the Rings: The Two Towers ◎年 代 2002 ◎产 地 美国 / 新西兰 ◎类 别 剧情 / 动作 / 奇幻 / 冒险 ◎语 言 英语 / 辛达林语 / 古代英语 ◎上映日期 2002-12-05(纽约首映) / 2002-12-18(美国) / 2003-04-25(中国大陆) ◎IMDb评分 8.7/10 from 1369619 users ◎IMDb链接 http://www.imdb.com/title/tt0167261 ◎豆瓣评分 9.1/10 from 410177 users ◎豆瓣链接 https://movie.douban.com/subject/1291572/ ◎片 长 179分钟 ◎导 演 彼得·杰克逊 Peter Jackson ◎编 剧 弗兰·威尔士 Fran Walsh / Philippa Boyens / Stephen Sinclair / 彼得·杰克逊 Peter Jackson / 托尔金 J.R.R. Tolkien ◎主 演 伊利亚·伍德 Elijah Wood 西恩·奥斯汀 Sean Astin 伊恩·麦克莱恩 Ian McKellen 维果·莫腾森 Viggo Mortensen 奥兰多·布鲁姆 Orlando Bloom 克里斯托弗·李 Christopher Lee 丽芙·泰勒 Liv Tyler 安迪·瑟金斯 Andy Serkis 雨果·维文 Hugo Weaving 卡尔·厄本 Karl Urban 凯特·布兰切特 Cate Blanchett 多米尼克·莫纳汉 Dominic Monaghan 大卫·文翰 David Wenham 比利·博伊德 Billy Boyd 布拉德·道里夫 Brad Dourif 伯纳德·希尔 Bernard Hill 约翰·瑞斯-戴维斯 John Rhys-Davies 米兰达·奥图 Miranda Otto ◎标 签 魔幻 | 史诗 | 经典 | 美国 | 战争 | 大片 | 新西兰 | 2002 ◎简 介 第二部在延续第一部风格的同时，故事呈现出多线发展的格局，情节有了更高的观赏性。 第一部结尾，博罗米尔被强兽人杀死之后，两个哈比族人皮平和梅利也被强兽人绑架，阿拉贡、精灵莱戈拉斯（奥兰多?布鲁姆 饰）、侏儒金利一路追踪强兽人，营救皮平和梅利，遇到了“复活”的白袍巫师甘道夫（伊恩?麦凯伦 饰）。此时，投降索伦的白袍巫师萨鲁曼控制了人类洛汉王国的国王，并派出大量的强兽人军队，准备消灭人类。阿拉贡、莱戈拉斯和金利在甘道夫的带领下，帮助洛汉王国对抗邪恶力量的入侵。 幸运的皮平和梅利被会说话的树精救了出来，并且遇到“复活”的甘道夫，在甘道夫的授意下，树精保护了两人的安全，并且带他们参加树精大会，大会上，树精们讨论对待中土大战的态度：是继续当中立者，逆来顺受，还是奋起反抗？ 身负重任的佛罗多(伊莱贾?伍德 饰)和山姆继续向末日山脉前进，一路上被咕噜跟踪，弗罗多依靠至尊魔戒的力量，成为了咕噜的主人，在咕噜的带领下，他们到了末日山脉的入口，黑门。就在他们准备进入之时，博罗米尔的弟弟法莫尔出现，将他们带回了刚铎。弗罗多又遇上了新的危机：法莫尔想利用至尊魔戒的力量对抗萨鲁曼的攻击…… ◎获奖情况 第75届奥斯卡金像奖(2003) 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 最佳剪辑(提名) 迈克·霍顿 最佳视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 最佳音效剪辑 迈克·霍普金斯 / 伊桑·范德莱恩 最佳音响(提名) 迈克·亨吉斯 / 哈蒙德·匹克 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 最佳艺术指导(提名) 格兰特·梅杰 / 丹·汉纳 / 艾伦·李 第56届英国电影学院奖(2003) 电影奖 最佳影片(提名) 巴里·M·奥斯本 / 彼得·杰克逊 / 弗兰·威尔士 电影奖 最佳导演(提名) 彼得·杰克逊 电影奖 最佳摄影(提名) 安德鲁·莱斯尼 电影奖 最佳剪辑(提名) 迈克·霍顿 / Jabez Olssen 电影奖 最佳化妆/发型(提名) Peter Owen / 彼得·金 / 理查德·泰勒 电影奖 最佳服装设计 恩吉拉·迪克森 / 理查德·泰勒 电影奖 最佳艺术指导(提名) 格兰特·梅杰 电影奖 最佳特殊视觉效果 Jim Rygiel / 兰德尔·威廉·库克 / 乔·莱特瑞 / Alex Funke 电影奖 最佳音效(提名) 迈克·亨吉斯 / 迈克·霍普金斯 / 迈克尔·斯曼内科 / 克里斯托弗·博伊斯 / 哈蒙德·匹克 / David Farmer / 伊桑·范德莱恩 电影奖 观众选择奖 第27届日本电影学院奖(2004) 最佳外语片(提名) 第3届美国电影学会奖(2002) 年度佳片 指环王2.双塔奇兵国语双语中英字幕.The.Lord.of.the.Rings.The.Two.Towers.2002.EXTENDED.BD1080P.X264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E6%8C%87%E7%8E%AF%E7%8E%8B2%EF%BC%9A%E5%8F%8C%E5%A1%94%E5%A5%87%E5%85%B5.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV4.81GB%5D%5B%E5%9B%BD%5D/"},{"title":"霍比特人1.意外之旅.蓝光加长版","text":"[2012] [欧美][奇幻][BT下载][霍比特人1.意外之旅.蓝光加长版][BD-MKV/3.58GB][国英双语中英字幕][1080P][特效史诗巨制] ◎译 名 霍比特人1：意外之旅/哈比人：不思议之旅(港)/哈比人：意外旅程(台)/指环王前传：霍比特人(上) ◎片 名 The Hobbit: An Unexpected Journey ◎年 代 2012 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2012-11-28(新西兰首映)/2012-12-14(美国)/2013-02-22(中国大陆) ◎IMDb评分 8.0/10 from 548,633 users ◎IMDb链接 http://www.imdb.com/title/tt0903624 ◎豆瓣评分 8.1/10 from 178,214 users ◎豆瓣链接 http://movie.douban.com/subject/1966182 ◎片 长 169分钟/182分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 肯·斯托特 Ken Stott 格拉汉姆·麦克泰维什 Graham McTavish 詹姆斯·内斯比特 James Nesbitt 迪恩·奥戈曼 Dean O’Gorman 艾丹·特纳 Aidan Turner 雨果·维文 Hugo Weaving 凯特·布兰切特 Cate Blanchett 安迪·瑟金斯 Andy Serkis 西尔维斯特·迈可伊 Sylvester McCoy 克里斯托弗·李 Christopher Lee 伊利亚·伍德 Elijah Wood 伊安·霍姆 Ian Holm 李·佩斯 Lee Pace ◎简 介 中土最后一座矮人王国埃尔波尔，巍峨壮丽，庄严雄伟。老国王索尔积聚大量财富，却引来恶龙史茅革的觊觎和荼毒，最终导致这座城池陷落。许多年后，灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）找到弗罗多的舅舅——霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰），邀请他加入由13名矮人组成的远征队伍。原来史茅革已多年不见声息，背负家国仇恨的矮人王子索林（理查德·阿米蒂奇 Richard Armitage 饰）希望借此机会收复故土。经过一番考虑，巴金斯决定加入。令他想不到的是，远征旅途多灾多难，与索林结下深仇大恨的苍白半兽人及其爪牙阴魂不散，更有食人鬼和石人制造的无数艰险。而在旅途中，巴金斯也意外得到了日后影响整个中土的重要宝物…… 本片根据J.R.R·托尔金的同名原著改编。 霍比特人1.意外之旅.国英双语中英字幕 The.Hobbit.2012.EXTENDED.1080p.BluRay.AC3. x264.mkv.torrent","link":"/2020/09/23/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA1.%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.58GB%5D/"},{"title":"霍比特人2：史矛革之战蓝光加长版","text":"[2013][欧美][动作][BT下载][霍比特人2：史矛革之战蓝光加长版][BD-MKV/3.59GB][国英双语中英字幕][1080P][豆瓣8.1分好评奇幻冒险] ◎译 名 霍比特人2：史矛革之战/霍比特人2：史矛革荒漠/哈比人：荒谷魔龙(港)/哈比人：荒谷恶龙(台)/霍比特人2：斯毛戈荒漠/指环王前传：霍比特人(中) ◎片 名 The Hobbit: The Desolation of Smaug ◎年 代 2013 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2013-12-13(美国)/2014-02-21(中国大陆) ◎IMDb评分 8.0/10 from 413,210 users ◎IMDb链接 http://www.imdb.com/title/tt1170358/ ◎豆瓣评分 8.1/10 from 152,878 users ◎豆瓣链接 http://movie.douban.com/subject/11606328/ ◎片 长 161分钟/186分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 伊恩·麦克莱恩 Ian McKellen 马丁·弗瑞曼 Martin Freeman 理查德·阿米蒂奇 Richard Armitage 本尼迪克特·康伯巴奇 Benedict Cumberbatch 奥兰多·布鲁姆 Orlando Bloom 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 斯蒂芬·弗雷 Stephen Fry 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 约翰·贝尔 John Bell 马努·贝内特 Manu Bennett 杰德·布罗菲 Jed Brophy 亚当·布朗 Adam Brown 约翰·凯伦 John Callen 瑞安·盖奇 Ryan Gage 马克·哈德洛 Mark Hadlow 皮特·哈姆贝尔顿 Peter Hambleton 斯蒂芬·亨特 Stephen Hunter 威廉姆·吉尔切尔 William Kircher 西尔维斯特·迈可伊 Sylvester McCoy 格拉汉姆·麦克泰维什 Graham McTavish 迪恩·奥戈曼 Dean O’Gorman 米克尔·佩斯勃兰特 Mikael Persbrandt 艾丹·特纳 Aidan Turner ◎简 介 距离孤山越来越近，矮人远征军的道路却变得异常艰险。他们躲过了苍白半兽人的不懈追杀，在幽暗密林前和甘道夫（伊恩·麦凯伦 Ian McKellen 饰）兵分两路，后者前往多尔哥多探寻索伦的动向，而霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）和矮人们先是遭到巨大蜘蛛的袭击，随后又被精灵王子莱戈拉斯（奥兰多·布鲁姆 Orlando Bloom 饰）及其木精灵同伴捕获。比尔博急中生智，利用魔戒救出伙伴，继而引发了木精灵、半兽人和矮人远征军之间精彩纷呈的三方会战。借助巴德（卢克·伊万斯 Luke Evans 饰）的帮助，疲惫的矮人们暂时落脚长湖镇。近在咫尺的孤山城堡，沉睡在财宝中的巨龙即将醒来…… 本片根据J.R.R·托尔金的同名原著改编。 ◎获奖情况 第86届奥斯卡金像奖 (2014) 最佳视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 / Eric Reynolds 最佳音效剪辑(提名) Brent Burge 最佳混音(提名) 迈克·亨吉斯 / 托尼·约翰逊 / 克里斯托弗·博伊斯 / 迈克尔·斯曼内科 第23届MTV电影奖 (2014) MTV电影奖 年度电影(提名) MTV电影奖 最佳打斗(提名) MTV电影奖 最佳银幕形象转变(提名) 奥兰多·布鲁姆 MTV电影奖 最佳英雄形象(提名) 马丁·弗瑞曼 第16届美国服装设计工会奖 (2014) 奇幻题材电影最佳服装设计(提名) 鲍勃·巴克 / 安·马斯克里 / 理查德·泰勒 第61届美国音效剪辑协会奖 (2014) 金卷轴奖 最佳电影音效剪辑(提名) David Farmer / Chris Ward / Hayden Collow / Craig Tomlinson / Justin Webster / Dave Whitehead / Melanie Graham / John Simpson 金卷轴奖 最佳配乐剪辑(提名) Jonathan Schultz / Steve Gallagher / Nigel Scott / Mark Willsher / Kirsty Whalley 第12届美国视觉效果协会奖 (2014) 最佳特效电影视觉效果(提名) 大卫·克莱顿 / 埃里克·赛恩登 / 乔·莱特瑞 最佳真人电影CG动画角色 大卫·克莱顿 / Eric Reynolds 最佳电影虚拟摄影(提名) Christian Rivers / Thelvin Cabezas 最佳真人电影模拟动画效果(提名) Areito Echevarria 最佳电影视觉效果合成(提名) Giuseppe Tagliavini / Charles Tait / Robin Hollander 第19届美国评论家选择电影奖 (2014) 最佳美术指导(提名) 丹·汉纳 / Ra Vincent 最佳服装设计(提名) 鲍勃·巴克 / Lesley Burkes-Harding / 安·马斯克里 / 理查德·泰勒 最佳化妆(提名) 最佳视觉效果(提名) 动作片最佳女主角(提名) 伊万杰琳·莉莉 第18届金卫星奖 (2014) 电影部门 最佳原创歌曲(提名) 第13届凤凰城影评人协会奖 (2013) 最佳原创配乐(提名) 霍华德·肖 霍比特人2.史矛革之战..国英双语中英字幕.The.Hobbit.2013.EXTENDED.1080p.BluRay.x264.AC3.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA2%EF%BC%9A%E5%8F%B2%E7%9F%9B%E9%9D%A9%E4%B9%8B%E6%88%98%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.59GB%5D/"},{"title":"霍比特人3.五军之战.蓝光加长版","text":"[2014][欧美][动作][BT下载][霍比特人3.五军之战.蓝光加长版][BD-MKV/3.88GB][国英双语中英双字][1080P][超视效史诗巨制必看] ※※※※※※※ 影片信息 ※※※※※※※ ◎译 名 霍比特人3：五军之战/哈比人：五军之战(港台)/哈比人：奇境再返(台) ◎片 名 The Hobbit: The Battle of the Five Armies ◎年 代 2014 ◎国 家 美国/新西兰 ◎类 别 动作/奇幻/冒险 ◎语 言 英语 ◎上映日期 2014-12-17(美国)/2015-01-23(中国大陆) ◎IMDb评分 7.5/10 from 307,296 users ◎IMDb链接 http://www.imdb.com/title/tt2310332/ ◎片 长 144分钟/164分钟(加长版) ◎导 演 彼得·杰克逊 Peter Jackson ◎主 演 马丁·弗瑞曼 Martin Freeman 伊恩·麦克莱恩 Ian McKellen 理查德·阿米蒂奇 Richard Armitage 伊万杰琳·莉莉 Evangeline Lilly 李·佩斯 Lee Pace 卢克·伊万斯 Luke Evans 本尼迪克特·康伯巴奇 Benedict Cumberbatch 肯·斯托特 Ken Stott 詹姆斯·内斯比特 James Nesbitt 比利·康诺利 Billy Connolly 凯特·布兰切特 Cate Blanchett 伊安·霍姆 Ian Holm 克里斯托弗·李 Christopher Lee 雨果·维文 Hugo Weaving 奥兰多·布鲁姆 Orlando Bloom 马努·贝内特 Manu Bennett 艾丹·特纳 Aidan Turner 迪恩·奥戈曼 Dean O’Gorman 格拉汉姆·麦克泰维什 Graham McTavish 斯蒂芬·弗雷 Stephen Fry 米卡埃尔·佩斯布兰特 Mikael Persbrandt ◎简 介 被吵醒的史矛革大闹长湖镇，最终为人类巴德（卢克·伊万斯 Luke Evans 饰）射杀。索林·橡木盾（理查德·阿米蒂奇 Richard Armitage 饰）多年的夙愿终于实现，孤山埃尔波尔重新回到矮人手中。然而这位矮人王子仿佛被史矛革的贪婪和堆成山的黄金迷惑了心窍，他 疯狂地搜寻象征王位的阿肯宝石，不仅撕毁了付给长湖镇报酬的约定，更拒绝了精灵王（李·佩斯 Lee Pace 饰）索要本族国宝的要求，为此导致三族的战争一触即发。与此同时，苍白半兽人阿索格率领大军浩浩荡荡向孤山逼近。得知消息的灰袍巫师甘道夫（伊恩·麦凯伦 Ian McKellen 饰）从中调停斡旋，而被索林视为唯一朋友的霍比特人比尔博·巴金斯（马丁·弗里曼 Martin John C. Freeman 饰）则掌握着中土命运的关键。五军会战，爆发在即！ 本片根据J.R.R·托尔金的同名原著改编，为霍比特人系列的最后一部。 ◎获奖情况 第17届美国青少年选择奖 (2015) 最佳科幻/奇幻电影(提名) 第87届奥斯卡金像奖 (2015) 最佳音效剪辑(提名) 霍比特人3.五军之战.国英双语中英双字The.Hobbit.The.Battle.of.the.Five.Armies.2014.EXTENDED.BluRay.1080p.x264.2Audios.mkv.torrent","link":"/2020/09/22/%5BBT%E4%B8%8B%E8%BD%BD%5D%5B%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA3.%E4%BA%94%E5%86%9B%E4%B9%8B%E6%88%98.%E8%93%9D%E5%85%89%E5%8A%A0%E9%95%BF%E7%89%88%5D%5BBD-MKV3.88GB%5D/"},{"title":"android之HandlerThread","text":"HandlerThread是个什么东西？查看类的定义时有这样一段话： 1Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是说：这个类的作用是创建一个包含looper的线程。那么我们在什么时候需要用到它呢?加入在应用程序当中为了实现同时完成多个任务，所以我们会在应用程序当中创建多个线程。为了让多个线程之间能够方便的通信，我们会使用Handler实现线程间的通信。这个时候我们手动实现的多线程+Handler的简化版就是我们HandlerThrea所要做的事了。 下面我们首先看一下HandlerThread的基本用法： 12345678910111213141516171819202122232425HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThreand&quot;); mHandlerThread.start(); // 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; title = (TextView) findViewById(R.id.title); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Message msg = new Message(); msg.obj = &quot;11111&quot;; mHandler.sendMessage(msg); msg = new Message(); msg.obj = &quot;2222&quot;; mHandler.sendMessage(msg); } }); 我们首先定义了一个HandlerThread对象，是直接通过new的方式产生的，查看其构造方法： 1234public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; }可以知道HandlerThread继承于Thread，所以说HandlerThread本质上是一个线程，其构造方法主要是做一些初始化的操作。 然后我们调用了mHandlerThread.start()方法，由上我们知道了HandlerThread类其实就是一个Thread，一个线程，所以其start方法内部调用的肯定是Thread的run方法，我们查看一下其run方法的具体实现： 12345678910111213@Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } 我们发现其内部调用了Looper.prepate()方法和Loop.loop()方法，熟悉android异步消息机制的童鞋应当知道，在android体系中一个线程其实是对应着一个Looper对象、一个MessageQueue对象，以及N个Handler对象，具体可参考： android源码解析之（二）–&gt;异步消息机制 所以通过run方法，我们可以知道在我们创建的HandlerThread线程中我们创建了该线程的Looper与MessageQueue； 这里需要注意的是其在调用Looper.loop()方法之前调用了一个空的实现方法：onLooperPrepared(),我们可以实现自己的onLooperPrepared（）方法，做一些Looper的初始化操作； run方法里面当mLooper创建完成后有个notifyAll()，getLooper()中有个wait()，这是为什么呢？因为的mLooper在一个线程中执行，而我们的handler是在UI线程初始化的，也就是说，我们必须等到mLooper创建完成，才能正确的返回getLooper();wait(),notify()就是为了解决这两个线程的同步问题 然后我们调用了： 1234567// 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; 该Handler的构造方法中传入了HandlerThread的Looper对象，所以Handler对象就相当于含有了HandlerThread线程中Looper对象的引用。 然后我们调用handler的sendMessage方法发送消息，在Handler的handleMessge方法中就可以接收到消息了。 最后需要注意的是在我们不需要这个looper线程的时候需要手动停止掉； 1234protected void onDestroy() { super.onDestroy(); mHandlerThread.quit(); } 相对来说HandlerThread还是比较简单的，这里总结一下： HandlerThread本质上是一个Thread对象，只不过其内部帮我们创建了该线程的Looper和MessageQueue； 通过HandlerThread我们不但可以实现UI线程与子线程的通信同样也可以实现子线程与子线程之间的通信； HandlerThread在不需要使用的时候需要手动的回收掉； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E4%B9%8BHandlerThread/"},{"title":"mac环境下，出现brew command not found错误的解决方法","text":"mac 终端下，执行以下命令，即可安装brew： /usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 在终端环境下，brew –version 查看brew的版本，也可以验证brew是否安装成功","link":"/2021/08/04/mac%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%87%BA%E7%8E%B0brew%20command%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"Android 项目构建流程","text":"平时开发过程中我们通过android studio编写完成android项目之后直接点击 Run ‘app’就可以在build/outputs/apk生成可以在android设备中安装的apk文件了，那么整个android源码的构建过程是怎么样的呢？ 我们可以根据Google官方提供的流程图来具体了解构建的过程： 通常的构建过程就是如上图所示，下面是具体描述： 1.AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。 2.AIDL工具会将所有的aidl接口转化为java接口。 3.所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。 4.Dex工具会将上述产生的.class文件及第三库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。 5.ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。 6.生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。 7.如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会减少内存的开销。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程","link":"/2020/09/11/android%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"一键解除iOS版Telegram对群组和频道的限制/苹果iPhone有些频道不显示问题","text":"一键解除iOS版Telegram对群组和频道的限制/苹果iPhone有些频道不显示问题Telegram，也就是我们所说的电报，是当前最流行的社交 APP，很多网站、品牌和公众人物都拥有自己的“电报群”。开放的群组和频道是 Telegram 最具特色的功能，也是很多用户（包括我）使用 Telegram 的主要目的。 Telegram 汇集了世界各地的用户。它开源且安全，轻便且没有广告，端到端加密数据，保护用户隐私……因为这些特性，用户能够在 Telegram 上获得几乎任何内容。 不过受限于苹果的政策，iOS 平台上的 Telegram 官方 APP 限制访问特定的群组或频道，例如包含色#情或盗版信息的那部分就被阻止了。如何突破限制，成为众多用户头疼的事情。往常的做法是使用第三方客户端，不过这个选择有很大的风险，因为用户不知道背后是否是窃取隐私信息的“有心人”。 具体可能会提示如下信息： This group/channel is blocked because it was used to spread pornograhic content. 该群组/频道由于传播色#情内容,已被屏蔽。 This channel can’t be displayed because it was used to spread pornographic content? This channel is blocked because it was used to spread pornograhic content. 如今这个问题已经有了“官方”的解决办法。不是说官方宣布，而是用官方客户端本身的功能来解决，再也不用借助于“旁门左道”了。 操作方法目前有两个方法来关闭敏感内容过滤，一是使用网页端，二是使用桌面客户端。从便捷性来考虑自然是网页端更好，不需要借助电脑，直接用手机浏览器就可以解决。 1、使用Telegram Web首先登录 Telegram Web 端：https://web.telegram.org/ 点击右上角的菜单，打开 Settings，将 Show Sensitive Content 的开关打开就完成了。 关掉 iOS APP 再重新打开就会发现福利已经尽显眼前了。 2、使用桌面客户端首先在下载和安装 Win 或 Mac 版 Telegram： Win版：https://desktop.telegram.org/ Mac版：https://macos.telegram.org/ 登录 Telegram 账号之后打开 Settings – Privacy and Security，把 Sensitive Content 下的 Disable filtering 打开： 好了，把 iOS 上的 Telegram APP 关掉重新打开，就会发现之前无法查看的群组和频道都已经可以访问。 根据选项下方的介绍，这个开关是全局性的，也就是说这样操作过后，该账号在所有平台上面的客户端都适用这个规则。如果想要浪子回头，把它再关掉就好了。","link":"/2020/10/21/%E4%B8%80%E9%94%AE%E8%A7%A3%E9%99%A4iOS%E7%89%88Telegram%E5%AF%B9%E7%BE%A4%E7%BB%84%E5%92%8C%E9%A2%91%E9%81%93%E7%9A%84%E9%99%90%E5%88%B6%E8%8B%B9%E6%9E%9CiPhone%E6%9C%89%E4%BA%9B%E9%A2%91%E9%81%93%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"},{"title":"在Mac下启动Tomcat","text":"1.将加压好的 Tomcat 安装包放在某个路径下，重命名为 Tomcat 。（例如我放在了资源库下）2.输入 cd Library/Tomcat/bin 进到 Tomcat 的 bin 目录下3.输入 sudo chmod 755 *.sh 设置权限4.输入 sudo sh startup.sh 启动 Tomcat。在浏览器中输入 localhost:8080 看到 Tomcat 主页即为成功。5.输入 sudo sh shutdown.sh 关闭 Tomcat。","link":"/2021/04/08/%E5%9C%A8Mac%E4%B8%8B%E5%90%AF%E5%8A%A8Tomcat/"},{"title":"安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL","text":"Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] 平台版本是android 7.0，在adb install *.apk 会提示下面的错误： Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI] 方法1： 修改AndroidManifest.xml 中android:testOnly=”true” 改成 android:testOnly=”false”，或者直接去掉。 方法2： adb push *.apk /tmp adb shell pm install -t /tmp/*.apk 方法3： adb install -t *.apk 方法4： Android Studio 3.0 and FLAG_TEST_ONLY 一文中，给出了关于Android studio 3.0中出现问题的说明：Option to indicate this application is only for testing purposes.For example, it may expose functionality or data outside of itself that would cause a security hole, but is useful for testing.This kind of application can not be installed without the INSTALL_ALLOW_TEST flag, which means only through adb install. You cannot install an app with android:testOnly=”true” by conventional means, such as from an Android file manager or from a download off of a Web site Android Studio 3.0 sets android:testOnly=”true” on APKs that are run from the IDE 解决办法：在gradle.properties(项目根目录或者gradle全局配置目录 ~/.gradle/)文件中添加：android.injected.testOnly=false 请转载的朋友表明出处： http://blog.csdn.net/shift_wwx/article/details/78468397","link":"/2021/01/26/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY:%20installPackageL/"},{"title":"序列化面试题","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243面试相关1. 反序列化后的对象，需要调用构造函数重新构造吗 反序列化调用不会调用构造函数。以存储的二进制数据进行构造2. 序列前的对象与序列化后的对象是什么关系？是(&quot;==&quot;还是equal？是浅复制还是深复制？) 序列化前和序列化后 是两个不同的对象，对象地址发生了改变。调用equal 和 == 返回true。是一个深复制。3. Android里面为什么要设计出Bundle而不是直接用Map结构 Bundle中是使用的Parcel打包数据。Parcel可以实现跨进程通讯。 &lt;!-- more --&gt; Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数 据对应下标，一个对象数组 保存key和value，内部使用二分法对key进行排序，所以在添加、删 除、查找数据的时候，都会使用二分法查找，只适合于小数 据量操作，如果在数据量比较大的情况 下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候， HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据 量，我没见过在两个Activity之 间传递10个以上数据的场景，所以相比之下，在这种情况下使用 ArrayMap保存数据，在操作速度和内存占用上都具有优势， 因此使用Bundle来传递数据，可以保 证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话， 需要数据是基本类型或者是可 序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。 而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为 了更加快速的进行数据的序列化和反序列化， 系统封装了Bundle类，方便我们进行数据的传输。4. SerialVersionID的作用是什么？ 版本控制5. Android中Intent/Bundle的通信原理及大小限制 大小限制 bundle 在zgote在创建进程的时候，分配了binder的内存大小。binder申请匿名内存有限制。 binder在内核空间创建内存映射时，大小限制在 &lt; 4M intent 1M限制 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限 制的(有些手机是 2 M)， 而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区 就更小了( 有人以前做过测试，大约一个线程可以占用 128 KB)。 所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时， 你应 该知道怎么解决了6. 为何Intent不能直接在组件间传递对象而要通过序列化机制？ startActivity（intent），activity启动流程要和AMS交互，需要跨进程通讯。只有把数据序列化后，传递。7. 序列化与持久化的关系和区别是什么？ 序列化:跨进程传输数据时，需要使用序列化。 持久化:数据的存储。 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程 (intent.prepareToLeaveProcess())， 这也就意味着，Intent所携带的数据要能够在不同进程间 传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输， 所以我 们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间 传输。 而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel 容器 ，后者也是Android系统专门推出的用于进程间通信等的接口","link":"/2020/09/11/%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"科学上网利器大全","text":"Algo - 在云中设置个人 IPSEC VPN。 源码 ClashX - 基于 clash 的一款支持规则过滤的科学上网工具。 源码 FreeVPN Plus - 永不过期 Mac 免费VPN。 Firefly 萤火虫 - 免费科学上网。 GoAgentX - 科学上网。(https://github.com/getlantern/lantern) GTX加速器 - 每天签到领取 500M 流量。 Lantern - 科学上网。(https://github.com/getlantern/lantern) LoCoVPN - 每天签到可获得 2 小时免费VPN加速。 SpechtLite - 支持 Shadowsocks 及规则管理的高效率代理。源码 ShadowsocksX - 一个快速的隧道代理，可以帮助你绕过防火墙。源码 ShadowsocksX-NG - 一款 ShadowsocksX 客户端软件。源码 Surge - 科学上网。 Shimo - 连接大量 VPN 的应用 Tunnelbear - 简单的私人 VPN。 Tunnelblick - OpenVPN 的免费软件。 tinc - VPN 软件. 源码 V2Ray - 原生支持 Socks、HTTP、Shadowsocks、VMess 等协议。 V2rayU - 一款 v2ray 客户端软件。源码 二师兄VPN - 提供无限流量、无限续期免费 VPN 账号。 风驰VPN - 无限流量、无限续期的免费 VPN 加速服务。","link":"/2020/10/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%88%A9%E5%99%A8%E5%A4%A7%E5%85%A8/"},{"title":"网络状态码分类","text":"网络状态码分类 状态码 名称 描述100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议200 OK 请求成功。一般用于GET与POST请求201 Created 已创建。成功请求并创建了新的资源202 Accepted 已接受。已经接受请求，但未处理完成203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域206 Partial Content 部分内容。服务器成功处理了部分GET请求300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI303 See Other 查看其它地址。与301类似。使用GET和POST请求查看304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源305 Use Proxy 使用代理。所请求的资源必须通过代理访问306 Unused 已经被废弃的HTTP状态码307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向400 Bad Request 客户端请求的语法错误，服务器无法理解401 Unauthorized 请求要求用户的身份认证402 Payment Required 保留，将来使用403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面405 Method Not Allowed 客户端请求中的方法被禁止406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权408 Request Time-out 服务器等待客户端发送的请求时间过长，超时409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息412 Precondition Failed 客户端请求信息的先决条件错误413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理415 Unsupported Media Type 服务器无法处理请求附带的媒体格式416 Requested range not satisfiable 客户端请求的范围无效417 Expectation Failed 服务器无法满足Expect的请求头信息500 Internal Server Error 服务器内部错误，无法完成请求501 Not Implemented 服务器不支持请求的功能，无法完成请求502 Bad Gateway 充当网关或代理的服务器，从远端服务器接收到了一个无效的请求503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理","link":"/2021/01/26/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/"},{"title":"Android 基础知识总结","text":"​ Activity生命周期 img Fragment生命周期 Activity**四种启动模式** standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard**模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Service**的生命周期与启动方法由什么区别？** startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service**生命周期：** 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 广播**发送和接收的原理了解吗**？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。、 Android Handler机制是做什么的，原理了解吗 主要涉及的角色如下所示： 1.Message:消息,分为硬件产生的消息（例如:按钮、触摸）和软件产生的消息。 2. MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。 3. Looper：消息循环器，主要用来把消息分发给相应的处理者。 4. Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。 整个消息的循环流程还是比较清晰的，具体说来： 1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。 2. Looper通过loop()循环提取触发Message,并将Message交给对应的target handler来处理。 3. target handler调用自身的handleMessage()方法来处理Message。 如何自定义android控件 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure(int widthMeasureSpec, int heightMeasureSpec) 布局onLayout(boolean changed, int left, int top, int right, int bottom) 绘制onDraw(Canvas canvas) onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 描述一下**View的绘**制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。 ④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 requestLayout()**、invalidate()与postInvalidate()有什么区别？** requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定 会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 APK的打包流程 1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。 2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。 3. 通过Javac工具编译项目源码，生成Class文件。 4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。 5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。 6. 利用KeyStore对生成的APK文件进行签名。 7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件 的速度会更快。 (adsbygoogle = window.adsbygoogle || []).push({}); APK的安装流程 1. 复制APK到/data/app目录下，解压并扫描安装包。 2. 资源管理器解析APK里的资源文件。 3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。 4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。 5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 6. 安装完成后，发送广播。 Android Binder**机制是做什么的，为什么选用Binder，原理了解吗？** Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。 为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种： 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息**队**列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \\6. 信号 : 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进 程等； 既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量： 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全 是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。","link":"/2020/09/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"},{"title":"2021 IntellJ IDEA 激活码。IntellJ IDEA 激活码","text":"激活步骤 1.打开Jetbrains软件，如：PHPstorm、IntelliJ IDEA、Golang、Pycharm等 2.点击activation code 3.复制粘贴如下激活码，点击OK 目前有效期到2021年10月份，本激活码会不断更新。 VHN8U3N26D-eyJsaWNlbnNlSWQiOiJWSE44VTNOMjZEIiwibGljZW5zZWVOYW1lIjoi5YWs5LyX5Y+377yaIOeMv+S6uue8lueoiyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNDIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IldTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSTSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTViIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJEUCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQREIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFdTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTSSIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUFMiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUEdPIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjAyMS0wNS0wNyIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUkIiLCJwYWlkVXBUbyI6IjIwMjEtMDUtMDciLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNXIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlJTIiwicGFpZFVwVG8iOiIyMDIxLTA1LTA3IiwiZXh0ZW5kZWQiOnRydWV9XSwibWV0YWRhdGEiOiIwMTIwMjEwNDA4UFBBTTAwMDAwNSIsImhhc2giOiIyMzYzNTg4My8wOjMwMjk3OTUwMyIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-WvTIuske6tbpFPNY8GS517PXzWvwo4Gg1LoLNtMEjHbRiBISmEYI9Shd0XuP1OH2eRo8rurQARB0jSrKBZbxvrT+ZBF9U+9Pu7UY7FBzt0SjSGhoNlD1tpw8Usvg7JwwbHVdJUcGTUimVZWnmkvcf2LLA7VPBG1By7tpttR1Y7iBejUp+i17kn5wwVCW5Y/rN5XqTC1pMksKF50EN0G6aPQjnBqYIHZ8c07Sne9E45HWbpuaAT7Vhs+qC/16UCaiyykZVCq3/wuQk1WYw9Qjv9oJgMzBrfCcQxsFbZVcml+A2jffY6MBxFfyacvgztLRyp3WBUb84hmruc211NkrXg==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD PZ973KPC0J-eyJsaWNlbnNlSWQiOiJQWjk3M0tQQzBKIiwibGljZW5zZWVOYW1lIjoi5r+A5rS75p2l5rqQIHd3d8K3YWppaHVvwrdjb20iLCJhc3NpZ25lZU5hbWUiOiIiLCJhc3NpZ25lZUVtYWlsIjoiIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiIiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTQyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1YiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUENXTVAiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUEMiLCJwYWlkVXBUbyI6IjIwMjEtMDYtMjkiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwicGFpZFVwVG8iOiIyMDIxLTA2LTI5IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTVyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSUyIsInBhaWRVcFRvIjoiMjAyMS0wNi0yOSIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIxMDUzMFBQQU0wMDAwMDUiLCJoYXNoIjoiMjQ1NDM2NTYvMDoxOTk0NjAwMTM2IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-j85wBAs/hMc+uKROvqVLWieom8KVghxJM0Zop+RYqfQXUIRyc07R9olyu2P29yoTpNpc/FRTpFSrosJI85dX9Lbd4Aj23ry9Ste5fbbviuevVMaIfVo0RaGiK70WVYR/ngcBKT8H0qtoll5qWaPzK8TgvmeaCIthwgzoVIb5Z0looRiNN5vH/tpWx2sU5+dcRQMsGd4UQ1gF5TJqhbg4yVLTl3S9QxTk3Q/6kUPvZeu8btxCiFHY1NfKaKAv+vxfJHHHzUr3+aQpydwFbQilKlTmDNbEWi5anBbRKcYn/r38NXYiI9s/dtTtwGDKd8pxBcV2ko/TmSoZWc8YaeY1GA==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD","link":"/2021/04/09/2021%20IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81%E3%80%82IntellJ%20IDEA%20%E6%BF%80%E6%B4%BB%E7%A0%81/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it&apos;s upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法：requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact MeQQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2019/10/11/Android%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%E4%BC%A0%E8%BE%93DEMO/"},{"title":"android之IntentService","text":"什么是IntentService？简单来说IntentService就是一个含有自身消息循环的Service，首先它是一个service，所以service相关具有的特性他都有，同时他还有一些自身的属性，其内部封装了一个消息队列和一个HandlerThread，在其具体的抽象方法：onHandleIntent方法是运行在其消息队列线程中，废话不多说，我们来看其简单的使用方法： 定义一个IntentService 123456789101112public class MIntentService extends IntentService{ public MIntentService() { super(&quot;&quot;); } @Override protected void onHandleIntent(Intent intent) { Log.i(&quot;tag&quot;, intent.getStringExtra(&quot;params&quot;) + &quot; &quot; + Thread.currentThread().getId()); }} 在androidManifest.xml中定义service 123&lt;service android:name=&quot;.MIntentService&quot; /&gt; 启动这个service 12345678title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, MIntentService.class); intent.putExtra(&quot;params&quot;, &quot;ceshi&quot;); startService(intent); } }); 可以发现当点击title组件的时候，service接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，这是为什么呢？ 下面我们来看一下service的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class IntentService extends Service { private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) { super(); mName = name; } /** * Sets intent redelivery preferences. Usually called from the constructor * with your preferred semantics. * * &lt;p&gt;If enabled is true, * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_REDELIVER_INTENT}, so if this process dies before * {@link #onHandleIntent(Intent)} returns, the process will be restarted * and the intent redelivered. If multiple Intents have been sent, only * the most recent one is guaranteed to be redelivered. * * &lt;p&gt;If enabled is false (the default), * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent * dies along with it. */ public void setIntentRedelivery(boolean enabled) { mRedelivery = enabled; } @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } /** * You should not override this method for your IntentService. Instead, * override {@link #onHandleIntent}, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } @Override public void onDestroy() { mServiceLooper.quit(); } /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override public IBinder onBind(Intent intent) { return null; } /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call {@link #stopSelf}. * * @param intent The value passed to {@link * android.content.Context#startService(Intent)}. */ @WorkerThread protected abstract void onHandleIntent(Intent intent);} 怎么样，代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。 下面看一下其onCreate方法： 12345678910111213@Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } 我们可以发现其内部定义一个HandlerIThread（本质上是一个含有消息队列的线程）具体可参考：android源码解析之（四）–&gt;HandlerThread然后用成员变量维护其Looper和Handler，由于其Handler关联着这个HandlerThread的Looper对象，所以Handler的handMessage方法在HandlerThread线程中执行。 然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法： 1234567@Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 很简单就是就是讲startId和启动时接受到的intent对象传递到消息队列中处理，那么我们具体看一下其消息队列的处理逻辑： 1234567891011private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } 可以看到起handleMessage方法内部执行了两个逻辑一个是调用了其onHandlerIntent抽象方法，通过分析其onCreate方法handler对象的创建过程我们知道其handler对象是依附于HandlerThread线程的，所以其handeMessage方法也是在HandlerThread线程中执行的，从而证实了我们刚刚例子中的一个结论，onHandlerIntent在子线程中执行。然后调用了stopSelf方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，参考其他文章我们知道，由于service可以启动N次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，只有当消息队列中最后一个消息被执行完成时才会真正的stop自身。 通过上面的例子与相关说明，我们可以知道： IntentService是一个service，也是一个抽象类； 继承IntentService需要实现其onHandlerIntent抽象方法； onHandlerIntent在子线程中执行； IntentService内部保存着一个HandlerThread、Looper与Handler等成员变量，维护这自身的消息队列； 每次IntentService后台任务执行完成之后都会尝试关闭自身，但是当且仅当IntentService消息队列中最后一个消息被执行完成之后才会真正的stop自身； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThread","link":"/2020/09/11/android%E4%B9%8BIntentService/"},{"title":"8 Zygote进程启动流程","text":"大家都知道android系统的Zygote进程是所有的android进程的父进程，包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的，而Zygote进程则是通过linux系统的init进程启动的，也就是说，android系统中各种进程的启动方式 init进程 –&gt; Zygote进程 –&gt; SystemServer进程 –&gt;各种应用进程 init进程：linux的根进程，android系统是基于linux系统的，因此可以算作是整个android操作系统的第一个进程； Zygote进程：android系统的根进程，主要作用：可以作用Zygote进程fork出SystemServer进程和各种应用进程； SystemService进程：主要是在这个进程中启动系统的各项服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务等等； 各种应用进程：启动自己编写的客户端应用时，一般都是重新启动一个应用进程，有自己的虚拟机与运行环境； 本文主要介绍一下Zygote进程的启动流程，关于SystenServer进程和各种应用进程的启动方式会在以后的文章中介绍。 init进程在启动Zygote进程时一般都会调用ZygoteInit类的main方法，因此我们这里看一下该方法的具体实现(基于android23源码)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String argv[]) { try { RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = &quot;zygote&quot;; String abiList = null; for (int i = 1; i &lt; argv.length; i++) { if (&quot;start-system-server&quot;.equals(argv[i])) { startSystemServer = true; } else if (argv[i].startsWith(ABI_LIST_ARG)) { abiList = argv[i].substring(ABI_LIST_ARG.length()); } else if (argv[i].startsWith(SOCKET_NAME_ARG)) { socketName = argv[i].substring(SOCKET_NAME_ARG.length()); } else { throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); } } if (abiList == null) { throw new RuntimeException(&quot;No ABI list supplied.&quot;); } registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) { startSystemServer(abiList, socketName); } Log.i(TAG, &quot;Accepting command socket connections&quot;); runSelectLoop(abiList); closeServerSocket(); } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; } } 第一行主要是调用enableDdms()，设置DDMS可用，可以发现DDMS启动的时机还是比较早的，在整个Zygote进程刚刚开始要启动额时候就设置可用了。 下面的循环主要是解析main方法的参数获取是否需要启动SystemService进程，获取abi列表，获取scoket连接名称（这里需要注意的是：android系统中进程之间通讯的方式是Binder，但是有一个例外是SystemService进程与Zygote进程之间是通过Socket的方式进行通讯的） 然后调用registerZygoteSocket（String socketName）为Zygote进程注册socket： 123456789101112131415161718192021private static void registerZygoteSocket(String socketName) { if (sServerSocket == null) { int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex); } try { FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); sServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException( &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex); } } } 接着调用系统方法preLoad() 123456789101112static void preload() { Log.d(TAG, &quot;begin preload&quot;); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, &quot;end preload&quot;); } 这其中：preloadClasses()用于初始化Zygote中需要的class类；preloadResources()用于初始化系统资源；preloadOpenGL()用于初始化OpenGL；preloadSharedLibraries()用于初始化系统libraries；preloadTextResources()用于初始化文字资源；prepareWebViewInZygote()用于初始化webview; 然后调用startSystemServer(abiList, socket); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;com.android.server.SystemServer&quot;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } /* For child process */ if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); } return true; } 可以看到这段逻辑的执行逻辑就是通过Zygote fork出SystemServer进程。 总结：Zygote进程mian方法主要执行逻辑： 初始化DDMS； 注册Zygote进程的socket通讯； 初始化Zygote中的各种类，资源文件，OpenGL，类库，Text资源等等； 初始化完成之后fork出SystemServer进程； fork出SystemServer进程之后，关闭socket连接； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCache","link":"/2020/09/11/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"6 android之Log日志","text":"首先说点题外话，对于想学android framework源码的同学，其实可以在github中fork一份，具体地址：platform_frameworks_base这里面基本都是android framework层的源码了。而且最近发现了一个比较不错的github插件：OctoTree，它 是一个浏览器插件，它可以让你在Github 看代码时，左边栏会出现一个树状结构，就像我们在IDE 一样。当我们看一个项目的结构，或者想看具体的某个文件，这样就会很方便。 怎么样这样查看源代码的话是不是很方面？ 好了说一下我们今天需要介绍的Log对象，它位于android framework层utils包下，是一个final class类：查看其具体定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public final class Log { /** * Priority constant for the println method; use Log.v. */ public static final int VERBOSE = 2; /** * Priority constant for the println method; use Log.d. */ public static final int DEBUG = 3; /** * Priority constant for the println method; use Log.i. */ public static final int INFO = 4; /** * Priority constant for the println method; use Log.w. */ public static final int WARN = 5; /** * Priority constant for the println method; use Log.e. */ public static final int ERROR = 6; /** * Priority constant for the println method. */ public static final int ASSERT = 7; private Log() { } /** * Send a {@link #VERBOSE} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int v(String tag, String msg) { return println(LOG_ID_MAIN, VERBOSE, tag, msg); } /** * Send a {@link #VERBOSE} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int v(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, VERBOSE, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #DEBUG} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int d(String tag, String msg) { return println(LOG_ID_MAIN, DEBUG, tag, msg); } /** * Send a {@link #DEBUG} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int d(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, DEBUG, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send an {@link #INFO} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int i(String tag, String msg) { return println(LOG_ID_MAIN, INFO, tag, msg); } /** * Send a {@link #INFO} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int i(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #WARN} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int w(String tag, String msg) { return println(LOG_ID_MAIN, WARN, tag, msg); } /** * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int w(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, msg + '\\n' + getStackTraceString(tr)); } /* * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param tr An exception to log */ public static int w(String tag, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr)); } /** * Send an {@link #ERROR} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int e(String tag, String msg) { return println(LOG_ID_MAIN, ERROR, tag, msg); } /** * Send a {@link #ERROR} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int e(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, ERROR, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Handy function to get a loggable stack trace from a Throwable * @param tr An exception to log */ public static String getStackTraceString(Throwable tr) { if (tr == null) { return &quot;&quot;; } // This is to reduce the amount of log spew that apps do in the non-error // condition of the network being unavailable. Throwable t = tr; while (t != null) { if (t instanceof UnknownHostException) { return &quot;&quot;; } t = t.getCause(); } StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); tr.printStackTrace(pw); pw.flush(); return sw.toString(); } /** * Low-level logging call. * @param priority The priority/type of this log message * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } /** @hide */ public static final int LOG_ID_MAIN = 0; /** @hide */ public static final int LOG_ID_RADIO = 1; /** @hide */ public static final int LOG_ID_EVENTS = 2; /** @hide */ public static final int LOG_ID_SYSTEM = 3; /** @hide */ public static final int LOG_ID_CRASH = 4; /** @hide */ @SuppressWarnings(&quot;unused&quot;) public static int println(int bufID, int priority, String tag, String msg) { return 0; }}可以看到其实final 类，所以我们不能通过继承Log类的方式实现自身的日志工具类，一般的我们可以通过定义Log成员变量的方式，封装Log工具方法； 在Log类中我们定义了六种日志级别，分别是：VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT等六种级别，但是我们平时使用的只有前五种，即VERBOSE,DEBUG,INFO,WARN,ERROR。 通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在github的源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志； 我们暂时只是分析到这里，至于底层的c++日志输出的具体实现不作分析，总结一下： Log.java是一个final类，所以我们不可以继承Log类来实现自己的日志框架，但是可以通过关联（保存Log成员变量）的方式实现自己的Log工具类； Log.java中定义了六种日志级别，但是我们通常只是使用其中的五种日志级别，分别对应着VERBOSE、DEBUG、INFO、WARN、ERROR，在具体的使用场景下具体分析； 有些同学对android自带的日志框架不太满意，主要是无法定位日志位置，这里可以查看我写的一篇实现自定义日志框架的文章：github项目解析（五）–&gt;android日志框架 日志可以个性化的展示相关信息： 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentService","link":"/2020/09/11/android%E4%B9%8BLog%E6%97%A5%E5%BF%97/"},{"title":"24 onSaveInstanceState执行时机","text":"我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍： This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}. 可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。 通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。 Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考: android源码解析之（十四）–&gt;Activity启动流程，文章中有对Activity生命周期的详细讲解。 好吧，先具体看一下ActivityThread.handlePauseActivity的源码： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; }可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { callCallActivityOnSaveInstanceState(r); } ... } 可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的： 1performPauseActivity(token, finished, r.isPreHoneycomb()); 可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的： 1234567public boolean isPreHoneycomb() { if (activity != null) { return activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB; } return false; } 可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法： 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 这里方法体中又回调了Activity的performSaveInstanceState方法。。。 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。 这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。 然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现： 12345678910111213141516171819private void handleStopActivity(IBinder token, boolean show, int configChanges) { ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; StopInfo info = new StopInfo(); performStopActivityInner(r, info, show, true); if (localLOGV) Slog.v( TAG, &quot;Finishing stop of &quot; + r + &quot;: show=&quot; + show + &quot; win=&quot; + r.window); updateVisibility(r, show); info.activity = r; info.state = r.state; info.persistentState = r.persistentState; mH.post(info); mSomeActivitiesChanged = true; } 然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现： 12345678910private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } ... } 可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码： 1performStopActivityInner(r, info, show, true); 好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。 总结 onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。 当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。 当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程","link":"/2020/09/11/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： | 搬瓦工配置 | 搬瓦工费用 | 优惠链接 || — | — | — || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $25.99/半年 | 点击进入 || SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 40 GB RAID-10RAM内存: 2048 MBCPU处理器: 1x Intel XeonTransfer流量: 2000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $27.99/季 | 点击进入 || SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 1x Intel XeonTransfer流量: 1000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $29.99 /半年 | 点击进入 || 80G KVM – PROMOSSD硬盘: 80 GB RAID-10RAM内存: 4 GBCPU处理器: 4x Intel XeonTransfer流量: 3 TB/mo连接速度: 1 GigabitMultiple locations | $19.99/月 | 点击进入 || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $49.99/年 | 点击进入 || 40G KVM – PROMOSSD硬盘: 40 GB RAID-10RAM内存: 2 GBCPU处理器: 3x Intel XeonTransfer流量: 2 TB/mo连接速度: 1 GigabitMultiple locations | $99.99/年 | 点击进入 || 160G KVM – PROMOSSD硬盘: 160 GB RAID-10RAM内存: 8 GBCPU处理器: 5x Intel XeonTransfer流量: 4 TB/mo连接速度: 1 GigabitMultiple locations | $39.99/月 | 点击进入 || 3200G KVM – PROMOSSD硬盘: 320 GB RAID-10RAM内存: 16 GBCPU处理器: 6x Intel XeonTransfer流量: 5 TB/mo连接速度: 1 GigabitMultiple locations | $79.99/月 | 点击进入 | 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：1yum install wget 执行安装ss：1wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限1chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限1chmod +x bbr.sh 启动BBR安装1./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2019/10/11/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%BF%AB%E9%80%9F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BASS(Shadowsocks)%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"注解相关知识","text":"注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解有一个属性value，是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，@Retention 注解指定标记注解的存储方式：RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略。 这是默认的生命周期；RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此运行时环境可以使用它。 @Target 注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：ElementType.ANNOTATION_TYP可以应用于注解类型。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.METHOD 可以应用于方法级注解。ElementType.PACKAGE 可以应用于包声明。ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。 package com.example.inject; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; 在Activity 中增加注解标注，通过注解+反射+动态代理等，来优化Activity中代码。省去 setContentView、findViewById、setOnClickListener等操作。Layout注解12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectLayout { @LayoutRes int value();} View注解12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface InjectView { @IdRes int value();} OnClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent(listenerSetter = &quot;setOnClickListener&quot;, listenerType = View.OnClickListener.class, methodName = &quot;onClick&quot;)public @interface OnClick { int[] value();} OnLongClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent( listenerSetter= &quot;setOnLongClickListener&quot;, listenerType= View.OnLongClickListener.class,methodName = &quot;onLongClick&quot;)public @interface OnLongClick { int[] value();} 元注解 标注 OnClick OnLongClick 的注解1234567@Target(ElementType.ANNOTATION_TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectEvent { String listenerSetter(); Class&lt;?&gt; listenerType(); String methodName();} 注解管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.example.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManage { public static void inJect(Activity activity) { injectLayout(activity); injectView(activity); injectEvent(activity); } /** * 依赖注入 layoutId布局 * 获取 Activity 上的注解 * * @param activity */ private static void injectLayout(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity是否为InjectLayout修饰 if (clazz.isAnnotationPresent(InjectLayout.class)) {// 3.获取InjectLayout注解 InjectLayout annotation = clazz.getAnnotation(InjectLayout.class); if (annotation != null) { try {// 4.通过反射获取 当前Activity 的 setContentView 方法 Method method = clazz.getMethod(&quot;setContentView&quot;, int.class);// 5.获取注解上的value layoutId int resourceId = annotation.value();// 6.调用setContentView method.invoke(activity, resourceId); } catch (Exception e) { e.printStackTrace(); } } } } /** * 依赖注入 获取View * * @param activity */ private static void injectView(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity中所有的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) {// 3. 判断字段是否为InjectView修饰 if (field.isAnnotationPresent(InjectView.class)) { InjectView injectView = field.getAnnotation(InjectView.class); if (injectView != null) { try {// 4.反射获取findViewById方法 Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);// 5.获取资源id int resourceId = injectView.value();// 6.获取View对象 View view = (View) method.invoke(activity, resourceId);// 7.设置访问权限 field.setAccessible(true);// 8.将反射获取到的view赋值到Activity上 field.set(activity, view); } catch (Exception e) { e.printStackTrace(); } } } } } /** * 依赖注入 获取 OnClick OnLongClick注解事件 * 注解 + 反射 + 动态代理 * * @param activity */ private static void injectEvent(Activity activity) { if (activity == null) { throw new NullPointerException(); } try {// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.获取Activity的所有成员方法 排除继承方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) {// 3.是否是自定义注解修饰 if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理 OnClick onClick = method.getAnnotation(OnClick.class); int[] value = onClick.value();// 4.获取注解上的注解 元注解 InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class); String listenerSetter = injectEvent.listenerSetter(); Class&lt;?&gt; listenerType = injectEvent.listenerType(); String methodName = injectEvent.methodName();// 5.动态代理 生成代理的listener ProxyHandler handler=new ProxyHandler(activity); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]{listenerType}, handler); handler.mapMethod(methodName,method);// 6.反射获取 findViewById方法的Method对象 Method findViewByIdMethod = clazz.getMethod(&quot;findViewById&quot;, int.class); findViewByIdMethod.setAccessible(true); for (int id : value) {// 7.通过findViewById获取view View btn = (View) findViewByIdMethod.invoke(activity, id);// 8.根据listenerSetter方法名和listenerType方法参数找到method Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType); listenerSetMethod.setAccessible(true); listenerSetMethod.invoke(btn, listener); } } } } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } }} ProxyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.inject;import android.app.Activity;import android.util.Log;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ProxyHandler implements InvocationHandler { private WeakReference&lt;Activity&gt; mHandlerRef; private HashMap&lt;String, Method&gt; mMethodHashMap; public ProxyHandler(Activity activity) { mHandlerRef = new WeakReference&lt;&gt;(activity); mMethodHashMap = new HashMap&lt;&gt;(); } public void mapMethod(String name, Method method) { mMethodHashMap.put(name, method); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { try { Object handler = mHandlerRef.get(); if (null == handler) return null; String name = method.getName(); //将onClick方法的调用映射到activity 中的注解标注的方法 Method realMethod = mMethodHashMap.get(name);// Log.i(&quot;injectEvent&quot;, &quot;proxy=&quot; + proxy + &quot;,method=&quot; + method.getName() + &quot;,realMethod=&quot; + realMethod); if (null != realMethod) { return realMethod.invoke(handler, args); } } catch (Exception e) { e.printStackTrace(); } return null; }} 12345678910111213141516171819202122232425262728293031323334@InjectLayout(value = R.layout.activity_network)public class NetworkActivity extends AppCompatActivity { @InjectView(R.id.get_data) Button button; @InjectView(R.id.get_data2) Button button2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); InjectManage.inJect(this);// setContentView();// button=findViewById(R.id.button)// button.setOnClickListener(new View.OnClickListener() {// @Override// public void onClick(View v) {// testNetWorkApi();// }// });// button.setOnLongClickListener(new View.OnLongClickListener() {// @Override// public boolean onLongClick(View v) {// return false;// }// }); } @OnClick({R.id.get_data,R.id.get_data2}) public void onClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onClick&quot;); } @OnLongClick(R.id.get_data) public void onLongClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onLongClick&quot;); } 期间遇到点小问题，就是动态代理这块，对这块理解不够深。首先 Activity中 使用OnClick注解修饰的方法onClick()是需要传入参数的，否则在动态代理里，动态代理回调这个方法就会出错。","link":"/2020/09/11/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"搭建WordPress博客教程","text":"本文转自：Nonecy 的小黑屋*链接：http://blog.studymany.com/2018/07/29/create-wordpress-blog/* 需要 一台服务器 一个域名，直接通过ip访问好傻好傻的样子，哈哈。 linux知识 肯折腾 具体步骤第一步购买服务器，国内阿里云的云服务器挺不错的，国外的就更多了，这一步就不介绍了，不懂得的自己上网搜。接下来操作需要： 远程连接服务器Windows 用户 以Xshell为例。 下载安装Xshell，官网链接。 安装完成后新建会话（Alt+N）。依次填写图中信息。名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。 连接 点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） 用户身份验证 填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 Mac OS 用户 打开终端或者iTerm2等。 1ssh root@45.32.195.77 然后输入密码即可。 安装nginx，mysql，php建议使用lnmp一键安装包安装，方便快捷。如果不用一键安装包，我估计得研究这一块的东西大概一周吧。下面以一键安装包为例。 获取lnmp一键安装包链接 lnpm官网链接 找到下载页面选择最新的复制其链接。 写此文时最新版本信息如下： 1234LNMP 1.4 测试版http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz (131KB)MD5：bd851e151b2ba13c3a32c435efb1a76c最后更新: 2017年2月14日14:18 GMT+8 其中的http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz就是我们需要的链接，复制到剪贴板。 安装 12345678# 下载，后边的路径直接粘贴就好。XShell上面复制快捷键是ctrl+insert，粘贴快捷键是Shift+insert，mac上面是我们熟悉的 command+c，command+vwget http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz# 解压tar -zxvf lnmp1.4beta.tar.gz# 进入lnmp目录cd lnmp1.4# 执行install.sh进行安装./install.sh lnmp 依次输入你要安装的选项前的数字并回车即可下一步。 MYSQL 选项 123456789You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.53 (Default)3: Install MySQL 5.6.344: Install MySQL 5.7.165: Install MariaDB 5.5.536: Install MariaDB 10.0.287: Install MariaDB 10.1.190: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 此处根据所需选择，如果使用的上述服务器，请选择2或者直接回车。我选择默认。 注意：安装MySql时，如果选择太高的版本安装会被拒绝，提示信息如下 Memory less than 1GB, can't install MySQL 5.6, 5.7 or MairaDB 10!。根据个人手动安装MySql5.7的经验来看，此768MB内存的服务器在运行一个nginx，mysql，php时还好，倘若再运行一个tomcat，mysql将会不定期down掉。所以此处选择一个低版本的5.5MySql即可。 1234You will install MySQL 5.5.53===========================Please setup root password of MySQL.(Default password: root)Please enter: 输入密码回车或直接回车，直接回车默认密码为root。此处做实验我选择默认，个人实际使用请修改。 1234MySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: 输入Y或者n然后回车或直接回车，直接回车默认启用InnoDB存储引擎。我选择默认。 1234567891011No input,The InnoDB Storage Engine will enable.===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.306: Install PHP 7.0.157: Install PHP 7.1.1Enter your choice (1, 2, 3, 4, 5, 6 or 7): 输入选项然后回车或者直接回车，直接回车默认安装PHP5.5.38版本。我选择默认。 12345You will install PHP 7.1.1===========================You have 3 options for your Memory Allocator install.1: Don't install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMalloc 输入选项然后回车或者直接回车，直接回车默认不安装内存分配器。我选择默认。 此时出现 1Press any key to install...or Press Ctrl+c to cancel 当然是摁任意键啦，一般都是回车咯。 然后出现一大堆信息。前几行如下： 12345678910111213You will install lnmp stack.nginx-1.10.3mysql-5.5.53php-5.5.38Enable InnoDB: yPrint lnmp.conf infomation...Download Mirror: http://soft.vpser.netNginx Additional Modules: PHP Additional Modules: Database Directory: /usr/local/mysql/varDefault Website Directory: /home/wwwroot/defaultCentOS release 6.8 (Final)Kernel \\r on an \\m 这一堆东西你就不用管啦。本次实验的开始时间23:04……经过了漫长漫长漫长的等待之后……大概23:35结束。所以期间你去洗个澡看个电视剧都不是问题。然后我们看到屏幕上最后输出的信息如下。 1234The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.Add Startup and Starting LNMP...Add nginx service at system startup...Starting nginx... doneAdd mysql service at system startup...Starting MySQL... SUCCESS! Add php-fpm service at system startup...Starting php-fpm done============================== Check install ==============================Checking ...Nginx: OKMySQL: OKPHP: OKPHP-FPM: OKClean src directory...+------------------------------------------------------------------------+| LNMP V1.4 for CentOS Linux Server, Written by Licess |+------------------------------------------------------------------------+| For more information please visit https://lnmp.org |+------------------------------------------------------------------------+| lnmp status manage: lnmp {start|stop|reload|restart|kill|status} |+------------------------------------------------------------------------+| phpMyAdmin: http://IP/phpmyadmin/ || phpinfo: http://IP/phpinfo.php || Prober: http://IP/p.php |+------------------------------------------------------------------------+| Add VirtualHost: lnmp vhost add |+------------------------------------------------------------------------+| Default directory: /home/wwwroot/default |+------------------------------------------------------------------------+| MySQL/MariaDB root password: root |+------------------------------------------------------------------------++-------------------------------------------+| Manager for LNMP, Written by Licess |+-------------------------------------------+| https://lnmp.org |+-------------------------------------------+nginx (pid 715 713) is running...php-fpm is runing! SUCCESS! MySQL running (1247)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp6 0 0 :::22 :::* LISTEN Install lnmp V1.4 completed! enjoy it. 简单说明一下，此安装过程安装完成便也启动了nginx，mysql，php-fpm并加入了开机启动项。如果重启服务器，不需要再单独手动开启相关的服务了。总的来说相当方便的。 关于Linux服务，自己之前做的笔记分享给大家。Linux 服务管理 这时候你在浏览器输入http://IP 例如 http://45.32.195.77便可以访问了。看到的内容如下： 访问页面 网站根目录路径/home/wwwroot/default,如果只用来放一些静态页面，那么，现在就足够了，直接将你的html，js，css等文件丢进去即可。这不是本文重点，在此不赘述了。 退出使用ctrl+c 安装WordPress下载WordPress包 中文官方站点英文官方站点具体的根据自己的需求选择。下面以中文版为例。当前最新版本是4.7.2 为了方便，我们还是在用站点默认的路径，但是我们投机取巧一下。 1234567891011121314# 进入根目录上一级目录cd /home/wwwroot/# 将default重命名为oldmv default old# 下载WordPress包中文版wget https://cn.wordpress.org/wordpress-4.7.2-zh_CN.tar.gz# 解压WordPress包tar -zxvf wordpress-4.7.2-zh_CN.tar.gz # 查看解压后的文件夹名，此处是wordpress，估计应该都是吧，看看保险啊[root@vultr wwwroot]# lsold wordpress wordpress-4.7.2-zh_CN.tar.gz# 将wordpress重命名为defaultmv wordpress default# 再次查看检验[root@vultr wwwroot]# lsdefault old wordpress-4.7.2-zh_CN.tar.gz 给相应目录授权 12345# 目录以及目录下的文件授权[root@vultr wwwroot]# chown -R 755 /home/wwwrootchown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted# 将目录的所有者分给www组下的www用户。[root@vultr wwwroot]# chown -R www:www /home/wwwroot/chown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted 出现的提示大概是说有一个文件无法更改用户分组和权限。不会影响你的wordpress，忽略就好。 创建一个数据库wordpress 1234567891011121314151617181920212223242526# 登录数据库mysql -u root -p# 输入密码默认的话就是root，否则就是你自己之前设置的那个# 登录进来之后，看到这样一些东西Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.53-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respective owners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; # 不用理会上面的，创建我们的数据库，比如名字为wordpress。记得加分号。mysql&gt; create database wordpress;# 看一下，有没有我们创建的数据库mysql&gt; show databases;# 大概看到如下内容。意味着这一步也没问题。+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.01 sec)# 退出mysqlexit 配置WordPress 这时候在此通过浏览器访问 http://IP 例如 http://45.32.195.77，浏览器将自动跳转到http://45.32.195.77/wp-admin/setup-config.php，这就是wordpress的配置页面了，看到的内容如下： 访问页面 点击现在就开始。这时候我们看到如下页面: 数据库配置 按照之前设置的，输入如下信息。 12345数据库名：wordpress用户名：root密码：root数据库主机：localhost表前缀：wp_ 点击提交。 数据库连接完成 到这一步，基本上就意味着大功告成了，因为后边基本不会出错啦。 点击进行安装按钮。出现下图： wordpress 设置 按照自己的需求填写，比如我这里填写如下： wordpress 我的设置 点击安装WordPress按钮，然后登录设置啥的纯页面操作就不在这里过多介绍咯。 主页大概是这样的 后期问题解决有问题的反馈在此，我会进行补充。 主题只显示一个原因：php没有权限读取文件目录。 解决方案：编辑php.ini文件中的disable_functions字段，将其中的scandir去掉。 123456# 使用一键安装包安装的php的配置文件路径如下vi /usr/local/php/etc/php.ini# 查找disable_functions在当前的底行模式下输入 /disable_functions,便可以找到这样一行disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server# 删掉其中的scandir，此处很容易搞乱，所以有必要会使用编辑模式，摁i进入编辑模式。就可以输入删除了。# 退出编辑模式，并保存退出。esc退出编辑模式，:wq保存退出。 更多的指令看我之前的一个简单的入门笔记吧。Linux VIM 文本编辑器 然后记得重启php-fpm服务 1/etc/init.d/php-fpm restart 这样再刷新，就会发现主题不只有一个啦。 更多如果你使用MarkDown，那么请安装JetPack插件，如果你需要语法高亮，请安装Crayon Syntax Highlighter。 以后可能会深入研究一下，有机会的话会专门写一篇文章介绍WordPress主题与插件的哈。","link":"/2020/09/11/%E6%90%AD%E5%BB%BA%20WordPress%20%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"},{"title":"20 Dialog取消绘制流程","text":"上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。 有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。 还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码： 123456789101112131415161718title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this.getApplication()); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.cannel(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。 好吧，看一下Dialog的cannel方法的具体实现： 12345678public void cancel() { if (!mCanceled &amp;&amp; mCancelMessage != null) { mCanceled = true; // Obtain a new message so this dialog can be re-used Message.obtain(mCancelMessage).sendToTarget(); } dismiss(); } 可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑： 123456789101112public void setOnCancelListener(final OnCancelListener listener) { if (mCancelAndDismissTaken != null) { throw new IllegalStateException( &quot;OnCancelListener is already taken by &quot; + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;); } if (listener != null) { mCancelMessage = mListenersHandler.obtainMessage(CANCEL, listener); } else { mCancelMessage = null; } }可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。 这样，我们来看一下dismiss方法的实现逻辑： 1234567public void dismiss() { if (Looper.myLooper() == mHandler.getLooper()) { dismissDialog(); } else { mHandler.post(mDismissAction); } } 可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义：12345private final Runnable mDismissAction = new Runnable() { public void run() { dismissDialog(); } };好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。 所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。123456789101112131415161718192021222324void dismissDialog() { if (mDecor == null || !mShowing) { return; } if (mWindow.isDestroyed()) { Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog's window was already destroyed!&quot;); return; } try { mWindowManager.removeViewImmediate(mDecor); } finally { if (mActionMode != null) { mActionMode.finish(); } mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); } }好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。 然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。 然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现： 1234@Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } 可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑: 1234567891011121314151617public void removeView(View view, boolean immediate) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView); } } 可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑： 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。 1234567891011121314151617boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, &quot;Attempting to destroy the window while drawing!\\n&quot; + &quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } 可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839void doDie() { checkThread(); if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface); synchronized (this) { if (mRemoved) { return; } mRemoved = true; if (mAdded) { dispatchDetachedFromWindow(); } if (mAdded &amp;&amp; !mFirst) { destroyHardwareRenderer(); if (mView != null) { int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) { // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try { if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) { mWindowSession.finishDrawing(mWindow); } } catch (RemoteException e) { } } mSurface.release(); } } mAdded = false; } WindowManagerGlobal.getInstance().doRemoveView(this); } 可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void dispatchDetachedFromWindow() { if (mView != null &amp;&amp; mView.mAttachInfo != null) { mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); mView.dispatchDetachedFromWindow(); } mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) { mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; } if (mInputEventReceiver != null) { mInputEventReceiver.dispose(); mInputEventReceiver = null; } try { mWindowSession.remove(mWindow); } catch (RemoteException e) { } // Dispose the input channel after removing the window so the Window Manager // doesn't interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) { mInputChannel.dispose(); mInputChannel = null; } mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals(); } 可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940void dispatchDetachedFromWindow() { AttachInfo info = mAttachInfo; if (info != null) { int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(GONE); } } onDetachedFromWindow(); onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) { imm.onViewDetachedFromWindow(this); } ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewDetachedFromWindow(this); } } if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) { mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; } mAttachInfo = null; if (mOverlay != null) { mOverlay.getOverlayView().dispatchDetachedFromWindow(); } } 其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法： 12345678910111213141516171819protected void onDetachedFromWindowInternal() { mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT; mPrivateFlags3 &amp;= ~PFLAG3_IS_LAID_OUT; removeUnsetPressCallback(); removeLongPressCallback(); removePerformClickCallback(); removeSendViewScrolledAccessibilityEventCallback(); stopNestedScroll(); // Anything that started animating right before detach should already // be in its final state when re-attached. jumpDrawablesToCurrentState(); destroyDrawingCache(); cleanupDraw(); mCurrentAnimation = null; } onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现： 12345678910public void destroyDrawingCache() { if (mDrawingCache != null) { mDrawingCache.recycle(); mDrawingCache = null; } if (mUnscaledDrawingCache != null) { mUnscaledDrawingCache.recycle(); mUnscaledDrawingCache = null; } } 这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。 这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。 而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。 这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：android源码解析之（十五）–&gt;Activity销毁流程当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现： 123456private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... wm.removeViewImmediate(v); ... } 可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。 总结： 窗口的取消绘制流程是相似的，包括Activity和Dialog等； 通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程； Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程","link":"/2020/09/11/Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"27 HOME事件流程","text":"上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。 好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } if (DEBUG_INPUT) { if (fallbackEvent == null) { Slog.d(TAG, &quot;No fallback.&quot;); } else { Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent); } } return fallbackEvent; } 通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现： 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) { ... // First we always handle the home key here, so applications // can never break it, although if keyguard is on, we do let // it handle it, because that gives us the correct 5 second // timeout. if (keyCode == KeyEvent.KEYCODE_HOME) { // If we have released the home key, and didn't do anything else // while it was pressed, then it is time to go home! if (!down) { cancelPreloadRecentApps(); mHomePressed = false; if (mHomeConsumed) { mHomeConsumed = false; return -1; } if (canceled) { Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;); return -1; } // If an incoming call is ringing, HOME is totally disabled. // (The user is already on the InCallUI at this point, // and his ONLY options are to answer or reject the call.) TelecomManager telecomManager = getTelecommService(); if (telecomManager != null &amp;&amp; telecomManager.isRinging()) { Log.i(TAG, &quot;Ignoring HOME; there's a ringing incoming call.&quot;); return -1; } // Delay handling home if a double-tap is possible. if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) { mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); // just in case mHomeDoubleTapPending = true; mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout()); return -1; } handleShortPressOnHome(); return -1; } // If a system window has focus, then it doesn't make sense // right now to interact with applications. WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null; if (attrs != null) { final int type = attrs.type; if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0) { // the &quot;app&quot; is keyguard, so give it the key return 0; } final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length; for (int i=0; i&lt;typeCount; i++) { if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) { // don't do anything, but also don't pass it to the app return -1; } } } // Remember that home is pressed and handle special actions. if (repeatCount == 0) { mHomePressed = true; if (mHomeDoubleTapPending) { mHomeDoubleTapPending = false; mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); handleDoubleTapOnHome(); } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) { preloadRecentApps(); } } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) { if (!keyguardOn) { handleLongPressOnHome(event.getDeviceId()); } } return -1; } // Let the application handle the key. return 0; } 这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。 1234567891011121314private void handleShortPressOnHome() { // Turn on the connected TV and switch HDMI input if we're a HDMI playback device. getHdmiControl().turnOnTv(); // If there's a dream running then use home to escape the dream // but don't actually go home. if (mDreamManagerInternal != null &amp;&amp; mDreamManagerInternal.isDreaming()) { mDreamManagerInternal.stopDream(false /*immediate*/); return; } // Go home! launchHomeFromHotKey(); } 可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现： 123void launchHomeFromHotKey() { launchHomeFromHotKey(true /* awakenFromDreams */, true /*respectKeyguard*/); } 可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) { if (respectKeyguard) { if (isKeyguardShowingAndNotOccluded()) { // don't launch home if keyguard showing return; } if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) { // when in keyguard restricted mode, must first verify unlock // before launching home mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() { @Override public void onKeyguardExitResult(boolean success) { if (success) { try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } }); return; } } // no keyguard stuff to worry about, just launch home! try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } if (mRecentsVisible) { // Hide Recents and notify it to launch Home if (awakenFromDreams) { awakenDreams(); } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); hideRecentApps(false, true); } else { // Otherwise, just launch Home sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } 可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。 1234567891011121314151617@Override public void stopAppSwitches() { if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(&quot;Requires permission &quot; + android.Manifest.permission.STOP_APP_SWITCHES); } synchronized(this) { mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME; mDidAppSwitch = false; mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG); Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG); mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME); } } 可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义： 123// Amount of time after a call to stopAppSwitches() during which we will // prevent further untrusted switches from happening. static final long APP_SWITCH_DELAY_TIME = 5*1000; 然后我们可以看一下mHander的handleMessage方法的具体实现： 12345case DO_PENDING_ACTIVITY_LAUNCHES_MSG: { synchronized (ActivityManagerService.this) { mStackSupervisor.doPendingActivityLaunchesLocked(true); } } break; 可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。 1234567final void doPendingActivityLaunchesLocked(boolean doResume) { while (!mPendingActivityLaunches.isEmpty()) { PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); } } 可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：android源码解析之（十四）–&gt;Activity启动流程 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行… 然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。 123void sendCloseSystemWindows(String reason) { PhoneWindow.sendCloseSystemWindows(mContext, reason); } 可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。 12345678public static void sendCloseSystemWindows(Context context, String reason) { if (ActivityManagerNative.isSystemReady()) { try { ActivityManagerNative.getDefault().closeSystemDialogs(reason); } catch (RemoteException e) { } } } 看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。 12345678910111213141516171819202122232425262728@Override public void closeSystemDialogs(String reason) { enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;); final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try { synchronized (this) { // Only allow this from foreground processes, so that background // applications can't abuse it to prevent system UI from being shown. if (uid &gt;= Process.FIRST_APPLICATION_UID) { ProcessRecord proc; synchronized (mPidsSelfLocked) { proc = mPidsSelfLocked.get(pid); } if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason + &quot; from background process &quot; + proc); return; } } closeSystemDialogsLocked(reason); } } finally { Binder.restoreCallingIdentity(origId); } } 可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。 123456789101112131415void closeSystemDialogsLocked(String reason) { Intent intent = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); if (reason != null) { intent.putExtra(&quot;reason&quot;, reason); } mWindowManager.closeSystemDialogs(reason); mStackSupervisor.closeSystemDialogsLocked(); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, -1, Process.SYSTEM_UID, UserHandle.USER_ALL); } 可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等： 12345678910111213141516171819@Override public void closeSystemDialogs(String reason) { synchronized(mWindowMap) { final int numDisplays = mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) { final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList(); final int numWindows = windows.size(); for (int winNdx = 0; winNdx &lt; numWindows; ++winNdx) { final WindowState w = windows.get(winNdx); if (w.mHasSurface) { try { w.mClient.closeSystemDialogs(reason); } catch (RemoteException e) { } } } } } } 讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。 12345678910111213141516171819202122232425262728void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) { if (awakenFromDreams) { awakenDreams(); } Intent dock = createHomeDockIntent(); if (dock != null) { try { if (fromHomeKey) { dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } startActivityAsUser(dock, UserHandle.CURRENT); return; } catch (ActivityNotFoundException e) { } } Intent intent; if (fromHomeKey) { intent = new Intent(mHomeIntent); intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } else { intent = mHomeIntent; } startActivityAsUser(intent, UserHandle.CURRENT); } 可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。 总结： 系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理； 系统监听到HOME按键之后会首先关闭相应的系统弹窗； 通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程","link":"/2020/09/11/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"10 Launcher启动流程","text":"Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。 不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。 通过上一篇文章，我们知道SystemServer进程主要用于启动系统的各种服务，二者其中就包含了负责启动Launcher的服务，LauncherAppService。具体关于SystenServer的启动流程可以参见： android源码解析之（九）–&gt;SystemServer进程启动流程 在SystemServer进程的启动过程中会调用其main静态方法，开始执行整个SystemServer的启动流程，在其中通过调用三个内部方法分别启动boot service、core service和other service。在调用startOtherService方法中就会通过调用mActivityManagerService.systemReady()方法，那么我们看一下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. mActivityManagerService.systemReady(new Runnable() { @Override public void run() { Slog.i(TAG, &quot;Making services ready&quot;); mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); try { mActivityManagerService.startObservingNativeCrashes(); } catch (Throwable e) { reportWtf(&quot;observing native crashes&quot;, e); } Slog.i(TAG, &quot;WebViewFactory preparation&quot;); WebViewFactory.prepareWebViewInSystemServer(); try { startSystemUi(context); } catch (Throwable e) { reportWtf(&quot;starting System UI&quot;, e); } try { if (networkScoreF != null) networkScoreF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Score Service ready&quot;, e); } try { if (networkManagementF != null) networkManagementF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Managment Service ready&quot;, e); } try { if (networkStatsF != null) networkStatsF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Stats Service ready&quot;, e); } try { if (networkPolicyF != null) networkPolicyF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Policy Service ready&quot;, e); } try { if (connectivityF != null) connectivityF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Connectivity Service ready&quot;, e); } try { if (audioServiceF != null) audioServiceF.systemReady(); } catch (Throwable e) { reportWtf(&quot;Notifying AudioService running&quot;, e); } Watchdog.getInstance().start(); // It is now okay to let the various system services start their // third party code... mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); try { if (wallpaperF != null) wallpaperF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying WallpaperService running&quot;, e); } try { if (immF != null) immF.systemRunning(statusBarF); } catch (Throwable e) { reportWtf(&quot;Notifying InputMethodService running&quot;, e); } try { if (locationF != null) locationF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying Location Service running&quot;, e); } try { if (countryDetectorF != null) countryDetectorF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying CountryDetectorService running&quot;, e); } try { if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying NetworkTimeService running&quot;, e); } try { if (commonTimeMgmtServiceF != null) { commonTimeMgmtServiceF.systemRunning(); } } catch (Throwable e) { reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e); } try { if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e); } try { if (atlasF != null) atlasF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying AssetAtlasService running&quot;, e); } try { // TODO(BT) Pass parameter to input manager if (inputManagerF != null) inputManagerF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying InputManagerService running&quot;, e); } try { if (telephonyRegistryF != null) telephonyRegistryF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e); } try { if (mediaRouterF != null) mediaRouterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MediaRouterService running&quot;, e); } try { if (mmsServiceF != null) mmsServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MmsService running&quot;, e); } } });可以发现这个方法传递了一个Runnable参数，里面执行了各种其他服务的systemReady方法，这里不是我们关注的重点，我们看一下在ActivityManagerService中systemReady方法的具体实现，方法体比较长，我就不在这里贴出代码了，主要的逻辑就是做一些ActivityManagerService的ready操作 1234567public void systemReady(final Runnable goingCallback) { ... // Start up initial activity. mBooting = true; startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); ... } 重点是在这个方法体中调用了startHomeActivityLocked方法，看其名字就是说开始执行启动homeActivity的操作，好了，既然如此，我们再看一下startHomeActivityLocked的具体实现： 12345678910111213141516171819202122232425262728boolean startHomeActivityLocked(int userId, String reason) { if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) { // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don't try to start anything. return false; } Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) { intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) { intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); mStackSupervisor.startHomeActivity(intent, aInfo, reason); } } return true; } 首先是调用getHomeIntent()方法，看一下getHomeIntent是如何实现构造Intent对象的： 12345678Intent getHomeIntent() { Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) { intent.addCategory(Intent.CATEGORY_HOME); } return intent; } 可以发现，启动Launcher的Intent对象中添加了Intent.CATEGORY_HOME常量，这个其实是一个launcher的标志，一般系统的启动页面Activity都会在androidmanifest.xml中配置这个标志。比如我们在github中的android launcher源码中查看其androidmanifest.xml文件：可以发现其Activity的定义intentfilter中就是定义了这样的category。不同的手机厂商可能会修改Launcher的源码，但是这个category一般是不会更改的。 继续回到我们的startHomeActivityLocked方法，我们发现经过一系列的判断逻辑之后最后调用了mStackSupervisor.startHomeActivity方法，然后我们可以查看一下该方法的具体实现逻辑： 12345678910111213141516void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) { moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); startActivityLocked(null /* caller */, intent, null /* resolvedType */, aInfo, null /* voiceSession */, null /* voiceInteractor */, null /* resultTo */, null /* resultWho */, 0 /* requestCode */, 0 /* callingPid */, 0 /* callingUid */, null /* callingPackage */, 0 /* realCallingPid */, 0 /* realCallingUid */, 0 /* startFlags */, null /* options */, false /* ignoreTargetSecurity */, false /* componentSpecified */, null /* outActivity */, null /* container */, null /* inTask */); if (inResumeTopActivity) { // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. scheduleResumeTopActivities(); } } 发现其调用的是scheduleResumeTopActivities()方法，这个方法其实是关于Activity的启动流程的逻辑了，这里我们不在详细的说明，关于Activity的启动流程我们在下面的文章中会介绍。 因为我们的Launcher启动的Intent是一个隐士的Intent，所以我们会启动在androidmanifest.xml中配置了相同catogory的activity，android M中配置的这个catogory就是LauncherActivity。 LauncherActivity继承与ListActivity，我们看一下其Layout布局文件： 12345678910111213141516171819202122&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;TextView android:id=&quot;@android:id/empty&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/activity_list_empty&quot; android:visibility=&quot;gone&quot; android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt;&lt;/FrameLayout&gt; 可以看到我们现实的桌面其实就是一个ListView控件，然后看一下其onCreate方法： 12345678910111213141516171819202122232425262728@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPackageManager = getPackageManager(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); setProgressBarIndeterminateVisibility(true); } onSetContentView(); mIconResizer = new IconResizer(); mIntent = new Intent(getTargetIntent()); mIntent.setComponent(null); mAdapter = new ActivityAdapter(mIconResizer); setListAdapter(mAdapter); getListView().setTextFilterEnabled(true); updateAlertTitle(); updateButtonText(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { setProgressBarIndeterminateVisibility(false); } } 可以看到在LauncherActivity的onCreate方法中初始化了一个PackageManager，其主要作用就是从中查询出系统所有已经安装的应用列表，应用包名，应用图标等信息。然后将这些信息注入到Adapter中，这样就可以将系统应用图标和名称显示出来了。在系统的回调方法onListItemClick中 12345@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } 这也就是为什么我们点击了某一个应用图标之后可以启动某一项应用的原因了，我们看一下这里的intentForPosition是如何实现的。 1234protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); } 这里又调用了adapter的intentForPosition方法： 12345678910111213public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以看到由于adapter的每一项中都保存了应用的包名可启动Activity名称，所以这里在初始化Intent的时候，直接将这些信息注入到Intent中，然后调用startActivity，就将这些应用启动了（关于startActivity是如何启动的下面的文章中我将介绍）。 总结： Launcher的启动流程 Zygote进程 –&gt; SystemServer进程 –&gt; startOtherService方法 –&gt; ActivityManagerService的systemReady方法 –&gt; startHomeActivityLocked方法 –&gt; ActivityStackSupervisor的startHomeActivity方法 –&gt; 执行Activity的启动逻辑，执行scheduleResumeTopActivities()方法。。。。 因为是隐士的启动Activity，所以启动的Activity就是在AndroidManifest.xml中配置catogery的值为： 1public static final String CATEGORY_HOME = &quot;android.intent.category.HOME&quot;; 可以发现android M中在androidManifest.xml中配置了这个catogory的activity是LauncherActivity，所以我们就可以将这个Launcher启动起来了 LauncherActivity中是以ListView来显示我们的应用图标列表的，并且为每个Item保存了应用的包名和启动Activity类名，这样点击某一项应用图标的时候就可以根据应用包名和启动Activity名称启动我们的App了。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程","link":"/2020/09/11/Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"MacOs快捷键说明","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 聚焦快捷键 启动快捷键 iTunes 快捷键：从 iTunes 菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。","link":"/2020/09/11/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"},{"title":"21 PopupWindow加载绘制流程","text":"在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。 在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明： A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. 一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。 在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。 1234567891011121314151617181920212223public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) { LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(layoutId, null); popupWindow = new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg)); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); int[] location = new int[2]; anchorView.getLocationOnScreen(location); popupWindow.setAnimationStyle(R.style.popwin_anim_style); popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12), location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10)); popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() { @Override public void onDismiss() { popupWindow = null; } }); return view; } 可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。 这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现： 123public PopupWindow(View contentView, int width, int height) { this(contentView, width, height, false); }可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑： 1234567891011public PopupWindow(View contentView, int width, int height, boolean focusable) { if (contentView != null) { mContext = contentView.getContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } setContentView(contentView); setWidth(width); setHeight(height); setFocusable(focusable); } 这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。 我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑： 123public void showAtLocation(View parent, int gravity, int x, int y) { showAtLocation(parent.getWindowToken(), gravity, x, y); } 可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式： 12345678910111213141516171819202122232425public void showAtLocation(IBinder token, int gravity, int x, int y) { if (isShowing() || mContentView == null) { return; } TransitionManager.endTransitions(mDecorView); unregisterForScrollChanged(); mIsShowing = true; mIsDropdown = false; final WindowManager.LayoutParams p = createPopupLayoutParams(token); preparePopup(p); // Only override the default if some gravity was specified. if (gravity != Gravity.NO_GRAVITY) { p.gravity = gravity; } p.x = x; p.y = y; invokePopup(p); } 可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637private void preparePopup(WindowManager.LayoutParams p) { if (mContentView == null || mContext == null || mWindowManager == null) { throw new IllegalStateException(&quot;You must specify a valid content view by &quot; + &quot;calling setContentView() before attempting to show the popup.&quot;); } // The old decor view may be transitioning out. Make sure it finishes // and cleans up before we try to create another one. if (mDecorView != null) { mDecorView.cancelTransitions(); } // When a background is available, we embed the content view within // another view that owns the background drawable. if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } mDecorView = createDecorView(mBackgroundView); // The background owner should be elevated so that it casts a shadow. mBackgroundView.setElevation(mElevation); // We may wrap that in another view, so we'll need to manually specify // the surface insets. final int surfaceInset = (int) Math.ceil(mBackgroundView.getZ() * 2); p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset); p.hasManualSurfaceInsets = true; mPopupViewInitialLayoutDirectionInherited = (mContentView.getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT); mPopupWidth = p.width; mPopupHeight = p.height; } preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程： 123456if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } 可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑： 12345678910111213141516private PopupBackgroundView createBackgroundView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupBackgroundView backgroundView = new PopupBackgroundView(mContext); final PopupBackgroundView.LayoutParams listParams = new PopupBackgroundView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height); backgroundView.addView(contentView, listParams); return backgroundView; } 可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。 继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现： 12345678910111213141516private PopupDecorView createDecorView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView; } 可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现： 12345678910111213141516@Override public boolean onTouchEvent(MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); if ((event.getAction() == MotionEvent.ACTION_DOWN) &amp;&amp; ((x &lt; 0) || (x &gt;= getWidth()) || (y &lt; 0) || (y &gt;= getHeight()))) { dismiss(); return true; } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) { dismiss(); return true; } else { return super.onTouchEvent(event); } } 可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。 好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑： 12345678910111213141516private void invokePopup(WindowManager.LayoutParams p) { if (mContext != null) { p.packageName = mContext.getPackageName(); } final PopupDecorView decorView = mDecorView; decorView.setFitsSystemWindows(mLayoutInsetDecor); setLayoutDirectionFromAnchor(); mWindowManager.addView(decorView, p); if (mEnterTransition != null) { decorView.requestEnterTransition(mEnterTransition); } } 我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是： 123if (mWindowManager == null &amp;&amp; mContentView != null) { mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } 而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现： 1234@Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。 1234public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } 这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下： 123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() { @Override public WindowManager createService(ContextImpl ctx) { return new WindowManagerImpl(ctx.getDisplay()); }}); 好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。 这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。 好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。 总结： PopupWindow的界面加载绘制流程也是通过Window对象实现的； PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象； PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程","link":"/2020/09/11/PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; } 在android 中配置 sourceSets { main { jni.srcDirs = [&apos;src/main/jni&apos;, &apos;src/main/jni/&apos;] } } externalNativeBuild { ndkBuild { path &apos;src/main/jni/Android.mk&apos; } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2019/10/11/SerialportManager/"},{"title":"22 Toast加载绘制流程","text":"前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。 其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。 Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。 下面我们来具体看一下Toast窗口的简单使用。 1Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); 上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。 下面我们来看一下makeText方法的具体实现： 1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) { Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; } 方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。 12345678public Toast(Context context) { mContext = context; mTN = new TN(); mTN.mY = context.getResources().getDimensionPixelSize( com.android.internal.R.dimen.toast_y_offset); mTN.mGravity = context.getResources().getInteger( com.android.internal.R.integer.config_toastDefaultGravity); }可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？ 1private static class TN extends ITransientNotification.Stub 从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件： 123LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); 这里我们可以看一下布局文件的具体代码： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。 然后我们通过调用： 1234567TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; 初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。 然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现： 12345678910111213141516public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } 首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。 然后我们执行了： 1INotificationManager service = getService(); 这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式： 1234567static private INotificationManager getService() { if (sService != null) { return sService; } sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; } 这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。 好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) { ... synchronized (mToastQueue) { int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try { ToastRecord record; int index = indexOfToastLocked(pkg, callback); // If it's already in the queue, we update it in place, we don't // move it to the end of the queue. if (index &gt;= 0) { record = mToastQueue.get(index); record.update(duration); } else { // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; } } } } record = new ToastRecord(callingPid, pkg, callback, duration); mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid); } // If it's at index 0, it's the current toast. It doesn't matter if it's // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don't // assume that it's valid after this. if (index == 0) { showNextToastLocked(); } } finally { Binder.restoreCallingIdentity(callingId); } } } 可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。 12345678910111213141516171819202122232425void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } 这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。 1234567private void scheduleTimeoutLocked(ToastRecord r) { mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); } 可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。 12345678910private void handleTimeout(ToastRecord record) { if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) { int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) { cancelToastLocked(index); } } } 好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现： 12345678910111213141516171819void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don't worry about this, we're about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); } } 好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了: 1mToastQueue.remove(index); 清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。 这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现： 12345@Override public void show() { if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); } 好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。 123456final Runnable mShow = new Runnable() { @Override public void run() { handleShow(); } }; 可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738public void handleShow() { if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) { // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) { context = mView.getContext(); } mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) { mParams.horizontalWeight = 1.0f; } if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) { mParams.verticalWeight = 1.0f; } mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); } } 好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章 android源码解析（十八）–&gt;Activity布局绘制流程&nbsp;&nbsp; android源码解析（十七）–&gt;Activity布局加载流程）通过这个方法就实现了Toast窗口的显示逻辑。 继续看一下TN的hide方法： 12345@Override public void hide() { if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); } 好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义： 12345678final Runnable mHide = new Runnable() { @Override public void run() { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; } }; 可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑： 1234567891011121314public void handleHide() { if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) { // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } mView = null; } } 可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。 总结： Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现） Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。 NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。 Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。 NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程","link":"/2020/09/11/Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"15 activity销毁流程","text":"继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？ 这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是： onPause(b)onRestart(a)onStart(a)onResume(a)onStop(b)onDestory(b) 好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。 一：请求销毁当前Activity MyActivity.finish()Activity.finish()ActivityManagerNative.getDefault().finishActivity()ActivityManagerService.finishActivity()ActivityStack.requestFinishActivityLocked()ActivityStack.finishActivityLocked()ActivityStack.startPausingLocked() 首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法： 123public void finish() { finish(false);}然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值： 123456789101112131415161718192021222324private void finish(boolean finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, &quot;Finishing self: token=&quot; + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(); } if (ActivityManagerNative.getDefault() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } 好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。 123456@Overridepublic final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) { ... res = tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true); ...} 这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。 1234567891011121314final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) { ActivityRecord r = isInStackLocked(token); if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES, &quot;Finishing activity token=&quot; + token + &quot; r=&quot; + &quot;, result=&quot; + resultCode + &quot;, data=&quot; + resultData + &quot;, reason=&quot; + reason); if (r == null) { return false; } finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true; } 这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现： 1234567final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) { ... startPausingLocked(false, false, false, false); ... return false; } 好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现： 123456789101112131415161718final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。 二：执行当前Activity的onPause方法 IApplicationThread.schedulePauseActivity()ActivityThread.schedulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused()ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked() 在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现： 123456public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges);} 然后调用了ActivityThread的sendMessage方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 然后又回调了sendMessage的重载方法。。 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码： performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause() 这样我们就回调了第一个生命周期方法：onPause。。。 在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法： 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 这样，我们继续看一下activityPausedLocked方法的实现： 12345final void activityPausedLocked(IBinder token, boolean timeout) { ... completePauseLocked(true); ...} 里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法： 1234private void completePauseLocked(boolean resumeNext) { ... mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); ... } 这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。 三：执行上一个Activity的onResume操作这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程： ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopInnerLocked()IApplicationThread.scheduleResumeActivity()ActivityThread.scheduleResumeActivity()ActivityThread.sendMessage()ActivityTherad.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.H.handleResumeMessage()Activity.performResume()Activity.performRestart()Instrumentation.callActivityOnRestart()Activity.onRestart()Activity.performStart()Instrumentation.callActivityOnStart()Activity.onStart()Instrumentation.callActivityOnResume()Activity.onResume() 好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。 四：执行栈顶Activity的销毁操作 Looper.myQueue().addIdleHandler(new Idler())ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.destroyActivityLocked()IApplicationThread.scheduleDestoryActivity()ActivityThread.scheduleDestoryActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleDestoryActivity()ActivityThread.performDestoryActivity()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop()Instrumentation.callActivityOnDestory()Activity.performDestory()Acitivity.onDestory()ActivityManagerNative.getDefault().activityDestoryed()ActivityManagerService.activityDestoryed()ActivityStack.activityDestoryedLocked() 我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现： 12345final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { .... stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;); .... } 可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现： 12345final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) { ... r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags); ... } 好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现： 1234public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) { sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0, configChanges);} 这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance); if (r != null) { cleanUpPendingRemoveWindows(r); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) { if (r.activity.mVisibleFromServer) { mNumVisibleActivities--; } IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) { if (r.onlyLocalRequest) { // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = v; r.mPendingRemoveWindowManager = wm; } else { wm.removeViewImmediate(v); } } if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) { WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), &quot;Activity&quot;); } r.activity.mDecor = null; } if (r.mPendingRemoveWindow == null) { // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), &quot;Activity&quot;); } // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) { ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), &quot;Activity&quot;); } } if (finishing) { try { ActivityManagerNative.getDefault().activityDestroyed(token); } catch (RemoteException ex) { // If the system process has died, it's game over for everyone. } } mSomeActivitiesChanged = true; } 可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法： 12345678private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... r.activity.performStop(); ... mInstrumentation.callActivityOnDestroy(r.activity); ... } 然后调用了Activity.performStop()方法，查看performStop方法： 12345final void performStop() { ... mInstrumentation.callActivityOnStop(this); ...} 然后调用了Instrumentation.callActivityOnStop()方法： 123public void callActivityOnStop(Activity activity) { activity.onStop(); } 好吧，终于调用了Activity的onStop方法。。。 我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法： 12345public void callActivityOnDestroy(Activity activity) { ... activity.performDestroy(); ...} 然后看一下Activity的performDestroy()方法的实现： 12345678910final void performDestroy() { mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) { mVoiceInteractor.detachActivity(); } } O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。 总结： Activity的销毁流程是从finish方法开始的 Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程","link":"/2020/09/11/activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/"},{"title":"Android异步任务AsyncTask","text":"android的异步任务体系中还有一个非常重要的操作类：AsyncTask，其内部主要使用的是java的线程池和Handler来实现异步任务以及与UI线程的交互。本文主要解析AsyncTask的的使用与源码。 首先我们来看一下AsyncTask的基本使用： 12345678910111213141516171819class MAsyncTask extends AsyncTask&lt;Integer, Integer, Integer&gt; { @Override protected void onPreExecute() { super.onPreExecute(); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } @Override protected void onPostExecute(Integer i) { super.onPostExecute(i); Log.i(&quot;TAG&quot;, &quot;onPostExecute...(开始执行后台任务之后)&quot;); } @Override protected Integer doInBackground(Integer... params) { Log.i(TAG, &quot;doInBackground...(开始执行后台任务)&quot;); return 0; } } 我们定义了自己的MAsyncTask并继承自AsyncTask；并重写了其中的是哪个回调方法：onPreExecute()，onPostExecute（），doInBackground();然后开始调用异步任务： 1new MAsyncTask().execute(); 好了，下面我们开始分析异步任务的执行过程，首先查看一下异步任务的构造方法： 1234567891011121314151617181920212223242526272829303132/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 咋一看AsyncTask的构造方法代码量还是比较多的，但是仔细一看其实这里面只是初始化了两个成员变量：mWorker和mFuture他们分别是：WorkerRunnable和FutureTask，熟悉java的童鞋应该知道这两个类其实是java里面线程池先关的概念。其具体用法大家可以在网上查询，这里具体的细节不在表述，重点是对异步任务整体流程的把握。 总结：异步任务的构造方法主要用于初始化线程池先关的成员变量。 接下来我们看一下execute方法： 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 这里发现该方法中添加一个@MainThread的注解，通过该注解，可以知道我们在执行AsyncTask的execute方法时，只能在主线程中执行，这里可以实验一下： 12345678new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); new MAsyncTask().execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); 然后执行，但是并没有什么区别，程序还是可以正常执行，我的手机的Android系统是Android5.0，具体原因尚未找到，欢迎有知道答案的童鞋可以相互沟通哈。但是这里需要主要的一个问题是：onPreExecute方法是与开始执行的execute方法是在同一个线程中的，所以如果在子线程中执行execute方法，一定要确保onPreExecute方法不执行刷新UI的方法，否则： 123456@Override protected void onPreExecute() { super.onPreExecute(); title.setText(&quot;########&quot;); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } 12345678910111213141516171819Process: com.example.aaron.helloworld, PID: 659 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6981) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1034) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.widget.RelativeLayout.requestLayout(RelativeLayout.java:380) at android.view.View.requestLayout(View.java:17704) at android.widget.TextView.checkForRelayout(TextView.java:7109) at android.widget.TextView.setText(TextView.java:4082) at android.widget.TextView.setText(TextView.java:3940) at android.widget.TextView.setText(TextView.java:3915) at com.example.aaron.helloworld.MainActivity$MAsyncTask.onPreExecute(MainActivity.java:53) at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:587) at android.os.AsyncTask.execute(AsyncTask.java:535) at com.example.aaron.helloworld.MainActivity$1$1.run(MainActivity.java:40) at java.lang.Thread.run(Thread.java:818) 若在子线程中执行execute方法，那么这时候如果在onPreExecute方法中刷新UI，会报错，即子线程中不能更新UI。 继续看刚才的execute方法，我们可以发现其内部调用了executeOnExecutor方法： 123456789101112131415161718192021222324@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } 可以看到其具体的内部实现方法里：首先判断当前异步任务的状态，其内部保存异步任务状态的成员变量mStatus的默认值为Status.PENDING,所以第一次执行的时候并不抛出这两个异常，那么什么时候回进入这个if判断并抛出异常呢，通过查看源代码可以知道，当我们执行了execute方法之后，如果再次执行就会进入这里的if条件判断并抛出异常，这里可以尝试一下： 123456789101112131415161718192021final MAsyncTask mAsyncTask = new MAsyncTask(); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { /*MLog.e(&quot;you have clicked the title textview!!!&quot;); Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent, 101);*/ new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); mAsyncTask .execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); } }); 这里我们可以看到我们定义了一个AsyncTask的对象，并且每次执行点击事件的回调方法都会执行execute方法，当我们点击第一次的时候程序正常执行，但是当我们执行第二次的时候，程序就崩溃了。若这时候第一次执行的异步任务尚未执行完成则会抛出异常： 1Cannot execute task:the task is already running. 若第一次执行的异步任务已经执行完成，则会抛出异常： 1Cannot execute task:the task has already been executed (a task can be executed only once) 继续往下看，在executeOnExecutor中若没有进入异常分之，则将当前异步任务的状态更改为Running，然后回调onPreExecute()方法，这里可以查看一下onPreExecute方法其实是一个空方法，主要就是为了用于我们的回调实现，同时这里也说明了onPreExecute（）方法是与execute方法的执行在同一线程中。 然后将execute方法的参数赋值给mWorker对象那个，最后执行exec.execute(mFuture)方法，并返回自身。 这里我们重点看一下exec.execute(mFuture)的具体实现，这里的exec其实是AsyncTask定义的一个默认的Executor对象： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 那么，SERIAL_EXECUTOR又是什么东西呢？ 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 继续查看SerialExecutor的具体实现： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 可以发现其继承Executor类其内部保存着一个Runnable列表，即任务列表，在刚刚的execute方法中执行的exec.execute(mFuture)方法就是执行的这里的execute方法。这里具体看一下execute方法的实现：1）首先调用的是mTasks的offer方法，即将异步任务保存至任务列表的队尾2）判断mActive对象是不是等于null，第一次运行是null，然后调用scheduleNext()方法3）在scheduleNext()这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。4）在这之后如果再有新的任务被执行时就等待上一个任务执行完毕后才会得到执行，所以说同一时刻只会有一个线程正在执行。5）这里的THREAD_POOL_EXECUTOR其实是一个线程池对象。 然后我们看一下执行过程中mWorker的执行逻辑： 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; 可以看到在执行线程池的任务时，我们回调了doInBackground方法，这也就是我们重写AsyncTask时重写doInBackground方法是后台线程的原因。 然后在任务执行完毕之后会回调我们的done方法： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; 这里我们具体看一下postResultIfNotInvoked方法： 123456private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 其内部还是调用了postResult方法： 1234567private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 这里可以看到起调用了内部的Handler对象的sendToTarget方法，发送异步消息，具体handler相关的内容可以参考： android源码解析之（二）–&gt;异步消息机制 追踪代码，可以查看AsyncTask内部定义了一个Handler对象： 1234567891011121314151617181920private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 可以看到起内部的handleMessage方法，有两个处理逻辑，分别是：更新进入条和执行完成，这里的更新进度的方法就是我们重写AsyncTask方法时重写的更新进度的方法，这里的异步任务完成的消息会调用finish方法： 12345678private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 这里AsyncTask首先会判断当前任务是否被取消，若被取消的话则直接执行取消的方法，否则执行onPostExecute方法，也就是我们重写AsyncTask时需要重写的异步任务完成时回调的方法。 其实整个异步任务的大概流程就是这样子的，其中涉及的知识点比较多，这里总结一下： 异步任务内部使用线程池执行后台任务，使用Handler传递消息； onPreExecute方法主要用于在异步任务执行之前做一些操作，它所在线程与异步任务的execute方法所在的线程一致，这里若需要更新UI等操作，则execute方法不能再子线程中执行。 通过刚刚的源码分析可以知道异步任务一般是顺序执行的，即一个任务执行完成之后才会执行下一个任务。 doInBackground这个方法所在的进程为任务所执行的进程，在这里可以进行一些后台操作。 异步任务执行完成之后会通过一系列的调用操作，最终回调我们的onPostExecute方法 异步任务对象不能执行多次，即不能创建一个对象执行多次execute方法。（通过execute方法的源码可以得知） 所有源码基于android23，中间有什么疏漏欢迎指正。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1AsyncTask/"},{"title":"7 android之LruCache","text":"android开发过程中经常会用到缓存，现在主流的app中图片等资源的缓存策略一般是分两级，一个是内存级别的缓存，一个是磁盘级别的缓存。 作为android系统的维护者google也开源了其缓存方案，LruCache和DiskLruCache。从android3.1开始LruCache已经作为android源码的一部分维护在android系统中，为了兼容以前的版本android的support-v4包也提供了LruCache的维护，如果App需要兼容到android3.1之前的版本就需要使用support-v4包中的LruCache，如果不需要兼容到android3.1则直接使用android源码中的LruCache即可，这里需要注意的是DiskLruCache并不是android源码的一部分。 在LruCache的源码中，关于LruCache有这样的一段介绍： 1A cache that holds strong references to a limited number of values. Each time a value is accessed, it is moved to the head of a queue. When a value is added to a full cache, the value at the end of that queue is evicted and may become eligible for garbage collection. cache对象通过一个强引用来访问内容。每次当一个item被访问到的时候，这个item就会被移动到一个队列的队首。当一个item被添加到已经满了的队列时，这个队列的队尾的item就会被移除。 其实这个实现的过程就是LruCache的缓存策略，即Lru–&gt;(Least recent used)最少最近使用算法。 下面我们具体看一下LruCache的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319public class LruCache&lt;K, V&gt; { private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override {@link #sizeOf}, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); } /** * Sets the size of the cache. * * @param maxSize The new maximum size. */ public void resize(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } synchronized (this) { this.maxSize = maxSize; } trimToSize(maxSize); } /** * Returns the value for {@code key} if it exists in the cache or can be * created by {@code #create}. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } /** * Caches {@code value} for {@code key}. The value is moved to the head of * the queue. * * @return the previous value mapped by {@code key}. */ public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } /** * Removes the entry for {@code key} if it exists. * * @return the previous value mapped by {@code key}. */ public final V remove(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V previous; synchronized (this) { previous = map.remove(key); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, null); } return previous; } /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * {@link #remove}, or replaced by a call to {@link #put}. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a {@link #put} or {@link #remove}. * @param newValue the new value for {@code key}, if it exists. If non-null, * this removal was caused by a {@link #put}. Otherwise it was caused by * an eviction or a {@link #remove}. */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {} /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for {@code key} exists in the cache when this method * returns, the created value will be released with {@link #entryRemoved} * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls {@link #put} while another is creating a value for the same * key. */ protected V create(K key) { return null; } private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); } return result; } /** * Returns the size of the entry for {@code key} and {@code value} in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * * &lt;p&gt;An entry's size must not change while it is in the cache. */ protected int sizeOf(K key, V value) { return 1; } /** * Clear the cache, calling {@link #entryRemoved} on each removed entry. */ public final void evictAll() { trimToSize(-1); // -1 will evict 0-sized elements } /** * For caches that do not override {@link #sizeOf}, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. */ public synchronized final int size() { return size; } /** * For caches that do not override {@link #sizeOf}, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() { return maxSize; } /** * Returns the number of times {@link #get} returned a value that was * already present in the cache. */ public synchronized final int hitCount() { return hitCount; } /** * Returns the number of times {@link #get} returned null or required a new * value to be created. */ public synchronized final int missCount() { return missCount; } /** * Returns the number of times {@link #create(Object)} returned a value. */ public synchronized final int createCount() { return createCount; } /** * Returns the number of times {@link #put} was called. */ public synchronized final int putCount() { return putCount; } /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() { return evictionCount; } /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() { return new LinkedHashMap&lt;K, V&gt;(map); } @Override public synchronized final String toString() { int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); }}可以看到LruCache初始化的时候需要使用泛型，一般的我们这样初始化LruCache对象： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 这里我们假设通过String作为key保存bitmap对象，同时需要传递一个int型的maxSize数值，主要用于设置LruCache链表的最大值。 查看其构造方法： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 可以看到其主要的是初始化了maxSize和map链表对象。 然后查看put方法： 12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } 需要传递两个参数：K和V，首先做了一下参数的判断，然后定义一个保存前一个Value值得临时变量，让putCount（put执行的次数）自增，让map的size大小自增。需要注意的是这里的 1previous = map.put(key, value); 我们看一下这里的map.put（）的具体实现： 1234567891011121314151617181920212223242526@Override public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { if (e.hash == hash &amp;&amp; key.equals(e.key)) { preModify(e); V oldValue = e.value; e.value = value; return oldValue; } } // No entry for (non-null) key is present; create one modCount++; if (size++ &gt; threshold) { tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } 将Key与Value的值压入Map中，这里判断了一下如果map中已经存在该key，value键值对，则不再压入map，并将Value值返回，否则将该键值对压入Map中，并返回null； 返回继续put方法： 1234previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } 可以看到这里我们判断map.put方法的返回值是否为空，如果不为空的话，则说明我们刚刚并没有将我么你的键值对压入Map中，所以这里的size需要自减； 然后下面： 123if (previous != null) { entryRemoved(false, key, previous, value); } 这里判断previous是否为空，如果不为空的话，调用了一个空的实现方法entryRemoved()，也就是说我们可以实现自己的LruCache并在添加缓存的时候若存在该缓存可以重写这个方法； 下面调用了trimToSize(maxSize)方法： 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } 该方法主要是判断该Map的大小是否已经达到阙值，若达到，则将Map队尾的元素（最不常使用的元素）remove掉。 总结：LruCache put方法，将键值对压入Map数据结构中，若这是Map的大小已经大于LruCache中定义的最大值，则将Map中最早压入的元素remove掉； 查看get方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } 可以看到参数值为Key，简单的理解就是通过key值从map中取出Value值。具体来说，判断map中是否含有key值value值，若存在，则hitCount（击中元素数量）自增，并返回Value值，若没有击中，则执行create(key)方法，这里看到create方法是一个空的实现方法，返回值为null，所以我们可以重写该方法，在调用get（key）的时候若没有找到value值，则自动创建一个value值并压入map中。 总结： LruCache，内部使用Map保存内存级别的缓存 LruCache使用泛型可以设配各种类型 LruCache使用了Lru算法保存数据（最短最少使用least recent use） LruCache只用使用put和get方法压入数据和取出数据 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Log","link":"/2020/09/11/android%E4%B9%8BLruCache/"},{"title":"25 onLowMemory执行流程","text":"上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：android源码解析（二十四）–&gt;onSaveInstanceState执行时机 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。 这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。 通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考： android源码解析之（九）–&gt;SystemServer进程启动流程）其中在SystemServer的startBootService方法中我们调用了： 12// Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); 方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this)); ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this)); ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this)); } ServiceManager.addService(&quot;permission&quot;, new PermissionController(this)); ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) { ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) { mPidsSelfLocked.put(app.pid, app); } updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } } catch (PackageManager.NameNotFoundException e) { throw new RuntimeException( &quot;Unable to find android system package&quot;, e); } } 这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑： 12345678910111213141516171819static class MemBinder extends Binder { ActivityManagerService mActivityManagerService; MemBinder(ActivityManagerService activityManagerService) { mActivityManagerService = activityManagerService; } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { if (mActivityManagerService.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) { pw.println(&quot;Permission Denial: can't dump meminfo from from pid=&quot; + Binder.getCallingPid() + &quot;, uid=&quot; + Binder.getCallingUid() + &quot; without permission &quot; + android.Manifest.permission.DUMP); return; } mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, &quot; &quot;, args, false, null); } }查看源码，我们可以发现MemBinder类继承于Binder类也就是说其实一个Binder类型的服务，并且有一个成员方法dump，该方法主要用于执行shell命令，当系统可用内存比较低的时候就会执行了该方法，然后回调到ActivityManagerService中的killAllBackground方法，下面我们重点看一下killAllBackground方法的具体实现： 123456789@Override public void killAllBackgroundProcesses() { ... doLowMemReportIfNeededLocked(null); ... } finally { Binder.restoreCallingIdentity(callingId); } } 可以看到这个方法体中会执行doLowMemReportIfNeededLocked方法，该方法是做什么的呢?我们继续看一下doLowMemReportIfNeededLoced方法的实现： 12345final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) { ... scheduleAppGcsLocked(); ... } 好吧，在这个方法中我们又调用了scheduleAppGcsLocked方法，这样我们就继续看一下scheduleAppGcsLocked方法的实现逻辑： 12345678910111213141516171819/** * Schedule the execution of all pending app GCs. */ final void scheduleAppGcsLocked() { mHandler.removeMessages(GC_BACKGROUND_PROCESSES_MSG); if (mProcessesToGc.size() &gt; 0) { // Schedule a GC for the time to the next process. ProcessRecord proc = mProcessesToGc.get(0); Message msg = mHandler.obtainMessage(GC_BACKGROUND_PROCESSES_MSG); long when = proc.lastRequestedGc + GC_MIN_INTERVAL; long now = SystemClock.uptimeMillis(); if (when &lt; (now+GC_TIMEOUT)) { when = now + GC_TIMEOUT; } mHandler.sendMessageAtTime(msg, when); } } 可以发现这里执行的逻辑就是通过mHandler发送一个msg.what为GC_BACKGROUND_PROCESSES_MSG的异步消息，这样消息体最终会被mHandler的handleMessage方法所执行，继续看一下mHandler的handleMessage方法的执行逻辑： 12345case GC_BACKGROUND_PROCESSES_MSG: { synchronized (ActivityManagerService.this) { performAppGcsIfAppropriateLocked(); } } break; 在mHandler的handleMessage方法中，首先会判断msg的what是否为GC_BACKGROUND_PROCESSES_MSG，然后会执行performAppGcsIfAppropriateLocked方法，这样我们继续看一下performAppGcsIfAppropriateLocked方法的实现： 1234567891011/** * If all looks good, perform GCs on all processes waiting for them. */ final void performAppGcsIfAppropriateLocked() { if (canGcNowLocked()) { performAppGcsLocked(); return; } // Still not idle, wait some more. scheduleAppGcsLocked(); } 可以发现这里首先判断是否能够执行gc操作，若不能继续执行上面的scheduleAppGcsLocked方法，然后继续执行发送异步消息的逻辑，直到变量canGcNowLocked为true，并执行performAppGcsLocked方法，然后return掉，这样我们继续跟踪代码，看一下performAppGcsLocked方法的执行逻辑： 1234567891011121314151617181920212223242526272829303132/** * Perform GCs on all processes that are waiting for it, but only * if things are idle. */ final void performAppGcsLocked() { final int N = mProcessesToGc.size(); if (N &lt;= 0) { return; } if (canGcNowLocked()) { while (mProcessesToGc.size() &gt; 0) { ProcessRecord proc = mProcessesToGc.remove(0); if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) { if ((proc.lastRequestedGc+GC_MIN_INTERVAL) &lt;= SystemClock.uptimeMillis()) { // To avoid spamming the system, we will GC processes one // at a time, waiting a few seconds between each. performAppGcLocked(proc); scheduleAppGcsLocked(); return; } else { // It hasn't been long enough since we last GCed this // process... put it in the list to wait for its time. addProcessToGcListLocked(proc); break; } } } scheduleAppGcsLocked(); } } 可以发现该方法经过一系列的逻辑判断之后会执行performAppGcLocked方法，我们继续看一下该方法的实现： 123456789101112131415161718/** * Ask a given process to GC right now. */ final void performAppGcLocked(ProcessRecord app) { try { app.lastRequestedGc = SystemClock.uptimeMillis(); if (app.thread != null) { if (app.reportLowMemory) { app.reportLowMemory = false; app.thread.scheduleLowMemory(); } else { app.thread.processInBackground(); } } } catch (Exception e) { // whatever. } } 可以发现最终执行的是app.thread.scheduleLowMemory方法，而这里的app.thread是ActivityThread.ApplicationThread对象，所以这里最终是通过Binder进程间通讯，执行的是ActivityThread.ApplicationThread的scheduleLowMemory方法，好吧让我们看一下ActivityThread.ApplicationThread的scheduleLowMemory方法的实现逻辑… 1234@Override public void scheduleLowMemory() { sendMessage(H.LOW_MEMORY, null); } 在ActivityThread中的scheduleLowMemory方法中并没有执行额外逻辑，而是直接调用了sendMessage方法，继续跟踪方法的执行： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现在sendMessage方法中最终通过一个Handler类型的mH成员变量发送一个异步消息，这样异步消息最终会被mH的handleMessage方法执行。。。。，经过查看源代码我们知道在mH的handleMessage方法中最终调用的是handleLowMemory方法： 12345678910111213141516171819202122final void handleLowMemory() { ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(true, null); final int N = callbacks.size(); for (int i=0; i&lt;N; i++) { callbacks.get(i).onLowMemory(); } // Ask SQLite to free up as much memory as it can, mostly from its page caches. if (Process.myUid() != Process.SYSTEM_UID) { int sqliteReleased = SQLiteDatabase.releaseMemory(); EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased); } // Ask graphics to free up as much as possible (font/image caches) Canvas.freeCaches(); // Ask text layout engine to free also as much as possible Canvas.freeTextLayoutCaches(); BinderInternal.forceGc(&quot;mem&quot;); } 可以发现这里通过遍历ComponentCallbacks2并执行了其onLowMemory方法，那么这里的ComponentCallBacks2是什么呢？这里我们查看一下collectComponentCallbacks方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks( boolean allActivities, Configuration newConfig) { ArrayList&lt;ComponentCallbacks2&gt; callbacks = new ArrayList&lt;ComponentCallbacks2&gt;(); synchronized (mResourcesManager) { final int NAPP = mAllApplications.size(); for (int i=0; i&lt;NAPP; i++) { callbacks.add(mAllApplications.get(i)); } final int NACT = mActivities.size(); for (int i=0; i&lt;NACT; i++) { ActivityClientRecord ar = mActivities.valueAt(i); Activity a = ar.activity; if (a != null) { Configuration thisConfig = applyConfigCompatMainThread( mCurDefaultDisplayDpi, newConfig, ar.packageInfo.getCompatibilityInfo()); if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) { // If the activity is currently resumed, its configuration // needs to change right now. callbacks.add(a); } else if (thisConfig != null) { // Otherwise, we will tell it about the change // the next time it is resumed or shown. Note that // the activity manager may, before then, decide the // activity needs to be destroyed to handle its new // configuration. if (DEBUG_CONFIGURATION) { Slog.v(TAG, &quot;Setting activity &quot; + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig); } ar.newConfig = thisConfig; } } } final int NSVC = mServices.size(); for (int i=0; i&lt;NSVC; i++) { callbacks.add(mServices.valueAt(i)); } } synchronized (mProviderMap) { final int NPRV = mLocalProviders.size(); for (int i=0; i&lt;NPRV; i++) { callbacks.add(mLocalProviders.valueAt(i).mLocalProvider); } } return callbacks; } 可以发现该方法最终返回类型为ArrayList类型的callBacks而我们的callBacks中保存的是我们应用进程中的Activity，Service，Provider已经Application等。咦？Activity，Service，Provider，Application都是ComponentCallBacks2类型的么？我们看一看一下具体的定义： Actvity的类定义： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback Service的类定义： 1public abstract class Service extends ContextWrapper implements ComponentCallbacks2 ContentProvider的类定义： 1public abstract class ContentProvider implements ComponentCallbacks2 Application的类定义： 1public class Application extends ContextWrapper implements ComponentCallbacks2 可以发现其都是继承与ComponentCalbacks2，所以其都可以被当做是ComponentCallbacks2类型的变量。而同样是四大组件的BroadcastReceiver，我们可以下其类定义： 1public abstract class BroadcastReceiver 可以看到其并未继承与ComponentCallbacks2，所以并未执行，所以通过这样的分析，我们知道了，最终应用程序中的Activity，Servier，ContentProvider，Application的onLowMemory方法会被执行。而由于我们是在系统内存紧张的时候会执行killAllBackground方法进而通过层层条用执行Activity、Service、ContentProvider、Application的onLowMemory方法，所以我们可以在这些组件的onLowMemory方法中执行了一些清理资源的操作，释放一些内存，尽量保证自身的应用进程不被杀死。 总结： 系统在JNI层会时时检测内存变量，当内存过低时会通过kiilbackground的方法清理后台进程。 经过层层的调用过程最终会执行Activity、Service、ContentProvider、Application的onLowMemory方法。 可以在组件的onLowMemory方法中执行一些清理资源的操作，释放内存防止进程被杀死。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机","link":"/2020/09/11/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"11 应用进程启动流程","text":"转载请标明出处：一片枫叶的专栏 在android guide中有这样的一段关于android应用程序进程的描述： 1By default, every application runs in its own Linux process. Android starts the process when any of the application's components need to be executed, then shuts down the process when it's no longer needed or when the system must recover memory for other applications. 每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。 本节主要是通过分析Activity的启动过程介绍应用程序进程的启动流程。 在上一篇文章中我们简要的介绍了Launcher的启动流程，在SystemServer进程执行完成，各种系统服务启动完成之后，会调用ActivityManagerService中的systemReady()方法，在systemReady（）方法中会执行Launcher启动的相关逻辑了，具体可以参考： android源码解析之（十）–&gt;Launcher启动流程 Launcher应用程序在启动过程中会通过PackageManagerService服务请求查询系统所有的已安装应用的包名，图标和应用名称等信息，然后填充到Launcher中的Adapter中，这样点击某一项应用图标的时候就可以根据该图标的包名和启动Activity的类名初始化Intent对象，然后调用startActivity(Intent)启动相关的应用程序了。 其实android中应用进程可以通过许多方式启动，比如启动一个Activity，启动一个Service，启动一个ContentProvider或者是一个BroadcastReceiver，也就是说我们可以通过启动四大组件的方式启动应用进程，在应用进程没有启动的时候，如果我们通过启动这些组件，这时候系统会判断当前这些组件所需要的应用进程是否已经启动，若没有的话，则会启动应用进程。 这里我们通过Launcher简单分析一下应用进程的启动流程。通过上一篇Launcher启动流程，我们知道每一个launcher中的图标对应着一个应用报名和启动activity类名，查看LauncherActivity中的图标点击事件: 1234protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }在通过应用包名和启动activity类名构造完成Intent之后，我们调用了startActivity方法来启动这个activity，很明显的，当前这个应用并没有启动，也就是说我们调用的startActivity方法不单单为我们启动了这个activity也同时在启动activity之前启动了这个应用进程，好了，那我们这里就以这个方法为入口分析一下应用进程的启动流程。 跟踪代码到Activity，发现其调用了startActivity的重载方法： 1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); } 继续跟进： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 很明显的我们此时传递的options为空： 123public void startActivityForResult(Intent intent, int requestCode) { startActivityForResult(intent, requestCode, null); } 好吧，最后调用的还是这个重载方法： 123456789101112131415161718192021222324252627public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现这里调用了mInstrumentation.execStartActivity方法，这里先简单介绍一下Instrumentation对象，他是Android系统中应用程序端操作Activity的具体操作类，这里的操作段是相对于ActivityManagerService服务端来说的。也就是说当我们在执行对Activity的具体操作时，比如回调生命周期的各个方法都是借助于Instrumentation类来实现的。 好了，下面我们继续看一下Instrumentation的execStartActivity方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 这里主要关注这个代码： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这断代码实际上是进程间通讯，我们可以发现ActivityManagerNative继承于Binder接口，所以ActivityManagerNative就是一个Binder对象，然后上面一节我们介绍SystemServer进程的时候对ActivityManagerService有过了解，发现其继承于ActivityManagerNative，好吧，了解过Binder机制的童鞋就知道了，ActivityManagerService就是这个Binder机制的服务器端而ActivityManagerNative就是这个Binder机制的客户端，所以我们这里调用的startActivity实际上是讲参数传递给ActivityManagerService并执行ActivityManagerService的startActivity方法。 既然这样，我们看一下ActivityManagerService的startActivity方法： 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 调用了startActivityAsUser方法，然后我们继续看一下startActivityAsUser方法： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 继续查看startActivityMayWait方法： 1234567891011121314151617181920final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } } 这个方法的逻辑比较多，我们重点关注的是其调用了startActivityLocked方法，也就是说在初始化其他逻辑之后，这个方法会调用startActivityLocked方法： 12err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); 代码量也是比较大的，在方法体中调用了startActivityUncheckedLocked方法，然后我们继续跟进startActivityUncheckedLocked方法： 1targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); 然后我们查看startActivityLocked方法的实现： 123if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } 可以发现其调用了resumeTopActivitiesLocked方法： 1stack.resumeTopActivityLocked(null); 继续跟进： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后我们看一下resumeTopActivityLocked方法的实现： 1result = resumeTopActivityInnerLocked(prev, options); 继续查看resumeTopActivityInnerLocked方法的实现： 1mStackSupervisor.startSpecificActivityLocked(next, true, true); 可以发现在方法体中执行了相关逻辑判断与初始化操作之后调用了startSpecificActivityLocked方法： 12mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); 可以发现在方法体中调用了startProcessLocked方法，从名字可以看出来这个方法就是启动进程的。 123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); } 查看startProcessLocked方法的实现： 1234checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;); startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, &quot;startProcess: done starting proc!&quot;); 查看startProcessLocked方法的具体实现； 123456checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); 查看关键代码，这里调用了Process.start方法： 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 这里的processClass就是要启动的进程的名称，这里传递的就是ActivityThread： 1&quot;android.app.ActivityThread&quot; 具体的Process启动进程的Native层代码这里不做过多的分析，这个方法就是启动了AcitivtyThread进程并执行了ActivityThread的main方法，所以我们经常说的进程的启动方法就是ActivityThread的main方法就是这里体现的。 总结： android应用进程会在需要启动其组件的时候启动，当没有任何组件运行或者是系统内存较低的时候应用进程会被杀死。 在启动应用四大组件的时候若发现当前应用的进程没有启动，则会首先启动应用程序的进程。 我们可以为应用程序配置多个进程，每个进程都有自己的JVM和运行环境，各个进程之间的通讯需要通过Binder机制。 Launcher启动的过程也是先启动Launcher进程再启动其Activity组件。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"各种学习资料，包括一些百度云视频链接还有pdf资料 --搬运工","text":"人生不如意事常八九 共勉 【0】Springboot微服务开发天气预报系统视频教程 https://pan.baidu.com/s/1joz7flyztCq8oklBlsz8dQ 提取密码：cpz7 【1】JAVA300集大型视频教程2018版发布 https://pan.baidu.com/s/1Bqy4mWSD1idd6JmIzS9ZLg 提取密码：llg2 【2】Vue2.5开发去旅游网站App从零基础入门到实战项目 https://pan.baidu.com/s/1DYCoIw_b893KXGkkYt_92Q 提取密码：bgoy 【3】opencv+tensorflow入门人工智能图像处理视频教程+源码下载 https://pan.baidu.com/s/10WefZkTQST094L5UQA7myg 提取密码：7b9w 【4】最新BAT面试真题讲解，想去大厂的别错过 https://pan.baidu.com/s/1ejf2Eh8ZA-T1bWbuT6gw0A 提取密码：mist 【5】Python3异步IO并发编程高级进阶视频教程下载 https://pan.baidu.com/s/1jiRwD5MNPmAKF98nXYzmKg 提取密码：hct4 【6】最新大数据数据分析与挖掘高级工程师第三期视频教程 https://pan.baidu.com/s/1g8xGPag9GiMA4_MEKbxePw 提取密码：z2v3 【7】姜承尧MYSQL,DBA视频课程(44天全)视频教程下载 https://pan.baidu.com/s/19NUjkkvdDZXhw1QG4yX21Q 提取密码：funf 【8】Python+AnsiblePlaybook+Django自动化运维项目实践课程 https://pan.baidu.com/s/1CfOHuaYi_TdPoAUzP9AW1w 提取密码：o3rc 【9】springcloud微服务实践-分布式与原理剖析链路追踪容器 https://pan.baidu.com/s/1g8QoqOnQwjI7N3zDSccr-w 提取密码：ygf5 【10】2018年最新Java高并发知识体系与高并发编程架构课程视频教程下载 https://pan.baidu.com/s/1E1NhSevRqwdnguiKSsOp5A 提取密码：mkh2 【11】2018年最新价值300Python人工智能TensorFlow框架应用实践视频课程下载 https://pan.baidu.com/s/1qYJjFz9aG6M5grMg311uRQ 提取密码：5hzp 【12】谭州学院价值1680元python视频教程12306网站案例vip特训班教程 https://pan.baidu.com/s/1yEQq5W1eSc3NA4XmyNmuJw 提取密码：cipi 【13】下载 https://pan.baidu.com/s/1D6hYdyi4ti2zpnKHVWWbEg 提取密码：glov 【14】Netty实战高性能分布式RPC视频教程下载 https://pan.baidu.com/s/1sDHh_g624MO08MTFIrwEDw 提取密码：mwa6 【15】2018年最新尚学堂Vue2全套学习视频教程下载 https://pan.baidu.com/s/147NvAV-Qse90xvTYDvHBcg 提取密码：wpfg 【16】最新2018疯狂SpringCloud微服务架构实战视频教程 https://pan.baidu.com/s/1jgC0lagtMG7tArATrAAHXg 提取密码：10kf 【17】kotlin高级教程从零开始开发完整安卓商城app https://pan.baidu.com/s/13F_C1aKuJ0ek5Kv-HWdygw 提取密码：krq2 【18】2018年最新疯狂Activiti6视频教程疯狂工作流讲义Activiti6.x视频教程 https://pan.baidu.com/s/1SriGV7tZAeSvYcYb6l_hdQ 提取密码：bzcu 【19】基于MyCat的MySQL高可用读写分离集群实战课程下载 https://pan.baidu.com/s/1DVCf57_O1iMDJkbOGxdnpw 提取密码：6a08 【20】2018年最新Webpack3由浅入深及搭载vue,react,angular框架多维度讲解 https://pan.baidu.com/s/1BYq5qb9fFMSyODlORBQCcw 提取密码：6wf3 【21】2018年最新Spark机器学习课程：智能客户系统项目实战视频教程 https://pan.baidu.com/s/12SrMtvLBlVJGOlOt5NQFjw 提取密码：uu9v 【22】最新离线数据分析平台实战驴妈妈项目实战培训视频教程 https://pan.baidu.com/s/129jhYGDLFzsM7BW5HYdg7Q 提取密码：vhjs 【23】2018年最新尚硅谷java9新特性视频教程下载 https://pan.baidu.com/s/1xC-xPm54rFMLAHYwis1Thg 提取密码：f0v6 【24】最新北风网人工智能+机器学习+深度学习+推荐系统实战第3期视频教程 https://pan.baidu.com/s/1E98ZYCtJ7Mom_tWZT6AM_g 提取密码：3abb 【25】[全栈开发]Vue+DjangoRESTframework打造生鲜电商项目视频教程 https://pan.baidu.com/s/1vFAkTEdydgL-GjdcpeEHGg 提取密码：k00f 【26】2018年最新node.js+ES+Koa2手把手教你开发一个短视频网站视频教程 https://pan.baidu.com/s/1jmxxQ88J_qWsovXkMNeDpQ 提取密码：46yh 【27】基于Java的微信平台开发教程视频下载 https://pan.baidu.com/s/1hMq-J7KFMuDezGSdzX35OA 提取密码：oycw 【28】最新精选蚂蚁-MySQL语句性能优化视频教程下载 https://pan.baidu.com/s/1miVf8Ze 提取密码：w5yt 【29】深度学习实战项目-利用RNN与LSTM网络原理进行唐诗生成视频课程 https://pan.baidu.com/s/1i6jyFtz 提取密码：vrzx 【30】2018年最新微信小游戏开发ES6+小游戏api开发视频教程下载 https://pan.baidu.com/s/1i7mwJCp 提取密码：ndl7 【31】最新甲骨论-Linux大数据及数据库存储视频教程下载 https://pan.baidu.com/s/1smi2oNj 提取密码：ypgn 【32】泰牛2017php基础班大牛班完整视频教程下载 https://pan.baidu.com/s/1ggKGo9d 提取密码：2tqk 【33】2018年最新Java微服务原理课程与改造房产销售平台视频教程 https://pan.baidu.com/s/1jKf8MMi 提取密码：i8ej 【34】使用dubbo、spring-boot等技术实现互联网后台服务项目架构视频教程 https://pan.baidu.com/s/1gg1JiBD 提取密码：1jtk 【35】最新区块链开发入门到精通视频教程下载 https://pan.baidu.com/s/1kW7FTwr 提取密码：hvep 【36】2018年最新价值1699元的深入大数据架构师之路，问鼎40万年薪视频教程下载 https://pan.baidu.com/s/1c3d1RbU 提取密码：22kw 【37】2018年最新java大数据基于storm开发实时流处理器视频教程 https://pan.baidu.com/s/1cOCHPk 提取密码：igw9 【38】2017年最新JAVA-ACE-架构师系列视频课程-RocketMQhttps://pan.baidu.com/s/1ghb9UAf 提取密码：sstz 【39】2017年深度学习项目实战视频课程-Seq2Seq序列生模型视频教程 https://pan.baidu.com/s/1dGEDwSp 提取密码：96eh 【40】2017年最新web前端工程师小白零基础入门到大神全套教程下载 https://pan.baidu.com/s/1dFQ8wgT 提取密码：7g4e 【41】2017年最新python高级模块matplotlib数据可视化分析视频教程 https://pan.baidu.com/s/1kWyRVmB 提取密码：qjaj 【42】价值1680元安卓特训班实战开发百思不得姐app项目教程下载 https://pan.baidu.com/s/1c3adHsc 提取密码：sxvg 【43】2018年最新价值799元Elasticsearch顶尖高手系列：高手进阶篇视频教程 https://pan.baidu.com/s/1mkkSBrU 提取密码：zmjn 【44】2017年最新深度学习框架Caffe使用案例视频课程下载 https://pan.baidu.com/s/1dGFsBnz 提取密码：q4dg 【45】炼数成精大数据的矩阵计算基础课程下载 https://pan.baidu.com/s/1mkaJbpY 提取密码：pnnc 【46】2018年最新redis从入门到精通与分布式架构视频教程下载 https://pan.baidu.com/s/1gggc7Fd 提取密码：img8 【47】2018年最新动力节点Java夜校视频教程下载 https://pan.baidu.com/s/1i6v7013 提取密码：dbnt 【48】全网最新基于ElasticSearch的找房网实战开发企业级房屋搜索网视频教程下载 https://pan.baidu.com/s/1bqUVrsF 提取密码：idjy 【49】Java高性能高并发秒杀系统实战视频教程下载 https://pan.baidu.com/s/1bqVBoqb 提取密码：ztqe 【50】2017最新最系统的PHP面试视频教程下载高薪无忧 https://pan.baidu.com/s/1o81Mu8q 提取密码：da2f 【51】2017年最新炼数成金机器读心术之神经网络与深度学习视频教程下载 https://pan.baidu.com/s/1mhJkQzI 提取密码：pvc6 【52】李兴华系列之Java8、Oracle、JavaScript、HTML5、Spring、Struts、Hibernate系列视频教程下载 https://pan.baidu.com/s/1o7O6ytc 提取密码：icgf 【53】2017年最新Python+scripy实现搜索引擎爬虫课程视频教程下载 https://pan.baidu.com/s/1mhLSFVy 提取密码：n333 【54】最新某某学院大数据工程师视频教程下载 https://pan.baidu.com/s/1o7Cvjwm 提取密码：ximb 【55】2017年Javaweb开发工程师成长之路全套视频教程附配套资料下载 https://pan.baidu.com/s/1qXJcyVa 提取密码：31di 【56】php高性能yii2框架开发高性能高可用负载均衡集群架构商城视频教程下载 https://pan.baidu.com/s/1jIKk70i 提取密码：b9bt 【57】2017最新兄弟连laravel入门到精通+博客实战开发教程下载 https://pan.baidu.com/s/1bZJAW2 提取密码：6p4c 【58】2017年最系统的PHP教程高薪就业视频教程下载 https://pan.baidu.com/s/1o7DG2pW 提取密码：rrds 【59】2017最新大数据10个小时快速入门hadoop3集群实战视频教程 https://pan.baidu.com/s/1hsgtagG 提取密码：dwin 【60】2017年最新Webpack+React全栈工程架构项目实战精讲视频教程下载 https://pan.baidu.com/s/1hsq2s64 提取密码：gprc 【61】2017年最新Uber车辆监控系统设计实战训练营高清视频教程全套附讲义代码 https://pan.baidu.com/s/1nv9Vm5b 提取密码：5bs8 【62】2017年最新DS206人脸识别与分析系统实战训练营硅谷讲师授课高清视频教程全套附讲义代码4周 https://pan.baidu.com/s/1c2LcBsc 提取密码：nv1h 【63】2017年最新React开发Native开发安卓与ios平台的GitHubApp视频教程 https://pan.baidu.com/s/1jI6DiXg 提取密码：7cyk 【64】2017年最新Google面试官亲授java校招面试视频讲解教程下载 https://pan.baidu.com/s/1nuDIkQ1 提取密码：hhnu 【65】Android传感器、无线传输与媒体硬件功能开发视频教程下载 https://pan.baidu.com/s/1bpoA4EV 提取密码：cvh9 【66】最新Kaggle神器之XGBoost从入门到精通高清精品视频教程附代码教程下载 https://pan.baidu.com/s/1nvj6fDR 提取密码：x493 【67】Oracle商业智能BI产品OBIEE11G深入浅出全套视频教程下载 https://pan.baidu.com/s/1o81KXPg 提取密码：f3sg 【68】2017年最新小象学院分布式爬虫第二期视频教程 https://pan.baidu.com/s/1geX7fKB 提取密码：2ac9 【69】mongodb从入门到精通高清视频教程下载 https://pan.baidu.com/s/1cpsdjC 提取密码：3ng4 【70】最新大数据快速数据挖掘平台RapidMiner数据分析视频教程下载 https://pan.baidu.com/s/1bpFE111 提取密码：3z6u 【71】最新Python自然语言分析视频课程下载 https://pan.baidu.com/s/1ge40FbP 提取密码：wa5r 【72】最新尚学堂redis视频教程下载 https://pan.baidu.com/s/1c35hRg 提取密码：gy5j 【73】最新oracle11gDBA开发和应用数据库视频教程下载 https://pan.baidu.com/s/1o7YE5Bk 提取密码：eu68 【74】2017vue2nodemongoKoa2Nuxt/VueSSR全栈开发小程序商城视频教程 https://pan.baidu.com/s/1jIw3lR4 提取密码：bmia 【75】最新python数据分析升级版视频教程下载 https://pan.baidu.com/s/1i5L7LdV 提取密码：bfk7 【76】Python数据分析(机器学习)经典案例视频教程 https://pan.baidu.com/s/1nuUCPlf 提取密码：3ytg 【77】DB2数据库性能优化视频教程下载 https://pan.baidu.com/s/1qYysRDE 提取密码：i1rx 【78】2017年node.js零基础入门到企业级全栈案例开发教程下载 https://pan.baidu.com/s/1eRBopRs 提取密码：ne2a 【79】Hadoop大数据视频教程：真实电商数据仓库全流程开发详解(共46讲)视频教程下载 https://pan.baidu.com/s/1bpMzOyr 提取密码：m3yt 【80】最新老男孩python全栈工程师第2期全套完整版视频教程下载 https://pan.baidu.com/s/1cIycbk 提取密码：cgfm 【81】价值2400元的python全栈开发系列FlaskPythonWeb网站编程视频教程 https://pan.baidu.com/s/1qXATJju 提取密码：huc3 【82】最新python从入门到精通到开发爬虫实例视频教程 https://pan.baidu.com/s/1mirFpeK 提取密码：9gmt 【83】极客学院VIP教程postgresql教程全集视频教程下载 https://pan.baidu.com/s/1i4DjPdF 提取密码：qgga 【84】最新angular4.x框架与redux开发大型企业级管理项目视频教程下载 https://pan.baidu.com/s/1nvEDQNB 提取密码：mqvu 【85】2017年数据分析与机器学习实战到经典案例全套高清视频教程（基于Python3.5anaconda4.2）15G https://pan.baidu.com/s/1nvqXoPN 提取密码：irdj 【86】2017年最新大数据实时分析Storm入门到精通学习路线视频教程 https://pan.baidu.com/s/1pL7OfvP 提取密码：2ze2 【87】使用php高可用webapp后端开发视频教程下载 https://pan.baidu.com/s/1qXTQ5FQ 提取密码：pybc 【88】2017年最新java算法详解与算法开发小游戏视频教程下载 https://pan.baidu.com/s/1dF0GWNn 提取密码：t6tk 【89】2017年9月最新pythonflask开发小视频网站视频教程 https://pan.baidu.com/s/1nuHfvZF 提取密码：pygf 【90】2017年5月炼数成金《MySQLDBA从小白到大神实战》视频教程 https://pan.baidu.com/s/1jHFP8sm 提取密码：qnmj 【91】Vue从入门到精通视频教程 https://pan.baidu.com/s/1pKCX6Wj 提取密码：h6hd 【92】北风网从C++起步到MFC实战VC++软件工程师高端培训(服务器端开发方向)332课全 https://pan.baidu.com/s/1c1SSWKg 提取密码：iw7p 【93】2017最新python3从零基础入门到精讲超清视频教程 https://pan.baidu.com/s/1c2Nd468 提取密码：h46d 【94】2017年最新使用MUI开发跨平台混合APP全套完整视频教程 https://pan.baidu.com/s/1dFxYZ0d 提取密码：9ury 【95】最新人脸识别深度学习项目实战视频教程 https://pan.baidu.com/s/1o8onm2m 提取密码：7aqr 【96】2017年最新Python网络爬虫实战案例视频教程下载共5章34课 https://pan.baidu.com/s/1micMg8w 提取密码：23gt 【97】基于Hadoop，Spark大数据技术的推荐系统算法实战教程 https://pan.baidu.com/s/1dFnP9K1 提取密码：djyk 【98】 https://pan.baidu.com/s/1gf0CGuB 提取密码：4tei 【99】2017年最新云知梦php全栈开发全套视频教程 https://pan.baidu.com/s/1qYPwSsW 提取密码：iv93 【100】Python编程高级进阶视频教程 https://pan.baidu.com/s/1bpnnEph 提取密码：y9sp 【101】2017年5月最新课程小象学院深度学习第四期视频教程 https://pan.baidu.com/s/1o7IzeXk 提取密码：kptc 【102】最新自动聊天机器人项目班实战视频课程下载 https://pan.baidu.com/s/1kU9bNev 提取密码：6p5z 【103】深度学习入门视频课程上篇+下篇下载 https://pan.baidu.com/s/1slG7qxv 提取密码：u2c4 【104】七月在线机器学习算法班9月在线班视频教程 https://pan.baidu.com/s/1nuLiXCl 提取密码：vdkz 【105】最新小象学院机器学习升级版III视频教程下载 https://pan.baidu.com/s/1gfeXSgb 提取密码：dt7t 【106】最新优达学城udacity无人驾驶工程师视频教程 https://pan.baidu.com/s/1c1UUEXi 提取密码：mjbs 【107】2017年深度学习项目实战之对抗生成网络视频课程 https://pan.baidu.com/s/1hs8chxU 提取密码：76mw 【108】2017年深度学习之Tensorflow项目实战视频课程-文本分类 https://pan.baidu.com/s/1c1Kf1wG 提取密码：dt52 【109】2017年kaggle案例实战班视频教程 https://pan.baidu.com/s/1boYu4FX 提取密码：4bhc 【110】深度学习实战决胜AI-强化学习实战系列视频课程 https://pan.baidu.com/s/1eRHZ1yq 提取密码：ifu2 【111】2017年最新从理论到实践机器学习视频教程 https://pan.baidu.com/s/1jHPsHSU 提取密码：xx9x 【112】2017最新基于springsecurity与spingmvc分布式权限管理系统 https://pan.baidu.com/s/1c13keOw 提取密码：xea9 【113】Java高并发程序设计实战视频教程 https://pan.baidu.com/s/1c1CDsnI 提取密码：xsic 【114】Sqoop、Flume、Oozie、Hue大数据工具视频教程 https://pan.baidu.com/s/1bo47OGR 提取密码：hxw7 【115】深入JVM内核—原理、诊断与优化视频教程 https://pan.baidu.com/s/1jIL46PK 提取密码：78yd 【116】Hadoop,Hbase,Hive源码解析与开发实战 https://pan.baidu.com/s/1hsznJsK 提取密码：dpmq 【117】传智播客黑马P2P金融项目网络借贷平台开发实战教程 https://pan.baidu.com/s/1pLieuzL 提取密码：gbxy 【118】2017年7月最新微服务架构的分布式事务解决视频教程 https://pan.baidu.com/s/1bo47p2R 提取密码：94hx 【119】亿级流量电商系统大型高并发与高可用缓存架构实战 https://pan.baidu.com/s/1pLmhZir 提取密码：6aj9 【120】2017Spark2.0大型项目实战：移动电商app交互式数据分析平台 https://pan.baidu.com/s/1o8EAk2Y 提取密码：gcsq 【121】NO89中移动大型分布式redis,solr,Linux,nginx,springmvc,mybatis电商项目 https://pan.baidu.com/s/1qY7K2SW 提取密码：cjj4 【122】SpringBoot从前端到后台打造企业级博客全栈实战视频 https://pan.baidu.com/s/1pKLc2BT 提取密码：8tjw 【123】（2017年）最新深度学习与机器学习 https://pan.baidu.com/s/1c76kgA 提取密码：5qyv 【124】SpringMvc+Spring+Mybatis整合视频教程 http://pan.baidu.com/s/1gfP90Pl 提取密码：kveg 【125】Struts2+Spring3+Hibernate4+Maven+EasyUI整合入门视频教程 http://pan.baidu.com/s/1bpztkOR 提取密码：krbn 【126】elk日志分析视频ELKStack视频教程以及Solr教程 http://pan.baidu.com/s/1qYwQOSc 提取密码：qr9u 【127】徐老师hadoophbasezookeepersparkkafka大数据视频教程 http://pan.baidu.com/s/1miLtQqO 提取密码：97tj 【128】2017年最新项目实战SpringBoot视频教程微服务整合Mybatis http://pan.baidu.com/s/1boMH2Cv 提取密码：gvt5 【129】传智播客最新大数据第3期实战培训完整版视频教程 http://pan.baidu.com/s/1miLZwwg 提取密码：56hs 【130】[大数据]极客学院大数据工程师全套视频代码课件 http://pan.baidu.com/s/1c160ug4 提取密码：6d28 【131】2017新版MySQL加强视频教程46课附课件源码 http://pan.baidu.com/s/1eSouP6U 提取密码：nh8i 【132】Python爬虫项目班从零开始实现爬虫系统 http://pan.baidu.com/s/1i5QiuzV 提取密码：2vpd 【133】Mongodb/Redis/HBaseNoSql视频教程2017数据库自学教程 http://pan.baidu.com/s/1kVytRIB 提取密码：mtnb 【134】Mahout零基础入门到精通实战视频教程（全套）下载 http://pan.baidu.com/s/1kUPNJaJ 提取密码：pvka 【135】2017年最新整理深度学习神经网络算法全套视频教程 http://pan.baidu.com/s/1pLsfdIb 提取密码：vy41 【136】阿里开源分布式框架dubbo&amp;mycat视频教程 https://pan.baidu.com/s/1geZwIYZ 提取密码：h7iw 【137】极客学院python开发工程师视频教程下载 https://pan.baidu.com/s/1miDOboc 提取密码：gwaa 【138】2017最新python教程老男孩Python14期视频教程下载 https://pan.baidu.com/s/1kVbWgzP 提取密码：9hk7 【139】达内2017Web前端全套最新价值2万元视频教程 http://pan.baidu.com/s/1jIA3oma 提取密码：rfqk 【140】达内Java全套最新价值2万元视频教程 https://pan.baidu.com/s/1sl545sx 提取密码：sa8i 【141】SparkMLlib机器学习算法与源码解析 https://pan.baidu.com/s/1pLptvMN 提取密码：ncek 【142】大数据开发之hadoop工程师成长之路零基础到精通下载 https://pan.baidu.com/s/1i4LciTf 提取密码：8z4m 【143】Kafka原理剖析及实战演练视频教程下载 https://pan.baidu.com/s/1mhAgeBA 提取密码：26ny","link":"/2020/09/28/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%80%E4%BA%9B%E7%99%BE%E5%BA%A6%E4%BA%91%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E8%BF%98%E6%9C%89pdf%E8%B5%84%E6%96%99%20--%E6%90%AC%E8%BF%90%E5%B7%A5/"},{"title":"29 应用程序返回按键执行流程","text":"从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。android系统的事件分发流程分为很多部分： Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层 所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。 在Native层android系统的事件流程： Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。 在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。 将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。 Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。 Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。 可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。 在ViewRootImpl层android系统的事件流程 在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现： 123private void dispatchInputEventFinished(int seq, boolean handled) { onInputEventFinished(seq, handled); }在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中： 12345678910private final class ImeInputEventSender extends InputEventSender { public ImeInputEventSender(InputChannel inputChannel, Looper looper) { super(inputChannel, looper); } @Override public void onInputEventFinished(int seq, boolean handled) { finishedInputEvent(seq, handled, false); } } 可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。 12345678910111213141516171819202122void finishedInputEvent(int seq, boolean handled, boolean timeout) { final PendingEvent p; synchronized (mH) { int index = mPendingEvents.indexOfKey(seq); if (index &lt; 0) { return; // spurious, event already finished or timed out } p = mPendingEvents.valueAt(index); mPendingEvents.removeAt(index); Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size()); if (timeout) { Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot; + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId); } else { mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p); } } invokeFinishedInputEventCallback(p, handled); } 在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。 1234567891011121314void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) { p.mHandled = handled; if (p.mHandler.getLooper().isCurrentThread()) { // Already running on the callback handler thread so we can send the // callback immediately. p.run(); } else { // Post the event to the callback handler thread. // In this case, the callback will be responsible for recycling the event. Message msg = Message.obtain(p.mHandler, p); msg.setAsynchronous(true); msg.sendToTarget(); } } 可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。 12345678@Override public void run() { mCallback.onFinishedInputEvent(mToken, mHandled); synchronized (mH) { recyclePendingEventLocked(this); } } 可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。 12345678910111213final class ImeInputStage extends AsyncInputStage implements InputMethodManager.FinishedInputEventCallback { ... @Override public void onFinishedInputEvent(Object token, boolean handled) { QueuedInputEvent q = (QueuedInputEvent)token; if (handled) { finish(q, true); return; } forward(q); } } 这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法： 12345678910111213141516171819202122at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141) 这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。 12345678private int processKeyEvent(QueuedInputEvent q) { ... // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) { return FINISH_HANDLED; } ...} 可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。 在DecorView层android系统的事件流程 从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean dispatchKeyEvent(KeyEvent event) { final int keyCode = event.getKeyCode(); final int action = event.getAction(); final boolean isDown = action == KeyEvent.ACTION_DOWN; if (isDown &amp;&amp; (event.getRepeatCount() == 0)) { // First handle chording of panel key: if a panel key is held // but not released, try to execute a shortcut in it. if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey != keyCode)) { boolean handled = dispatchKeyShortcutEvent(event); if (handled) { return true; } } // If a panel is open, perform a shortcut on it without the // chorded panel key if ((mPreparedPanel != null) &amp;&amp; mPreparedPanel.isOpen) { if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) { return true; } } } if (!isDestroyed()) { final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) { return true; } } return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event); } 从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。 在Activity层android系统的事件流程 所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法： 12345678910111213141516171819public boolean dispatchKeyEvent(KeyEvent event) { onUserInteraction(); // Let action bars open menus in response to the menu key prioritized over // the window handling it if (event.getKeyCode() == KeyEvent.KEYCODE_MENU &amp;&amp; mActionBar != null &amp;&amp; mActionBar.onMenuKeyEvent(event)) { return true; } Window win = getWindow(); if (win.superDispatchKeyEvent(event)) { return true; } View decor = mDecor; if (decor == null) decor = win.getDecorView(); return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this); } 从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。 123456789101112131415public final boolean dispatch(Callback receiver, DispatcherState state, Object target) { switch (mAction) { ... case ACTION_UP: if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state + &quot;: &quot; + this); if (state != null) { state.handleUpEvent(this); } return receiver.onKeyUp(mKeyCode, this); ... } return false; } 这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。 1234567891011public boolean onKeyUp(int keyCode, KeyEvent event) { if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) { onBackPressed(); return true; } } return false; } 看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。 123456789public void onBackPressed() { if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) { return; } if (!mFragments.getFragmentManager().popBackStackImmediate()) { finishAfterTransition(); } } 可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。 12345public void finishAfterTransition() { if (!mActivityTransitionState.startExitBackTransition(this)) { finish(); } } O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。 总结： 本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程； 事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"热修复技术原理总结","text":"#1.什么是热修复 传统更新流程：版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;重新发版-&gt;用户安装 弊端:重新发版本代价高 :用户下载安装成本高 :bug修复不及时，体验差 解决方案 Hybrid方案:业务逻辑以H5方式加载 插件化方案:Atlas或者DroidPlugin方案 热修复方案:采用热修复技术，将更新补丁上传到云端，APP从云端下拉补丁直接应用生效 热修复更新流程:版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;打出补丁,推送给用户-&gt;自动拉取补丁修复 优势 1.无需重新发版，实时高效热修复 2.用户无感知修复，无需下载新应用,代价小 3.修复成功率高，把损失降到最低 ##2.热修复框架 腾讯QQ控件的超技补丁技术，微信的Tinker，饿了么的Amigo，美团的Robust 非侵入式Android热修复方案SophixSophix不支持四大组件的修复,如果要修复四大组件，必须在AndroidManifest里预先插入代理组件，并且声明所有权限。对app运行流程的侵入性太强。未作处理。 ##3.Android热修复的三大领域:代码修复,资源修复,So修复。 ###3.1代码修复 ###代码修复方案:一种是阿里系的底层替换方案，一种是腾讯系的类加载方案优劣: 底层替换方案限制多，但时效性好，加载快，立即见效。类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。 ###底层替换方案 底层替换方案是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改。因而无法实现对原有类进行方法和字段的增减，因为这样将破坏原有类结构。一旦补丁类中出现了方法的增加或减少，就会导致这个类以及整个Dex的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。更严重的问题是，如果在程序运行中间某各类突然增加了一个字段，那么对于原先已经产生的这个类的实例，他们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。传统的底层替换方式，不论是Dexposed、Andfix或者其他安全界的Hook方案，都是直接依赖修改虚拟机方法实体的具体字段，例如，改Dalvik方法的jni函数指针、修改类或者方法的访问权限。Android开源，各大厂商对代码进行改造，Andfix里的ArtMethod的结构是根据Android源码中的结构写死的。如果ArtMethod做修改，这种替换机制就会出问题。 Sophix是一种无视底层具体结构的替换方式，解决了兼容性问题。忽略了底层ArtMethod结构的差异，对于Android版本不需要区分，代码量大大减少。只要ArtMethod数组是以线性结构排列，就不会出现问题。 ###类加载方案类加载方案的原理是在app重新启动后让Classloader去加载新的类。因为app运行时，所有需要发生变更的类已经被加载过了，在Android上是无法对一个类进行卸载。如果不重新启动，原来的类还在虚拟机上，就无法加载新类。只有重新启动，在业务逻辑执行前，抢先加载补丁中的新类，当访问这个类时就会Resolve为新类，达到热修复目的。 ###底层替换原理 Andfix即时生效，其原理是，在已经加载的类中直接在native层替换掉原有方法，实在原有类基础上进行修改。其核心在于replaceMethod函数，这是一个native方法。 其参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的事需要被替换的原有方法。dest对应的就是新方法，新方法存在于补丁包中的新类中，也就是补丁方法。 Android的java运行环境，在4.4以下用的事dalvik虚拟机，而在4.4以上用的是art虚拟机。 我们以art为例，对于不同Android版本的art，底层Java对象的数据结构是不同的，因而会进一步区分不同的替换函数，这里我们以Android6.0为例，对应的就是replace_6_0. 每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等。 通过env-&gt;FromReflectedMethod，可以由Method对象得到这个方法对应的ArtMethod的真正起始地址。然后可以把它强转成ArtMethod指针，从而对其所有成员进行修改。这样全部替换完之后就完成了热修复逻辑，以后调用这个方法时就会直接走到新方法的实现中了。 为什么这样替换完就可以实现热修复了呢？需要从虚拟机调用方法的原理说起。 在Art虚拟机中ArtMethod结构中，包含两个重8_point_from_quick_compiled_code_了，他们是方法的执行入口。Java代码在Android中会被编译成DexCode。你也不 Art中可以采用解析模式或者AOT机器码模式执行。 解析模式，就是去除Dex Code，逐条解析执行，如果方法的调用者以解析模式运行，在调用方法时，就会取得这个方法的entry_point_from_interpreter_,然后他交转过去执行。AOT的方式，就会先预编译好Dex Code 对应的机器码，然后执行期直接执行机器码，不需要一条条解析执行Dex Code。如果方法的调用者是以AOT机器码方式执行的，在调用这个方法是，就是跳转到entry_point_from_quick_compiled_code执行。因此，当把一个旧方法的所有成员字段都换成新方法后，执行时所有数据就可以保持和新方法的一至。这样在所有执行到旧方法的地方，回取得新方法的执行入口、所属class、方法索引号及所属dex信息，然后想调用旧方法一样的执行到新方法的逻辑。 Native替换方案，比如Andfix和其他安全界的Hook方案，都是写死ArtMethod结构体，这样会带来兼容性问题。Native层替换思路，其实就是替换ArtMethod的所有成员 Sophix采取的是将ArtMethod的作为整体进行替换。 访问权限的问题 方法调用时的权限检查、同包名下的权限问题、反射调用非静态方法问题。 即时生效在什么情况下不适用？ 引起原有类中发生结构变化的修改 修复了的非静态方法会被反射调用 内部类编译 内部类会在编译器会被编译为跟外部类一样的顶级类。 冷启动类加载原理当类结构发生变化时，如新增减少类的method/field再热部署模式下会受到限制，但是冷部署能够达到修复目的。 ##冷启动实现方案 ##插桩实现的前因后果 如果仅仅把补丁类打入补丁包中而不做任何处理的话， 在运行时类加载的时候会异常退出。加载一个dex文件到本地内存时，如果不存在odex文件，首先会执行dexopt，dexopt 的入口在davilk/opt/OptMain.cpp的main方法，最后调用到verifyAndOptimizeClass执行真正的verify/optimize操作。 Apk第一次安装的时候，会对原dex执行dexopt,此时假如apk只存在一个dex，所以dvmVerifyClass(clazz)结果为true,所以apk中所有的类都会被打上CLASS_ISPREVERIFIED标识，接下来执行dvmOptimizeClass，类接着被打上CLASS_ISOPTIMIZED标识。 现在加入A类是补丁类，所以补丁A类在单独的dex中，类B中的某个方法引用到补丁类A，所以执行到该方法会尝试解析类A。 类B由于被打上了CLASS_ISPREVERIFIED标志，接下来referrer是类B，resClassCheck是补丁类A，他们属于不同的dex。所以会提示dvmThrowlllegalAccessError。为了解决这个问题，一个单独无关帮助类放到一个单独的dex中，原dex中所有类的构造函数都引用这个类，一般的实现方法都是侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。Art下冷启动实现 Dalvik下和Art下对DexFile.loadDex尝试把一个dex文件解析加载到native内存发生了什么？实际都是调用了DexFile.openDexFileNative这个native方法。Dalvik尝试加载一个压缩文件的时候只会去把classes.dex加载到内存中，如果此时内存文件中有多个dex，那么除了classes.dex之外的其他dex被直接忽略掉Art虚拟机方法调用链DexFile-&gt;openDexFileNative-&gt;OpenDexFilesFromat-&gt;LoadDexFilesArt下默认支持加载压缩文件中包含多个dex，首先肯定优先加载primary dex其实就是classes.dex，后续会加载其他的dex。所以补丁类只需要放到classes.dex即可，后续出现在其他dex中的“补丁类“是不会被重复加载的。 Art最终冷启动解决方案 把补丁dex命名为classes.dex。原apk中的dex一次命名为classes(2,3,4…).dex就好了，然后一起打包为一个压缩文件。然后DexFile.LoadDex得到DexFile对象，最后把该DexFile对象整个替换旧的dexElements数据就可以了。 Sophix 和 tinker 方案 补丁dex必须命名为classes.dex loadDex得到的DexFile完整替换掉dexElements数组而不是插入 DexFile.loadDex尝试把一个dex文件解析并加载到native内存，在加载到native内存之前，如果dex不存在对应的odex，那么Dalvik下回执行dexopt，Art下回执行dexoat，最后得到的都是一个优化后的odex，实际上最后虚拟机执行的事这个odex而不是dex。dex足够大那么dexopt/dexoat实际上是很好似的，Dalvik下实际影响比较下，因为loadDex仅仅是补丁包，Art下影响非常大，因为loadDex是补丁dex和apk中原dex合并成一个完整补丁压缩包，所以dexoat非常耗时。如果优化后的odex文件没生成或者没生成一个完整的odex文件，那么loadDex便不能在应用启动的时候进行的，因为会阻塞loadDex线程，一般是主线程。所以解决这个问题，Sophix把loadDex当做一个事务来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，那么重启另一子进程loadDex，重启之后在生效。 具体实施方案对Dalvik和Art下 Dalvik下采用自行研发的全量Dex方案 Art下本质上虚拟机已经支持多dex的加载，我们只需把补丁dex作为主dex(classes.dex)加载而已 冷启动方案限制？当新增一个publlic/protected/default方法，会出现方法调用错乱。 Google的dexmerge方案 把补丁dex和原dex合并一个完整的dex。 Dalvik下完整DEX方案的新探索 冷启动类加载修复 对于Android下的冷启动类加载修复，最早的实现方案是QQ空间提出的dex插入方案。主要思想是，把插入新dex插入到ClassLoader索引路径的最前面，这样在load一个class时，优先找到补丁中的。这类插入dex 的方案，会遇到一个主要的问题，就是如何解决Dalvik虚拟机下类的pre-verify问题。 如果一个类 中直接引用到的所有非系统类都和该类在同一个dex里的话，那么这个类就会被打上CLASS_ISPREVERIFIED,具体判定代码可见虚拟机中的verifyAndOptimizeClass函数。 腾讯的三大热修复方案是如何解决这个问题的： QQ控件的处理方式，是在每个类中插入一个来自其他dex的hack.class,由此让所有类里面都无法满足pre-verified条件。 Tinker的方式，是合成全量的dex文件，这样所有class的都在全量dex中解决，从而消除class重复而带来的冲突。 Qfix的方式，是取得虚拟机中的某些底层函数，提前resolve所有补丁类，以此绕过Pre-verify检查。Sophix的方式，补丁中已包含变动的类，主要在原先基线包中dex里边，去掉补丁中已有的class。这样，补丁+去除了补丁类的基线包=app中所有类。参考Android原生multi-dex的实现，是把一个apk所用到的所有类拆分到classes.dex、classes2.dex、classes.dex…之中，而每个dex都只包含了部分的类的定义，但单个dex也是可以加载的，因为只要把所有dex都load进去，本dex中不存在的类就可以在运行期间在其他dex中找到。 #资源热修复技术 ##3.2资源修复InstantRun资源热修复原理： 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManger中，这样就得到一个含有所有新资源的AssetManager。 找到所有之前引用到愿你有Assetmanager的地方，通过反射，把引用处替换成新的AssetManager。Sophix 资源热修复原理:构造一个package id 为0x66的资源包，其中包含改变了的资源项，然后直接在原有的AssetManager中addAssetPath这个包就可以了。由于补丁包的package id 为0x66,不与目前已经加载的0x7f冲突，因此直接加入到已有的AssetMananger中就可以直接使用。替换方式更加优雅，直接在原有的AssetManageer对象上进行析构和重构，原先AssetManager对象的引用没有发生改变，不用像InstantRun进行繁琐修改。 ###资源替换方案优势 不修改AssetManager的引用处，替换更快更安全。 不必下发完整包，补丁包中只包含有变动的资源 不要在运行时合成完整包。不占用运行时计算和内存资源。 一个Android进程只包含一个ResTable,ResTable的成员变量mPackageGroups就是所有解析过的资源包的集合。任何 一个资源包中都含有resources.arsc,他记录了所有资源的id分配情况以及资源中的所有字符串。这些信息是以二进制方式存储的。底层的AssetManager做的事就是解析这个文件，然后把相关信息存储到mPackageGroups里面。 资源信息主要是指每隔资源的名称以及他对应的编号。每隔资源，都有唯一编号。 编号是一个32位数字，用十六进制来标识就是0xPPTTEEEE。PP为package id，TT为type id，EEEE为entry id。 运行时资源的解析 默认由Android SDK编出来的apk，是由aapt工具进行打包的，其资源包的package id 是 0x7f。系统的资源包，也就是framework-res.jar，package id 为0x01。在走到app 的第一行代码之前，系统就已经帮我们构造好一个已经添加了安装包资源的AssetManager了。 因此，这个AssetManager里就已经包含了系统资源包以及app的安装包，就是package id 为0x01的framework-res.jar中的资源和package id为0x7f的app安装包资源。 如果此时直接在addAssetPath其实补丁包里的资源是不生效的。因为在getResTable已经执行很多次了。不会发生真正的解析。 ###Sophix资源解决方案 构造一个package id 为0x66的资源包，包含了改变的资源项，然后直接在原有AssetManager中addAssetPath这个包。不与已经加载的0x7f冲突。 而资源的改变包含增加、减少、修改这三种情况，分别是如何处理的呢？ 对于新增资源，直接加入补丁包，然后新代码里直接引用就可以了 对于减少资源，我们只要不使用他就行了，因此不用考虑这种情况，他也不影响补丁包 对于修改资源，比如替换了一张图片之类的情况。我们把它视为新增资源，在打补丁的时候，代码在引用处也会做响应修改，也就是直接把原来使用就资源id的地方变成新id。#3.3 So库修复So库修复本质上是对native方法的修复和替换。Sophix采用的是类似类修复反射注入方式。把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，达到加载so库时时补丁so库，而不是原来so库的目录，从而达到修复的目的。采用这种方案，完全由Sophix在启动期间反射注入patch中的so库。其他方案是手动替换系统的System.load来实现替换目的。Java Api提供一下两个接口加载一个so库 System.loadLibrary(String libName);传进去的参数 so库名称，表示的so库文件，位于apk压缩文件中的libs目录，最后复制到apk安装目录下。 System.load(String pathName)传进去的参数 so库在磁盘中的完整路径。加载一个自定义外部so库文件。两种方式加载一个so库，实际上最后都调用nativeLoad这个native方法去加载so库，这个方法的参数fileName so库在磁盘中的完整路径名。 JNI编程中，动态注册的natvie方法必须实现JNI_ONLoad方法，同时实现一个JNINativeMethod[]数组 ，静态注册的native方法必须是Java+类完整路径+方法名的格式。 ##3.1. SO库冷部署重启生效实现方案 SO库修复方案 接口调用替换方案，需要强制侵入用户接口调用 反射注入方案，重启生效 总结： 动态注册的native方法映射通过加载so库过程中调用JNI_OnLoad方法调用完成 静态注册的native方法映射是在该native方法第一次执行的时候才完成映射，当然前提是该so库已经load过。 ##3.2 SO库热部署实时生效分析 ###3.2.1动态注册native方法实时生效动态注册的native方法调用一次JNI_OnLoad方法都会重新完成一次映射，所以我们是否只要先加载原来的so库，然后在加载补丁so库，就完成Java层native方法到native层patch后的新方法映射，这样就完成动态注册native方法的patch实时修复。 实测发现art下这样是可以实时生效，但Dalvik下做不到试试生效。原因Dalvik第二次load补丁so库，执行的仍然是原来的so库的JNI_OnLoad方法，而不是补丁so库的JNI_OnLoad方法。Dalvik虚拟机下dlopen方法实现，底层方法会校验so库是否已经加载过，方法的判断依据是判断name,如果加载过直接返回该so库的句柄。如果so库从未加载过，则load_library执行加载。所以Dalvik下面加载修复后的补丁so拿到的还是原so库文件的句柄，所以执行的仍然是原so库的JNI_OnLoad方法，Art下不存在问题，因Art下该方法以name作为key去查找不是bname,所以art下重新load一遍补丁so库，拿到的是补丁so库的句柄，然后执行补丁so库的JNI_OnLoad。解决Dalvik下该问题，可对补丁so库进行改名。 ###3.2.2静态注册native方法实时生效静态注册native方法的映射实在native方法第一次执行的时候完成映射，如果native方法在加载补丁so库之前已经执行过，是否这个静态注册native方法一定得不到修复？幸运的是，系统JNI API提供了解注册的接口 UnregisterNatives（JNIEnv* env,jclass jclazz）函数回吧jclazz所在类的所有native方法都重新指向为dvmResolveNativeMethod，所以调用unregisterNatives之后不管是静态注册还是动态注册的native方法之前是否执行过在加载补丁so 的时候都会重新去做映射。所以我们只需要以下调用。 ##3.3 SO库冷部署重启生效实现方案 ###3.3.1.接口调用替换方案Sdk提供接口替换System默认加载so库接口 SOPatchManager。loadLibrary接口加载so库的时候有限尝试去加载sdk指定目录下的补丁so，加载策略如下： 如果存在则加载补丁so库而不会去加载安装apk安装目录下的so库。 如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的so库。 方案优缺点：优点：不需要对不同sdk版本进行兼容，因为所有的SDK版本都有System.loadLibrary这个接口。缺点：调用方需要替换掉System默认加载so库接口为sdk提供的接口，如果是已经编译混淆好的三方库的so库需要patch，那么是很难做到接口的替换。 ###3.3.2反射注入方案System.loadLibrary(“native-lib”)，加载so库的原理，其实native-lib这个 so库最终传给native方法执行的参数是so库在磁盘中的完整路径，比如/data/app-lib/com.taobao.jni-2/libnative-lib.so,so库会在DexPathList.nativeLibraryDirectories/nativeLibraryPathElements变量所表示的目录下去遍历搜索。 可以发现会遍历nativeLibraryDirectories数组，如果找到了IoUtils.canOpenReadOnly(path)返回true，那么就直接返回该path，IoUtils。canOpenReadOnly(path)返回true的前提肯定是需要path标识的so文件存在的。我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复的目的。 Sdk23以上findLibrary 实现已经发生变化，只需把补丁so库的完整路径违参数构建一个Element对象，然后再插入nativeLibraryPathElements数组的最前面就好了。 优点：可以修复三方库的so库。同事接入方不需要想方案1一样强制侵入用户接口调用。缺点：需要不断的对sdk进行适配，如上sdk23为分界线，findLibrary接口实现已发生变化。不管是补丁包还是apk中一个so库存在多种cpu架构的so文件，比如armeabi，arm64-v8a,x86等。加载可定是加载其中一个so库文件的，如何选择机型对应的so库文件将是重点所在。 虚拟机究竟如何选择哪个abis目录作为参数构建PathClassLoader对象，原理如图 实际上补丁so也存在类似的问题，我们的补丁so库文件放到补丁包的libs目录下，libs目录和.dex文件res资源文件一起打包成一个压缩文件作为最后的补丁包，libs目录可能也包含多种abis目录。所以我们需要选择手机最合适的primaryCpuAbi，然后从libs目录下选择这个primaryCpuAbi子目录插入到nativeLibraryDirectories/nativeLibraryPathElements数组。所以怎么选择primaryCpuAbi是关键，具体实现如图： 1.sdk&gt;=21时，直接反射拿到ApplicationInfo对象的primaryCpuAbi即可2.sdk&lt;21时，有雨此时不支持64位，所以直接吧Build.CPU_ABI,Build.CPU_ABI2作为primaryCpuAbi即可。","link":"/2019/10/11/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"title":"23 Android异常处理流程 Android 项目构建流程","text":"前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。 这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~ 开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息： 那么这里的force close弹窗是如何弹出的呢？ 还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考： 在Android中自定义捕获Application全局异常） 带着这两个问题，我们开始今天的异常流程分析。 在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：Android应用程序进程启动过程的源代码分析） 而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现： 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller { if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader); } 可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现： 12345private static final void commonInit() { ... Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); ... }可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。 看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考： 在Android中自定义捕获Application全局异常所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现： 123456789101112131415161718192021222324252627282930313233343536private static class UncaughtHandler implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread t, Throwable e) { try { // Don't re-enter -- avoid infinite loops if crash-reporting crashes. if (mCrashing) return; mCrashing = true; if (mApplicationObject == null) { Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e); } else { StringBuilder message = new StringBuilder(); message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\\n&quot;); final String processName = ActivityThread.currentProcessName(); if (processName != null) { message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;); } message.append(&quot;PID: &quot;).append(Process.myPid()); Clog_e(TAG, message.toString(), e); } // Bring up crash dialog, wait for it to be dismissed ActivityManagerNative.getDefault().handleApplicationCrash( mApplicationObject, new ApplicationErrorReport.CrashInfo(e)); } catch (Throwable t2) { try { Clog_e(TAG, &quot;Error reporting crash&quot;, t2); } catch (Throwable t3) { // Even Clog_e() fails! Oh well. } } finally { // Try everything to make sure this process goes away. Process.killProcess(Process.myPid()); System.exit(10); } } } 这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。 然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？ 123static public IActivityManager getDefault() { return gDefault.get(); } 可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑： 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。 12345678910111213public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app); crashInfo.writeToParcel(data, 0); mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0); reply.readException(); reply.recycle(); data.recycle(); } 这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。 1234567public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) { ProcessRecord r = findAppProcess(app, &quot;Crash&quot;); final String processName = app == null ? &quot;system_server&quot; : (r == null ? &quot;unknown&quot; : r.processName); handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo); } 可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。 1234567891011121314void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) { EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber); addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo); crashApplication(r, crashInfo); } 可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File logFile, final ApplicationErrorReport.CrashInfo crashInfo) { // NOTE -- this must never acquire the ActivityManagerService lock, // otherwise the watchdog may be prevented from resetting the system. final String dropboxTag = processClass(process) + &quot;_&quot; + eventType; final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE); // Exit early if the dropbox isn't configured to accept this report type. if (dbox == null || !dbox.isTagEnabled(dropboxTag)) return; final StringBuilder sb = new StringBuilder(1024); appendDropBoxProcessHeaders(process, processName, sb); if (activity != null) { sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid != process.pid) { sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent != activity) { sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\\n&quot;); } if (subject != null) { sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\\n&quot;); } sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\\n&quot;); if (Debug.isDebuggerConnected()) { sb.append(&quot;Debugger: Connected\\n&quot;); } sb.append(&quot;\\n&quot;); // Do the rest in a worker thread to avoid blocking the caller on I/O // (After this point, we shouldn't access AMS internal data structures.) Thread worker = new Thread(&quot;Error dump: &quot; + dropboxTag) { @Override public void run() { if (report != null) { sb.append(report); } if (logFile != null) { try { sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE, &quot;\\n\\n[[TRUNCATED]]&quot;)); } catch (IOException e) { Slog.e(TAG, &quot;Error reading &quot; + logFile, e); } } if (crashInfo != null &amp;&amp; crashInfo.stackTrace != null) { sb.append(crashInfo.stackTrace); } String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag; int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0); if (lines &gt; 0) { sb.append(&quot;\\n&quot;); // Merge several logcat streams, and take the last N lines InputStreamReader input = null; try { java.lang.Process logcat = new ProcessBuilder(&quot;/system/bin/logcat&quot;, &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;, &quot;-b&quot;, &quot;crash&quot;, &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start(); try { logcat.getOutputStream().close(); } catch (IOException e) {} try { logcat.getErrorStream().close(); } catch (IOException e) {} input = new InputStreamReader(logcat.getInputStream()); int num; char[] buf = new char[8192]; while ((num = input.read(buf)) &gt; 0) sb.append(buf, 0, num); } catch (IOException e) { Slog.e(TAG, &quot;Error running logcat&quot;, e); } finally { if (input != null) try { input.close(); } catch (IOException e) {} } } dbox.addText(dropboxTag, sb.toString()); } }; if (process == null) { // If process is null, we are being called from some internal code // and may be about to die -- run this synchronously. worker.run(); } else { worker.start(); } } 可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。 继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { long timeMillis = System.currentTimeMillis(); String shortMsg = crashInfo.exceptionClassName; String longMsg = crashInfo.exceptionMessage; String stackTrace = crashInfo.stackTrace; if (shortMsg != null &amp;&amp; longMsg != null) { longMsg = shortMsg + &quot;: &quot; + longMsg; } else if (shortMsg != null) { longMsg = shortMsg; } AppErrorResult result = new AppErrorResult(); synchronized (this) { if (mController != null) { try { String name = r != null ? r.processName : null; int pid = r != null ? r.pid : Binder.getCallingPid(); int uid = r != null ? r.info.uid : Binder.getCallingUid(); if (!mController.appCrashed(name, pid, shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) { if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;)) &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) { Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name + &quot;(&quot; + pid + &quot;) during testing&quot;); } else { Slog.w(TAG, &quot;Force-killing crashed app &quot; + name + &quot; at watcher's request&quot;); if (r != null) { r.kill(&quot;crash&quot;, true); } else { // Huh. Process.killProcess(pid); killProcessGroup(uid, pid); } } return; } } catch (RemoteException e) { mController = null; Watchdog.getInstance().setActivityController(null); } } final long origId = Binder.clearCallingIdentity(); // If this process is running instrumentation, finish it. if (r != null &amp;&amp; r.instrumentationClass != null) { Slog.w(TAG, &quot;Error in app &quot; + r.processName + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;); if (shortMsg != null) Slog.w(TAG, &quot; &quot; + shortMsg); if (longMsg != null) Slog.w(TAG, &quot; &quot; + longMsg); Bundle info = new Bundle(); info.putString(&quot;shortMsg&quot;, shortMsg); info.putString(&quot;longMsg&quot;, longMsg); finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info); Binder.restoreCallingIdentity(origId); return; } // Log crash in battery stats. if (r != null) { mBatteryStatsService.noteProcessCrash(r.processName, r.uid); } // If we can't identify the process or it's already exceeded its crash quota, // quit right away without showing a crash dialog. if (r == null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) { Binder.restoreCallingIdentity(origId); return; } Message msg = Message.obtain(); msg.what = SHOW_ERROR_MSG; HashMap data = new HashMap(); data.put(&quot;result&quot;, result); data.put(&quot;app&quot;, r); msg.obj = data; mUiHandler.sendMessage(msg); Binder.restoreCallingIdentity(origId); } int res = result.get(); Intent appErrorIntent = null; synchronized (this) { if (r != null &amp;&amp; !r.isolated) { // XXX Can't keep track of crash time for isolated processes, // since they don't have a persistent identity. mProcessCrashTimes.put(r.info.processName, r.uid, SystemClock.uptimeMillis()); } if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) { appErrorIntent = createAppErrorIntentLocked(r, timeMillis, crashInfo); } } if (appErrorIntent != null) { try { mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId)); } catch (ActivityNotFoundException e) { Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e); } } } 可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。 在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243case SHOW_ERROR_MSG: { HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) msg.obj; boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0; synchronized (ActivityManagerService.this) { ProcessRecord proc = (ProcessRecord)data.get(&quot;app&quot;); AppErrorResult res = (AppErrorResult) data.get(&quot;result&quot;); if (proc != null &amp;&amp; proc.crashDialog != null) { Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc); if (res != null) { res.set(0); } return; } boolean isBackground = (UserHandle.getAppId(proc.uid) &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; proc.pid != MY_PID); for (int userId : mCurrentProfileIds) { isBackground &amp;= (proc.userId != userId); } if (isBackground &amp;&amp; !showBackground) { Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;); if (res != null) { res.set(0); } return; } if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) { Dialog d = new AppErrorDialog(mContext, ActivityManagerService.this, res, proc); d.show(); proc.crashDialog = d; } else { // The device is asleep, so just pretend that the user // saw a crash dialog and hit &quot;force quit&quot;. if (res != null) { res.set(0); } } } ensureBootCompleted(); } 可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: …. O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码： 1234// After the timeout, pretend the user clicked the quit button mHandler.sendMessageDelayed( mHandler.obtainMessage(FORCE_QUIT), DISMISS_TIMEOUT); 这里的常量DISMISS_TIME = 5 60 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。 好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。 这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~ 总结： App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。 默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。 自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。 force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程","link":"/2020/09/11/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"title":"19 Dialog加载绘制流程","text":"前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。 可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码） 好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。 12345678910111213141516171819title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。 一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。 那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法： 123public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); }好吧，这里调用的是Builder的重载构造方法： 1234public Builder(Context context, int themeResId) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); } 那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。 12345public AlertParams(Context context) { mContext = context; mCancelable = true; mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); } 可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码： 1AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); 就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现： 1234public Builder setIcon(@DrawableRes int iconId) { P.mIconId = iconId; return this; } 可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。 然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现： 1234public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } 好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。 再看一下builder.setTitle方法： 1234public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } 可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。 然后我们看一下builder.setView方法： 123456public Builder setView(int layoutResId) { P.mView = null; P.mViewLayoutResId = layoutResId; P.mViewSpacingSpecified = false; return this; } 可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。 然后我们调用了builder.setPositiveButton方法： 123456builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); 好吧，这里我们看一下builder的setPositiveButton的源码： 12345public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } 好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。 上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行： 1builder.setIcon().setMessage().setTitle().setView().setPositiveButton()... 这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。 然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。 123456789101112131415public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } 可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现： 1234567AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } 可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法： 1234567891011121314151617181920212223Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == 0) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); } else { mContext = context; } mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法： 1mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法： 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了： 1mAlert = new AlertController(getContext(), this, getWindow()); 相当于初始化了AlertDiaog的成员变量mAlert。 继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ublic void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId != 0) { dialog.setIcon(mIconId); } if (mIconAttrId != 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } else if (mViewLayoutResId != 0) { dialog.setView(mViewLayoutResId); } } 看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。 继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了： 1dialog.setCancelable(P.mCancelable); 可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void show() { if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; if (!mCreated) { dispatchOnCreate(null); } onStart(); mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; } try { mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); } finally { } } 方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看： 123if (!mCreated) { dispatchOnCreate(null); } mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑： 123456void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { onCreate(savedInstanceState); mCreated = true; } } 好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent(); } 可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。 12345678public void installContent() { /* We use a custom title so never request a window title */ mWindow.requestFeature(Window.FEATURE_NO_TITLE); int contentView = selectContentView(); mWindow.setContentView(contentView); setupView(); setupDecor(); } 可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。 12345678910private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } // TODO: use layout hint side for long messages/lists return mAlertDialogLayout; } 可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（android源码解析（十七）–&gt;Activity布局加载流程）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。 12mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~ 继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。 然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。 O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。 最后我们调用了sendShowMessage方法，可以看一下这个方法的实现： 123456private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); } } 这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？ 123456alertDialog.setOnShowListener(new DialogInterface.OnShowListener() { @Override public void onShow(DialogInterface dialog) { } }); 这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现： 1234567public void setOnShowListener(OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; } } 这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。 注：这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出： 12345678910111213141516Process: com.example.aaron.helloworld, PID: 11948 android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an applicationat android.view.ViewRootImpl.setView(ViewRootImpl.java:690)at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)at android.app.Dialog.show(Dialog.java:298)at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)at android.view.View.performClick(View.java:4811)at android.view.View$PerformClick.run(View.java:20136)at android.os.Handler.handleCallback(Handler.java:815)at android.os.Handler.dispatchMessage(Handler.java:104)at android.os.Looper.loop(Looper.java:194)at android.app.ActivityThread.main(ActivityThread.java:5552)at java.lang.reflect.Method.invoke(Native Method)at java.lang.reflect.Method.invoke(Method.java:372)at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。 总结： Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑； Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象； Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类； 构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程","link":"/2020/09/11/Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"9 SystemServer进程启动流程","text":"转载请标明出处：一片枫叶的专栏 上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，具体可参见： android源码解析之（八）–&gt;Zygote进程启动流程那么SystemServer进程是做什么用的呢？ 其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。 由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑： 123456/** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } 这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。 然后我们查看run方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private void run() { // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } // If the system has &quot;persist.sys.language&quot; and friends set, replace them with // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } // Here we go! Slog.i(TAG, &quot;Entered the Android system server!&quot;); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis()); // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) { SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() { @Override public void run() { SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null); } }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); } // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit(); // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper(); // Initialize native services. System.loadLibrary(&quot;android_servers&quot;); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) { Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); } // Loop forever. Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 好吧，代码比较多，慢慢看。。。 1234if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } 首先判断系统当前时间，若当前时间小于1970年1月1日，则一些初始化操作可能会处所，所以当系统的当前时间小于1970年1月1日的时候，设置系统当前时间为该时间点。 然后代码： 12345678if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } 主要是设置系统的语言环境等；下面的主要是设置虚拟机运行内存，加载运行库，设置SystemServer的异步消息，具体的异步消息机制可参见： android源码解析之（二）–&gt;异步消息机制 然后下面的代码是： 1234567891011121314151617// Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 首先调用createSystemContext()方法： 12345private void createSystemContext() { ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); } 可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。 然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。 然后调用： 1LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); 是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。 最后开始执行： 12345678910// Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 里面主要涉及了是三个方法：startBootstrapServices() 主要用于启动系统Boot级服务startCoreServices() 主要用于启动系统核心的服务startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务 下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。 首先看一下startBootstrapServices方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void startBootstrapServices() { // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // Power manager needs to be started early because other services need it. // Native daemons may be watching for it to be registered so it must be ready // to handle incoming binder calls immediately (including being able to verify // the permissions for those calls). mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // Now that the power manager has been started, let the activity manager // initialize power management features. mActivityManagerService.initPowerManagement(); // Manages LEDs and display backlight so we need it to bring up the display. mSystemServiceManager.startService(LightsService.class); // Display manager is needed to provide display metrics before package manager // starts up. mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // Only run &quot;core&quot; apps if we're encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; } // Start the package manager. Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Slog.i(TAG, &quot;User Service&quot;); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); // Initialize attribute cache used to cache resources from packages. AttributeCache.init(mSystemContext); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); // The sensor service needs access to package manager service, app ops // service, and permissions service, therefore we start it after them. startSensorService(); } 首先执行： 1Installer installer = mSystemServiceManager.startService(Installer.class); mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); } final T service; try { Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service constructor threw an exception&quot;, ex); } // Register it. mServices.add(service); // Start it. try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); } return service; } 可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法： 12345@Override public void onStart() { Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;); mInstaller.waitForConnection(); } 很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。然后查看waitForConnection（）方法： 123456789public void waitForConnection() { for (;;) { if (execute(&quot;ping&quot;) &gt;= 0) { return; } Slog.w(TAG, &quot;installd not ready&quot;); SystemClock.sleep(1000); } } 通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）； 总结：在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。 继续来看startBootstrapServices方法： 12345// Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); 这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。 首先看一下Lifecycle类的定义： 1234567891011121314151617public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; public Lifecycle(Context context) { super(context); mService = new ActivityManagerService(context); } @Override public void onStart() { mService.start(); } public ActivityManagerService getService() { return mService; } } 可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现： 123456789private void start() { Process.removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); } 由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。 然后是启动PowerManagerService服务： 1mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); 启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。 然后是启动LightsService服务 1mSystemServiceManager.startService(LightsService.class); 主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法； 然后是启动DisplayManagerService服务 1mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); 主要是手机显示方面的服务； 然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。 12345Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); 可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; } 可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。 然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。 然后查看startCoreServices方法： 1234567891011121314private void startCoreServices() { // Tracks the battery level. Requires LightService. mSystemServiceManager.startService(BatteryService.class); // Tracks application usage stats. mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // Update after UsageStatsService is available, needed before performBootDexOpt. mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); // Tracks whether the updatable WebView is in a ready state and watches for update installs. mSystemServiceManager.startService(WebViewUpdateService.class); } 可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。 最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。 总结： SystemServer进程是android中一个很重要的进程由Zygote进程启动； SystemServer进程主要用于启动系统中的服务； SystemServer进程启动服务的启动函数为main函数； SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务； SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动 SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务； 创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量； 服务对象都有自己的异步消息对象，并运行在单独的线程中； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程","link":"/2020/09/11/SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"Handler异步休息机制","text":"知乎上看了一篇非常不错的博文：有没有必要阅读ANDROID源码痛定思过，为了更好的深入android体系，决定学习android framework层源码，就从最简单的android异步消息机制开始吧。 （一）Handler的常规使用方式 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity { public static final String TAG = MainActivity.class.getSimpleName(); private TextView texttitle = null; /** * 在主线程中定义Handler，并实现对应的handleMessage方法 */ public static Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;接收到handler消息...&quot;); } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); texttitle = (TextView) findViewById(R.id.texttitle); texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { // 在子线程中发送异步消息 mHandler.sendEmptyMessage(101); } }.start(); } }); }} 可以看出，一般handler的使用方式都是在主线程中定义Handler，然后在子线程中调用mHandler.sendEmptyMessage();方法，然么这里有一个疑问了，我们可以在子线程中定义Handler么？ （二）如何在子线程中定义Handler？ 我们在子线程中定义Handler，看看结果: 123456789101112131415161718texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 点击按钮并运行这段代码： 可以看出来在子线程中定义Handler对象出错了，难道Handler对象的定义或者是初始化只能在主线程中？其实不是这样的，错误信息中提示的已经很明显了，在初始化Handler对象之前需要调用Looper.prepare()方法，那么好了，我们添加这句代码再次执行一次： 12345678910111213141516171819texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Looper.prepare(); Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 再次点击按钮执行该段代码之后，程序已经不会报错了，那么这说明初始化Handler对象的时候我们是需要调用Looper.prepare()的，那么主线程中为什么可以直接初始化Handler呢？ 其实不是这样的，在App初始化的时候会执行ActivityThread的main方法： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 可以看到原来Looper.prepare()方法在这里调用了，所以在其他地方我们就可以直接初始化Handler了。 并且我们可以看到还调用了：Looper.loop()方法，通过参考阅读其他文章我们可以知道一个Handler的标准写法其实是这样的： 12345678910Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); （三）查看Handler源码1）查看Looper.prepare()方法 12345678910111213141516171819// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}. */ public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 可以看到Looper中有一个ThreadLocal成员变量，熟悉JDK的同学应该知道，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。具体参考：彻底理解ThreadLocal由此可以看出在每个线程中Looper.prepare()能且只能调用一次，这里我们可以尝试一下调用两次的情况。 1234567891011121314/** * 这里Looper.prepare()方法调用了两次*/Looper.prepare();Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); 再次运行程序，点击按钮，执行该段代码：可以看到程序出错，并提示prepare中的Excetion信息。 我们继续看Looper对象的构造方法，可以看到在其构造方法中初始化了一个MessageQueue对象： 1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 综上小结（1）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。 2）查看Handler对象的构造方法 12345678910111213141516171819public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 可以看出在Handler的构造方法中，主要初始化了一下变量，并判断Handler对象的初始化不应再内部类，静态类，匿名类中，并且保存了当前线程中的Looper对象。综上小结（2）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。而Handler的构造方法则在Handler内部维护了当前线程的Looper对象 3）查看handler.sendMessage(msg)方法一般的，我们发送异步消息的时候会这样调用： 1mHandler.sendMessage(new Message()); 通过不断的跟进源代码，其最后会调用： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 原来msg.target就是Handler对象本身；而这里的queue对象就是我们的Handler内部维护的Looper对象关联的MessageQueue对象。查看messagequeue对象的enqueueMessage方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 可以看到这里MessageQueue并没有使用列表将所有的Message保存起来，而是使用Message.next保存下一个Message，从而按照时间将所有的Message排序； 4）查看Looper.Loop()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 可以看到方法的内容还是比较多的。可以看到Looper.loop()方法里起了一个死循环，不断的判断MessageQueue中的消息是否为空，如果为空则直接return掉，然后执行queue.next()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 可以看到其大概的实现逻辑就是Message的出栈操作，里面可能对线程，并发控制做了一些限制等。获取到栈顶的Message对象之后开始执行：1msg.target.dispatchMessage(msg); 那么msg.target是什么呢？通过追踪可以知道就是我们定义的Handler对象，然后我们查看一下Handler类的dispatchMessage方法： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 可以看到，如果我们设置了callback（Runnable对象）的话，则会直接调用handleCallback方法： 123private static void handleCallback(Message message) { message.callback.run(); } 即，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。比如我们经常写的runOnUiThread方法： 123456runOnUiThread(new Runnable() { @Override public void run() { } }); 看其内部实现： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 而如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。由于Handler对象是在主线程中创建的，所以handler的handlerMessage方法的执行也会在主线程中。 综上可以知道：1）主线程中定义Handler，直接执行： 123456Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); }}; 而如果想要在子线程中定义Handler，则标准的写法为： 1234567891011// 初始化该线程Looper，MessageQueue，执行且只能执行一次 Looper.prepare(); // 初始化Handler对象，内部关联Looper对象 Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; // 启动消息队列出栈死循环 Looper.loop(); 2）一个线程中只存在一个Looper对象，只存在一个MessageQueue对象，可以存在N个Handler对象，Handler对象内部关联了本线程中唯一的Looper对象，Looper对象内部关联着唯一的一个MessageQueue对象。 3）MessageQueue消息队列不是通过列表保存消息（Message）列表的，而是通过Message对象的next属性关联下一个Message从而实现列表的功能，同时所有的消息都是按时间排序的。 4）android中两个子线程相互交互同样可以通过Handler的异步消息机制实现，可以在线程a中定义Handler对象，而在线程b中获取handler的引用并调用sendMessage方法。 5）activity内部默认存在一个handler的成员变量，android中一些其他的异步消息机制的实现方法：Handler的post方法： 123456mHandler.post(new Runnable() { @Override public void run() { } }); 查看其内部实现： 1234public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 可以发现其内部调用就是sendMessage系列方法。。。 view的post方法： 123456789public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true; } 可以发现其调用的就是activity中默认保存的handler对象的post方法。 activity的runOnUiThread方法： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 判断当前线程是否是UI线程，如果不是，则调用handler的post方法，否则直接执行run方法。 参考文章：Android异步消息处理机制完全解析，带你从源码的角度彻底理解 Android异步消息处理机制详解及源码分析 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"title":"16 应用进程Context创建流程","text":"今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？ 这个问题的答案是Application + N个Activity + N个Service。 还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章： Android Context 是什么？ 好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？ android源码解析之（十一）–&gt;应用进程启动流程最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧， 由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。 首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。 123456public static void main(String[] args) { ... ActivityThread thread = new ActivityThread(); thread.attach(false); ... }这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ViewRootImpl.addFirstDrawHandler(new Runnable() { @Override public void run() { ensureJitEnabled(); } }); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { mgr.releaseSomeActivities(mAppThread); } catch (RemoteException e) { } } } }); } else { ... } } 这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 然后这里面又调用了attachApplicationLocked方法： 12345678private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,getCommonServicesLocked(app.isolated),mCoreSettingsObserver.getCoreSettingsLocked()); ... 可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) { if (services != null) { // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); } setCoreSettings(coreSettings); /* * Two possible indications that this package could be * sharing its runtime with other packages: * * 1.) the sharedUserId attribute is set in the manifest, * indicating a request to share a VM with other * packages with the same sharedUserId. * * 2.) the application element of the manifest has an * attribute specifying a non-default process name, * indicating the desire to run in another packages VM. * * If sharing is enabled we do not have a unique application * in a process and therefore cannot rely on the package * name inside the runtime. */ IPackageManager pm = getPackageManager(); android.content.pm.PackageInfo pi = null; try { pi = pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId()); } catch (RemoteException e) { } if (pi != null) { boolean sharedUserIdSet = (pi.sharedUserId != null); boolean processNameNotDefault = (pi.applicationInfo != null &amp;&amp; !appInfo.packageName.equals(pi.applicationInfo.processName)); boolean sharable = (sharedUserIdSet || processNameNotDefault); // Tell the VMRuntime about the application, unless it is shared // inside a process. if (!sharable) { VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir, appInfo.processName); } } AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data); } 好吧，最后调用了ActivityThread.sendMessage()… 123private void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } 然后我们看一下其sendMessage的重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void handleBindApplication(AppBindData data) { ... // 创建Instrumentation if (data.instrumentationName != null) { InstrumentationInfo ii = null; try { ii = appContext.getPackageManager(). getInstrumentationInfo(data.instrumentationName, 0); } catch (PackageManager.NameNotFoundException e) { } if (ii == null) { throw new RuntimeException( &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName); } mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = ii.nativeLibraryDir; mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); ApplicationInfo instrApp = new ApplicationInfo(); instrApp.packageName = ii.packageName; instrApp.sourceDir = ii.sourceDir; instrApp.publicSourceDir = ii.publicSourceDir; instrApp.splitSourceDirs = ii.splitSourceDirs; instrApp.splitPublicSourceDirs = ii.splitPublicSourceDirs; instrApp.dataDir = ii.dataDir; instrApp.nativeLibraryDir = ii.nativeLibraryDir; LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); ContextImpl instrContext = ContextImpl.createAppContext(this, pi); try { java.lang.ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } mInstrumentation.init(this, instrContext, appContext, new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) { mProfiler.handlingProfiling = true; File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); } } else { mInstrumentation = new Instrumentation(); } ... / If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try { mInstrumentation.onCreate(data.instrumentationArgs); } catch (Exception e) { throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } finally { StrictMode.setThreadPolicy(savedPolicy); } } 这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = &quot;android.app.Application&quot;; } try { java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) { initializeJavaContextClassLoader(); } ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); } catch (Exception e) { if (!mActivityThread.mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); } } mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) { try { instrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!instrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) { final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) { continue; } rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); } return app; } 可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。 继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现： 123public void callApplicationOnCreate(Application app) { app.onCreate(); } 咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。 这样我们整个Application的创建执行流程就讲解完了。 总结： 应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象； ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application； 每个应用进程对应一个Instrumentation，对应一个Application； Instrumentation与Application都是通过java反射机制创建； Application创建过程中会同时创建一个ContextImpl对象，并建立关联； 接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见： android源码解析之（十四）–&gt;Activity启动流程，这里我们看一下其具体的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ... return activity; } 这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。 123456789101112131415161718192021222324252627282930private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) { int displayId = Display.DEFAULT_DISPLAY; try { displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token); } catch (RemoteException e) { } ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); // For debugging purposes, if the activity's package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) { for (int id : dm.getDisplayIds()) { if (id != Display.DEFAULT_DISPLAY) { Display display = dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id)); baseContext = appContext.createDisplayContext(display); break; } } } return baseContext; } 可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。 总结： Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中； Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用； 创建Activity –&gt; 创建Activity相关ContextImpl对象； 创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"26 截屏事件流程","text":"今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。 在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** {@inheritDoc} */ @Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { ... final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理： 123456789101112131415161718192021222324252627282930313233343536@Override public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { if (!mSystemBooted) { // If we have not yet booted, don't let key events do anything. return 0; } ... // Handle special keys. switch (keyCode) { case KeyEvent.KEYCODE_VOLUME_DOWN: case KeyEvent.KEYCODE_VOLUME_UP: case KeyEvent.KEYCODE_VOLUME_MUTE: { if (mUseTvRouting) { // On TVs volume keys never go to the foreground app result &amp;= ~ACTION_PASS_TO_USER; } if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { if (down) { if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } } else { mScreenshotChordVolumeDownKeyTriggered = false; cancelPendingScreenshotChordAction(); } } ... return result; } 可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。 回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行： 12345678if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } 可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。 123456789101112131415private void interceptScreenshotChord() { if (mScreenshotChordEnabled &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) { final long now = SystemClock.uptimeMillis(); if (now &lt;= mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS &amp;&amp; now &lt;= mScreenshotChordPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) { mScreenshotChordVolumeDownKeyConsumed = true; cancelPendingPowerKeyAction(); mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay()); } } } 在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。 12345678private long getScreenshotChordLongPressDelay() { if (mKeyguardDelegate.isShowing()) { // Double the time it takes to take a screenshot from the keyguard return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER * ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout(); } 回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：android源码解析之（二）–&gt;异步消息机制 这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现: 123456private final Runnable mScreenshotRunnable = new Runnable() { @Override public void run() { takeScreenshot(); } }; 好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void takeScreenshot() { synchronized (mScreenshotLock) { if (mScreenshotConnection != null) { return; } ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;, &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;); Intent intent = new Intent(); intent.setComponent(cn); ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { synchronized (mScreenshotLock) { if (mScreenshotConnection != this) { return; } Messenger messenger = new Messenger(service); Message msg = Message.obtain(null, 1); final ServiceConnection myConn = this; Handler h = new Handler(mHandler.getLooper()) { @Override public void handleMessage(Message msg) { synchronized (mScreenshotLock) { if (mScreenshotConnection == myConn) { mContext.unbindService(mScreenshotConnection); mScreenshotConnection = null; mHandler.removeCallbacks(mScreenshotTimeout); } } } }; msg.replyTo = new Messenger(h); msg.arg1 = msg.arg2 = 0; if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; try { messenger.send(msg); } catch (RemoteException e) { } } } @Override public void onServiceDisconnected(ComponentName name) {} }; if (mContext.bindServiceAsUser( intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) { mScreenshotConnection = conn; mHandler.postDelayed(mScreenshotTimeout, 10000); } } } 可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。 1234567891011121314151617181920212223242526272829303132public class TakeScreenshotService extends Service { private static final String TAG = &quot;TakeScreenshotService&quot;; private static GlobalScreenshot mScreenshot; private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 1: final Messenger callback = msg.replyTo; if (mScreenshot == null) { mScreenshot = new GlobalScreenshot(TakeScreenshotService.this); } mScreenshot.takeScreenshot(new Runnable() { @Override public void run() { Message reply = Message.obtain(null, 1); try { callback.send(reply); } catch (RemoteException e) { } } }, msg.arg1 &gt; 0, msg.arg2 &gt; 0); } } }; @Override public IBinder onBind(Intent intent) { return new Messenger(mHandler).getBinder(); }} 可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Takes a screenshot of the current display and shows an animation. */ void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) { // We need to orient the screenshot correctly (and the Surface api seems to take screenshots // only in the natural orientation of the device :!) mDisplay.getRealMetrics(mDisplayMetrics); float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels}; float degrees = getDegreesForRotation(mDisplay.getRotation()); boolean requiresRotation = (degrees &gt; 0); if (requiresRotation) { // Get the dimensions of the device in its native orientation mDisplayMatrix.reset(); mDisplayMatrix.preRotate(-degrees); mDisplayMatrix.mapPoints(dims); dims[0] = Math.abs(dims[0]); dims[1] = Math.abs(dims[1]); } // Take the screenshot mScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } // Optimizations mScreenBitmap.setHasAlpha(false); mScreenBitmap.prepareToDraw(); // Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); } 可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的： 1234if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; 可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了： 12// Take the screenshotmScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); 方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。 1234567public static Bitmap screenshot(int width, int height) { // TODO: should take the display as a parameter IBinder displayToken = SurfaceControl.getBuiltInDisplay( SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN); return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true, false, Surface.ROTATION_0); } 好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功： 12345if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } 若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。 123456789101112131415161718192021static void notifyScreenshotError(Context context, NotificationManager nManager) { Resources r = context.getResources(); // Clear all existing notification, compose the new notification and show it Notification.Builder b = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_failed_title)) .setContentTitle(r.getString(R.string.screenshot_failed_title)) .setContentText(r.getString(R.string.screenshot_failed_text)) .setSmallIcon(R.drawable.stat_notify_image_error) .setWhen(System.currentTimeMillis()) .setVisibility(Notification.VISIBILITY_PUBLIC) // ok to show outside lockscreen .setCategory(Notification.CATEGORY_ERROR) .setAutoCancel(true) .setColor(context.getColor( com.android.internal.R.color.system_notification_accent_color)); Notification n = new Notification.BigTextStyle(b) .bigText(r.getString(R.string.screenshot_failed_text)) .build(); nManager.notify(R.id.notification_screenshot, n); } 然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像： 1234567891011121314if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } 在takeScreenshot方法的最后若截屏成功，我们调用了： 123// Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); 开始截屏的动画，好吧，看一下动画效果的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Starts the animation after taking the screenshot */ private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible, boolean navBarVisible) { // Add the view for the animation mScreenshotView.setImageBitmap(mScreenBitmap); mScreenshotLayout.requestFocus(); // Setup the animation with the screenshot just taken if (mScreenshotAnimation != null) { mScreenshotAnimation.end(); mScreenshotAnimation.removeAllListeners(); } mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams); ValueAnimator screenshotDropInAnim = createScreenshotDropInAnimation(); ValueAnimator screenshotFadeOutAnim = createScreenshotDropOutAnimation(w, h, statusBarVisible, navBarVisible); mScreenshotAnimation = new AnimatorSet(); mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim); mScreenshotAnimation.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Save the screenshot once we have a bit of time now saveScreenshotInWorkerThread(finisher); mWindowManager.removeView(mScreenshotLayout); // Clear any references to the bitmap mScreenBitmap = null; mScreenshotView.setImageBitmap(null); } }); mScreenshotLayout.post(new Runnable() { @Override public void run() { // Play the shutter sound to notify that we've taken a screenshot mCameraSound.play(MediaActionSound.SHUTTER_CLICK); mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null); mScreenshotView.buildLayer(); mScreenshotAnimation.start(); } }); } 好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现： 1234567891011121314151617/** * Creates a new worker thread and saves the screenshot to the media store. */ private void saveScreenshotInWorkerThread(Runnable finisher) { SaveImageInBackgroundData data = new SaveImageInBackgroundData(); data.context = mContext; data.image = mScreenBitmap; data.iconSize = mNotificationIconSize; data.finisher = finisher; data.previewWidth = mPreviewWidth; data.previewheight = mPreviewHeight; if (mSaveInBgTask != null) { mSaveInBgTask.cancel(false); } mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, R.id.notification_screenshot).execute(data); } 好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data, NotificationManager nManager, int nId) { ... // Show the intermediate notification mTickerAddSpace = !mTickerAddSpace; mNotificationId = nId; mNotificationManager = nManager; final long now = System.currentTimeMillis(); mNotificationBuilder = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;)) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setWhen(now) .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color)); mNotificationStyle = new Notification.BigPictureStyle() .bigPicture(picture.createAshmemBitmap()); mNotificationBuilder.setStyle(mNotificationStyle); // For &quot;public&quot; situations we want to show all the same info but // omit the actual screenshot image. mPublicNotificationBuilder = new Notification.Builder(context) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setCategory(Notification.CATEGORY_PROGRESS) .setWhen(now) .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color)); mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build()); Notification n = mNotificationBuilder.build(); n.flags |= Notification.FLAG_NO_CLEAR; mNotificationManager.notify(nId, n); // On the tablet, the large icon makes the notification appear as if it is clickable (and // on small devices, the large icon is not shown) so defer showing the large icon until // we compose the final post-save notification below. mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap()); // But we still don't set it for the expanded view, allowing the smallIcon to show here. mNotificationStyle.bigLargeIcon((Bitmap) null); } 可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。 总结： 在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键 通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。 具体的截屏代码是在native层实现的。 截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。 截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程","link":"/2020/09/11/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"17 Activity布局加载流程","text":"好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？ 要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。 其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。 废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考： android源码解析之（十四）–&gt;Activity启动流程 ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try { r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) { r.state = oldState; } if (!r.activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPause()&quot;); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to pause activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.paused = true; } } else { // If there was an error, for any reason, tell the activity // manager to stop us. try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { // Ignore } } }可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... return activity; } 从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了： 1mInstrumentation.callActivityOnCreate(activity, r.state); 这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现： 12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现： 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } 原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。 至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法： 123456789101112131415161718192021222324protected void onCreate(@Nullable Bundle savedInstanceState) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (mLastNonConfigurationInstances != null) { mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); } if (mActivityInfo.parentActivityName != null) { if (mActionBar == null) { mEnableDefaultActionBarUp = true; } else { mActionBar.setDefaultDisplayHomeAsUpEnabled(true); } } if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(this, savedInstanceState); if (mVoiceInteractor != null) { mVoiceInteractor.attachActivity(this); } mCalled = true; } 可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。 1FATAL EXCEPTION: main Process: com.example.aaron.helloworld, PID: 18001 android.util.SuperNotCalledException: Activity {com.example.aaron.helloworld/com.example.aaron.helloworld.SecondActivity} did not call through to super.onCreate() at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5552) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。 1234567891011activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } 在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。 然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现： 1234public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。 123456789101112131415161718192021222324@Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现： 1234567891011private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } ... } 这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现： 123protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法： 12if (mContentParent == null) { mContentParent = generateLayout(mDecor); 这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122protected ViewGroup generateLayout(DecorView decor) { ... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { layoutResource = R.layout.screen_swipe_dismiss; } else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) { if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_title_icons; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println(&quot;Title Icons!&quot;); } else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) { // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println(&quot;Progress!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) { // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_custom_title; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) { // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) { layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); } else { layoutResource = R.layout.screen_title; } // System.out.println(&quot;Title!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) { layoutResource = R.layout.screen_simple_overlay_action_mode; } else { // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); } mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) { throw new RuntimeException(&quot;Window couldn't find content container view&quot;); } if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) { ProgressBar progress = getCircularProgressBar(false); if (progress != null) { progress.setIndeterminate(true); } } if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { registerSwipeCallbacks(); } // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } mDecor.finishChanging(); return contentParent; } 可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系mDector –&gt; mContentRoot –&gt; mContentParent（包含）并且我们来看一下典型的布局文件： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。 然后我们具体看一下LayoutInflater.inflater方法： 123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null); } 这里调用了inflate的重载方法。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // Empty } if (type != XmlPullParser.START_TAG) { throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); } final String name = parser.getName(); if (DEBUG) { System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); } if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) { if (DEBUG) { System.out.println(&quot;Creating params from root: &quot; + root); } // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) { // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); } } if (DEBUG) { System.out.println(&quot;-----&gt; start inflating children&quot;); } // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) { System.out.println(&quot;-----&gt; done inflating children&quot;); } // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; } catch (Exception e) { InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; } finally { // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; } Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; } } 通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了： 1mLayoutInflater.inflate(layoutResID, mContentParent); 这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。 总结： Activity的展示界面的特性是通过Window对象来控制的； 每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前； 每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view； Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中； 典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。 好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"},{"title":"28 电源开关机按键事件流程","text":"前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。 下面首先看一下dispatchUnhandledKey方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 通过前面两篇文章的分析（ android源码解析（二十六）–&gt;截屏事件流程&nbsp;&nbsp;android源码解析（二十七）–&gt;HOME事件流程）我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。 12345678910111213141516public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { ... case KeyEvent.KEYCODE_POWER: { result &amp;= ~ACTION_PASS_TO_USER; isWakeKey = false; // wake-up will be handled separately if (down) { interceptPowerKeyDown(event, interactive); } else { interceptPowerKeyUp(event, interactive, canceled); } break; } ... return result; } 这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void interceptPowerKeyDown(KeyEvent event, boolean interactive) { ... // Latch power key state to detect screenshot chord. if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordPowerKeyTriggered = true; mScreenshotChordPowerKeyTime = event.getDownTime(); interceptScreenshotChord(); } // Stop ringing or end call if configured to do so when power is pressed. TelecomManager telecomManager = getTelecommService(); boolean hungUp = false; if (telecomManager != null) { if (telecomManager.isRinging()) { // Pressing Power while there's a ringing incoming // call should silence the ringer. telecomManager.silenceRinger(); } else if ((mIncallPowerBehavior &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) { // Otherwise, if &quot;Power button ends call&quot; is enabled, // the Power button will hang up any current active call. hungUp = telecomManager.endCall(); } } // If the power key has still not yet been handled, then detect short // press, long press, or multi press and decide what to do. mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered; if (!mPowerKeyHandled) { if (interactive) { // When interactive, we're already awake. // Wait for a long press or for the button to be released to decide what to do. if (hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } } else { wakeUpFromPowerKey(event.getDownTime()); if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); mBeganFromNonInteractive = true; } else { final int maxCount = getMaxMultiPressPowerCount(); if (maxCount &lt;= 1) { mPowerKeyHandled = true; } else { mBeganFromNonInteractive = true; } } } } } 这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。 123case MSG_POWER_LONG_PRESS: powerLongPress(); break; 我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。 123456789101112131415161718192021private void powerLongPress() { final int behavior = getResolvedLongPressOnPowerBehavior(); switch (behavior) { case LONG_PRESS_POWER_NOTHING: break; case LONG_PRESS_POWER_GLOBAL_ACTIONS: mPowerKeyHandled = true; if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) { performAuditoryFeedbackForAccessibilityIfNeed(); } showGlobalActionsInternal(); break; case LONG_PRESS_POWER_SHUT_OFF: case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM: mPowerKeyHandled = true; performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false); sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF); break; } } 可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面： 然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。 12345678910111213void showGlobalActionsInternal() { sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); if (mGlobalActions == null) { mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs); } final boolean keyguardShowing = isKeyguardShowingAndNotOccluded(); mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned()); if (keyguardShowing) { // since it took two seconds of long press to bring this up, // poke the wake lock so they have some time to see the dialog. mPowerManager.userActivity(SystemClock.uptimeMillis(), false); } } 可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（android源码解析（二十七）–&gt;HOME事件流程）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法： 12345678910111213141516171819202122232425262728293031public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { mContext = context; mWindowManagerFuncs = windowManagerFuncs; mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); mDreamManager = IDreamManager.Stub.asInterface( ServiceManager.getService(DreamService.DREAM_SERVICE)); // receive broadcasts IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED); context.registerReceiver(mBroadcastReceiver, filter); ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE); // get notified of phone state changes TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE); mContext.getContentResolver().registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE); mHasVibrator = vibrator != null &amp;&amp; vibrator.hasVibrator(); mShowSilentToggle = SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean( com.android.internal.R.bool.config_useFixedVolume); } 可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。 123456789101112public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) { mKeyguardShowing = keyguardShowing; mDeviceProvisioned = isDeviceProvisioned; if (mDialog != null) { mDialog.dismiss(); mDialog = null; // Show delayed, so that the dismiss of the previous dialog completes mHandler.sendEmptyMessage(MESSAGE_SHOW); } else { handleShow(); } } 可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。 1234567891011121314151617private void handleShow() { awakenIfNecessary(); mDialog = createDialog(); prepareDialog(); // If we only have 1 item and it's a simple press action, just do this action. if (mAdapter.getCount() == 1 &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) { ((SinglePressAction) mAdapter.getItem(0)).onPress(); } else { WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes(); attrs.setTitle(&quot;GlobalActions&quot;); mDialog.getWindow().setAttributes(attrs); mDialog.show(); mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND); } 在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private GlobalActionsDialog createDialog() { ... mAirplaneModeOn = new ToggleAction( R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) { void onToggle(boolean on) { if (mHasTelephony &amp;&amp; Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) { mIsWaitingForEcmExit = true; // Launch ECM exit dialog Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null); ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(ecmDialogIntent); } else { changeAirplaneModeSystemSetting(on); } } @Override protected void changeStateFromPress(boolean buttonOn) { if (!mHasTelephony) return; // In ECM mode airplane state cannot be changed if (!(Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) { mState = buttonOn ? State.TurningOn : State.TurningOff; mAirplaneState = mState; } } public boolean showDuringKeyguard() { return true; } public boolean showBeforeProvisioning() { return false; } }; onAirplaneModeChanged(); mItems = new ArrayList&lt;Action&gt;(); String[] defaultActions = mContext.getResources().getStringArray( com.android.internal.R.array.config_globalActionsList); ArraySet&lt;String&gt; addedKeys = new ArraySet&lt;String&gt;(); for (int i = 0; i &lt; defaultActions.length; i++) { String actionKey = defaultActions[i]; if (addedKeys.contains(actionKey)) { // If we already have added this, don't add it again. continue; } if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) { mItems.add(new PowerAction()); } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) { mItems.add(mAirplaneModeOn); } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) { if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 &amp;&amp; isCurrentUserOwner()) { mItems.add(getBugReportAction()); } } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) { if (mShowSilentToggle) { mItems.add(mSilentModeAction); } } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) { if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) { addUsersToMenu(mItems); } } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) { mItems.add(getSettingsAction()); } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) { mItems.add(getLockdownAction()); } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) { mItems.add(getVoiceAssistAction()); } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) { mItems.add(getAssistAction()); } else { Log.e(TAG, &quot;Invalid global action key &quot; + actionKey); } // Add here so we don't add more than one. addedKeys.add(actionKey); } mAdapter = new MyAdapter(); AlertParams params = new AlertParams(mContext); params.mAdapter = mAdapter; params.mOnClickListener = this; params.mForceInverseBackground = true; GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params); dialog.setCanceledOnTouchOutside(false); // Handled by the custom class. dialog.getListView().setItemsCanFocus(true); dialog.getListView().setLongClickable(true); dialog.getListView().setOnItemLongClickListener( new AdapterView.OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { final Action action = mAdapter.getItem(position); if (action instanceof LongPressAction) { return ((LongPressAction) action).onLongPress(); } return false; } }); dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); dialog.setOnDismissListener(this); return dialog; } 方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面： 好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了： 1mItems.add(new PowerAction()); 这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。 1234567891011121314151617181920212223242526272829303132private final class PowerAction extends SinglePressAction implements LongPressAction { private PowerAction() { super(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off); } @Override public boolean onLongPress() { UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE); if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) { mWindowManagerFuncs.rebootSafeMode(true); return true; } return false; } @Override public boolean showDuringKeyguard() { return true; } @Override public boolean showBeforeProvisioning() { return true; } @Override public void onPress() { // shutdown by making sure radio and power are handled accordingly. mWindowManagerFuncs.shutdown(false /* confirm */); } } 可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。 12345public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { ... mWindowManagerFuncs = windowManagerFuncs; ...} 好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。 经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。 12345678910private void initPolicy() { UiThread.getHandler().runWithScissors(new Runnable() { @Override public void run() { WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper()); mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this); } }, 0); } 这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。 然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false / confirm /);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。 1234@Override public void shutdown(boolean confirm) { ShutdownThread.shutdown(mContext, confirm); } 好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。 12345public static void shutdown(final Context context, boolean confirm) { mReboot = false; mRebootSafeMode = false; shutdownInner(context, confirm); } 可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void shutdownInner(final Context context, boolean confirm) { // ensure that only one thread is trying to power down. // any additional calls are just returned synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;); return; } } final int longPressBehavior = context.getResources().getInteger( com.android.internal.R.integer.config_longPressOnPowerBehavior); final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm); Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior); if (confirm) { final CloseDialogReceiver closer = new CloseDialogReceiver(context); if (sConfirmDialog != null) { sConfirmDialog.dismiss(); } sConfirmDialog = new AlertDialog.Builder(context) .setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off) .setMessage(resourceId) .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { beginShutdownSequence(context); } }) .setNegativeButton(com.android.internal.R.string.no, null) .create(); closer.dialog = sConfirmDialog; sConfirmDialog.setOnDismissListener(closer); sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); sConfirmDialog.show(); } else { beginShutdownSequence(context); } } 可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static void beginShutdownSequence(Context context) { synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;); return; } sIsStarted = true; } ... if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) { mRebootUpdate = new File(UNCRYPT_PACKAGE_FILE).exists(); if (mRebootUpdate) { pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_update_prepare)); pd.setMax(100); pd.setProgressNumberFormat(null); pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); pd.setProgress(0); pd.setIndeterminate(false); } else { // Factory reset path. Set the dialog message accordingly. pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_reset_message)); pd.setIndeterminate(true); } } else { pd.setTitle(context.getText(com.android.internal.R.string.power_off)); pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress)); pd.setIndeterminate(true); } pd.setCancelable(false); pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); pd.show(); sInstance.mProgressDialog = pd; sInstance.mContext = context; sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE); // make sure we never fall asleep again sInstance.mCpuWakeLock = null; try { sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;); sInstance.mCpuWakeLock.setReferenceCounted(false); sInstance.mCpuWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mCpuWakeLock = null; } // also make sure the screen stays on for better user experience sInstance.mScreenWakeLock = null; if (sInstance.mPowerManager.isScreenOn()) { try { sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;); sInstance.mScreenWakeLock.setReferenceCounted(false); sInstance.mScreenWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mScreenWakeLock = null; } } // start the thread that initiates shutdown sInstance.mHandler = new Handler() { }; sInstance.start(); } 在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。 总结： 电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中； 在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等； 当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程","link":"/2020/09/11/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"30 触摸事件分发流程","text":"前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。 123456789101112131415161718192021at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)at android.view.View.dispatchPointerEvent(View.java:8698)at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185) 这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。 在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明： Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device. 然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？ 12public void onUserInteraction() { }可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍： Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. 理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。 回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。 1234567private final class DecorView extends FrameLayout implements RootViewSurfaceTaker { ... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } ...} 在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。 好了，这里先暂时说一下Acitivty中的事件分发流程 ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法； Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。 若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。 下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。 然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。 123public boolean onInterceptTouchEvent(MotionEvent ev) { return false; } 一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。 123456789101112131415161718public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } } 比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。 然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。 然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？ 在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; }然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。 但这里大概分析了一下ViewGroup的事件分发流程 首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。 在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。 下面我们继续看一下View的dispatchTouchEvent方法。12345678910111213141516171819public boolean dispatchTouchEvent(MotionEvent event) { ... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; }View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。 123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l; } 可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。 所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; } 在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。 1234567891011121314public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; } 所以View组件分发触摸事件的时候： View控件会首先执行dispatchTouchEvent方法。 View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。 View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。 View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。 如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。 参考：http://blog.csdn.net/xiaanming/article/details/21696315http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程android源码解析（二十九）–&gt;应用程序返回按键执行流程","link":"/2020/09/11/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"title":"12 系统启动并解析Manifest的流程","text":"最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢? 其实android系统启动过程中解析Manifest的流程是通过PackageManagerService服务来实现的。这里我们重点分析一下PackageManagerService服务是如何解析Manifest的。 首先看一下在SystemServer进程启动过程中是如何启动PackageManagerService服务的： 123456789private void startBootstrapServices() { ... mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); ... } 在SystemServer进程启动过程中会调用SystemServer类的startBootstrapServices方法（主要用于启动ActivityManagerService服务和PackageManagerService服务），然后会在这个方法中会调用PackageManagerService.main静态方法，这个方法主要是用来初始化PackageManagerService服务并执行相关逻辑的。下面我来看一下main方法的具体逻辑： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; }可以发现main方法的实现逻辑主要是创建了一个PackageManagerService对象，并将这个对象添加到ServierManager中为其他组件提供服务。好吧，看来PackageManagerService的初始化操作主要是在PackageManagerService的构造方法中了，下面我们来看一下其构造方法的实现逻辑： 1234567File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, &quot;data&quot;); mAppInstallDir = new File(dataDir, &quot;app&quot;); mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;); mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath(); mUserAppDataDir = new File(dataDir, &quot;user&quot;); mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); PackageManagerService的构造方法代码量比较大，这里就不贴出所有的代码了，我们主要和解析Manifest相关的主要代码，在构造方法中有这样几段代码。可以发现在构造方法中，解析了系统中几个apk的安装目录，这几个目录就是系统中安装apk的目录，android系统会默认解析这几个目录下apk文件，也就是说如果我们android手机在其他的目录下存在apk文件系统是不会默认解析的，反过来说，如果我们把我们的apk文件移动到这几个目录下，那么重新启动操作系统，该apk文件就会被系统解析并执行相关的逻辑操作，具体做什么操作呢？我们看下面的实现。 123456789101112131415161718192021222324252627282930313233343536/ overlay packages if they reside in VENDOR_OVERLAY_DIR. File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0); // Find base frameworks (resource packages without code). scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try { vendorAppDir = vendorAppDir.getCanonicalFile(); } catch (IOException e) { // failed to look up canonical path, continue with original one } scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 在我们刚刚的PackageManagerService.mani方法中，解析完刚刚的几个系统目录之后系统会调用scanDirLI方法，那么这个方法主要是做什么用的呢？看它的名字应该是遍历这个系统目录。好吧，这个方法主要就是用于解析上面几个目录下的apk文件的。不信？我们看一下scanDirLI方法的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) { final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) { Log.d(TAG, &quot;No files in app dir &quot; + dir); return; } if (DEBUG_PACKAGE_SCANNING) { Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags + &quot; flags=0x&quot; + Integer.toHexString(parseFlags)); } for (File file : files) { final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) { // Ignore entries which are not packages continue; } try { scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); } catch (PackageManagerException e) { Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage()); // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) { logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file); if (file.isDirectory()) { mInstaller.rmPackageDir(file.getAbsolutePath()); } else { file.delete(); } } } } } 可以放下其首先会遍历该目录下的所有文件，并判断是否是apk文件，如果是apk文件则调用scanPackageLI方法，scanPackageLI方法的名字很明显，就是用于解析这个apk文件的。 继续看一下scanPakcageLI方法的实现： 123456789101112131415161718192021private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile); parseFlags |= mDefParseFlags; PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) { parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY; } final PackageParser.Package pkg; try { pkg = pp.parsePackage(scanFile, parseFlags); } catch (PackageParserException e) { throw PackageManagerException.from(e); } ...} 好吧，这个方法也比较复杂，这里只是列出重点相关的代码，我们可以发现在这个方法中创建了一个PackagerParser对象，并调用了parsePackage方法，这个方法其实就是解析Manifest的主要方法，我们可以看一下其具体的实现： 1234567public Package parsePackage(File packageFile, int flags) throws PackageParserException { if (packageFile.isDirectory()) { return parseClusterPackage(packageFile, flags); } else { return parseMonolithicPackage(packageFile, flags); } } 可以发现，若我们解析的File对象是一个文件夹则执行调用parseClusterPackage方法，否则调用执行parseMonolithicPackage方法，很明显的因为我们这里解析的是apk文件（在上一方法中我们循环遍历得到了apk文件，这里的File对象就代表了一个个的apk文件信息），所以这里会执行parseMonolithicPackage方法，然后我们来看一下parseMonolithicPackage方法： 123456789101112131415161718public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException { if (mOnlyCoreApps) { final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (!lite.coreApp) { throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, &quot;Not a coreApp: &quot; + apkFile); } } final AssetManager assets = new AssetManager(); try { final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.codePath = apkFile.getAbsolutePath(); return pkg; } finally { IoUtils.closeQuietly(assets); } } 可以看出，这里又调用了parseBaseApk方法： 12345private Package parseBaseApk(File apkFile, AssetManager assets, int flags) ... final Package pkg = parseBaseApk(res, parser, flags, outError); ... } 可以看出，这个parseBaseApk方法调用了其重载的parseBaseApk方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;application&quot;)) { if (foundApp) { if (RIGID_PARSER) { outError[0] = &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;); XmlUtils.skipCurrentTag(parser); continue; } } foundApp = true; if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) { return null; } } else if (tagName.equals(&quot;overlay&quot;)) { pkg.mTrustedOverlay = trustedOverlay; sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestResourceOverlay); pkg.mOverlayTarget = sa.getString( com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage); pkg.mOverlayPriority = sa.getInt( com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority, -1); sa.recycle(); if (pkg.mOverlayTarget == null) { outError[0] = &quot;&lt;overlay&gt; does not specify a target package&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) { outError[0] = &quot;&lt;overlay&gt; priority must be between 0 and 9999&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;key-sets&quot;)) { if (!parseKeySets(pkg, res, parser, attrs, outError)) { return null; } } else if (tagName.equals(&quot;permission-group&quot;)) { if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission&quot;)) { if (parsePermission(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission-tree&quot;)) { if (parsePermissionTree(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;uses-permission&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-permission-sdk-m&quot;) || tagName.equals(&quot;uses-permission-sdk-23&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-configuration&quot;)) { ConfigurationInfo cPref = new ConfigurationInfo(); sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesConfiguration); cPref.reqTouchScreen = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen, Configuration.TOUCHSCREEN_UNDEFINED); cPref.reqKeyboardType = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType, Configuration.KEYBOARD_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD; } cPref.reqNavigation = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation, Configuration.NAVIGATION_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV; } sa.recycle(); pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-feature&quot;)) { FeatureInfo fi = parseUsesFeature(res, attrs); pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi); if (fi.name == null) { ConfigurationInfo cPref = new ConfigurationInfo(); cPref.reqGlEsVersion = fi.reqGlEsVersion; pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;feature-group&quot;)) { FeatureGroupInfo group = new FeatureGroupInfo(); ArrayList&lt;FeatureInfo&gt; features = null; final int innerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } final String innerTagName = parser.getName(); if (innerTagName.equals(&quot;uses-feature&quot;)) { FeatureInfo featureInfo = parseUsesFeature(res, attrs); // FeatureGroups are stricter and mandate that // any &lt;uses-feature&gt; declared are mandatory. featureInfo.flags |= FeatureInfo.FLAG_REQUIRED; features = ArrayUtils.add(features, featureInfo); } else { Slog.w(TAG, &quot;Unknown element under &lt;feature-group&gt;: &quot; + innerTagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); } XmlUtils.skipCurrentTag(parser); } if (features != null) { group.features = new FeatureInfo[features.size()]; group.features = features.toArray(group.features); } pkg.featureGroups = ArrayUtils.add(pkg.featureGroups, group); } else if (tagName.equals(&quot;uses-sdk&quot;)) { if (SDK_VERSION &gt; 0) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesSdk); int minVers = 0; String minCode = null; int targetVers = 0; String targetCode = null; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = minVers = val.data; } } val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = val.data; } } sa.recycle(); if (minCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (minCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } } else if (minVers &gt; SDK_VERSION) { outError[0] = &quot;Requires newer sdk version #&quot; + minVers + &quot; (current version is #&quot; + SDK_VERSION + &quot;)&quot;; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } if (targetCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (targetCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } // If the code matches, it definitely targets this SDK. pkg.applicationInfo.targetSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; } else { pkg.applicationInfo.targetSdkVersion = targetVers; } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;supports-screens&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestSupportsScreens); pkg.applicationInfo.requiresSmallestWidthDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp, 0); pkg.applicationInfo.compatibleWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp, 0); pkg.applicationInfo.largestWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp, 0); // This is a trick to get a boolean and still able to detect // if a value was actually set. supportsSmallScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens, supportsSmallScreens); supportsNormalScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens, supportsNormalScreens); supportsLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens, supportsLargeScreens); supportsXLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens, supportsXLargeScreens); resizeable = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable, resizeable); anyDensity = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity, anyDensity); sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;protected-broadcast&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestProtectedBroadcast); // Note: don't allow this value to be a reference to a resource // that may change. String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name); sa.recycle(); if (name != null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) != 0) { if (pkg.protectedBroadcasts == null) { pkg.protectedBroadcasts = new ArrayList&lt;String&gt;(); } if (!pkg.protectedBroadcasts.contains(name)) { pkg.protectedBroadcasts.add(name.intern()); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;instrumentation&quot;)) { if (parseInstrumentation(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;original-package&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) { if (pkg.mOriginalPackages == null) { pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; } pkg.mOriginalPackages.add(orig); } sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;adopt-permissions&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) { if (pkg.mAdoptPermissions == null) { pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); } pkg.mAdoptPermissions.add(name); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-gl-texture&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;compatible-screens&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;supports-input&quot;)) { XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;eat-comment&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (RIGID_PARSER) { outError[0] = &quot;Bad element under &lt;manifest&gt;: &quot; + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;Unknown element under &lt;manifest&gt;: &quot; + parser.getName() + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } } 在这个parseBaseApk方法中有一个while循环，该循环主要就是用于解析AndroidManifest.xml文件中的节点信息。在开始解析application节点的时候，同时调用了parseBaseApplication方法，该方法解析了application节点下的activity，service，broadcast，contentprovier等组件的定义信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;activity&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (tagName.equals(&quot;receiver&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.receivers.add(a); } else if (tagName.equals(&quot;service&quot;)) { Service s = parseService(owner, res, parser, attrs, flags, outError); if (s == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.services.add(s); } else if (tagName.equals(&quot;provider&quot;)) { Provider p = parseProvider(owner, res, parser, attrs, flags, outError); if (p == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.providers.add(p); } else if (tagName.equals(&quot;activity-alias&quot;)) { Activity a = parseActivityAlias(owner, res, parser, attrs, flags, outError); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (parser.getName().equals(&quot;meta-data&quot;)) { // note: application meta-data is stored off to the side, so it can // remain null in the primary copy (we like to avoid extra copies because // it can be large) if ((owner.mAppMetaData = parseMetaData(res, parser, attrs, owner.mAppMetaData, outError)) == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } else if (tagName.equals(&quot;library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestLibrary_name); sa.recycle(); if (lname != null) { lname = lname.intern(); if (!ArrayUtils.contains(owner.libraryNames, lname)) { owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); if (lname != null) { lname = lname.intern(); if (req) { owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); } else { owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-package&quot;)) { // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); } else { if (!RIGID_PARSER) { Slog.w(TAG, &quot;Unknown element under &lt;application&gt;: &quot; + tagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } else { outError[0] = &quot;Bad element under &lt;application&gt;: &quot; + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } } 这样，经过这里循环遍历，整个androidManifest的节点信息就被解析并保存在了Package对象中。可以看到我们平时在Manifest中定义的各种节点，其实都是在这里有所体现。当androidManifest.xml文件被解析完成之后会调用我们刚刚介绍的scanPackageLI的重载方法，将解析完成的Package对象信息保存的Setting对象中，这个对象用于保存app的安装信息，具体实现是在方法： 12private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException 当解析完成manifest文件之后会调用其重载方法： 123// Note that we invoke the following method only if we are about to unpack an application PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); 这样，解析的manifest文件信息就会被保存到Settings中，并持久化，然后执行安装apk的操作，我们可以看一下该重载方法的具体实现： 1234567891011121314private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { boolean success = false; try { final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user); success = true; return res; } finally { if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) { removeDataDirsLI(pkg.volumeUuid, pkg.packageName); } } } 可以发现其内部调用了scanPackageDirtyLI方法，这个方法就是实际实现持久化manifest信息并安装APK操作的： 12345678private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { ... // And now re-install the app. ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo); ...} 可以发现其内部调用了createDataDirLI，该方法主要实现安装apk的操作。 1234567891011121314151617private int createDataDirsLI(String volumeUuid, String packageName, int uid, String seinfo) { int[] users = sUserManager.getUserIds(); int res = mInstaller.install(volumeUuid, packageName, uid, uid, seinfo); if (res &lt; 0) { return res; } for (int user : users) { if (user != 0) { res = mInstaller.createUserData(volumeUuid, packageName, UserHandle.getUid(user, uid), user, seinfo); if (res &lt; 0) { return res; } } } return res; } 查看该方法的实现：1234567891011121314public int install(String uuid, String name, int uid, int gid, String seinfo) { StringBuilder builder = new StringBuilder(&quot;install&quot;); builder.append(' '); builder.append(escapeNull(uuid)); builder.append(' '); builder.append(name); builder.append(' '); builder.append(uid); builder.append(' '); builder.append(gid); builder.append(' '); builder.append(seinfo != null ? seinfo : &quot;!&quot;); return mInstaller.execute(builder.toString()); }怎么样？很熟悉吧，这里的Installer其实调用的就是我们平时运行android项目很熟悉的install命令，原来android系统安装apk文件底层都是调用的adb命令。 总结： android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作； 解析Manifest流程：Zygote进程 –&gt; SystemServer进程 –&gt; PackgeManagerService服务 –&gt; scanDirLI方法 –&gt; scanPackageLI方法 –&gt; PackageParser.parserPackage方法； 解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程","link":"/2020/09/11/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/"},{"title":"13 apk安装流程","text":"上一篇文章中给大家分析了一下android系统启动之后调用PackageManagerService服务并解析系统特定目录，解析apk文件并安装的过程，这个安装过期实际上是没有图形界面的，底层调用的是我们平时比较熟悉的adb命令，那么我们平时安装apk文件的时候大部分是都过图形界面安装的，那么这种方式安装apk具体的流程是怎样的呢？ 下面我们就来具体看一下apk的具体安装过程，相信大家都知道如果我们想在代码里执行apk的安装，那么一般都是这样： 1234Intent intent = new Intent(Intent.ACTION_VIEW);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setDataAndType(Uri.parse(&quot;file://&quot; + path),&quot;application/vnd.android.package-archive&quot;);context.startActivity(intent); 这样，我们就会打开安装apk文件的程序并执行安装逻辑了，那么这段代码具体是打开那个activity呢？好吧，从这个问题开始，我们来解析apk的安装流程… 这里跟大姐简单介绍一下android的源码，平时我们使用的android.jar里面的java源码只是android系统源码的一部分，还有好多源码并没有打入到android.jar中，这里为大家推荐一个android源码的地址：https://github.com/android里面根据android系统的不同模块包含了许多android模块的源码。 这里我们找到platform_packages_apps_packageinstaller库，这里面就是android系统安装程序的源码了。 这里我们找到其androidManifest.xml，然后我们来看一下其具体的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.packageinstaller&quot; coreApp=&quot;true&quot;&gt; &lt;original-package android:name=&quot;com.android.packageinstaller&quot; /&gt; ... &lt;application android:label=&quot;@string/app_name&quot; android:allowBackup=&quot;false&quot; android:theme=&quot;@style/Theme.DialogWhenLarge&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.InstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.UninstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/Theme.AlertDialogActivity&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.DELETE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.UNINSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.UninstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.GrantPermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/GrantPermissions&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.ManagePermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:label=&quot;@string/app_permissions&quot; android:theme=&quot;@style/Settings&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.OverlayWarningDialog&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@android:style/Theme.DeviceDefault.Light.Dialog.NoActionBar&quot; /&gt; &lt;provider android:name=&quot;.wear.WearPackageIconProvider&quot; android:authorities=&quot;com.google.android.packageinstaller.wear.provider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.wear.WarningConfirmationActivity&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot; android:theme=&quot;@style/Settings&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt;好吧，这里我们大概看一下Activity的定义，这里我们重点看一下PackageInstallerActivity的定义： 123456789101112131415161718192021&lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 恩？这里不就是我们刚刚定义的启动安装Apk activity的intent filter？好吧，所以说一开始我们调用的startActivity其实启动的就是PackageInstallerActivity，那么下面我们就看一下PackageInstellerActivity的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 这里我们主要先看一下PackageInstallerActivity的onCreate方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 可以发现，在onCreate方法中，首先执行一些初始化操作，获取PackageManager和Installer、UserManager等对象，然后会根据当前Intent的信息最一些逻辑判断并弹出消息弹窗，我们可以看一下具体的消息弹窗类型： 12345678private static final int DLG_BASE = 0; private static final int DLG_UNKNOWN_SOURCES = DLG_BASE + 1; private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2; private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3; private static final int DLG_INSTALL_ERROR = DLG_BASE + 4; private static final int DLG_ALLOW_SOURCE = DLG_BASE + 5; private static final int DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES = DLG_BASE + 6; private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7; 可以发现当分析Intent对象的时候，如果可以得到这样几种结果：不知道apk的来源，package信息错误，存储空间不够，安装时报，来源正确，允许未知来源的apk文件，在wear上不支持等，这样根据不同的消息类型会弹出不同的消息弹窗： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Override public Dialog onCreateDialog(int id, Bundle bundle) { switch (id) { case DLG_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_dlg_text) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Finishing off activity so that user can navigate to settings manually&quot;); finish(); }}) .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Launching settings&quot;); launchSecuritySettings(); } }) .setOnCancelListener(this) .create(); case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_admin_dlg_text) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_PACKAGE_ERROR : return new AlertDialog.Builder(this) .setTitle(R.string.Parse_error_dlg_title) .setMessage(R.string.Parse_error_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_OUT_OF_SPACE: // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText = getString(R.string.out_of_space_dlg_text, appTitle.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.out_of_space_dlg_title) .setMessage(dlgText) .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { //launch manage applications Intent intent = new Intent(&quot;android.intent.action.MANAGE_PACKAGE_STORAGE&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); } }) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Canceling installation&quot;); finish(); } }) .setOnCancelListener(this) .create(); case DLG_INSTALL_ERROR : // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle1 = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText1 = getString(R.string.install_failed_msg, appTitle1.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.install_failed) .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setMessage(dlgText1) .setOnCancelListener(this) .create(); case DLG_ALLOW_SOURCE: CharSequence appTitle2 = mPm.getApplicationLabel(mSourceInfo); String dlgText2 = getString(R.string.allow_source_dlg_text, appTitle2.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.allow_source_dlg_title) .setMessage(dlgText2) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_CANCELED); finish(); }}) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { SharedPreferences prefs = getSharedPreferences(PREFS_ALLOWED_SOURCES, Context.MODE_PRIVATE); prefs.edit().putBoolean(mSourceInfo.packageName, true).apply(); startInstallConfirm(); } }) .setOnCancelListener(this) .create(); case DLG_NOT_SUPPORTED_ON_WEAR: return new AlertDialog.Builder(this) .setTitle(R.string.wear_not_allowed_dlg_title) .setMessage(R.string.wear_not_allowed_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_OK); finish(); } }) .setOnCancelListener(this) .create(); } return null; } 消息弹窗的主要作用，用于提示用户当前安装apk文件的特性。都知道android系统在android apk文件之前会解析器manifest文件，这个操作也是早onCreate方法中执行的： 1PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); 我们具体看一下getPackageInfo方法的实现： 12345678910public static PackageParser.Package getPackageInfo(File sourceFile) { final PackageParser parser = new PackageParser(); try { PackageParser.Package pkg = parser.parseMonolithicPackage(sourceFile, 0); parser.collectManifestDigest(pkg); return pkg; } catch (PackageParserException e) { return null; } } 好吧，到了这里是不是代码变得很熟悉了？parseMonolithicPackage就是我们上一节分析的android系统解析manifest文件的过程，具体的可参考：http://blog.csdn.net/qq_23547831/article/details/51203482 而collectManifestDigest方法，我们这里简单的介绍一下，其主要是要争apk的签名是否正确。好吧通过这两部我们就把apk文件的manifest和签名信息都解析完成并保存在了Package中。 接着往下走，在所有的解析完成之后我们会在onCreate方法中执行initiateInstall();方法，刚方法的主要作用是初始化安装。 123456789101112131415161718192021222324252627282930313233343536private void initiateInstall() { String pkgName = mPkgInfo.packageName; // Check if there is already a package on the device with this name // but it has been renamed to something else. String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // Check if package is already installed. display confirmation dialog if replacing pkg try { // This is a little convoluted because we want to get all uninstalled // apps, but this may include apps with just data, and if it is just // data we still want to count it as &quot;installed&quot;. mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.GET_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } mInstallFlowAnalytics.setReplace(mAppInfo != null); mInstallFlowAnalytics.setSystemApp( (mAppInfo != null) &amp;&amp; ((mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0)); // If we have a session id, we're invoked to verify the permissions for the given // package. Otherwise, we start the install process. if (mSessionId != -1) { startInstallConfirm(); } else { startInstall(); } } 好吧，这里面有调用了startInstallConfirm方法，然后我们看一下startInstallConfirm方法的实现: 12345private void startInstallConfirm() { ... //初始化安装确认界面 ...} 好吧，这个方法的实现比较简单，主要的实现逻辑就是现实该activity的用户界面，平时我们安装某一个应用的时候会弹出一个安装确认页面，还有一个确认和取消按钮，有印象么？其实就是在这里执行的界面初始化操作。 好吧，一般情况下在apk安装确认页面，我们会点击确认按钮执行安装逻辑吧？那么这里我们找一下确认按钮的点击事件： 1234567891011121314151617181920212223242526272829public void onClick(View v) { if (v == mOk) { if (mOkCanInstall || mScrollView == null) { mInstallFlowAnalytics.setInstallButtonClicked(); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); // We're only confirming permissions, so we don't really know how the // story ends; assume success. mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult( PackageManager.INSTALL_SUCCEEDED); finish(); } else { startInstall(); } } else { mScrollView.pageScroll(View.FOCUS_DOWN); } } else if (v == mCancel) { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_CANCELLED_BY_USER); finish(); } } 很明显了，这里当我们点击确认按钮的时候会执行startInstall方法，也就是开始执行安装逻辑： 123456789101112131415161718192021222324252627282930313233private void startInstall() { // Start subactivity to actually install the application Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallAppProgress.class); newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest); newIntent.putExtra( InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics); String installerPackageName = getIntent().getStringExtra( Intent.EXTRA_INSTALLER_PACKAGE_NAME); if (mOriginatingURI != null) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI); } if (mReferrerURI != null) { newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI); } if (mOriginatingUid != VerificationParams.NO_UID) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid); } if (installerPackageName != null) { newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); } if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); } if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish(); } 可以发现，点击确认按钮之后我们调用启用了一个新的Activity–&gt;InstallAppProgress，这个Activity主要用于执行apk的安装逻辑了。 123456789101112131415161718192021222324252627@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); Intent intent = getIntent(); mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mInstallFlowAnalytics = intent.getParcelableExtra(EXTRA_INSTALL_FLOW_ANALYTICS); mInstallFlowAnalytics.setContext(this); mPackageURI = intent.getData(); final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); throw new IllegalArgumentException(&quot;unexpected scheme &quot; + scheme); } mInstallThread = new HandlerThread(&quot;InstallThread&quot;); mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver( mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null /*scheduler*/); initView(); } 可以发现InstallAppProcess这个Activity的onCreate方法中主要初始化了一些成员变量，并调用initView方法，我们在iniTView方法中可以看到： 12345678910void initView() { ... mInstallHandler.post(new Runnable() { @Override public void run() { doPackageStage(pm, params); } }); ...} 经过一些view的初始化操作之后调用了doPackageStage方法，该方法主要是通过调用PackageInstaller执行apk文件的安装，这里就不在详细的介绍了，在apk文件安装完成之后PackageInstaller会发送一个安装完成的广播，刚刚我们在onCreate方法中注册了一个广播接收器，其可以用来接收apk安装完成的广播： 123456789101112private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final int statusCode = intent.getIntExtra( PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (statusCode == PackageInstaller.STATUS_PENDING_USER_ACTION) { context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT)); } else { onPackageInstalled(statusCode); } } }; 这样apk安装完成之后，这里的广播接收器会接收到广播并执行onPackageInstalled方法，执行后续的处理逻辑，那么我们来看一下onPackageInstalled方法的具体实现逻辑： 12345void onPackageInstalled(int statusCode) { Message msg = mHandler.obtainMessage(INSTALL_COMPLETE); msg.arg1 = statusCode; mHandler.sendMessage(msg); } 好吧，这里是发送Handler异步消息，我们来看一下异步消息的处理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case INSTALL_COMPLETE: mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(msg.arg1); if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1); setResult(msg.arg1 == PackageInstaller.STATUS_SUCCESS ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); finish(); return; } // Update the status text mProgressBar.setVisibility(View.INVISIBLE); // Show the ok button int centerTextLabel; int centerExplanationLabel = -1; LevelListDrawable centerTextDrawable = (LevelListDrawable) getDrawable(R.drawable.ic_result_status); if (msg.arg1 == PackageInstaller.STATUS_SUCCESS) { mLaunchButton.setVisibility(View.VISIBLE); centerTextDrawable.setLevel(0); centerTextLabel = R.string.install_done; // Enable or disable launch button mLaunchIntent = getPackageManager().getLaunchIntentForPackage( mAppInfo.packageName); boolean enabled = false; if(mLaunchIntent != null) { List&lt;ResolveInfo&gt; list = getPackageManager(). queryIntentActivities(mLaunchIntent, 0); if (list != null &amp;&amp; list.size() &gt; 0) { enabled = true; } } if (enabled) { mLaunchButton.setOnClickListener(InstallAppProgress.this); } else { mLaunchButton.setEnabled(false); } } else if (msg.arg1 == PackageInstaller.STATUS_FAILURE_STORAGE){ showDialogInner(DLG_OUT_OF_SPACE); return; } else { // Generic error handling for all other error codes. centerTextDrawable.setLevel(1); centerExplanationLabel = getExplanationFromErrorCode(msg.arg1); centerTextLabel = R.string.install_failed; mLaunchButton.setVisibility(View.INVISIBLE); } if (centerTextDrawable != null) { centerTextDrawable.setBounds(0, 0, centerTextDrawable.getIntrinsicWidth(), centerTextDrawable.getIntrinsicHeight()); mStatusTextView.setCompoundDrawablesRelative(centerTextDrawable, null, null, null); } mStatusTextView.setText(centerTextLabel); if (centerExplanationLabel != -1) { mExplanationTextView.setText(centerExplanationLabel); mExplanationTextView.setVisibility(View.VISIBLE); } else { mExplanationTextView.setVisibility(View.GONE); } mDoneButton.setOnClickListener(InstallAppProgress.this); mOkPanel.setVisibility(View.VISIBLE); break; default: break; } } }; 可以发现，当apk安装完成之后，我们会更新UI，显示完成和打开按钮，是不是和我们平时安装apk的逻辑对应上了？这时候我们可以看一下这两个按钮的点击事件。 1234567891011public void onClick(View v) { if(v == mDoneButton) { if (mAppInfo.packageName != null) { Log.i(TAG, &quot;Finished installing &quot;+mAppInfo.packageName); } finish(); } else if(v == mLaunchButton) { startActivity(mLaunchIntent); finish(); } } 好吧，比较简单，点击完成按钮，直接finish掉这个activity，点击打开，则直接调用startActivity启动安装的应用，然后直接finish自身。 总结： 代码中执行intent.setDataAndType(Uri.parse(“file://“ + path),”application/vnd.android.package-archive”);可以调起PackageInstallerActivity； PackageInstallerActivity主要用于执行解析apk文件，解析manifest，解析签名等操作； InstallAppProcess主要用于执行安装apk逻辑，用于初始化安装界面，用于初始化用户UI。并调用PackageInstaller执行安装逻辑； InstallAppProcess内注册有广播，当安装完成之后接收广播，更新UI。显示apk安装完成界面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程","link":"/2020/09/11/apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"title":"18 Activity布局绘制流程","text":"这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。 顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。 前面有一篇文章中我们介绍过Activity的启动流程，可参考：android源码解析之（十四）–&gt;Activity启动流程在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } ... // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } ... } 可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑： 12345678void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } 首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。 这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现: 123public WindowManager getWindowManager() { return mWindowManager; } 好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程： 1mWindowManager = mWindow.getWindowManager(); 好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？ 123public WindowManager getWindowManager() { return mWindowManager; } 那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？ 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？ 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } 好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到： WindowManagerImpl –&gt; WindowManager –&gt; ViewManager; 继续往下看： 1wm.addView(mDecor, getWindow().getAttributes()); 这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } 然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } int index = findViewLocked(view, false); if (index &gt;= 0) { if (mDyingViews.contains(view)) { // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); } else { throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; } } 可以发现在WindowManagerGlobal中存在着三个数据列表： 1234private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。 最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现： 12345public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { ... requestLayout(); ... } 可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现： 12345678@Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } 可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。 继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现： 12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义： 123456final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } 在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑： 1234567891011121314151617void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } 好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private void performTraversals() { ... // 执行View组件的onMeasure方法，主要用于测量View if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let's measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } layoutRequested = true; } } } ... // 主要用于测量View组件的位置 ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) { // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) { mTranslator.translateRegionInWindowToScreen(mTransparentRegion); } if (!mTransparentRegion.equals(mPreviousTransparentRegion)) { mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try { mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); } catch (RemoteException e) { } } } if (DBG) { System.out.println(&quot;======================================&quot;); System.out.println(&quot;performTraversals -- after setFrame&quot;); host.debug(); } } ... // 主要用于View的绘制过程 ... if (!cancelDraw &amp;&amp; !newSurface) { if (!skipDraw || mReportNextDraw) { if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).startChangingAnimations(); } mPendingTransitions.clear(); } performDraw(); } } else { if (viewVisibility == View.VISIBLE) { // Try again scheduleTraversals(); } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).endChangingAnimations(); } mPendingTransitions.clear(); } } mIsInTraversal = false; } 可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件； 即：测量大小 –&gt; 测量位置 –&gt; 绘制组件 好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现： 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法： 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... } 在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到这个方法中调用了setMeasuredDimension方法： 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 好吧，方法体里面又调用了setMeasuredDimensionRaw方法： 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。 继续回到我们的performTransles方法，然后我们继续看performLayout方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during layout: running second layout pass&quot;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during second layout pass: posting in next frame&quot;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false; } 可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现： 我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现： 1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */); } 可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } } } 跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。 好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。 12345private void performDraw() { ... draw(fullRedrawNeeded); ... } 可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现： 1234567private void draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } ... } 可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法： 12345678private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { ... mView.draw(canvas); ... return true; } 可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; } /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) { paddingLeft += getLeftPaddingOffset(); } int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) { right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); } final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) { length = (bottom - top) / 2; } // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) { length = (right - left) / 2; } if (verticalEdges) { topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; } if (horizontalEdges) { leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; } saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } if (drawBottom) { canvas.saveLayer(left, bottom - length, right, bottom, null, flags); } if (drawLeft) { canvas.saveLayer(left, top, left + length, bottom, null, flags); } if (drawRight) { canvas.saveLayer(right - length, top, right, bottom, null, flags); } } else { scrollabilityCache.setFadeColor(solidColor); } // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) { matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); } if (drawBottom) { matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); } if (drawLeft) { matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); } if (drawRight) { matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); } canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); } 整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。 总结： Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。 View的绘制流程包含了测量大小，测量位置，绘制三个流程； Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程； View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的； View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法; View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法； View的绘制流程：onDraw等方法； View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑； Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"多线程并发知识","text":"Thread 底层调用start的 native方法 并行 及 并发 概念？ 并行，多个线程同时执行的概念。 并发，单位时间内，线程处理数据的能力，吞吐量。 Java默认是多线程 高并发编程的意义及好处？ 平衡使用我们的线程(好处) 不要cpu 过累(意义) 面试题 1.run 和start方法的区别？ .run()时函数调用和线程没有任何关系，.start()方法执行native底层函数，系统最终调度到run函数，这才是线程。 \\2. 如何控制线程的执行顺序？ .join() 函数控制，让t2获取执行权力，能够做到顺序执行 \\3. 多线程中的并行和并发是什么？ 四个车道，四辆车并行的行驶，就是并行。 四个车道，五秒钟多少的车流量，多少的吞吐量，是并发。单位时间内的执行效率 \\4. 在Java中能不能指定CPU去执行某个线程？ 不能，Java是做不到的，唯一能够去干预的是C语言调用内核的API去执行才行。 \\5. 项目开发过程中，你会考虑线程优先级么？ 不会考虑优先级，为什么呢？因为线程的优先级很依赖与系统的平台，所以这个优先级无法对号入座，无法做到你想象中的优先级，属于 不稳定，有风险，因为某些开源框架，也不能依靠线程优先级来设置自己想要的优先级顺序，这个是不可靠的。 例：Java线程优先级有十级，而此时操作系统优先级指有2~3级，那就对应不上了。 \\6. sleep 和 wait 有什么区别？ sleep是休眠，等休眠时间一国，才有执行的资格，注意是有资格，并不能马上就会被执行，什么时候执行，取决于cpu系统调度。 wait是登台，需要唤醒，唤醒后，才有执行的资格。 sleep()：线程进入睡眠状态，不会释放锁 wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁 含义不同: sleep 无条件可以休眠， wait是某些原因与条件 需要等待一下。 \\7. 在Java中能不能强制中断线程的执行 虽然提供了stop函数，但是此函数不推荐使用。因为这种方式很暴力，很危险，例如:下载图片5kb，只下载了4kb等我们可以使用interrupt来 处理我线程的停止，但是注意interrupt只是协作式的方式，并不能绝对保证终中断，并不是抢占式。 \\8. 如何让出当前线程的执行权？ yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行 \\9. notify()和notifyAll()区别？ ​ notify()可能发生信号丢失的情况。并且可能会导致死锁现象。 ​ 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法( ​ 或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权， ​ 但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。 ​ 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程）， 被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池， 而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法， 它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁， 这时锁池中的线程会继续竞争该对象锁。 唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争 ，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。 10.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？ yield()：让出时间片，不会释放锁 sleep()：线程进入睡眠状态，不会释放锁 wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁 notify()：调动方法之前，必须要持有锁，调用notify()方法本身不会释放锁的。而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁 notifyAll()：同notify，有一点不同在于，notifyAll会发出n个信号（n=等待线程数），而notify只会发出一个信号，通常情况下，尽量选择notifyAll 11.join()函数作用？ 线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作 12.sleep 和 wait 哪个函数才会清除interrupt中断标记？ sleep 在抛出异常的时候，捕获异常之前就已经清除中断标记。 锁、多线程、唤醒机制 13．有几种新启线程的方式？(两种) 1.继承Thread类 2.实现Runnable接口 实现Callable 严格意义上不算。实现Callable的接口对象会封装到FutureTask。FutureTask实现RunnableFuture。RunnableFuture 接口继承了Runnable和Future接口。 线程的生命周期? \\1. 初始 NEW \\2. 运行 RUNNING \\3. 就绪 REDAY \\4. 等待 WAITING \\5. 阻塞 BLOCK \\6. 终止 TERMINATED 运行：获取到时间片cpu调度。 调用wait进入等待 调用notify唤醒 调用synchronized修饰的方法中，未获取到锁 进入阻塞状态 调用sleep进入等待态 调用lock没有拿到锁，进入阻塞态？不会！只是进入等待、等待超时。 只有在synchronized修饰才会进入阻塞态。 锁概念 有一个线程进入，加锁后，其他线程无法进入。 synchronized 隐式锁 可重入锁 内部会完成 锁定解锁底层逻辑。JDK内置锁 无法修改。需要关键字 synchronized lock 显式锁 可以手动控制锁定解锁 唤醒机制 等待区域:wait() 获取对象的锁🔒 synchronized(对象锁){ wait() //释放锁 } 通知区域:notify() 获取对象的锁🔒 synchronized(对象锁){ notify() } 死锁 死锁是指 两个或两个以上的进程在执行过程中，由于竞争资源或者用于彼此通信造成的一种阻塞的现象，若无外力作用，他们 都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 条件 1.多个操作者(M&gt;=2)争夺多个资源(N&gt;=2) (N&lt;=M) 2.争夺资源的顺序不对 3.拿到资源不放手 规范 1.互斥条件 2.请求和保持 3.不剥夺 4.循环 死锁解决，规定争夺资源的顺序，lock.try尝试拿锁。 活锁 线程A、B 锁 1、2 线程A 持有锁1 想 获取锁2 发现线程B持有锁2 释放所有锁 重复 持有锁1 想 获取锁2 线程B 持有锁2 想 获取锁1 发现线程A持有锁1 释放所有锁 重复 持有锁2 想 获取锁1 两个线程都在不停工作。 锁饥饿 ThreadLocal 自定义存在问题。 map存在竞争。 ThreadLocal 实现原理？ thread 变量 class Thread{//持有ThreadLocal.ThreadLocalMap 成员变量 } class ThreadLocalMap{//持有一个Entry[]数组 Entry[] table } class Entry{//每个元素，持有ThreadLocal Object value ThreadLocal&lt;?&gt; k , Object v } CAS基本原理 Compare And Swap 比较和交换 CAS原理 利用现代处理器都支持CAS的指令 循环这个指令，知道成功为止 执行流程 1.get变量值(旧值) 2.计算后得到新值 3.compare内存中变量值和旧值 4.相等 旧值swap为新值 5.不相等 重复操作 CAS问题 ABA问题 开销问题 只能保证一个共享变量的原子操作 Atomic 原子变量类。cas 操作 如何实现原子操作？ 1.synchronized 2.compare and swap(轻量级) 悲观锁(synchronized) 乐观锁(cas) synchronized执行时，阻塞时会上下文切换，非常耗时。 cas 不会进入阻塞 ABA问题 线程1 A–&gt;B 线程执行A–&gt;B 线程2 A–&gt;C–&gt;A 解决ABA问题 版本戳 AtomicReference AtomicMarkableReference(是否改动) AtomicStampedReference(是否改动，改动次数) AtomicReference 解决只能保证一个共享变量的原子操作，可以支持改两个变量。 CAS 比较交换操作 为原子操作，由CPU保证。 线程池 AsynTask内部 线程池 构造函数各个参数的含义？ CorePoolSize 核心线程数 maximumPoolSize 最大线程数 keepAliveTime 存活时间 TimeUnit ThreadFactory BlockingQueue 超过的线程进入阻塞队列 RejectedExecutionHandler 默认拒绝策略 \\1. AbortPolicy 直接抛出异常(默认) \\2. DiscardPolicy 把最新提交的任务废弃 \\3. CallerRunsPolicy 让调用者线程执行任务 \\4. DiscardOldestPolicy 直接丢弃队列中最老的 keepAliveTime TimeUnit 根据这两个参数来控制线程的存活时间，线程池超过数值就会销毁。 什么是线程池？为什么要用线程池？ Thread 线程 操作系统 T1：创建 T2：任务执行 T3：销毁 为了统一管理，节省内存。用到线程池。 \\1. 线程池的创建 \\2. 提交任务 \\3. 关闭线程池 Excute Submit futureTask 有返回值 Shutdown尝试关闭线程池，没有执行的 ShutdownNow 线程的中断，协作机制 合理配置线程 任务特性： CPU密集型 机器的核心数 磁盘虚拟内存 最多+1 可能会产生页缺失，为保证cpu跑满+1 IO密集型 机器的核心数*2 混合型 JDK中的线程池工作原理？ 创建线程池值后，会根据CorePoolSize创建出线程 ，当有提交任务，CorePool里边会执行任务，当线程都在占用，继续有任务提交，超出核心线程数，会创建新线程并添加到BlockingQueue阻塞队列中。当阻塞队列中也满了，根据maximumPool继续创建线程执行。当线程数超出maximumPool大小，使用拒绝策略。 DMA 中断 OS 零拷贝 控制器 OS 内核空间 用户空间 mmap directmeory Java并发基础知识补全启动启动线程的方式只有： 1、X extends Thread;，然后X.start 2、X implements Runnable；然后交给Thread运行 线程的状态Java中线程的状态分为6种： \\1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 \\2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 \\3. 阻塞(BLOCKED)：表示线程阻塞于锁。 \\4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。1 \\5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 \\6. 终止(TERMINATED)：表示该线程已经执行完毕。 状态之间的变迁如下图所示 死锁概念是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 举个例子：A和B去按摩洗脚，都想在洗脚的时候，同时顺便做个头部按摩，13技师擅长足底按摩，14擅长头部按摩。 这个时候A先抢到14，B先抢到13，两个人都想同时洗脚和头部按摩，于是就互不相让，扬言我死也不让你，这样的话，A抢到14，想要13，B抢到13，想要14，在这个想同时洗脚和头部按摩的事情上A和B就产生了死锁。怎么解决这个问题呢？ 第一种，假如这个时候，来了个15，刚好也是擅长头部按摩的，A又没有两个脑袋，自然就归了B，于是B就美滋滋的洗脚和做头部按摩，剩下A在旁边气鼓鼓的，这个时候死锁这种情况就被打破了，不存在了。 第二种，C出场了，用武力强迫A和B，必须先做洗脚，再头部按摩，这种情况下，A和B谁先抢到13，谁就可以进行下去，另外一个没抢到的，就等着，这种情况下，也不会产生死锁。 所以总结一下： 死锁是必然发生在多操作者（M&gt;=2个）情况下，争夺多个资源（N&gt;=2个，且N&lt;=M）才会发生这种情况。很明显，单线程自然不会有死锁，只有B一个去，不要2个，打十个都没问题；单资源呢？只有13，A和B也只会产生激烈竞争，打得不可开交，谁抢到就是谁的，但不会产生死锁。同时，死锁还有几个要求，1、争夺资源的顺序不对，如果争夺资源的顺序是一样的，也不会产生死锁； 2、争夺者拿到资源不放手。 学术化的定义死锁的发生必须具备以下四个必要条件。 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 只要打破四个必要条件之一就能有效预防死锁的发生。 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 避免死锁常见的算法有有序资源分配法、银行家算法。 危害1、线程不工作了，但是整个程序还是活着的2、没有任何的异常信息可以供我们检查。3、一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序，对正式已发布程序来说，这是个很严重的问题。 解决关键是保证拿锁的顺序一致 两种解决方式 1、 内部通过顺序比较，确定拿锁的顺序； 2、采用尝试拿锁的机制。 其他线程安全问题活锁两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。 解决办法：每个线程休眠随机数，错开拿锁的时间。 线程饥饿低优先级的线程，总是拿不到执行时间 ThreadLocal辨析与Synchonized的比较ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。 ThreadLocal的使用ThreadLocal类接口很简单，只有4个方法，我们先来了解一下： • void set(Object value) 设置当前线程的线程局部变量的值。 • public Object get() 该方法返回当前线程所对应的线程局部变量。 • public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 • protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 public final static ThreadLocal RESOURCE = new ThreadLocal();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。 实现解析 上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。 看下ThreadLocal的内部类ThreadLocalMap源码： 可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。 回顾我们的get方法，其实就是拿到每个线程独有的**ThreadLocalMap** 然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。 CAS基本原理什么是原子操作？如何实现原子操作？假定有两个操作A和B(A和B可能都很复杂)，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁， 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。 实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。 CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。 CAS实现原子操作的三大问题ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。 如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。 Jdk中相关原子操作类的使用AtomicInteger•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。 •boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。 •int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。 •int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。 AtomicIntegerArray主要是提供原子的方式更新数组里的整型，其常用方法如下。 •int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。 •boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。 更新引用类型原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。 AtomicReference原子更新引用类型。 AtomicStampedReference利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。 AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。 阻塞队列和线程池原理阻塞队列队列 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。 什么是阻塞队列1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。 为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 ·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。 ·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。 ·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。 ·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。 常用阻塞队列·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 ·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 ·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 ·DelayQueue：一个使用优先级队列实现的无界阻塞队列。 ·SynchronousQueue：一个不存储元素的阻塞队列。 ·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 ·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 以上的阻塞队列都实现了BlockingQueue接口，也都是线程安全的。 有界无界？有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。 无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。 ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置 LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 Array实现和Linked实现的区别\\1. 队列中锁的实现不同 ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁； LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock \\2. 在生产或消费时操作不同 ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的； LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能 \\3. 队列大小初始化方式不同 ArrayBlockingQueue实现的队列中必须指定队列的大小； LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE PriorityBlockingQueuePriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。 LinkedTransferQueue多了tryTransfer和transfer方法， （1）transfer方法 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。 （2）tryTransfer方法 tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。 LinkedBlockingDequeLinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。 多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。 线程池为什么要用线程池？Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 ThreadPoolExecutor 的类关系Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。 ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口； AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法； ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。 ScheduledExecutorService接口继承了ExecutorService接口，提供了带”周期执行”功能ExecutorService； ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。 线程池的创建各个参数含义public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) corePoolSize线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize； 如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行； 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize keepAliveTime线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用 TimeUnitkeepAliveTime的时间单位 workQueueworkQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。 一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响。 1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。 2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。 3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。 4）更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。 threadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。 Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。 RejectedExecutionHandler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： （1）AbortPolicy：直接抛出异常，默认策略； （2）CallerRunsPolicy：用调用者所在的线程来执行任务； （3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； （4）DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 线程池的工作机制1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。 4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 提交任务execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 合理地配置线程池要想合理地配置线程池，就必须首先分析任务特性 要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 •任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 •任务的优先级：高、中和低。 •任务的执行时间：长、中和短。 •任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。 CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。 混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。 如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。 AbstractQueuedSynchronizer学习AQS的必要性队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。 AQS使用方式和其中的设计模式AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。 在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。 同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系： 锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节； 同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。 实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。 模板方法模式同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是Spring框架里的各种Template。 实际例子我们开了个蛋糕店，蛋糕店不能只卖一种蛋糕呀，于是我们决定先卖奶油蛋糕，芝士蛋糕和慕斯蛋糕。三种蛋糕在制作方式上一样，都包括造型，烘焙和涂抹蛋糕上的东西。所以可以定义一个抽象蛋糕模型 然后就可以批量生产三种蛋糕 这样一来，不但可以批量生产三种蛋糕，而且如果日后有扩展，只需要继承抽象蛋糕方法就可以了，十分方便，我们天天生意做得越来越赚钱。突然有一天，我们发现市面有一种最简单的小蛋糕销量很好，这种蛋糕就是简单烘烤成型就可以卖，并不需要涂抹什么食材，由于制作简单销售量大，这个品种也很赚钱，于是我们也想要生产这种蛋糕。但是我们发现了一个问题，抽象蛋糕是定义了抽象的涂抹方法的，也就是说扩展的这种蛋糕是必须要实现涂抹方法，这就很鸡儿蛋疼了。怎么办？我们可以将原来的模板修改为带钩子的模板。 做小蛋糕的时候通过flag来控制是否涂抹，其余已有的蛋糕制作不需要任何修改可以照常进行。 AQS中的方法模板方法实现自定义同步组件时，将会调用同步器提供的模板方法， 这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。 可重写的方法 访问或修改同步状态的方法重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。 •getState()：获取当前同步状态。 •setState(int newState)：设置当前同步状态。 •compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。 CLH队列锁CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。 CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。 当一个线程需要获取锁时： \\1. 创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用 \\2. 线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred 线程B需要获得锁，同样的流程再来一遍 3.线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked == false) 4.当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点 如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。 CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。 Java中的AQS是CLH队列锁的一种变体实现。 ReentrantLock的实现锁的可重入重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。 1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。 2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。 nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。 如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。 公平和非公平锁ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁”FairSync。 nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 深入理解并发编程和归纳总结JMM基础-计算机原理Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。Jmm遇到的问题与现代计算机中遇到的问题是差不多的。 物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 根据《Jeff Dean在Google全体工程大会的报告》我们可以看到 计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。 （以下案例仅做说明，并不代表真实情况。） 如果从内存中读取1M的int型数据由CPU进行累加，耗时要多久？ 做个简单的计算，1M的数据，Java里int型为32位，4个字节，共有10241024/4 = 262144个整数 ，则CPU 计算耗时：262144 0.6 = 157 286 纳秒，而我们知道从内存读取1M数据需要250000纳秒，两者虽然有差距（当然这个差距并不小，十万纳秒的时间足够CPU执行将近二十万条指令了），但是还在一个数量级上。但是，没有任何缓存机制的情况下，意味着每个数都需要从内存中读取，这样加上CPU读取一次内存需要100纳秒，262144个整数从内存读取到CPU加上计算时间一共需要262144*100+250000 = 26 464 400 纳秒，这就存在着数量级上的差异了。 而且现实情况中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是基本上是无法消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 在计算机系统中，寄存器划是L0级缓存，接着依次是L1，L2，L3（接下来是内存，本地磁盘，远程存储）。越往上的缓存存储空间越小，速度越快，成本也更高；越往下的存储空间越大，速度更慢，成本也更低。从上至下，每一层都可以看做是更下一层的缓存，即：L0寄存器是L1一级缓存的缓存，L1是L2的缓存，依次类推；每一层的数据都是来至它的下一层，所以每一层的数据是下一层的数据的子集。 在现代CPU上，一般来说L0， L1，L2，L3都集成在CPU内部，而L1还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存（Instruction Cache，I-Cache，L1i），分别用于存放数据和执行数据的指令解码。每个核心拥有独立的运算处理单元、控制器、寄存器、L1、L2缓存，然后一个CPU的多个核心共享最后一层CPU缓存L3 Java内存模型（JMM）从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。 要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后, 那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令，CPU 指令，CPU 指令，而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++包含了三个CPU指令！ volatile详解volatile特性可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步 可以看成 所以volatile变量自身具有下列特性： 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2 volatile的实现原理通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。 Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。 synchronized的实现原理Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。 对同步块，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。 对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。 JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 synchronized使用的锁是存放在Java对象头里面， 具体位置是对象头里面的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息， 但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式 了解各种锁自旋锁原理自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。 如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 自旋锁的优缺点自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！ 但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。 自旋锁时间阈值自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要 JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。 JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制； 锁的状态一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。 偏向锁引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。 偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。 偏向锁获取过程： 步骤1、 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。 步骤2、 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。 步骤3、 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。 步骤4、 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word） 步骤5、 执行同步代码。 偏向锁的释放： 偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁的适用场景 始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； 在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。 jvm开启/关闭偏向锁 开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 关闭偏向锁：-XX:-UseBiasedLocking 轻量级锁轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； 轻量级锁的加锁过程： 在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 不同锁的比较","link":"/2020/10/26/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%A8/"},{"title":"中国近代史大纲","text":"一、第一次鸦片战争时期 1.1839年： 林则徐在广州禁烟。 林则徐编写《四洲志》；睁眼看世界第一人； 6月在虎门海滩销烟。英国政府决定发动侵略中国战争。2.1840年： 6月，鸦片战争爆发，英军从广州转攻厦门，攻陷定海，北犯天津。3.1841年： 1月，琦善同英国签订《穿鼻草约》，道光帝不满，派奕山到广州主持军事，对英作战。关天培在虎门炮台抗击英军，壮烈牺牲。 5月，英军进逼广州，弈山投降。三元里人民进行抗英斗争。 9月，定海再次陷落，三总兵抗敌牺牲。4.1842年： 2月，广东水师提督关天培在虎门与英军战死。 6月，陈化成坚守吴淞口以身报国。 7月，海龄，镇江以身报国。 8月，英舰到达南京江面，清政府被迫签订了《中英南京条约》。魏源编著《海国图志》，提出“师夷长技以制夷” 5.1843年： 英国强迫清攻府签订《中英五口通商章程》和《中英虎门条约》，作为《南京条约》的附件。洪秀全创立拜上帝教。6.1844年： 《中美望厦条约》和《中法黄埔条约》签订。7.1851年： 1月11日，洪秀全在广西金田村起义，建号太平天国。 9月，在永安州城建制封王。8.1853年： 3月，太平军占领南京，改名天京，定为都城。颁布《天朝田亩制度》。 4月，发动北伐与西征。 二、第二次鸦片战争时期 1.1856年： 英国利用“亚罗号事件”、法国利用“马神甫事件”发动第二次鸦片战争；秋，“天京事变”发生，严重地削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭；2.1858年： 沙俄强迫黑龙江将军奕山签订《爱珲条约》。英法联军占领天津。俄、英、法、美强迫清政府分别签订《天津条约》。3.1859年： 6月，英法公使到北京交换条约文本，蓄意挑衅，炮轰大沽口，史荣椿、乐善捐躯。洪仁圩提出了一个统筹全局的改革方案《资政新篇》4.1860年： 英法联军攻占天津、北京。与英、法《北京条约》签订。 三、洋务运动时期 兴起早期维新思想:王韬、郑观应。最早做出完整表述的是冯桂芬。 1.1861年： 11月，那拉氏发动政变（史称“辛酉政变”或“北京政变”）。 中外反动势力勾结起来，共同镇压太平天国运动； 曾国藩创设安庆军械所。它是洋务派办的第一个军事工业。 清政府设立“总理衙门”，由奕担任总理大臣2.1862年： 太平天国军民进行天京保卫战。 总理衙门设立京师同文馆、清末最早设立的″洋务学堂″3.1864年： 7月，天京被湘军攻破、天京陷落，太平天国失败。4.1872年： 李鸿章在上海设立轮船招商局。它是洋务派办的第一个与民用有关的工业； 陈启源在广东南海商办的继昌隆缫丝厂创立（近代中国第一家缫丝厂）。 5.1883年： 12月，中法战争爆发。6.1884年： 8月下旬，法舰突然袭击马尾军港的福建水师。清政府下诏对法国正式宣战。 10月，刘铭传的清军击退进犯台北的法军。 7.1885年： 3月，法舰进犯浙江镇海。 刘永福黑旗军和越南人民配合，在临洮大败法军，收复十多个州县。 冯子材在镇南关大败法军，乘胜追击，收复谅山等要地。 6月，《中法新约》签订。 19世纪70年代 清政府建成北洋水师19世纪70至80年代 “边疆危机”英国从印度侵人西藏，又从缅甸入侵云南； 法国则从越南侵犯广西； 俄国从中亚人侵新疆；日本吞并琉球、侵犯中国台湾。19世纪90年代资产阶级维新派创办的学会主要有强学会 洋务派兴办军用工业： 1865年，李鸿章筹办上海江南制造总局,当时国内最大的兵工厂；同年,李鸿章在南京设立金陵机器局； 1866年，左宗棠在福建创办福州船政局，附设有船政学堂，是当时国内最大的造船厂； 1867年，崇厚在天津建立天津机器局； 1890年，张之洞在汉阳创办湖北枪炮厂。 民用企业（官督商办）：1873年李鸿章创办轮船招商局、开平矿务局、天津电报局和上海机器织布局 1869年，方举赞在上海开设发昌机器厂，中国民族资本主义产生 1881年，中国人第一条铁路唐胥铁路建成通车 四、维新变法时期 1.1888年： 康有为第一次向光绪帝上书，要求变法。成立北洋舰队2.1894年： 朝鲜东学党起义，日本乘机出兵朝鲜，占领汉城。 7月，日军突然袭击在牙山附近的中国运输船和驻军，挑起侵略中国的甲午战争。 左宝贵在平壤战役牺牲。 在黄海战役中，邓世昌、林永升等牺牲。 日军侵入辽东半岛，东北人民英勇抗敌，保卫国土。 孙中山在美国檀香山成立兴中会。喊出了”振兴中华”这个时代的最强音。3.1895年： 在威海卫战役中，北洋海军覆灭。清政府向日本求和，被迫签订中日《马关条约》。 徐骧领导的台湾义军和刘永福配合，抗击日军； 康有为等“公车上书”，反对同日本议和，请求变法。使维新思想发展成为爱国救亡运动。 康有为在北京创办《中外记闻》、严复《救亡决论》，喊出了”救亡”的口号；4.1896年： 康有为写了《新学伪经考》、《孔子改制考》、《人类公理》； 梁启超写了《变法通议》； 谭嗣同写了《仁学》； 严复翻译了《天演论》（”物竞天择”、”适者生存”）等。5.1897年： 德国强占胶州湾，民族危机严重；梁启超任主笔的上海《时务报》、严复主办的天津《国闻报》以及湖南的《湘报》等。严复译述的《天演论》在 《国闻报》上定期发表。 6.1898年： 6月，光绪帝颁布《定国是诏》任康有为为总理衙门章京。接着又派谭嗣同、杨锐、刘光第、林旭等人参预变法。 9月，那拉氏（慈禧太后）发动政变，囚禁光绪帝，杀害谭嗣同、杨锐、刘光第、林旭等六人（即戊戌六君子）。史称“戊戌政变”。戊戌变法失败。 五、八国联军侵华战争时期 1.1899年： 秋，山东平原县义和团在朱红灯领导下举行武装起义“扶清灭洋”；美国提出侵略中国的“门户开放”政策；2.1900年： 夏，在京津地区义和团运动的影响下，其他各地也爆发了义和团运动，全国掀起了反帝反封建斗争的浪潮； 6月，八国联军侵略中国。义和团在廊坊、老龙头车站、紫竹林租界等地抗击八国联军； 围攻北京东交民巷使馆和西什库教堂，在北仑配合清军阻击八国联军； 7月17日至21，沙俄出兵侵略我国东北，制造江东六十四屯惨案 ；与1900年7月16日发生的海兰泡惨案，并称为“庚子俄难”；3.1901年： 9月，《辛丑条约》签订。 六、辛亥革命时期 1.1902年： 2月8日，梁启超创办《新民丛报》； 5月21日，张之洞创立湖北师范学院；2.1903年： 5月27日，邹容著《革命军》，章炳麟为《革命军》作序。 5月，章炳麟的《驳康有为论革命书》在《苏报》上发表。3.1904年： 2月8日，日本偷袭旅顺，日俄战争爆发； 2月15日，华兴会成立； 7月3日，科学补习所在武昌成立； 资产阶级革命团体华兴会、光复会、岳王会、科学补习所成立。 陈天华著《猛回头》和《警世钟》。4.1905年： 中国同盟会在日本东京成立，提出政治纲领，选举孙中山为总理，创办了《民报》。5.1906年： 革命党在萍乡、醴陵、浏阳起义，安源矿工六千人参加斗争，最终失败。6.1907年： 孙中山领导潮州、惠州、钦州、廉州和镇南关起义，旋败。徐锡麟在安徽起义，失败被害。秋瑾准备在浙江响应，被捕慷慨就义。7.1910年： 广州新军起义、黄花岗起义；“皇族内阁”成立8.1911年： 4月，孙中山和黄兴发动广州起义； 5月，保路运动爆发。四川最为激烈； 10月10日，（共进会和文学社）武昌起义爆发。革命首先在武汉三镇取得胜利，成立湖北军政府，改国号为中华民国。9.1912年： 元旦，中华民国临时大总统孙中山在南京就职，宣告中华民国成立。接着成立临时参议院，不久，颁布参议院制定的《中华民国临时约法》、《告 各友邦书》。《中国邻国临时约法》中国历史上第一步具有资产阶级共和国宪法性质的大典； 2月，清帝退位。孙中山辞职，袁世凯窃取了革命果实，接任中华民国临时大总统。宋教仁等准备组织责任内阁，以限制袁世凯的权力：将同盟会改 组为国民党。 10.1913年： 3月，袁世凯派人在上海火车站杀害了宋教仁；非法签订善后大借款； 7月，主要在九江、南京一带，史称“赣宁之役”，称“二次革命”。；11.1914年： 孙中山在日本组织中华革命党，坚持反袁武装斗争； 秋、日本派兵入侵山东，取代德国在山东的侵略地位； 七、新文化运动时期 提倡民主科学，反对专制迷信，主张文学革命1.1915年： 1月，日本提出灭亡中国的《二十一条》。 5月9日，“五九国耻”日，接受《二十一条》； 9月15日，陈独秀创办《青年杂志》，在创刊号上发表《敬告青年》一文，提出民主和科学的口号，掀起新文化运动。 12月12日，袁世凯当上了中华帝国皇帝，改年：号为“洪宪”。 12月15日，蔡锷、唐继尧在云南组织”护国军”，形成护国运动。2.1916年： 袁世凯在绝望中死去。黎元洪继任总统。 总理段祺瑞操纵北京政府实权。 杜亚泉在《东方杂志》上抨击新文化运动，拉开中西文化论战序幕3.1917年： 张勋复辟失败。段祺瑞下令对德宣战，宣布不再恢复《临时约法》和国会。 孙中山在广州发动第一次护法运动。 陈独秀任北大文科学长； 俄国十月革命胜利，极大促进了马克思主义在中国的传播。4.1918年： 鲁迅发表《狂人日记》，号召人民起来推翻吃人的旧社会。 李大钊发表《法、俄革命之比较观》、《庶民的胜利》和《布尔什维主义的胜利》，热情歌颂十月社会主义革命。 5月，护法运动失败，标志着整个中国民族资产阶级领导的旧民主主义革命的终结。5.1919年： 《新青年》出版“马克思研究专号”、李大钊发表《我的马克思主义观》； 5月4日，“五四”运动爆发；巴黎和会上中国外交的失败是直接导火索。 6月，中心转移到上海。“五四运动”是新民主主义革命的开端 邓中夏、高君宇北京大学马克思学说研究会 陈独秀上海马克思主义研究会 新民学会、互助社、觉悟社； 10月，将中华革命党改组为中国国民党；八、第一次国共合作时期 1.1920年： 8月，孙中山传令粤军陈炯明回师广东，讨伐桂系军阀金春煊、陆荣延。陈望道第一翻译《共产党宣言》 11月，孙中山领导第二次护法运动 陈独秀在上海创办中国共产党第一个早期组织，陈独秀，李汉俊、李达；2.1921年： 7月23日，中共一大在上海召开，标志中国共产党成立； 8月，中国劳动组合书记部成立，中国共产党领导工人运动的专门机关； 9月，孙平广西，统一两广；3.1922年： 1月－3月，香港中国海员大罢工 6月，陈炯明炮轰，孙登永丰舰； 7月，中共二大召开，制定反帝反封建的民主革命纲领， 党的最高纲领是实现社会主义、共产主义 当前阶段的纲领是：打倒军阀,推翻国际帝国主义的压迫; 统一中国为真正民主共和国。 8月9日，孙离广赴上；二次革命战争失败；标志资产阶级领导的旧民主主义革命走到了历史尽头； 9月，安阳路矿工罢工；4.1923年： 2月，京汉铁路工人举行“二七”大罢工；从1922年1月香港海员罢工到1923年2月京汉铁路工人罢工，在中国共产党的领导、组织、推动下，中国掀起了第一个工人运动的髙潮。（包括安源路矿工人罢工、开滦五矿工人罢工） 6月，中共三大在广州召开，决定同国民党合作，建立革命统一战线，标志着第一次国共合作的正式形成5.1924年： 1月，中国国民党“一大”召开，提出“新三民主义”，革命统一战线正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面； 5月，黄埔军校的建立； 7月，国民党设立农民部，林伯渠、澎湃；广州开办农民运动讲义所，澎湃、阮啸仙、毛泽东； 10月23日，冯玉祥发动北京政变6.1925年： 3月12日，孙中山先生逝世； 5月30日，发生“五卅”惨案，“五卅”反帝运动爆发；7.1925年6月－1926年10月： 香港工人大罢工，当时世界上罢工时间最长的一次；8.1926年： 3月，毛泽东发表《中国社会各阶级的分析》；蒋介石策动“中山舰事件”； 5月，蒋介石提出“整理党务案”； 7月，国民革命军出师北伐，推翻北洋军阀； 9月1日，毛泽东发表《国民革命与农民运动》一文，指出：”农民问题乃国民革命的中心问题”，”所谓国民革命运动，其大部分即是农民运动”。9.1926年10月－1927年3月： 上海工人三次武装起义；10.1927年： 1月，武汉和九江人民收回英租界；国民政府从广州迁到武汉，武汉成为当时全国革命的中心； 3月，毛泽东发表《湖南农民运动考察报告》； 4月12日，蒋介石在上海发动反革命政变；“四·一二”反革命政变； 4月18日，蒋介石在南京成立国民政府； 4月27日至5月9日，中国共产党第五次全国代表大会在武汉召开； 5月，夏斗寅、许克祥叛变 7月15日，汪精卫在武汉召开“分共”会议，制造“七·一五”反革命政变。 第二次国内革命战争爆发；政变后，宁汉合流；国共合作破裂，国民革命失败 8月1日，“八一”南昌起义；打响了武装反抗国民党反动统治的第一枪。这是中国共产党独立领导革命战争、创建人民军队和武装夺取政权的开端。 8月7日，在汉口召开“八七会议”，彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。 毛泽东在会上强调“政权是由枪杆子中取得的”；八七会议”开始了从大革命失败到土地革命战争兴起的历史性转折。 9月，毛泽东领导湘赣边秋收起义；失败后，三湾改编，明确了共产党对军队的绝对领导，武装夺取政权的保证； 10月，毛泽东率领工农革命军在井冈山创立革命根据地； 12月11日，广州起义； 中国革命由此发展到一个新的阶段，即土地革命战争时期（十年内战时期）；11.1928年： 4月，井冈山会师，成立中国工农红军第四军； 6月，南京国民政府宣布改定新约； 10月，国民党中央常务委员会通过了《训政纲领》； 10月和11月，毛泽东写了《中国的红色政权为什么能够存在？》和《井冈山的斗争》，阐述了共产党领导的土地革命、武装斗争与革命根据地建设者三者之间的辩证统一关系。强调“工农武装割据”的思想； 12月29日，张学良东北易帜，南京国民政府在形式上完成了全国统一12.1930年： 1月，毛泽东在《星星之火，可以燎原》中指出：红军、游击队和红色区域的建设和发展，是半殖民地中国在无产阶级领导之下的农民战争的最高形式和半殖民地农民斗争发展的必然结果，并且是促进全国革命高潮的最重要因素。 5月，1、毛泽东在《反对本本主义》，阐明了坚持辩证唯物主义的思想路线（即坚持理论与实际相结合的原则）的极端重要性，提出了“没有调査，没有发言权”和“中国革命斗争的胜利要靠中国同志了解中国情况”的重要思想，表现了毛泽东开辟新道路、创造新理论的革命首创精神。 2、农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义即毛泽东思想的初步形成。 九、抗日战争时期 1.1931年： 9月18日，日本帝国主义发动“九·一八”事变； 11月，中华苏维埃第一次全国代表大会召开，中华苏维埃共和国临时中央政府成立；2.1932年： 1月28日，日本帝国主义发动“一·二八”事变，十九路军奋起抗战； 2月东北全境沦陷； 3月，日本扶植前清逊帝溥仪建立伪满洲国3.1934年： 4月，共产党提出，宋庆龄、何香凝、李杜签名发表了《中国人民对日作战的基本纲领》 10月，工农红军第五次反“围剿”失败，中央革命根据地主力红军开始长征；4.1935年： 1月，遵义会议召开；解决组织问题、军事问题；确立毛为代表的马克思主义主线的领导地位，生死攸关转折点；毛泽东、周恩来、王稼祥负责军事行动； 2月，东北抗日联军建立； 6月，四川懋功，红一，红四会师； 8月1日，中共中央发表八一宣言（《为抗日救国告全国同胞书》）； 10月，陕北吴起镇，中央红军同十五军团胜利会师； 12月9日，“一二·九”运动爆发（反对华北自治、打倒日本帝国主义、停止内战，一致对外）； 12月，中共中央瓦窑堡会议，毛泽东发表《论反对日本帝国主义的策略》，通过了《中央关于目前政治形势与党的任务决议》，阐明党的抗日民族 统一战线的新政策，批判党内的关门主义和对于革命的急性病,系统地解决了党的政治路线上的问题。； 华北事变；5.1936年： 5月，全国各界救国联合会成立； 7月，西康甘孜，红四方面军，红二、六方面军会师； 10月，甘肃会宁、静宁将台堡，红一、红二、红四在胜利会师，长征胜利结束；红四张国焘 徐向前 12月，张学良、杨虎城扣押蒋介石，西安事变，抗日民族统一战线初步形成； 毛泽东写了《中国革命战争的战略问题》,总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。6.1937年： 7月7日，“芦沟桥事变”，抗日战争开始； 7月15日，中共提出国共合作的抗日宣言； 7月28日，赵登禹抗日殉国； 8月13日，日本发动“八·一三”事变，蓄意已久地为扩大侵华战争在中国上海制造的事变； 8月22日，中共洛川会议，会议通过了《关于目前形势和党的任务的决定》颁布《抗日救国十大纲领》； 9月，国民党公布国共合作抗日宣言，抗日民族统一战线建立；八路军平型关大捷； 10月，八路军创立第一个抗日根据地——晋察冀根据地； 12月13日，南京沦陷。日军制造南京大屠杀7.1938年： 3月，李宗仁指挥军队开展徐州会战，台儿庄战役是抗战以来正面战场取得的战果最大的一次胜利； 5月，毛泽东发表《论持久战》； 10月，中共召开六届六中全会，毛泽东明确提出了”马克思主义的中国化”这个命题； 10月，广州、武汉失守，抗战进入相持阶段； 12月，汪精卫投降日本。8.1939年： 1月，五届五中全会，国民党成立”防共委员会”，确定了”防共、限共、溶共、反共”的方针9.1940年： 1月，毛泽东发表《新民主主义论》； 3月，汪精卫伪国民政府在南京成立； 5月，枣宜会战国民党张自忠捐躯； 8－11月，彭德怀指挥八路军发动百团大战；10.1941年： 1月，国民党发动第二次反共高潮——皖南事变； 5月，毛泽东作了《改造我们的学习》的报告； 12月，日军发动太平洋战争，美、英对日宣战，整个世界格局发生变化。11.1941－1942年： 中国共产党采取“三三制”原则， 加强抗日民主政权建设， 实行减租减息政策， 开展大生产运动和整风运动， 进行反“扫荡”斗争，保卫解放区；12.1942年： 1月，中、美、英、苏等26国共同签署《联合国宣言》 缅甸北部对日作战以身殉职的是中国远征军戴安澜 十、国共内战时期 1945-1949 1.1945年： 4月，中共“七大”召开；同美国、英国、苏联发起旧金山会议(联合国制宪会议)董必武前往； 8月8日，苏联对日宣战； 8月15日，日本宣布无条件投降； 9月2日，日本正式签订投降书； 9月3日，抗战胜利纪念日； 8月25日，中共中央在《对目前时局的宣言》中提出的口号是“和平、民主、团结”； 8月28日－10月10日，国共重庆谈判，签订《双十协定》； 9月，“向北发展，向南防御”； 10月中下旬，上党、邯郸战役，粉碎国民党的局部进攻； 12月1日，昆明学生发动“一二·一”爱国运动； 2.1946年： 1月10日，国共两党签订停战协定；政协会议开幕； 2月10日，国民党特务在重庆制造的破坏“庆祝政协成功大会”的事件，校场口惨案 6月，国民党发动全面内战，第三次国内革命战争开始；起点是大局围攻中原解放区； 6月23日，上海人民团体联合会、学生和平存进为反对内战，联合发起组成上海人民和平请愿团，下关惨案； 12月30日，北平学生发动抗议美军暴行的运动； 3.1947年： 2月28日，台湾人民举行“二·二八”起义； 3月－7月，延安保卫战，孟良崮战役，粉碎国民党的重点进攻； 5月20日，全国学生发动“反饥饿、反内战、反迫害”的爱国运动； 6月30日，刘邓大军挺进大别山； 7月，人民解放军开始全国规模的反攻； 9月，中共全国土地会议召开，公布《中国土地法大纲》； 10月10日，《中国人民解放军宣言》发表；打到蒋介石，解放全中国；4.1948年： 9月－11月，辽沈战役； 11月－1949年1月，淮海战役； 12月－1949年1月，平津战役；5.1949年： 1月，将革命进行到底； 3月，西柏坡中共七届二中全会；规定政治、经济、外交基本政策；农业国转变工业国、新民主主义社会转变社会主义社会方向；提出“两个务必”要求； 4月21日，毛泽东、朱德发而进军令，解放军渡江作战； 4月23日，解放南京，国民党反动统治结束； 6月30日，毛泽东发表《论人民民主专政》； 9月21日，中国人民政治协商会议第一届全体会议开幕； 10月1日，中华人民共和国成立，民主革命终结和社会主义革命开始；标志着中国进入了新民主主义社会； 1948 9月－11月 辽沈战役 中国近代史解放战争的“三大战役”之一，战役结束后，中国人民解放军首次在兵力数量方面超越国民党军。 11月－次年1月 淮海战役 淮海战役是三大战役中解放军牺牲最重，歼敌数量最多，政治影响最大、战争样式最复杂的战役。 12月－次年1月 平津战役 解放战争中具有决定意义的三大战役中的最后一个战役。平津战役胜利结束，人民解放军进驻北平城，北平宣告完全解放。 十一、中华人民共和国成立和巩固时期：1949—1953年： 1.1950年： 7月，中国共产党召开七届三中全会，毛做《为争取国家财政经济状况的基本好转而斗争的》报告，创建三个条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减；2.1950年10月—1953年7月， 中国人民志愿军抗美援朝； 中央人民政府颁布《中华人民共和国土地改革法》，规定废除地主阶级封建剥削的土地所有制，实行农民的土地所有制。 毛泽东在《在晋绥干部会议上的讲话》第一次全面、系统地提出了新民主主义革命的总路线和总政策，即“无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命”；3.1950—1952年底： 土地改革。土地改革的完成，彻底废除了我国存在两千多年的封建土地制度，地主阶级被消灭，农民成为土地的主人； 使人民政权更加巩固，农村生产力大大解放，为国家的工业化建设准备了条件；4.1951年： 5月，同西藏地方政府达成关于和平解放西藏办法的协议； 10月，西藏和平解放； 标志着祖国大陆获得了统一，各族人民实现了大团结；5.1951年底-1952年春 开展反贪污、反浪费、反官僚主义的“三反”运动，处决了犯有严重贪污罪的天津地委前任书记刘青山、现任书记张子善；6.1952年 1月26日，五反运动是指建国初期在资本主义工商业者中开的反行贿、反偷税漏税、反盗骗国家财产、反偷工减料、反盗窃国家经济情报的斗争； 十二、向社会主义过渡时期：1953—1956年： 1.1953—1957年： 第一个五年计划。一五计划的完成使我国开始改变了工业落后的面貌，向社会主义工业化迈进； “一化三改”。“一化”即社会主义工业化，就是要发展生产力。 “三改”即对农业、手工业、资本主义工商业的社会主义改造，其中对农业、手工业实行合作化，对资本主义工商业实行公私合营 对资本主义工商业采取利用、限制、改造的政策，对资产阶级采取赎买政策。 在经过委托加工、计划订货、统购包销、委托经销代销等一系列从初级到高级的国家资本主义过渡形式2.1953年底： 周恩来在接见印度代表团时提出和平共处五项原则，成为处理国与国之间关系的基本准则。3.1954年9月： 第一届全国人民代表大会制定了《中华人民共和国宪法》，这是我国第一部社会主义类型的宪法。4.1955年： 周恩来出席万隆会议（亚非国际会议），提出“求同存异”的方针，促进了会议的圆满成功，也促进了中国同亚非各国的团结与合作。 十三、探索建设社会主义道路时期（全面建设社会主义时期）：1956—1966年： 1.1956年： 4月25日，毛在中央政治局扩大会议上作了《论十大关系》的讲话，调动一切积极因素，为社会主义事业服务。为探索适合中国国情的社会主义建设道路提出了许多重要的思想原则，从思想上、理论上为八大的召开作了重要的准备。 8月30日至9月12日，在北京举行了八大预备会议。毛泽东在会上作了《增强党的团结，继承党的传统》的讲话，指出八大召开的目的和宗旨是： 总结七大以来的经验，团结全党，团结国内外一切可以团结的力量，为建设社会主义中国而奋斗。号召全党要继承优良传统，反对主观主义、宗派主义和官僚主义。 中共提出“百花齐放，百家争鸣”的方针，使文学艺术创作出现了崭新的局面。 2.1956年： 中共八大召开。这是探索建设社会主义道路的良好开端。陈云提出“三个主体，三个补充”思想。党和人民当前的主要任务是把我国从落后的农业国变为先进的的工业国； 三大改造完成，实现了把生产资料私有制转变为社会主义公有制的任务，标志着我国初步建立起社会主义的基本制度，进入社会主义初级阶段； 长春第一汽车制造厂建成投产、沈阳机床厂建成投产、北京电子管厂建成投产、沈阳飞机制造厂试制成功；3.1957年： 2月，毛在最高国务会议上发表《关于正确处理人民内部矛盾的问题》讲话，区分和处理敌我和人民内部两类矛盾的学说；强制-专制；民主-说服教育-团批团； 武汉长江大桥通车；青藏、康藏、新藏公路通车；4.1958年： “大跃进”和人民公社化运动开始。这是党在探索建设社会主义道路中的一次严重失误。5.20世纪60年代初： 西藏地区完成民主改革，废除了封建农奴制度，百万农奴翻身当家做了主人，进入社会主义阶段。6.1961年春： 中共八届九中全会，决定对国民经济实行“调整、巩固、充实、提高”方针的会议 党和政府全面调整国民经济 ,恢复发展生产。7.1962年春： 中共重要为统一思想、总结经验教训和明确工作方向召开了“七千人会议”8.1964年： 10月16日：我国第一颗原子弹爆炸成功，打破了帝国主义的核垄断。 12月，周恩来第三届人大第一次会议，四个现代化 十四、“文化大革命”时期：1966—1976年： 1966年： 中国战略导弹部队组建成功，主要担任核反击任务。 1967年： 6月17日中国成功试爆第一枚氢弹 1970年： 我国成功发射第一颗人造地球卫星——东方红1号。 1971年： 7月，基辛格秘密访华。 9月13日，九一三事件，林彪反革命集团被粉碎。 10月25日，第26届联合国大会恢复了我国在联合国的合法席位。 1972年： 2月，尼克松访华，中美双方在上海签署了《中美联合公报》，中美关系开始走向正常化。日本首相田中角荣访华，中日建交。 1973年： 袁隆平在世界上首次育成籼型杂交水稻。 1976年： 10月，粉碎江青反革命集团（“四人帮”），标志“文化大革命”结束。 十五、社会主义现代化建设的新时期（改革开放时期）：1978年至今 1978年： 关于真理标准问题的讨论展开。这是一场深刻的思想解放运动，为十一届三中全会的召开奠定了思想基础。 12月，中共十一届三中全会召开。这是建国以来党的历史上具有深远意义的转折，是改革开放的开端，从此我国进入社会主义现代化建设的新时期。 1979年： 1月，《告台湾同胞书》 中美建交。 3月，邓小平在中央理论工作务虚会上明确提出必须坚持四项基本原则。 坚持社会主义道路，坚持人民民主专政，坚持共产党的领导，坚持马克思列宁主义，毛泽东思想。 1980年： 我国在广东的深圳,珠海,汕头和福建的厦门建立经济特区，开始对外开放。 1982年： 中共十二大，邓小平提出建设有中国特色的社会主义，全国人大颁布了第四部《中华人民共和国宪法》。 1984年： 12月，中英《关于香港问题的联合申明》 1985年： 3月，《关于科学技术体制改革的决定》 5月，《关于教育体制改革的决定》 1986年： 颁布《中华人民共和国义务教育法》和《中华人民共和国民法通则》。 1987年： 4月，中葡《关于澳门问题的联合生命》 10月25日-11月1日，中共十三大，邓小平阐明了社会主义初级阶段理论，提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线，即以经济建设为中心，坚持四项基本原则，坚持改革开放。台湾当局调整“三不”政策，两岸关系发生了历史性的变化。制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标 1988年： 4月13日，海南经济特区； 1990年： 中国首次成功举办亚洲运动会。1990年台湾成立了海峡交流基金会。 1991年： 大陆成立了海峡两岸关系协会。 1992年：扩大改革，开放上海浦东位新的经济特区；海基会与海协会达成“九二共识”，即“海峡两岸均坚持一个中国原则”。 1992年初：邓小平南巡讲话，强调发展才是硬道理。南巡讲话进一步解放了人们的思想，对建设有中国特色的社会主义产生了深远影响。 1992年：中共十四大，提出建立社会主义市场经济体制，确立了邓小平理论在全党的指导地位，形成了以江泽民为核心的第三代领导集体。 1993年：“汪辜会谈”（海协会会长汪道涵和海基会董事长辜振甫在新加坡举行的会谈），将“加强两岸经济交流，互补互利”写入协议，标志着海峡两岸关系的发展迈出了历史性的重要一步。 14. 1995年初：1月，江泽民发表《为促进祖国统一大业的完成而继续奋斗》，提出“八项主张”，成为新时期推进祖国和平统一进程的指导思想。 1997年：7月1日：香港回归，中华人民共和国香港特别行政区正式成立。9月12日至18日，中共十五大，把邓小平理论写入党章，确立为党的指导思想。通过了关于《中国共产党章程修正案》的决议； 1999年：12月20日：澳门回归，中华人民共和国澳门特别行政区正式成立。我国成功发射第一艘无人飞船“神舟一号”。 20世纪90年代：党和政府提出“科教兴国”战略，把九年义务教育作为科教兴国的奠基工程。 20世纪末：中国整体上进入小康社会。 2000年：全国基本普及九年义务教育。 2001年：12月11日，加入世贸组织，标志着对外开放进入一个新阶段。中国在上海成功举办了亚太经合组织会议（APEC会议）。这是中国迄今举行的规模最大、规格最高的多边外交活动。 2002年：11月8日至14日，中共十六大北京召开；高举邓小平理论伟大旗帜，全面贯彻“三个代表”重要思想，继往开来，与时俱进，全面建设小康社会，加快推进社会主义现代化，为开创中国特色社会主义事业新局面而奋斗； 2003年：我国成功发射第一艘载人飞船“神州五号”。 2004年：9月，中共十六届四中全会提出的战略任务是构建社会主义和谐社会； 2005年3月14日第十届人民大表大会三次会议，反分裂国家法 2007年：10月15日至21日，中共十七大明确指出，高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制； 2008年：中国成功举办了奥运会和残奥会。 2010年：5月，中央新疆工作会议上中央正式批准霍尔果斯、喀什设立经济特区。 2011年：确立建设社会主义文化强国战旅目标的会议是 2013年：11月，中共十八届三中全会做出《关于全面深化改革若干重大问题的决定》，提出了全面深化改革的知道思想、重要方针、目标任务、政治举措，明确了全面深化改革的总目标、时间表、路线图，成为知道新形势下全面深化改革的纲领性文件；2017年：第十二届全国人大常委会第二十九次会议通过的法律《中华人民共和国国歌法》 主要运动： 四一二事变 1927年4月12日 上海 蒋中正大规模逮捕、处决中国共产党党员，并取缔苏联顾问。 七一五事变 1927年7月15日 武汉 汪精卫分工事件 九一八事变 1931年9月18日 东北 日本帝国主义发动“九·一八”事变 一二八事变 1932年1月28日 上海 日本帝国主义发动“一·二八”事变，淞沪会战，蒋光鼐蔡延凯抗击 一二九运动 1935年12也9日 北平 抗议日本侵占；北平爱国学生举行的抗日游行运动； 七七事变 1937年7月7日 卢沟桥 抗日战争开始 八一三事变 1937年8月13日 上海 蓄意已久地为扩大侵华战争在中国上海制造的事变 一二一运动 1945年12月1日 昆明 反对内战，争取自由；吹响了国统区爱国学生运动的第一声号角； 校场口惨案 1946年2月10 重庆 庆祝政协成功大会 下关惨案 1946年6月23日 上海 和平请愿团 一二三O运动 1946年12月30日 北平 抗议驻华美军暴行； 五二O运动 1947年5月20日 南京 反饥饿，反内战，挽救教育危机； 香港海员罢工 1922年1月 香港 中国工人阶级第一次直接同帝国主义势力进行的有组织的较量；工人运动第一个高潮起点。 主要党派： 兴中会 1894年11月 美国檀香山； 中国同盟会 1905年8月 日本东京； 中华革命军 1914年7月 日本东京； 中国国民党 1919年10月 中国上海； 中国 土地革命战争前中期，中国共产党内出现的主要错误倾向： “左”倾盲目主义 1927.11-1928.4 “左”倾冒险主义 1930.6-1930.9 “左”倾教条主义 1931.1-1935.1 为国捐躯的清政府爱国将领 第一次鸦片战争 关天培 1841.2 虎门 陈化成 1842.6 吴淞西炮台 海龄 1842.7 镇江 第二次鸦片战争 史荣椿 1859.6 大沽炮台 乐善 1859.6 大沽炮台 甲午战争 左宝贵 1894 平壤战役 丁汝昌 1895.2.11 北洋舰队 邓世昌 1894 甲午海战 林永升 1894 甲午海战 刘步蝉 重要将领介绍： 赵登禹，抗日牺牲； 佟麟阁，抗日牺牲； 张自忠，枣宜会战； 戴安澜，缅甸抗战； 李宗仁，台儿庄战役； 谢晋元，上海四行仓库牺牲； 蒋光鼐蔡延凯，淞沪会战； 一大党，二大纲。三大连国搞合作，四大五大净瞎忙。八一南昌第一枪，八七政权要靠抢。秋收工农来战斗，三湾改编新军装。遵义生死转折点，瓦窑战线要统一。洛川纲领有十条，七大老毛思想立。七届二中进城忙，七届三中复元气。八大主矛搞建设，九大十大不能提。十一三中搞开放，十一六中评价毛。十二小平提中特，十三别忘三步跑。十三一中两基本，十四泽民建市场。十五小平进党章，十六三代要小康。十七科观入党章，三届人大现代化。务虚四项要坚持，十八三中改革大。十九建成奔小康 1.封建社会的基本特点？（过） 经济上，封建土地所有制占主导地位，小农经济是其基本生产结构； 政治上，实行高度中央集权的封建君主专制制度； 文化上，以儒家思想为核心； 社会结构上，是族权和政权相结合的封建宗法等级制度； 2.近代中国社会的主要矛盾及其影响？（过） 帝国主义和中华民族的矛盾，封建社会和人民大众的矛盾，帝国主义和中华民族的矛盾是主要矛盾； 两对主要矛盾相互交织在一起，贯穿了整个半殖民地半封建社会的始终，对中国社会的发展变化起这决定性作用； 相互关系： 当外国列强向中国发动侵略战争时，阶级矛盾降到次要地位，民族矛盾上升到主要地位； 当外国侵略者同中国封建政权相勾结，共同镇压中国革命，尤其是封建地主阶级对人民的压迫特别残酷时，阶级矛盾上升为主要矛盾； 3.近代以来中华民族面临的历史任务？（过） 两大历史任务： 一是求得民族独立和人民解放； 二是实现国家繁荣富强和人民共同富裕； 相互区别，相互联系； 前者要从根本上推翻中国半殖民地半封建社会的统治秩序，着重解决生产关系问题； 后者要改变近代中国经济、文化和社会落后的地位和状况，是要充分发展近代民族工商业，着重解决生产力问题； 只有完成第一大任务，才能为第二大任务的完成创造条件。 争取民族独立和人民解放是实现国家繁荣富强和人民共同富裕的前提条件。争取民族独立和人民解放的最终目的是使中国走向现代化，实现国家繁 荣富强和人民共同富裕，是中国民族自立于世界民族之林； 4.太平天国农民战争的历史意义？（过） 它沉重打击了封建统治阶级，强烈撼动了清政府的统治根基。它坚持了14年之久，革命的势力先后扩展到18个省，其规模之大，时间之长，影响之深，是以往历次农民起义都比不上的。 它是中国旧式农民战争的最高峰。它把千百年来农民对拥有土地的渴望，在《天朝田亩制度》中比较完整的表达了出来。《资政新篇》则是中国近代史上第一个比较系统的发展资本主义的方案。 它冲击了孔子和儒家经典的正统权威。在一定程度上削弱了封建统治的精神支柱。 它有力的打击了外国侵略势力。 它和亚洲其他国家的民族解放运动汇合在一起，冲击了西方殖民主义在亚洲的统治。 5.简述太平天国定都天京后，先后颁布的两个重要纲领及其特点？（过） 1853年冬颁布《天朝田亩制度》，这是一个以解决农民土地问题为中心的比较完整的社会改革方案，最能体现太平天国社会理想； 太平天国后期提出《资政新篇》，这是一个带有鲜明资本主义色彩的改革与建设方案； 6.太平天国农民战争失败的主要原因？（过） 缺乏先进阶级的领导（根本原因）。农民阶级不是新的生产力和生产关系的代表，带有小生产者所固有的阶级局限性； 没有科学理论的指导，它是以拜上帝教来发动、组织群众的，但是拜上帝教教义不是科学的思想理论； 对外国资本主义列强缺乏理性的认识，笼统地把信奉上帝的西方人都视为“洋兄弟”； 7.资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战（过） 要不要变法； 要不要兴民权、设议院、实行君主立宪； 要不要废八股、改科举和兴学堂； 8.资产阶级革命派同改良派论战的主要内容及重要意义？（过） 1905年至1907年，孙中山为代表的革命派和以康有为为代表的改良派，分别以《民报》和《新民从报》为主要舆论阵地展开论战 要不要以革命手段推翻清政府，论战焦点； 要不要推翻帝制，实现共和； 要不要社会革命； 论战以革命派的胜利告终； 重要意义： 划清了革命与改良的界限； 是资产阶级民主思想和三民主义思想得到了更广泛的传播； 9.近代中国工人阶级的特点？（过） 深受帝国主义、封建势力和资产阶级三重压迫和剥削，革命性最强； 人数虽少，但相对集中，便于形成革命的力量和传播先进的思想； 主要由破产农民和家庭手工业者转化而来，同农民有着天然关系，便于结成工农联盟； 10.洋务运动的指导思想和举办的洋务事业是什么？（过） 洋务运动的指导思想是“中学为体，西学为用”。 兴办近代企业，最早兴办的是军用工业，70年代开始兴办民用企业； 建立新式海陆军； 创办新式学堂、派遣留学生； 11.洋务运动失败的主要原因？（过） 洋务运动具有封建性； 洋务运动对西方列强具有依赖性，企图仰仗西方列强来达到“求强”、“求富”的目的； 洋务企业的管理具有腐朽性，对企业采取的是封建衙门式的管理方法； 洋务运动的指导思想是“中学为体，西学为用”，只注重西法练兵和办企业，而不去改变落后的政治制度； 12.洋务运动的历史作用？（过） 促进了中国早期工业和民族资本主义的发展； 开辟了一批新式学堂，派出了最早的留学生，成为中国近代教育的开端； 传播了新知识，打开了人们的眼界； 引起了社会风气和价值观念的改变； 资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战 论战主要问题： 要不要变法； 要不要兴民权、设议院、实行君主立宪； 要不要废八股、改科举和兴学堂； 13.戊戌变法的主要内容： 改革政府机构，裁撤冗官，任用维新人士； 鼓励私人兴办工矿企业； 开办新式学堂吸引人才，翻译西方书籍，传播新思想； 创办报刊，开放言论； 训练新式陆军海军同时规定，科举考试废除八股文，取消多余的衙门和无用的官职； 14.戊戌变法的意义：（过） 是一次具有爱国救亡意义的变法维新运动， 是一场资产阶级性质的的政治改革，也是一次思想启蒙运动， 这次变法促进了思想解放，并且对思想文化的发展和促进中国近代社会的进步起了重要推动作用。 15.戊戌失败原因：（过） 根本原因 资产阶级维新派力量过于弱小，即资产阶级的软弱性；慈禧所代表的顽固派掌握实权，实力强大。 直接原因 缺乏正确的理论指导； 缺乏坚强的组织领导； 脱离广大人民群众，只寄希望于没有实权的皇帝和极少数的官僚； 对帝国主义抱有不切实际的幻想； 16.辛亥革命的历史局限性是什么？（过） 没有提出彻底的反对帝国主义和反封建主义的革命纲领； 没有充分发动和依靠民众； 没有建立坚强的革命政党； 17.辛亥革命的历史意义：（过） 1）推翻了清王朝，结束了中国数千年的君主专制统治； 2）创建了中华民国； 3）颁布了中国历史上第一部具有资产阶级共和国宪法性质的《临时约法》，使人民获得了一些民主权利； 4）开创了完全意义上的近代民族民主革命； 5）给中国先进分子以巨大的刺激和深刻的启发，使他们觉悟到必须另谋新的救国救民之路。 局限性：辛亥革命以同旧势力的妥协而告终，没有从根本上改变中国半殖民地半封建社会的性质。 18.1912年建立的南京临时革命政府是一个资产阶级共和国性质的革命政权？ 在人员构成上，资产阶级革命派控制着政权； 其实行的各项政策措施，集中体现了中国民族资产阶级的愿望和利益； 临时参议院颁布《中华民国临时约法》，是中国历史上第一步具有资产阶级共和国宪法性质的大点； 19.新文化运动的历史意义？ 它是资产阶级民主主义的新文化同封建主义旧文化的斗争，是辛亥革命的思想文化领域的延续，沉重打击了封建专制主义； 它大力宣传了民主和科学，启发了人民的理智和民主主义觉悟，将人们从封建专制所造成的蒙昧中解放出来，开启了思想解放的潮流； 它为中国先进分子接受马克思主义做了准备，为以五四运动为开端的中国新民主主义革命创造了思想文化上的条件； 20.同盟会在日本东京成立： 创办机关刊物《民报》； 提出“驱除鞑虏，恢复中华，创立民国，平均地权”的纲领； 并概括为“民族”、“民权”、“民生”的“三民主义”； 这是近代中国第一个领导资产阶级革命的全国性政党，它的成立标志着中国资产阶级民主革命进人到一个新的阶段。 21.简述孙中山三民主义学说的主要内容及其意义？ 民主主义，包括“驱除鞑虏，恢复中华”。一是以革命手段推翻清王朝，二是变“次殖民地”的中国为独立的中国； 民权主义，“创立民国”，指推翻封建君主专制制度，建立资产阶级民主共和国； 民生主义，“平均地权”，基本方案是：核定地价，按价征税，涨价归公，按价售卖； 意义： 这是一个比较完备的民主主义的革命纲领，推动了革命思想的传播和革命运动的发展； 22.五四运动的历史特点及意义？（过） 五四运动是中国近代史上一次彻底反帝国反封建的革命运动，是一场真正群众性的革命运动； 促进了马克思主义在中国的广泛传播; 促进马克思主义同中国工人运动的结合; 五四运动是中国新民主主义革命的开端; 无产阶级逐渐替代资产阶级成为近代中国民族民主革命的领导者； 23.八一南昌起义的历史意义是什么？（过） 打响武装反抗国民党反动统治的第一枪; 它成为共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端； 揭开土地革命战争的序幕； 体现了中国共产党人为实行中国人民的根本利益和中国民族的解放事业而前赴后继的革命精神 24.中国共产党成立的历史意义？ 它标志着中国革命终于有了一个坚强的领导核心，有了可依赖的组织者和领导者； 中国革命从此有了科学的指导思想，中国共产党以马克思列宁主义基本原理观察和分析中国的问题，为中国指明了斗争目标、革命前途和胜利之路； 它沟通了中国革命与世界革命的联系，把中华民族的解放运动同世界无产阶级社会主义革命运动相联结，是中国革命有了新的前途； 自从有了中国共产党，中国革命的革命就焕然一新了； 25.毛泽东领导的湘赣边界秋收起义的特点？ 它放弃了“左派国民党”运动的旗号，公开打出了“工农革命军”的气质； 它不仅是军队的行动，而且有数量众多的工农武装参加； 26.三湾改编的主要内容？ 将原有的一个师缩编为一个团； 在部队中建立共产党各级组织，将党的支部建在连上； 成立各级士兵委员会，部队内部实行民主管理； 27.1926年至1927年，北伐战争直接打击的目标和战略方针？ 北伐的直接目标是打倒帝国主义支持的北洋军阀：吴佩孚、孙传芳、张作霖； 北伐的战略方针：首先进军两湖，消灭吴佩孚，然后引兵东向，消灭孙传芳，最后，北上解决张作霖； 28.八七会议的主要内容是什么？ 彻底清算大革命后期陈独秀右倾机会主义错误； 选出了以瞿秋白为首的中央临时政治局； 确立了土地革命和武装斗争的方针； 毛泽东提出了“须知政权是由枪杆子中取得的”重要理论； 29.遵义会议集中解决的主要问题及其意义？（过） 遵义会议集中解决了当时具有决定意义的军事和组织问题； 意义： 开始确立了以毛泽东为代表的马克思主义正确线路在党中央的领导地位； 在极其危机的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命； 成为中国共产党历史上一个生死攸关的转折点； 为党和革命事业转危为安、不断打开新局面提供了最重要的保证； 30.洛川会议指定的《抗日救国十条纲领》的主要内容是什么？ 要打倒日本帝国主义，关键在于实行全国军事总动员、全国人民的总动员，使抗战成为全面的全民族的抗战； 必须改革政治机构，给人民以充分的抗日民主权利，并适当改善工农大众的生活； 必须坚持统一战线中无产阶级的领导权，在敌后放手发动独立自主的山地游击战争，在国统区放手发动抗日的群众运动； 31.井冈山根据地创建的历史意义？ 它点燃了“工农武装割据”的星星之火，为共产党领导的其他各地的起义武装树立了榜样； 它从实践上开辟了一条在敌我力量十分悬殊的情况下，共产党深入农村保存和发展革命力量的正确道路； 32.中国工农红军长征胜利的历史意义？ 中国工农红军的长征是一部伟大的革命英雄主义史诗。它粉碎了国民党“围剿”红军、消灭革命力量的企图，是中国革命转危为安的关键 通过长征，中国革命的大本营放在了西北，这位迎接中国人民抗日救亡的新高潮准备了条件； 长征保存并锤炼了中国革命的骨干力量，这是党和红军极为宝贵的精华； 长征播撒了革命的火种，它为沿途的人民群众宣布，只有在中国共产党的领导下，中国各族人民才能翻身得解放； 中国共产党人和红军将士用生命和热血铸就了伟大的长征精神； 33.中国革命统一战线中的两个联盟及其关系是什么？ 一个是劳动者的联盟，主要是工人、农民和城市小资产阶级的联盟，这是最基本的、重要的； 一个是劳动者与非劳动者的联盟，主要是劳动者民族资产阶级的联盟，包括一部分大资产阶级的暂时联盟，这是辅助的、重要的； 34.中国共产党在全民族抗战中的中流砥柱作用？ 中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。中国共产党自成立之日起就把实现中华民族伟大复兴作为自己的历史使命。 在抗日战争中，中国共产党坚持全面抗战路线，制定了正确战略策略，开辟广大敌后战场，成为坚持抗战的中坚力量；中国共产党以自己的政治主张，坚定意志、模范行动，支撑起全民族救亡图存的希望，引领着夺取战争胜利的正确方向。成为夺取战争胜利的民族先锋。 35.中国人民抗日战争胜利的主要原因？ 以爱国主义为核心的伟大民族精神是中国人民抗日战争胜利的决定因素； 中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键； 全民族抗战是中国人民抗日战争胜利的主要法宝； 世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持，是中国人民抗日战争胜利的国际条件； 36.中国人民抗日战争在世界反法西斯战争中的地位？ 中国人民抗日战争是世界反法西斯战争的东方主战场。中国抗战开始最早，持续时间最长，牵制和抗击了日本军国主义的主要兵力，对日本侵略者的彻底覆灭起到了决定性作用； 中国人民的持久抗战，遏制了日本的“北进”计划，迟滞了日本的“南进”步伐，达达减轻了其他战场的压力，为盟国军队完成战略转折和实施战略反攻创造了有利条件； 中国作为亚太地区盟军对日作战的重要后方基地，为盟军提供了大量战略物资和军事情报，中国军队出锅作战，不近打击了日本，还对盟军给与了实际支援； 中国为战胜法西斯、维护世界和平付出了巨大的牺牲，做出了伟大的贡献； 37.中国共产党抗日民族统一战线的策略总方针是什么？ 发展进步势力，进步势力主要指工人、农民和城市小资产阶级； 争取中间势力，中间势力主要指民族资产阶级、开明绅士和地方实力派； 孤立顽固势力，顽固势力主要指大地主大资产阶级的抗日拍，以蒋介石集团为代表的国民党亲英美派； 38.中国新民主主义革命胜利的基本经验？ 建立广泛的统一战线。这是坚持和发展革命的政治基础。统一战线中存在着两个联盟：一个是劳动者的联盟，一个是劳动者与非劳动者的联盟，必 须坚持依靠第一个联盟，争取建立和夸大第二个联盟； 坚持革命的武装斗争，中国革命只能以长期的武装斗争作为主要形式：中国革命必须走农村包围城市、武装夺取政权的道路；必须建立一直党绝对 领导下的新式人民军队； 加强共产党自身的建设，着重从思想上建党：培育和发扬理论与实际相结合、密切联系群众和自我批评的作风；成为统一战线和武装斗争这两个武 器以实行对敌冲锋陷阵的英勇战士，成为中国各族人民拥戴的领导核心； 39.新民主主义社会的五种经济成分及特点？ 社会主义性质的国营经济； 半社会主义性质的合作社经济； 农民和手工业者的个体经济； 私人资本主义经济； 国家资本主义经济； 特点：既有社会主义因素，又有资本主义因素，本身具有过渡性； 40.在《论持久战》一文中，毛泽东如何阐述抗日战争是持久战，最后胜利属于中国？ 中日双发存在着相互矛盾的四个特点：敌强我弱，敌小我大，敌退步我进步，敌寡助我多助； 一方面，日本是强国，中国是弱国，强国弱国的对比，决定了抗日战争只能是持久战； 一方面，日本是效果，发动的事退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，国际上得道 多助； 中国已经有了代表中华民族和中国人民根本利益的共产党及其领导的人民军队和抗日根据地。因此，最后胜利是中国的； 41.毛泽东在《论持久战》中对抗日战争历史进程的阐述。 中国抗日战争将经过战略防御、战略相持、战略反攻三个阶段； 战略相持阶段，时中国抗日战争取得最后胜利的最关键的阶段； 只要坚持持久抗战、坚持抗日民族统一战线，中国将在这个阶段获得转弱为强的力量； 42.简述中国新民主主义革命取得胜利的主要原因？ 一是有了中国工人阶级的先锋队，中国共产党的领导。它以马克思列宁主义基本原理与中国实际相结合的毛泽东思想作为一切工作的指针，制定出符合中国国情和人民利益的纲领、路线、方针和政策；他具有远见，最富有牺牲精神，最坚定，从而赢得了中国人民的衷心拥护； 二是人民群众和各界人士的广泛参加和大力支持。工人、农民、城市小资产阶级群众是民主革命的主要力量；随着斗争的发展，民族资产阶级也逐步向共产党靠拢； 三是国际无产阶级和人民群众的支持； 43.中国共产党在过渡时期总路线的内容及其特点？ 要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、手工业和对资本主义工商业的社会主义改造。 这是社会主义建设同社会主义改造同时并举的总路线，体现了生产力和变革生产关系的有机统一。 44.全国解放战争时期，各民主党派与中国共产党团结合作的重要表现？ 在重庆谈判和政协会议期间，各民主党派作为“第三方面”，同共产党一起反对国民党反动派的内战、独裁政策，为和平民主二共同努力。 在国民党当局撕毁政协协议、发面全面内战后，民主党派中的大多数同共产党保持一致，拒绝参加国民党一手包办的“国民大会”、反对国民党炮制的“宪法” 45.毛泽东提出的社会主义现代化建设的战略目标和步骤？ 社会主义现代化建设的战略目标：把中国建设成为一个具有现代农业、现代工业、现代国防和现代科学强国。 社会主义现代化建设的步骤：采取“两步走”的发展战略， 第一步，建立一个独立的比较完整的工业体系和国民经济体系； 第二步，全面实现农业、工业、国防和科学技术的现代化，是中国的经济走向世界前列； 46.新中国建立初期中国共产党面临的主要问题和考验？ 能不能保卫住人民胜利的成果，巩固新生的人民政权； 能不能战胜严重的经济困难，迅速恢复和发展国民经济； 能不能巩固民族独立，维护国家主权和安全。 能不能经受住执政的考验，继续保持谦虚、谨慎、不骄、不躁的作风和艰苦奋斗的作风。 47.七大召开 大会提出党的政治路线是： 放手发动群众，壮大人民力量，在党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国。 大会强调毛泽东思想为全党的指导思想。 大会通过的新党章强调了群众路线和党的民主集中制原则。 这次大会是团结的大会，胜利的大会，为抗日战争和夺取新民主主义革命在全国的胜利奠定了基础。 48.毛泽东发表《论十大关系》一文的意义？ 它是以毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志； 从经济和政治方面提出了新的指导方针，为中共八大（1956年）的召开做了理论准备； 49.四个现代化？ 农业现代化、工业现代化、国防现代化、科学技术现代化 50.简述1979年3月，邓小平提出的四项基本原则及坚持这些原则的重要性？ 坚持社会主义道路，坚持人民民主专政，坚持共产党领导，坚持马克思列宁主义、毛泽东思想； 这是实现四个现代化的根本气体，如果动摇了其中的任何一项，也就动摇了整个社会主义现代化建设事业； 51.简述毛泽东等老一代革命家探索中国社会主义民主政治建设道路的理论贡献？ 第一，要造成一个又有集中又有民权，又有纪律又有自由，又有统一意志，又有个人心情舒畅、生动活泼的政治局面； 第二，把正确处理人民内部矛盾作为国家政治生活的主题，坚持人民民主，团结一切可以团结的力量； 第三，处理好中国共产党同各民主党派的关系，坚持长期共存、互相监督的方针，巩固和扩大爱国统一战线； 第四，切实保障人民当家做主的各项权利，尤其是人民参与国家和社会事务管理的权利； 第五，社会主义法制要保护劳动人民利益，保护社会主义经济基础，保护社会主义生产力； 52.中共八大如何分析我国社会主义改造完成后国内的矛盾和主要任务？ 社会主义改造完成后，我们国内的主要矛盾，已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文 化迅速发展需要同当前经济文化不能满足人民需要的状况之间的矛盾； 当合全国人民的主要任务是集中力量来解决这个矛盾，把我国尽快从落后的农业国变成先进的工业国； 53.中共八大提出的我国经济建设和政治建设的指导方针时什么？ 在经济建设上，大会坚持既反保守又反冒进，即在综合平衡中稳步前进的方针； 再政治建设上，大会要求继续加强我国的人民民主专政，加强国内各民族的团结，继续巩固人民民主统一战线，逐步指定完善的法律，建立健全的法制； 54.社会主义改造基本完成的意义？ 社会主义改造的基本完成，使社会主义基本经济制度在中国全面地建立起来了，是中国进入社会主义社会的最重要的标志； 社会主义改造是在生产关系方面由私有制到公有制的一场伟大的变革，对生产力的发展支持起到了促进作用； 通过社会主义改造，中国共产党领导全国各族人民创造性地完成了由新民主主义到社会主义的过渡，实现了中国历史上最深刻的社会制度； 55.中国经历的三次历史性巨变？ 第一次是辛亥革命，推翻通知中国几千年的君主专制制度； 第二次是中华人民共和国的成立和社会主义制度的建立； 第三次是改革开放，为实现社会主义现代化而奋斗； 56.我国农村社会主义改造的过渡性经济组织形式以及其性质是什么？ 第一是互助组，这是具有社会主义萌芽性质的经济组织； 第二是初级农业生产合作社，这是具有半社会主义性质的经济组织； 第三是高级农村生产合作社，这是具有社会主义性质的经济组织； 57.“三个主体，三个补充”的内容是什么？ 国家经营和集体经营为主体，一定数量的个体经营为补充； 计划生产是主体，一定范围的自由生产为补充； 国家市场是主题，一定范围的自由市场为补充； 58.中共十三大指定的社会主义现代化建设“三步走”的战略部署是什么？ 第一步，实现国民生产总值比1980年翻一番，解决人民的温饱问题； 第二步，到20世纪末，使国民生产总值再增长一倍，人民生产达到小康水平； 第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化； 60.一二九运动及其历史意义是什么？ 1935年12月9日，在中国共产党救亡图存、全民抗战的号召和中共北平临时工作委员会的领导下，北平学生举行声势浩大的抗日游戏，遭到国民党军警镇压。 一二九运动打击了日本帝国主义侵略中国并吞并华北的计划，促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。 在20世纪30年代后期和40年代前期，毛泽东撰写了《〈共产党人〉发刊词》、《中国革命和中国共产党》、《新民主主义论》等一批重要的理论著作。新民主主义理论的系统阐明，标志着毛泽东思想得到多方面展开而达到成熟。1937年夏，毛泽东在延安抗日军政大学讲授《实践论》、《矛盾论》，科学地阐明了党的马克思主义的思想路线。平型关大捷 八路军出师以来打的第一个大胜仗 中共一大，标志中国共产党成立；纲领是：革命军队必须与无产阶级一起推翻资本家阶级的政权；确定党的根本政治目的是实行社会革命。中共二大，制定反帝反封建的民主革命纲领；中共三大，决定同国民党合作，建立革命统一战线；国民党一大，标志着第一次国共合作的正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面；中共四大，通过了《对于民族革命运动之议决案》，陈独秀当选为中央总书记兼中央组织部主任，彭述之任中央宣传部主任，张国焘任中央工农部主任，蔡和森、瞿秋白任中央宣传部委员；中共五大，大会通过了《政治形势与党的任务议决案》《土地问题议决案》等；“八七会议”，在汉口召开，彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。中共六届六中全会，毛提出了”马克思主义的中国化”这个命题；中共七届二中全会，规定政治、经济、外交基本政策；农业国转变工业国、新民主主义社会转变社会主义社会方向；提出“两个务必”要求；中共七届三中全会，毛做《为争取国家财政经济状况的基本好转而斗争的》报告，创建三个条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减；中共七大，通过了新的党章，确定以马克思列宁主义与中国革命实践相统一的毛泽东思想作为全党一切工作的指针；中共八大，探索建设社会主义道路的开端。陈提“三个主体，三个补充”思想。党和人民主要任务是把我国从落后的农业国变为先进的的工业国；中共十一届三中全会，这是建国以来党的历史上具有深远意义的转折，是改革开放的开端，从此我国进入社会主义现代化建设的新时期。中共十二大，邓小平提出建设有中国特色的社会主义，全国人大颁布了第四部《中华人民共和国宪法》。中共十三大，邓阐明了社会主义初级阶段理论，提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线，即以经济建设为中心，坚持四项基本原则，坚持改革开放。制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标；中共十四大，提出建立社会主义市场经济体制，确立了邓小平理论在全党的指导地位，形成了以江泽民为核心的第三代领导集体。中共十五大，把邓小平理论写入党章，确立为党的指导思想。通过了关于《中国共产党章程修正案》的决议；中共十六届四中全会，提出的战略任务是构建社会主义和谐社会；中共十七大，明确指出高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制；中共十八届三中全会，发表《关于全面深化改革若干重大问题的决定》，提出了全面深化改革的知道思想、重要方针、目标任务、政治举措，明确了全面深化改革的总目标、时间表、路线图，成为知道新形势下全面深化改革的纲领性文件；中共十八大,进入全面建成小康社会决定性阶段召开的一次十分重要的大会。审议并通过《中国共产党章程（修正案）》中共十九大,作了题为《决胜全面建成小康社会 夺取新时代中国特色社会主义伟大胜利》的报告。主题是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。是在全面建成小康社会决胜阶段、中国特色社会主义发展关键时期召开的一次十分重要的大会。","link":"/2020/10/16/%E5%8E%86%E5%8F%B2%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%97%A7%EF%BC%89/"},{"title":"14 activity启动流程","text":"好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍： An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture. 英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。 在介绍Activity的启动流程之前，我们先介绍几个概念： Activity的生命周期 protected void onCreate(Bundle savedInstanceState);protected void onRestart();protected void onStart();protected void onResume();protected void onPause();protected void onStop();protected void onDestory();以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。关于Activity生命周期的详细介绍可以参考： Android activity的生命周期 Activity的启动模式 activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。关于Activity启动模式的详细介绍，可以参考： Android任务和返回栈完全解析 Activity的启动进程 在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。 Intent启动Activity的方式 Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。 Android Framework层的CS模式通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑： Zygote进程 --&gt; SystemServer进程 --&gt; 各种系统服务 --&gt; 应用进程 在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。 Android系统进程间通讯Binder机制Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍： 好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。 还记得前面我们讲过的Launcher启动流程么？可以参考：android源码解析之（十）–&gt;Launcher启动流程在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法： 123456789101112131415161718192021222324@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); }public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？ 这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。 继续，我们查看startActivity方法的具体实现： 一:开始请求执行启动Activity MyActivity.startActivity()Activity.startActivity()Activity.startActivityForResultInstrumentation.execStartActivtyActivityManagerNative.getDefault().startActivityAsUser() 在我们的Activity中调用startActivity方法，会执行Activity中的startActivity1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); }然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1. 注意：通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。 好吧，我们继续往下看，startActivityForResult方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑： 123if (requestCode &gt;= 0) { mStartedActivity = true;} 通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。 然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。 可以发现execStartActivity方法传递的几个参数：this，为启动Activity的对象；contextThread，为Binder对象，是主进程的context对象；token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；target，为启动的Activity；intent，启动的Intent对象；requestCode，请求码；options，参数； 这样就调用了Imstrument.execStartActivity方法了： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现： 123static public IActivityManager getDefault() { return gDefault.get(); } 好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？ 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现： 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService； 这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。 好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。 继续往下卡，我们调用的是： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法： 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) { data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { data.writeInt(0); } if (options != null) { data.writeInt(1); options.writeToParcel(data, 0); } else { data.writeInt(0); } mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; } 这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。 以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。 二：ActivityManagerService接收启动Activity的请求 ActivityManagerService.startActivity()ActvityiManagerService.startActivityAsUser()ActivityStackSupervisor.startActivityMayWait()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.startActivityUncheckedLocked()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.resumeTopActivitiesLocked()ActivityStackSupervisor.resumeTopActivityInnerLocked() 好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现； 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现： 1234567891011121314151617final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } 这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法： 1234567891011121314151617final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) { int err = ActivityManager.START_SUCCESS; ... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); ... return err; } 这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法： 12345678910111213final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) { ... ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) { // Don't set focus on an activity that's going to the back. mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;); } return ActivityManager.START_SUCCESS; } startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法： 1234567final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) { ... if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } } 这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法： 1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) { if (targetStack == null) { targetStack = mFocusedStack; } // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) { result = targetStack.resumeTopActivityLocked(target, targetOptions); } for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) { // Already started above. continue; } if (isFrontStack(stack)) { stack.resumeTopActivityLocked(null); } } } return result; } 可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后调用： 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) { mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); } result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 继续调用resumeTopActivityInnerLocked方法： 12345678910private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) { ... if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); } ... return true; } 经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。 三：执行栈顶Activity的onPause方法 ActivityStack.startPausingLocked()IApplicationThread.schudulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage();ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused(token)ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked()ActivityStack.resumeTopActivitiesLocked()ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopActivityInnerLocked()ActivityStack.startSpecificActivityLocked 好吧，方法比较多也比较乱，首先来看startPausingLocked方法： 1234567891011121314151617181920212223242526final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev); try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。 这里的ApplicationThread可以和ActivityManagerNative对于一下：通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯 然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现： 12345678public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges); } 发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 调用了其重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现： 123456789101112public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { ... case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...} 可以发现其调用了handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; } 然后调用其重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... mInstrumentation.callActivityOnPause(r.activity); ... return !r.activity.mFinished &amp;&amp; saveState ? r.state : null; } 这样回到了mInstrumentation的callActivityOnPuase方法： 123public void callActivityOnPause(Activity activity) { activity.performPause(); } 呵呵，原来最终回调到了Activity的performPause方法： 1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onPause()&quot;); } mResumed = false; } 终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。 然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现： 1234567final void activityPausedLocked(IBinder token, boolean timeout) { ... if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;)); completePauseLocked(true); ... } 然后执行了completePauseLocked方法： 12345678910111213141516171819202122private void completePauseLocked(boolean resumeNext) { ... if (resumeNext) { final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) { mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); } else { mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(null); if (top == null || (prev != null &amp;&amp; top != prev)) { // If there are no more activities available to run, // do resume anyway to start something. Also if the top // activity on the stack is not the just paused activity, // we need to go ahead and resume it to ensure we complete // an in-flight app switch. mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); } } } ... } 经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过resumeTopActivitiesLocked –&gt;ActivityStack.resumeTopActivityLocked() –&gt;resumeTopActivityInnerLocked –&gt;startSpecificActivityLocked好吧，我们看一下startSpecificActivityLocked的具体实现： 123456789101112131415161718192021222324252627282930313233void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. } mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); } 可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。 四：启动Activity所属的应用进程 关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考： android源码解析之（十一）–&gt;应用进程启动流程 这里在简单的介绍一下 ActivityManagerService.startProcessLocked()Process.start()ActivityThread.main()ActivityThread.attach()ActivityManagerNative.getDefault().attachApplication()ActivityManagerService.attachApplication() 好吧，首先看一下startProcessLocked()方法的具体实现： 12345private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */); } 然后回调了其重载的startProcessLocked方法： 123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ... boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; + app.processName); checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); ... } 可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”: 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 然后调用了startViaZygote方法： 123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(Process.class) { ... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); } } 继续查看一下zygoteSendArgsAndGetResult方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx( &quot;embedded newlines not allowed&quot;); } writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } result.usingWrapper = inputStream.readBoolean(); return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } } 可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。 为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。 好了，这时候我们看一下ActivityThread的main方法的实现逻辑。 123456789101112131415161718192021222324public static void main(String[] args) { ... Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。 12345678910private void attach(boolean system) { ... final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } ...} 刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的： 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。 12345678910111213141516171819private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... // See if the top visible activity is waiting to run in this process... if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; } } ... return true; } 该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~ 五：执行启动Acitivity ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked()IApplicationThread.scheduleLauncherActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()Instrumentation.callActivityOnCreate()Activity.onCreate()ActivityThread.handleResumeActivity()ActivityThread.performResumeActivity()Activity.performResume()Instrumentation.callActivityOnResume()Activity.onResume()ActivityManagerNative.getDefault().activityResumed(token) 首先看一下attachApplicationLocked方法的实现： 1234567891011121314151617181920212223242526272829303132boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) { continue; } ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) { if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) { try { if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; } } } } } if (!didSomething) { ensureActivitiesVisibleLocked(null, 0); } return didSomething; } 可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑： 1234567891011121314final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... return true; } 可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现： 1234567891011121314151617181920212223242526272829303132333435@Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); } 好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法： 1234567891011121314private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); } ... } 可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。 12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } ... if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } ... return activity; } 可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。 123456public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 然后执行activity的performCreate方法。。。。好吧，都转晕了。。。 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。 在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式： 123456789101112131415final void performStart() { mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStart()&quot;); } mFragments.dispatchStart(); mFragments.reportLoaderStart(); mActivityTransitionState.enterReady(this); } 好吧，还是通过Instrumentation调用callActivityOnStart方法： 123public void callActivityOnStart(Activity activity) { activity.onStart(); } 然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~ 还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) { final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } } else { // If an exception was thrown when trying to resume, then // just end this activity. try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { } } } 可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) { ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r + &quot; finished=&quot; + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) { if (clearHide) { r.hideForNow = false; r.activity.mStartedActivity = false; } try { r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) { deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; } if (r.pendingResults != null) { deliverResults(r, r.pendingResults); r.pendingResults = null; } r.activity.performResume(); EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to resume activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } } return r; } 在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现： 12345final void performResume() { ... mInstrumentation.callActivityOnResume(this); ... } 好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。 1234567891011121314public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。 终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。 有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。 好吧，具体的逻辑我们下一步再说 六：栈顶Activity执行onStop方法 Looper.myQueue().addIdleHandler(new Idler())Idler.queueIdle()ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.stopActivityLocked()IApplicationThread.scheduleStopActivity()ActivityThread.scheduleStopActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleStopActivity()ActivityThread.performStopActivityInner()ActivityThread.callCallActivityOnSaveInstanceState()Instrumentation.callActivityOnSaveInstanceState()Activity.performSaveInstanceState()Activity.onSaveInstanceState()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop() 回到我们的handleResumeActivity方法，在方法体最后有这样的一代码： 1Looper.myQueue().addIdleHandler(new Idler()); 这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法： 12345678910111213141516171819202122final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { ... // Stop any activities that are scheduled to do so but have been // waiting for the next one to start. for (int i = 0; i &lt; NS; i++) { r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) { if (r.finishing) { stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); } else { stack.stopActivityLocked(r); } } } ... return r; } 可以发现在其中又调用了ActivityStack.stopActivityLocked方法： 123456789final void stopActivityLocked(ActivityRecord r) { if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r); if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) { ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... } } 好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) { sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); } 然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。 12345private void handleStopActivity(IBinder token, boolean show, int configChanges) { ... performStopActivityInner(r, info, show, true); ... } 然后我们看一下performStopActivityInner的实现逻辑： 1234567891011121314151617181920212223242526private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } if (!keepShown) { try { // Now we are idle. r.activity.performStop(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.stopped = true; } } } 好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 好吧，又是通过Instrumentation来执行。。。 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 又间接调用了Activity的performSaveInstanceState方法： 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。 然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法： 1234567891011121314151617181920212223242526272829303132333435363738final void performStop() { mDoReportFullyDrawn = false; mFragments.doLoaderStop(mChangingConfigurations /*retain*/); if (!mStopped) { if (mWindow != null) { mWindow.closeAllPanels(); } if (mToken != null &amp;&amp; mParent == null) { WindowManagerGlobal.getInstance().setStoppedState(mToken, true); } mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStop()&quot;); } synchronized (mManagedCursors) { final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) { ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) { mc.mCursor.deactivate(); mc.mReleased = true; } } } mStopped = true; } mResumed = false; } 还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。 123public void callActivityOnStop(Activity activity) { activity.onStop(); } O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()….. 总结： Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的 startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0 Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯 ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。 ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。 ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法； ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发； ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作； ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程； ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法； 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作； ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作； ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法； ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法； ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread； ActivityThread执行真正的onStop方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程","link":"/2020/09/11/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"ADB命令大全(转)","text":"ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 Other languages: :gb: English 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: \"android.intent.action.MAIN\" Category: \"android.intent.category.LAUNCHER\" AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider} applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package{55f714c org.mazhuang.guanggoo} codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures{af09595 [53c7caa2]} installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es \"toast\" \"hello, world\" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令：1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed \"s/\\r$//\" &gt; sc.png Mac OS X 1adb shell screencap -p | gsed \"s/\\r$//\" &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network={ ssid=\"TP-LINK_9DFC\" scan_ssid=1 psk=\"123456789\" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893}network={ ssid=\"TP-LINK_F11E\" psk=\"987654321\" key_mgmt=WPA-PSK sim_num=1 priority=17293} ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server's $ADB_VENDOR_KEYS is not setTry 'adb kill-server' if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666，shawnlinboy，s-xq，lucky9322。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）","link":"/2019/10/11/README/"},{"title":"科学上网电报 Telegram 群组汇总（转）","text":"科学上网电报 Telegram 群组汇总Cover Image for 科学上网电报 Telegram 群组汇总December 25, 2020Telegram电报群实在是太多了，小伙伴根本找不过来，加上Telegram本身无法搜索群组，想找一些合适的好玩的电报群租非常麻烦。如何快速的找到自己想要加入的Telegram群组？本文是电报群组大汇总，建议使用浏览器的搜索功能查找关键字，这样才能快速定位。建议收藏本汇总。 推荐Telegram 中文 NEWS:https://t.me/YinxiangBiji_NewsTelegram 中文社群:https://t.me/yxbjxTelegram 中文群组频道搜索机器人: https://t.me/ququn_botBear 熊掌记用户群:https://t.me/joinchat/Ag98FxRIKr7UkwUPqKKmfwRSS 交流群:https://t.me/joinchat/Ag98F0evTbZwY8HB7oH4fA笔记软件交流讨论:https://t.me/joinchat/Ag98F0DdcZr1X1xS6lJsyA幕布用户群:https://t.me/joinchat/Ag98F01tRQ2RIk_icHhiyA为知笔记用户群:https://t.me/joinchat/Ag98F1MLJji5WC5OpjAcHQ有道云笔记用户群:https://t.me/joinchat/Ag98F1C2ip5g0Bac_KCJ2ATodoist 用户群:https://t.me/joinchat/Ag98F1DuGqE_dIiNkeM2uASimplenote 用户群:https://t.me/joinchat/Ag98F0f7fjEKqZKVHNW0aAMarginNote 用户群:https://t.me/joinchat/Ag98F0ZLDrJZOSBWXAEiowiMazing 用户群:https://t.me/joinchat/Ag98F07KJmIlmwSCfTOKxQTypora 用户群:https://t.me/joinchat/Ag98FxBSO7eJ9mMwxxUIPw光年VPN 用户群:https://t.me/lightyearvpn群组 Group番羽土番Tempest(rixCloud) 群:https://t.me/rixCloud_UserSurge 交流:https://t.me/loveappsSurge Pro:https://t.me/SurgeProQuantumult X:https://t.me/QuanXAppQuantumult:https://t.me/quantumultQuantumult X小白群:https://t.me/QuanX_AppShadowrocket:https://t.me/ShadowrocketApplhie1/Rules:https://t.me/lhie1xDivineEngine Chat:https://t.me/joinchat/BlP48kmUGY-iR41Iq11-3wQuantumult X、Surge、Loon的脚本讨论:https://t.me/joinchat/JikZ61Y-WyLUu6dBFPfu6wthor，Quantumult X，小火箭 JSBox交流群:https://t.me/weixiaoge777 Loon:https://t.me/Loon0x00rixCloud 用户群:https://t.me/rixCloudbot (绑定账号后,发送’/joingroup’获取群链接)Dler Cloud 用户群:https://t.me/DlerCloud_bot (绑定账号后,会给你发送群链接)YoYu - Global Accelerate:https://t.me/YoYuBot (发送’/bind’绑定账号后,会给你发送群链接)喵帕斯用户群:https://t.me/npsBoostbot (绑定账号后,发送’/joingroup’获取群链接)歪兔YTOO:https://t.me/YToo_bot (绑定账号后,获取群链接)N3RO Network:https://t.me/nnn3ro科学上网技术研究会:https://t.me/kxswjs科学上网，科技分享:https://t.me/qiankeji老王用户群:https://t.me/wangvpn_users老王讨论群:https://t.me/wangvpn_user_chat嘿嘿嘿:https://t.me/hellcell321神机规则群:LAMP交流群:https://t.me/qiushui2018V1blog交流群:https://t.me/V1blog_gBGP测速:https://t.me/hxisj8whsv机场测速频道:https://t.me/jcfast自用机场测速:https://t.me/shangguanhongxinSpeedtest by Delected Account:https://t.me/delspeedtestSurge/Quantumult X Script:https://t.me/scriptgroupShadowsocks:https://t.me/joinchat/A1lxzDuvcioTtic84c12vQShadowsocksR 讨论组:https://t.me/ssrunofficialShadowsocksR 讨论组 2群:https://t.me/chatssrShadowsocksRR 讨论组:https://t.me/ssrrchatNetch 游戏加速工具:https://t.me/Netch_Discuss_GroupClash:Clash for Windows:Clash for Android:Clash 交流群:https://t.me/ClashclientClashR 交流群组:https://t.me/ClashR_ChatClashW:https://t.me/joinchat/AAAAAFHaKhGQaovvfpKr4gShellClash(Clash for Miwifi):https://t.me/clashfmTrojan-Qt5:https://t.me/TrojanQt5Pharos Pro For iOS:https://t.me/Shadow_x_user_supportPharos Pro For Android:https://t.me/joinchat/EthDYRQ80Clo_dj8e3PJnQTrojan Qt5:https://t.me/TrojanQt5Dashboard更新发布:https://t.me/db4cmShadowRay:https://t.me/ShadowRayProject V(V2Ray):https://t.me/projectv2rayProject X(Xray):https://t.me/projectXrayNetch 游戏加速工具:https://t.me/NetchV2fly Official:https://t.me/v2fly_chatV2Fly #Off-Topic:https://t.me/joinchat/GhXX_0zQFLOkjy9z81eQqgQv2ray User Group:https://t.me/qv2rayQv2ray Outpost:https://t.me/qv2ray_outpostv2rayN&amp;G:https://t.me/v2rayN老毛子Padavan固件自助交流群:https://t.me/pdcn2老毛子Padavan固件iOS自助交流群:https://t.me/pdcn3Wingy Halal Group:https://t.me/wingytg魅影极速:魅影极速分站ARK:https://t.me/joinchat/HOQoQ0gXFKNdjqQ1S5ymfACordCloud泡面交流群:https://t.me/joinchat/DsPjq0KEVl6saO_62MHEDANexitally 的老年人活动中心:https://t.me/nexitallyusersAmyTelecom官方群:https://t.me/amytelecomgroupIPLC.cloud:https://t.me/joinchat/Kt2jPxWr4SxT4M40CKDfjAWireGuard:https://t.me/WireGuardVPN讨论群:https://t.me/gouwu202Net:https://t.me/chatwith202海豚湾の三温暖:https://t.me/joinchat/IVfY9w2yQbtFtuyjcS7i6wSurfboard 交流群:https://t.me/surfboardappSockBoom 咕咕咕交流群:https://t.me/sockboomCCCAT Madhouse:https://t.me/joinchat/AwB5ckAQb8s9Ev9c6shndgCCCAT Helpdesk:https://t.me/joinchat/AwB5ckdlwjLKRARW0nac2APython云-一个学习py的公益机场:https://t.me/pythonyun忍者云:https://t.me/joinchat/JzPmF0Vpbn30D36D9_Ja_wNyanCAT Group:https://t.me/NyanCaaaat几鸡:https://t.me/ngcss梦迪mdssCloud:https://t.me/MdCloud梦迪mdssCloud:https://t.me/mdssiosssrcloud:https://t.me/ssrcloud次元链接:https://t.me/cylink星愿云加速:https://t.me/starwishss百草园:https://t.me/baicaoyuan星愿云SWcloud:https://t.me/starwishss不拘阁:https://t.me/bujuyigeMunClolud:https://t.me/MunCloudSSRNSL NetWork:https://t.me/nsl_ssr飞云flycloud:https://t.me/FeiYunGroupI·SSR·do:https://t.me/i_SSRLSJ AirPort:https://t.me/lsjairportPoiCloud:https://t.me/PoiCloud良辰云:https://t.me/liangchenyunssZCSSR:https://t.me/zcssrqazCloud:https://t.me/qazcloud陆玖:https://t.me/GroupFor69Conair:https://t.me/conairmeFlysocks-Server:https://t.me/flysocksX-Air T3航站楼:https://t.me/xssr_boosterFHV站(antei):https://t.me/FHVHKHKloriCloud:https://t.me/loricloud928Net购物小车:https://t.me/net928贼船:https://t.me/zeichuanSoCloud 聊天群:https://t.me/socloudso牧场物语官方交流群:https://t.me/mcwy666999GLaDOS 中文社区:https://t.me/glados_network盈科數碼動力 Pacific Century CyberWorks Limited:https://t.me/ssrcloudGeekCloud:https://t.me/joinchat/Ky2VFBBt2S5uRDbF3bJfQgTHE.SSR官方售后群(BLINKLOAD):https://t.me/thessrgroup浪花云:https://t.me/langhuayunSunCloud萌妹吃瓜:https://t.me/Mengmm永久公益机场:https://t.me/AC_FFree大水比交流群:https://t.me/hxisj8whsv大佬吹牛群:https://t.me/xddos0少数人TG交流群:https://t.me/shaoshurenxWestCloud养生之道:https://t.me/joinchat/LM3Mm061YantoLHzgOs41QDLK的奔放交流时间:https://t.me/dlkvpnMcatCloud - V2ray:https://t.me/McatCloudQatar Airways:https://t.me/qatar00Mac-SSR:https://t.me/MacSSRMac翻墙 · SpechtLite交流群:https://t.me/SpechtLiteGFW 吐槽 &amp;&amp; 翻墙方法讨论:https://t.me/DiscussCrossGFWAlice:https://t.me/joinchat/AAAAAEAKmMX609B2f_Z9iQAnyFlow:https://t.me/AnyFlowApp极客公园:https://t.me/geekparkSSR V2ray 讨论分享:https://t.me/joinchat/HHeAr1ELdNEKXdOhr1yXkw路由器梅林固件交流群:https://t.me/joinchat/AAAAAEC7pgV9vPdPcJ4dJw恩山论坛→软路由综合交流群:https://t.me/Router166XX-Net:https://t.me/xxnetpipesocks:https://t.me/pipesocksSocksCap64官方群:https://t.me/tarolabNICO Homemade “CupSS”:https://t.me/niconodeVPS全球主機交流:https://t.me/VPSchatBIS科学上网:https://t.me/BISprojectglzjinmod:https://t.me/glzjinmod代理「配置·规则」分享:https://t.me/RuleConfig狸猫加速器活动交流群:https://t.me/joinchat/AAAAAEQuL_IYR9I0wuLnfQKitsunebi交流:https://t.me/Kitsunebi_funs精品免费翻墙app推荐:https://t.me/fuckyougfwSSTap Rule:https://t.me/SSTapRuleSSGlobal.co 官方群:https://t.me/joinchat/ESwgR0Ckp_zXMCuRKqykqATrojan:https://t.me/trojangfwLantern Beta:https://t.me/joinchat/BxT4KUg7B5HATgrFP22VXg几鸡-小圈自用公益机场:https://t.me/lisuanlaojiSuJ-Tech公益SSR:https://t.me/joinchat/KKbIW0pwN0JfXI86groWNASSRLittle小布机场:https://t.me/ssrlivAgent云计算加速服务:https://t.me/crossgreatfirewallss panel v3 mod 非官方水群:https://t.me/SSUnion小布吉岛闲聊群:https://t.me/bujidaochatOKAB3吹水:https://t.me/OKAB3ScriptSurgio 交流:https://t.me/surgiotgnebula_net:https://t.me/nebula_netOfficial Geph Users 迷霧通官方用戶群:https://t.me/gephusersExCloud:https://t.me/excloudAK’s Tech Studio:https://t.me/joinchat/GnoDABmvn-48g2PpaySbeQspeedtest测速吹水群:https://t.me/del_speedtestSignin Script:https://t.me/Suntany章鱼哥的SSPanel之家:https://t.me/woaizyg枫之谷加速:https://t.me/fzgjsYtFlow α:https://t.me/YtFlowVPS信号旗情报本部:https://t.me/vps_xinhaoqi飞享一刻:https://t.me/fhyw37咸鱼News:https://t.me/saltyfishnews软件Microsoft users:https://t.me/Microsofthelp捷径 Shortcuts:https://t.me/SiriShortcuts捷径社区:https://t.me/shortcuts_cnSnipaste:https://t.me/joinchat/BGyWwD9ZNqE3pLbhXc-VgQSnipaste Discuss:https://t.me/joinchat/BGyWwEDqrqiwizDA6gt16gPrice Tag:https://t.me/pricetagappApp 种草群:https://t.me/appfoundgroup版本控:https://t.me/nextnbChrome:https://t.me/ChromeCNMWeb 及相关讨论:https://t.me/mwebappMOZE 官方群:https://t.me/mozeapp岁寒输入法交流:https://t.me/SuiHanIMEHyperApp:https://t.me/hyperappPlus Messenger Support:https://t.me/plusmsgrchatPlus Messenger Chat:https://t.me/offTopicPlusChatPlus Messenger 中文討論區:https://t.me/plusfgcUnigram Insiders:https://t.me/unigraminsidersDocker:https://t.me/dockertutorialPin:https://t.me/PinTG奇点:https://t.me/jidianThor:https://t.me/thorshuThor HTTP Sniffer:https://t.me/thoranubisThor/HTTP/JSBox/捷径/Cydia交流群:https://t.me/yqc_666Pythonista 3:https://t.me/Pythonista3jiaoliuquniTools:https://t.me/toolinboxX.cat:https://t.me/PcatAppDrafts:https://t.me/drafts4Aria2 中文交流群:https://t.me/Aria2_CNLucis（优雅的第三方 Tumblr 客户端）:https://t.me/LucisAppLyricsX:https://t.me/LyricsXTestFlightPureWriter’s Friends:https://t.me/purewriter/码农群英会:https://t.me/devmanmanEOS:https://t.me/EOSprojectSifter:https://t.me/sifterappIINA 中文:https://t.me/IINAUsersZHIINA:https://t.me/IINAUsersRSSHub:https://t.me/rsshubPPHub 官方群:https://t.me/joinchat/Jn89QxI2MWt9hgTLQQW2GgCuto 壁纸:https://t.me/joinchat/BC6PtD89sEGgHKR28OtQVAUpperSoft-讨论组:https://t.me/UpperSoftDiscussMac玩儿法茶馆:https://t.me/waerfa软件技术资源共享:https://t.me/SharedResourcesplusTelePlus 官方討論組:https://t.me/TelePlus_GroupMK播放器:https://t.me/MKPlayerApp畅邮（Cymail）电子邮箱客户端:https://t.me/cyemail记账应用讨论:https://t.me/accountingappsMixin Network (XIN):https://t.me/MixinCommunity52破解信息:https://t.me/wuaipojieLaunch Center Pro 交流分享:https://t.me/lcpappReddigram:https://t.me/reddigramNicegram Chat:https://t.me/nicegramchatAdGuard Chat [EN]:https://t.me/adguard_enAdguard [CN]:https://t.me/adguard_cnAdGuard 【中文】:https://t.me/AdGuard_chineseGridea 群组:https://t.me/joinchat/IDY0ahRqb8NPodv95BNpBgOffice Tool Group:https://t.me/joinchat/GdsEL0ejcWZ-T-koyW4WugExcel学习群:https://t.me/excellearnerVShareCloud:https://t.me/VShareCloudMoonFM:https://t.me/joinchat/FLWvJhDhXGAQO5SGDg87nwTelegreat 中文支援區:https://t.me/TelegreatXInstagram:https://t.me/joinchat/AAAAAFL_lXy0yPL754j5CQPanDownload交流群:https://t.me/joinchat/Lz9fSlOgUUyinc5N7Gv6tgAPKs, ROMs &amp; Tools:https://t.me/r3l3as3sdotPlayer 小点播放器:https://t.me/dotplayer期待APP:https://t.me/angeliachatElpass:https://t.me/ElpassAppuTools:https://t.me/u_toolsttte for Twitter:https://t.me/ttteappHere内测群:https://t.me/HereAppPigeon Insiders:https://t.me/pigeon_appVNoteX:https://t.me/vnotexVVebo官方群:https://t.me/vvebogroupVVeboX非官方群:https://t.me/VVeboX_unofficialGBox官方交流群:https://t.me/GBoxTGGBox Official:https://t.me/GBoxOfficialTransno:https://t.me/transnousergroupFastClip:https://t.me/fastclipchatStack Insiders:https://t.me/stack_apppyTelegramBotAPI:https://t.me/joinchat/Bn4ixj84FIZVkwhk2jag6ACC来电拦截:https://t.me/ccblockerSubs - subscriptions tracker:https://t.me/app_subs时光软件:https://t.me/sgxxqgScriptable 交流群:https://t.me/Scriptable_JS社区/用户Telegram 中文社群:https://t.me/yxbjxVultr 中文社群:https://t.me/vultr_groupBear 熊掌记用户群:https://t.me/joinchat/Ag98FxRIKr7UkwUPqKKmfwRSS 交流群:https://t.me/joinchat/Ag98F0evTbZwY8HB7oH4fA笔记软件交流讨论:https://t.me/joinchat/Ag98F0DdcZr1X1xS6lJsyA幕布用户群:https://t.me/joinchat/Ag98F01tRQ2RIk_icHhiyA为知笔记用户群:https://t.me/joinchat/Ag98F1MLJji5WC5OpjAcHQ有道云笔记用户群:https://t.me/joinchat/Ag98F1C2ip5g0Bac_KCJ2ATodoist 用户群:https://t.me/joinchat/Ag98F1DuGqE_dIiNkeM2uASimplenote 用户群:https://t.me/joinchat/Ag98F0f7fjEKqZKVHNW0aAMarginNote 用户群:https://t.me/joinchat/Ag98F0ZLDrJZOSBWXAEiowiMazing 用户群:https://t.me/joinchat/Ag98F07KJmIlmwSCfTOKxQTypora 用户群:https://t.me/joinchat/Ag98FxBSO7eJ9mMwxxUIPwNewlearner水群:https://t.me/NewlearnerGroup科技花:https://t.me/zaihuachat谷歌交流社区 • 科技圈:https://t.me/GoogleFans逗比根据地:https://t.me/doubi逗比根据地:https://t.me/doubi2中文输入法爱好者群:https://t.me/IME_zhCN少数派 sspai 社群 非官方:https://t.me/sspai_groupiOS &amp; Mac · Free Talk:https://t.me/joinchat/BC6PtDwOzSNWFpXosJUnYwAndroid · Free Talk:https://t.me/joinchat/BC6PtDwBMhfDu6pnrg2wgwTech·Free Talk:https://t.me/joinchat/Ag98FzveUjPyDL-fMVNuXgAndroid &amp; iOS 相爱群:https://t.me/iosandandroidloveApple Talk 交流群:https://t.me/apple_talkApple Park:https://t.me/apple_parkAPPLE 交流群:http://t.me/apple_cnApple 产品交流群:https://t.me/applepro2iBeta 尝鲜派 官方用户讨论群:https://t.me/ibetame库克的后厨 Cook’s Kitchen:https://t.me/OnlineAppleUserGroup不知名科技吐槽:https://t.me/LifeAnaTechApple Watch 大集合:https://t.me/apple_watchApple TV+:https://t.me/AppleTVPlusApple Arcade CN:https://t.me/applearcadecnmimi:https://t.me/Orz_mini肆意🅥科学上网:https://t.me/kexueshangwang_41电脑玩物:https://t.me/joinchat/CHRBlQyz8PjB_RzmdXTavQ程序员技术资源分享群(陈皓(左耳朵耗子)创建的群):https://t.me/joinchat/FwAZpxdwmTHP2W1sPydPAQtinyfool的墙外群:https://t.me/joinchat/MqAAGRSeOCbZ1qDsOLBwig高可用技术研究:https://t.me/joinchat/FiMK0A5tQhJxLu9tBb0QTA大虾的编程资源交流群:https://t.me/programmingsrchubgroup东京IT技术者交流群:https://t.me/TokyoITPixelExperience - Official chat:https://t.me/pixelexperiencechat🔍telegram🇨🇳综合搜索:https://t.me/sssoou_resource🐑telegram🇨🇳羊毛自助搜索:https://t.me/sssoou_yangmao一加手机/OnePlus:https://t.me/oneplus666GIF 群聚地:https://t.me/GIFgroupTW貼圖群 Sticker Group:https://t.me/StickerGroupV2EX 后花园:https://t.me/joinchat/Bg3MFjv5FgYrWI0WqHDo8QV2EX 后花园 v2.0:https://t.me/goV2EXV2EX 交流群:https://t.me/v2exchatV2EX-修仙:https://t.me/xiuxianAppinn Talk (小众软件):https://t.me/appinnSetapp 开车群:https://t.me/joinchat/AacydhT79JJBmDj68rCC9wSetapp 拼车群:https://t.me/setapp_diSetApp - Mac玩儿法开车群:https://t.me/setappondriveJS神技能:https://t.me/joinchat/IH5XJktzBKU7RptjDo9fXQ电丸科技AK:https://t.me/joinchat/J0l1qkdif6F3O8T6sVvXtwBIGdongdongGroup:https://t.me/bigdongdongGroupCODEKON 抗压能力研究所:https://t.me/WhiteBoard2019YouTube—ImShuker:https://t.me/shukerzNotion 中文社区:https://t.me/NotionsoNotion爱好者交流:https://t.me/NotionfansNotionPlus:https://t.me/joinchat/Grv3kRuQAtl7ZuY3JpUhsg电报人:https://t.me/three001Google Drive 无限容量:https://t.me/google_driveGoogle Drive 交流群:https://t.me/GoogleDriveStore搬瓦工 (BandwagonHost):https://t.me/BandwagonHostGroup跳蚤市场-科学上网交流等:http://t.me/PharosMarketShopping读舍 - 享受阅读时光:https://t.me/shufmiGame 游戏交流群:https://t.me/gamecn读书会:https://t.me/readingclub1984读书会众议院:https://t.me/readingclubhouse鲸发现:https://t.me/whalediscovery无限月读Group:https://t.me/la4jiNF^2 影视交流群:https://t.me/joinchat/M8iUbkx2I_gi-wGusMqDUA4K影视屋-蓝光无损 Chat:https://t.me/yingshiwuPayPal交流群:http://t.me/paypal_us游戏交流群:https://t.me/cngamekindle电子书读书会:https://t.me/zebook创造者们:https://t.me/joinchat/DNc0EECuTl_xs0O30bvCWQ数码养生:https://t.me/joinchat/KN3lR1QT8tGXImuc8L8k3g编程随想读者群:https://t.me/programthinkreader码力全开 Friends:http://t.me/forcecoderOpenWRT 编译官方大群:https://t.me/joinchat/JhKgAA6Hx1uiihA7RaTW1wOpenWRT LEDE/Wireless Routers:https://t.me/OpenWRT_Routerskoolshare OpenWRT X64:https://t.me/joinchat/ERO9vEMMVu1dzQ-F8nP6kA老毛子Padavan固件自助交流群:http://t.me/pdcn2老毛子Padavan固件IOS自助交流群:http://t.me/pdcn3安卓手机交流圈:https://t.me/androidseeGoogle Fi 交流群:https://t.me/google_fiYouTube Music:https://t.me/YTMusicCN字谈字畅听众群:https://t.me/TypeChatRuby 中文圈:https://t.me/rubycnpolyhedron:https://t.me/polyhedron聽世界:https://t.me/listentotheworldVap0rVVave:https://t.me/Vap0rVVaveNickTalk:https://t.me/nicktalkiTunes Gift Card:http://t.me/iTunesGiftiOS:https://t.me/iOSdevoteeiPad:https://t.me/aboutipadMacGG:https://t.me/macggmacOS 交流组:https://t.me/macosermacOS:https://t.me/getosxiOS 交流群:https://t.me/iOS_cniPadOS 交流群:https://t.me/iPadOSAPPLE 用户交流群:https://t.me/apple_cnmacOS 用户交流群:https://t.me/mac_cnIT之家 群组:https://t.me/iOS1314黑苹果与白苹果用户交流群:https://t.me/Balancer996233Blog:https://t.me/blog233悟空的日常粉丝:https://t.me/wkongsvlogsynology/黑群晖用户交流群:https://t.me/nasfanssgobal:https://t.me/joinchat/ESwgR0Ckp_zXMCuRKqykqAGroupHub_Chat:https://t.me/GroupHub_Chat中国数字时代读者群:https://t.me/cdtchinese掘金 iOS 开发交流群:https://t.me/joinchat/BAjjKkLl8h5wfynrpFvOwQ掘金 Android 开发交流群:https://t.me/joinchat/BAjjKkMXyR2_SrASapNZ0AGoogle Voice 交流群:https://t.me/googlevoiceGoogle Voice 互拨交流群:https://t.me/zh_GVGoogle Play Party:https://t.me/joinchat/AAAAAEQyqqFfIeHCsuQe5wGoogle Fans Club 中文:https://t.me/googlecnIngress Prime 讨论群:https://t.me/joinchat/BJY4f03cl_8YHMdUrVDxuwRedSoloCup’s League of Ingress Agents:https://t.me/joinchat/DEqMlRFr-nH2lu73mP7_9QGTD Users Base:https://t.me/gtdusersbase小米手机讨论群:https://t.me/M_PhoneMIUI Beta Team - China:https://t.me/joinchat/DdB-ZxL__BxfXlQCGJUUmgM-Team official chat - Chinese:https://t.me/M_Team_ChatNexus Users:https://t.me/nexususersOne Plus:https://t.me/oneplus3ttGoogle交流群:https://t.me/GoogleFans生活 读书 新知:https://t.me/joinchat/BZKdbj1dAu5m8X48JV2gYg主机测评(zhujiceping.com):https://t.me/zhujicepingBTSynChina中文资源分享:https://t.me/btsynchinaSync资源分享讨论:https://t.me/joinchat/Drwnmz6wvT8wpIcFEBI57gNAS私有云技术交流:https://t.me/NASteam路由器固件玩家群:https://t.me/sbxswDev. iOS/macOS/watchOS/tvOS:https://t.me/AppleDevCNJava 编程语言:https://t.me/JavaerJava Programming Chat:http://t.me/javaprogrammingchatIT人的生活日常:https://t.me/it_normal_lifeAndroid Develop 中文讨论群:https://t.me/AndroidDevCnAndroid Delicious:https://t.me/AndroidDiscussAndroid Dress:https://t.me/AndroidDressAndroid Dev:https://t.me/AndroidDevChatAndroid Dev[CN]:https://t.me/AndroidDevCn网易云音乐:https://t.me/NetEaseMusicGeeks Chat:https://t.me/geeksChatNintendo Switch 闲聊群:https://t.me/NintendoSwitchCN红红火火恍恍惚惚:https://t.me/joinchat/DfC7Q0HhtNTA5R53WfAZyQ香港 IT 群:https://t.me/din_lo_it酷友交流群:https://t.me/coolapkchinaZeroNet[zh]:https://t.me/joinchat/AAAAAAtSeltSs7ffxR0wzwBeijing GNU/Linux User Group:https://t.me/beijinglugMAT - 广场（My Android Tools）:https://t.me/MyAndroidTools美剧交流群:https://t.me/SSKMJBTSTg攝影社群:https://t.me/photographyintelegram知日讀者群:https://t.me/zhijapanfibjs 交流:https://t.me/fibjs加密货币与区块链讨论群:https://t.me/onBlockchain第欧根尼俱乐部 The Diogenes Club:https://t.me/TheDiogenesClubNetflix迷:https://t.me/NetflixFunNetflix 讨论群:https://t.me/netflixchinaNetflix 讨论:https://t.me/joinchat/C94vkUP2WbygEhA59U4mZANetflix-剧天堂:https://t.me/NetflixGodNetflix等App解锁:https://t.me/happy_dns解锁大会员的世界:https://t.me/bili_bi莓友会:https://t.me/bbfans群晖壕技术交流:https://t.me/joinchat/BzNX6A2jzj1nMBlltYKbEg社工库机器人CCTV认证群:https://t.me/shegroupgate.io的小伙伴们:https://t.me/gate_ioSteam:https://t.me/SteamCNthe speechless $$ apexidea:https://t.me/thespeechlessDEW官方中文群:https://t.me/dew_cnDEW Offical EnglishGroup:https://t.me/dew_enDEW 日本語グループ:https://t.me/dew_jpDEW 공식 한국어 그룹:https://t.me/dew_krPython数据社群,数据分析大数据相关知识交流:https://t.me/datapyTechCrunch中文版讨论组:https://t.me/techcrunchcngroup锤子科技 Smartisan 讨论组:https://t.me/smartisan_unofficial内涵段子:https://t.me/duanzigeTeFuir 自渡:https://t.me/TeFuirZIDuDribbble 设计交流:https://t.me/dribbbletalkAndroid Plaza:https://t.me/AndroidPlaza[ZH/EN] 摄影:https://t.me/cnphotog加速吧小宝（koolshare merlin firmware）:https://t.me/xbchat软路由综合交流群:https://t.me/Balancer66软路由交流群:https://t.me/ruanlueSir PlayGround:https://t.me/joinchat/JjxmyRZZXJWb74I-sCrryAeSir Playground固件&amp;插件交流群:https://t.me/joinchat/JjxmyUrN3utQKXt_5LD54g机场联萌-Linux&amp;vps@SSpanel:http://t.me/supermarket666阿里云交流群:https://t.me/Balancer985微软云(Azure)交流群:https://t.me/Balancer211谷歌云(Gcp)交流群:https://t.me/Balancer166博客搭建交流群:https://t.me/Balancer863Tasker中文交流群组:https://t.me/taskercn简信用户群:https://t.me/mailtimeRime&amp;iRime交流群:https://t.me/joinchat/F2HuOQpBU2NjUrg8ybQMDgVim 用户交流群:http://t.me/vimhubiOS 越狱讨论群:https://t.me/iOS_JailbreakiOS 越狱交流群:https://t.me/iOS_jailbreakingJailbreak Chat:https://t.me/joinchat/AAAAAD161xTKVMuu-bOaxgTelegram Hath Group:https://t.me/telehathgroupVps交流:https://t.me/talkvps自由世界之声:https://t.me/TetgramC今日我地唔倾健身倾人生:https://t.me/telegrcProduct Hunt 分享讨论:https://t.me/joinchat/CreGnBZN4DGqRb4HiBkm9gwikipedia-zh:https://t.me/wikipedia_zh_nOld-wikipedia-zh:https://t.me/wikipedia_zhwikipedia-zh-help:https://t.me/wikipedia_zh_helpwikipedia-zh-game:https://t.me/wikipedia_zh_gamewikipedia-zh-science&amp;technology:https://t.me/wikipedia_zh_science_and_techwikipedia-zh-computer-science:https://t.me/wikipedia_zh_cswikipedia-zh-humanities&amp;SoSci:https://t.me/wikipedia_zh_humanitieswikipedia-zh-jurisprudence:https://t.me/wikipedia_zh_jurisprudencewikipedia-zh-entertainment&amp;art:https://t.me/wikipedia_zh_entmt_and_artwikipedia-zh-acg:https://t.me/wikipedia_zh_acg_nwikipedia-zh-physics:https://t.me/wikipedia_zh_physicswikipedia-zh-BioMed:https://t.me/Wikipedia_zh_bio_and_medwikipedia-zh-language:https://t.me/wikipedia_zh_langwikipedia-zh-translation:https://t.me/wikipedia_zh_translationwikipedia-zh-food&amp;drink:https://t.me/wikipedia_zh_food_and_drinkwikipedia-zh-sports:https://t.me/wikipedia_zh_sportswikipedia-zh-library&amp;museum:https://t.me/wikipedia_zh_libwikipedia-zh-Geo&amp;Transpt:https://t.me/wikipedia_zh_geo_and_transptwikipedia-zh-LGBT+:https://t.me/wikipedia_zh_LGBTwikipedia-zh-appeal&amp;meta:https://t.me/wikipedia_zh_appeal_n_metawikipedia-zh-DC:https://t.me/wikipedia_zh_DCwikipedia-zh-ingress:https://t.me/wikipedia_zh_ingress台大維基社:https://t.me/ntuwpc高雄維基人 Kaohsiung Wikimedia community:https://t.me/wikikaohsiung維基學生會:https://t.me/wikipedia_zh_wsu邊緣人小組｜边缘人小组 Marginalized Persons’ Club:https://t.me/marginalizedpersonsclub《維基人》讀者交流群:https://t.me/the_Wikipedian_groupwikipedia-zh patrol:https://t.me/wikipedia_zh_patrolWikipedia-zh-DYK:https://t.me/wikipedia_zh_dykzh wiki bulletin:https://t.me/zhwiki_bulletin中文维基《求闻》- Qiuwen Chinese Wikipedia:https://t.me/Qiuwenwikimedia-commons-zh:https://t.me/wikimedia_commons_zhwikibooks-zh:https://t.me/wikibooks_zhwikisource-zh:https://t.me/wikisource_zhwikiversity-zh:https://t.me/wikiversity_zhwikinews-zh:https://t.me/wikinews_zh_nwikivoyage-zh:https://t.me/wikivoyage_zhwikipedia-lzh:https://t.me/wikipedia_lzhlzh wiki bulletin:https://t.me/lzhwiki_bulletinWamLzh:https://t.me/wamlzhcvn-zho:https://t.me/cvn_zhocvn-zh-sw:https://t.me/cvn_zh_swwikipedia-mnc:https://t.me/wikipedia_mncwikipedia-yue:https://t.me/wikipedia_yuewikipedia-cdo:https://t.me/wikipedia_cdocdo wiki bulletin:https://t.me/cdowiki_bulletinRetroShare:https://t.me/cnretroshareMoeUnion:https://t.me/MoeUnionVediotalk:https://t.me/VedioTalkGroup利器 👨🏻‍💻👩‍💻 🧤:https://t.me/fun_makersDeveloper 中文圈:https://t.me/coderzh酷安闲聊群:https://t.me/coolapkxianliao酷安:https://t.me/cool_apkLicenses Group 合租 美剧讨论 薅羊毛:https://t.me/Licensess[合租] Netflix Spotify office365 YouTube Hulu Surge等音乐影视:https://t.me/hezu1合租小车🚗:https://t.me/TogetherHub拼车小组:https://t.me/PinCheGroupBen先生的闲聊群:https://t.me/Ben_zahuopunetflix spotify hulu账号交流:https://t.me/zxc1017yyfxNETFLIX极乐世界:https://t.me/duxiangNFNetflix/Spo/Hulu/HBO低价体验车:https://t.me/FreetrialStoreBen先生的杂货铺:https://t.me/joinchat/K1vTsBMebnPn7mLwR6KGmAEhViewer・DEPRECATED・交流群:https://t.me/ehviewer谈股论金:https://t.me/CNFinance三家村:https://t.me/platoer谷歌、微软云盘讨论群:https://t.me/google_win黑洞资源交流群:https://t.me/debated好棒 羊毛福利站 自助查:https://t.me/dajiajia优质 淘宝 京东 隐藏优惠券 福利推荐:https://t.me/taobaojuan频道🏆资源福利分享 Chat:https://t.me/freemorebestchatVIA Official Group:https://t.me/viatgMagisk中文讨论群组:https://t.me/magiskCNshareLetITFly’s Group:https://t.me/joinchat/DnJ2K0An6XhI3N-5EK2FtASpotify Addict Group:https://t.me/spotifyaddictSpotify使用者:https://t.me/joinchat/DlW6BkAiT7ReIIADtANzYwApple Music:https://t.me/amthings远鉴字幕组官方交流群:https://t.me/joinchat/KmUaGRU5OgWsuv27BABIDg奈菲影视求片专用群:https://t.me/joinchat/KmUaGRMWdO29JVd3wcCHCg峰哥分享技术交流超级群:https://t.me/fengsharegroupTG技术党:https://t.me/MRHXPJ真是药丸:https://t.me/joinchat/L5ipUhYff4tk98bOrdqutQTelegram中文:https://t.me/Chat_CN网络中文圈:https://t.me/CN_InternetBitcron 中文圈:https://t.me/bitcron小点播放器+m3u8直播源交流群:https://t.me/conchplayerSaoDaye - TG总群:https://t.me/saodayeSaoDaye - TG飙车:https://t.me/yiqisaoPi&amp;N1玩家交流群,专业:https://t.me/PIN1GroupeBooksPlan小声读书:https://t.me/what_youread读书分享:https://t.me/dushufenxiang_chatzread 读书会:https://t.me/zreadi-Book.in 讨论组:https://t.me/i_book_inChinese Developers:https://t.me/ChineseDevelopersBAT 大家庭:https://t.me/china_net_group三人行中文群(工作生活学习交流平台):https://t.me/three001996.ICU:https://t.me/anti996流浪防区 /r/China_irl 官方群:https://t.me/China_irl流浪防区 666游戏厅:https://t.me/China_irl_GamesMi Video feedback group:https://t.me/MiVideoFeedbackTelegramd中文技术交流群:https://t.me/cntelegramd主机贴士:https://t.me/BWH1NET二进制/sudo:https://t.me/huochesijiGoogle Voice讨论组:https://t.me/swatpc1Ssrconnect:https://t.me/ssrconnect专业Linux/运维/虚拟化讨论:https://t.me/professionallinux酸奶ssr2.0:https://t.me/ssruSSR浪漫生活群:https://t.me/llmsh软件源TG:https://t.me/appcgntg趣·享:https://t.me/peekfun免费DDOS群:https://t.me/joinchat/Ma3VglCDtwnOGNPbKAl5MwTYPCN Group:https://t.me/joinchat/BoV2zj_WY5j8BxC98_6MCQ今天的砼与钢(建筑群):https://t.me/jintiandetongyugang苹果旧版交流:https://t.me/xinapp特斯拉 Tesla 交流群:https://t.me/teslafast网络技术交流–AE:https://t.me/joinchat/KvkGoxAJywGVPq7LVUAXugAmazon 海淘购物交流群:https://t.me/firstAmazonApple Boy:https://t.me/joinchat/BJpk_BFL2deF7841fGKEbQGoogle Suite 交流群:http://t.me/googlesuitelibra 区块链大中华交流:https://t.me/joinchat/Lfx59xaZjZfOm8BEJXgSGQ夸吧·夸夸群:https://t.me/kuaba谷歌云端GCP交流群:http://t.me/Google_CloudPlatformCloudflare在中国:https://t.me/CN_Cloudflare月光博客IT技术交流群:https://t.me/yueguangqunPixel 3 小窝:https://t.me/Pixel3House戒赌吧2.0:https://t.me/joinchat/FHxB4lkIZ3IjoCt3_Yh3awTbo 粉丝群:https://t.me/TboJiangGroupGDrive , INFUSE , SYNOLOGY , PLEX:https://t.me/infusetvOur Bittorrents Club:https://t.me/joinchat/IST_uFF7P-u5oecKl3uvFg戒赌吧2.0:https://t.me/joinchat/L6o3d1kIZ3JCcg2ki2SGsg群组检索导航:https://t.me/Groups_cn日本語学習Japanese Study:https://t.me/joinchat/BGDV_Qcq7MTcpiFkB2n7FwZUOLUOTV 专属交流群:https://t.me/zuoluotv不知名科技吐槽:https://t.me/ApexIdeaTechKevin自留地:https://t.me/mrkevinh主机百科:https://t.me/zhujiwikiAffyun.com:https://t.me/pingcat91yun.co 大海航行靠舵手:https://t.me/im91yunLeonn:https://t.me/zhenggui古博-VPS仓交流群/VPS推荐实测:https://t.me/guboorg如有乐享:https://t.me/joinchat/EqJkBQ4FsPUuWoN8HsOjNgTechnical Blog 技術博客:https://t.me/Technical_BlogGigsGigsCloud.com 意见交流:http://t.me/gigsgigscloudgroupTenVM/ToSpeed 交流群:https://t.me/tenvmgroup微基主机讨论组 - 原50KVM/50VZ:https://t.me/network50_chatNathosts主机交流群:https://t.me/nathostsHKServerSolution 交流&amp;建议:https://t.me/hkserversolution爱听歌交流群:https://t.me/musictools666利器社群在 TG 上的分支:http://t.me/fun_makers圆角水群:https://t.me/UoVzCloud中文独立博客:https://t.me/indieBlogsTelegram蛤丝总群:https://t.me/joinchat/EgReJ0BeLkTPKtZLJ1HipA黑苹果osx86项目中文讨论/Hackintosh CHN Discussion:https://t.me/osx86zhChromebook CN:https://t.me/chromebook_cnC 语言中文交流:https://t.me/ClanguagezhC++ 中文交流:https://t.me/cpluspluszhCSS 討論區:https://t.me/csstwHaskell 中文交流:https://t.me/haskellzhJavaScript 中文交流:https://t.me/javascriptzhJulia 编程语言交流:https://t.me/julialangzhPerl 中文交流:https://t.me/perlzhPython:https://t.me/PythonPython中文社区:https://t.me/PyChinaPython 中文交流:https://t.me/pythonzhGo:https://t.me/GolangCNR 语言中文交流:https://t.me/rprojectzhScala 中文群组:https://t.me/scala_zhTypeScript 中文交流:https://t.me/typescriptzhKali / BlackArch Linux 中文交流:https://t.me/hackerzhCentOS 中文:https://t.me/centoszhUbuntu 中文:https://t.me/ubuntuzhSublimeText用户组:https://t.me/sublimecnJava/Android开发交流:https://t.me/java_android_dev大数据杂谈:https://t.me/bigdatazhFrontend 前端中文技术交流:https://t.me/frontend_talkiOS Dev CN:https://t.me/iOS_Dev_CNStone Server 中文交流:https://t.me/stone_serverHexo 博客交流:https://t.me/hexozhHugo 博客交流:https://t.me/hugoblogDat 中文交流:https://t.me/datzhZeroNet 中文交流:https://t.me/zeronetzhGoogle Play 交流:https://t.me/googleplay_cn体育爱好者/足球/篮球/NBA/CBA 交流:https://t.me/tiyu365Wallpapers 壁纸:https://t.me/G_WallpapersSM.MS 图床粉丝群:https://t.me/smms_images博物館愛好者 Museum lovers:https://t.me/PakMyotKuanhios黑科技交流群:https://t.me/ioshkj007HN 中文社区:https://t.me/hn_china树莓派:https://t.me/shumeipai中英語言学习:https://t.me/LinguisticAcademyTechCrunch中文讨论组:https://t.me/tcchineseLotteryHelperBot 抽奖群:https://t.me/Lottery_Group🀄️ Fedora 中文用户组:https://t.me/fedorazhiOS软件学习交流:https://t.me/ChujiuGGG家庭网络资源共享群:https://t.me/homenet6UoL BSc讨论组:https://t.me/uolbsc「韵味科技」TG技术交流群:https://t.me/ywadminPS4:https://t.me/ps4cn2Nintendo Switch 娱乐 - 动森:https://t.me/nintendoswitch_cn财经幽灵电报群:https://t.me/financial_ghostGroupTg云音乐:https://t.me/Tgsongs中文音樂討論群組:https://t.me/joinchat/AyylyVG1Gf-53dJgnjjq9A智能家居交流群:https://t.me/homeassiant666Handshake中文社区:https://t.me/handshake_cn第二现场:https://t.me/dearlive科技聚会:https://t.me/pixelcnSurge for Android:https://t.me/SurgeforAndroid翼起乐:https://t.me/YiQiLePanoanDrive(离线下载自动转存Google Drive):https://t.me/PanoanDriveBasic数字移民讨论群:https://t.me/shuziyimin_groupAnytype community:https://t.me/anytypeGraphQL China:https://t.me/graphql_china今日热榜:https://t.me/joinchat/IL6n4w9xiRMvHaU1YpVFog品品品品葱葱葱葱:https://t.me/pcfanzei茶馆Teahouse:https://t.me/aTeaHouse柯基犬的日常 - 吹水群:https://t.me/UntitledGroup希饭 学习&amp;技术&amp;分享:https://t.me/idcmoe荔枝木上荔枝果，荔枝木下你和我:https://t.me/lycheewood_discuss西西书屋 精校电子书:https://t.me/xixishuwu读者中心:https://t.me/duzhe今天你动森了吗:https://t.me/AnimalCrossingXLife &amp; Knowledge.:https://t.me/LifeAndKnowledge[CN]Flutter Dev:https://t.me/FlutterCNinfuse交流群:https://t.me/infusepro6台灣蘋果同好交流群:https://t.me/TaiwanAppleFans日本旅遊同好交流群:https://t.me/JP_Travel高清影音数码折腾群:https://t.me/TalkUHDBot开发者交流群:https://t.me/bot_dev_groupVULTR用户交流群:https://t.me/VultrChatTGX-社群:https://t.me/tgx_groupXDA-General:https://t.me/joinchat/GobKO1HujyceuQ_ijPmmFwXDA-Chromebooks:https://t.me/joinchat/GobKO0oLNMy0AVuHsL4ApQXDA-Google:https://t.me/joinchat/GobKO059P187L04_lROAjAXDA-Samsung:https://t.me/joinchat/GobKO1MO9T7g7iY2y1-oLgXDA-OnePlus:https://t.me/joinchat/GobKO0WAM7JznxHXgKkCiwXDA-Huawei:https://t.me/joinchat/GobKO0yVKYAHOOON_KuXIwXDA-Realme:https://t.me/joinchat/GobKO1b8S_BrnHRZ3N_ScwXDA-Sony:https://t.me/joinchat/GobKO0fZhvNzc__RcJuGzQXDA-HTC:https://t.me/joinchat/GobKO0BtfvCQLqQ6SAqregXDA-LG:https://t.me/joinchat/GobKO1HUnWgyZcjQ8iIkRAXDA-Motorola:https://t.me/joinchat/GobKO0fPbFnKzIzUq8QD2AXDA-Nokia:https://t.me/joinchat/GobKO08UpiE7HUWxr_yc2AXDA Labs:https://t.me/xda_feed微信读书分享交流:https://t.me/iWeRead码力全开 Friends:https://t.me/forcecoder互联网1号聊天室:https://t.me/chatroom11111FlyOS Official Group:https://t.me/flyosproRed C Linux DEV.&amp;COM.:https://t.me/redclinux多平台技术交流:https://t.me/alldesktop奈飞Pro - Netflix奈飞合租/拼车:https://t.me/naifei_pro中文翻译机器人反馈群:https://t.me/fanyi_group各种云☁️交流群:http://t.me/Server699SaltyLeo的博客讨论组:https://t.me/SaltyLeo_blog数字尾巴粉丝群:https://t.me/joinchat/GnoDABh4Ob-e5zKOOMe4bgCodingStartup 起碼課:https://t.me/codingstartupOpenWrt Discuss CTCGFW’s Group:https://t.me/ctcgfw_openwrt_discuss PLEX/EMBY交流群:https://t.me/bigdongdongmedia Alook 视频解析 收集 分享:https://t.me/jsdayanki交流群:https://t.me/anki_appPayPal交流群:https://t.me/paypal_us播客Checked.FM 听众群:https://t.me/joinchat/Ag98Fw0TEeBh2Xz8s0d9mg一天世界:https://t.me/ipn_yitianshijie○△□（不鳥萬通讯）:https://t.me/igiveafuck灭茶苦茶 听众群:https://t.me/ipn_miechakucha选・美 听众群:https://t.me/joinchat/At5ANzwvTWoETwagE5S09w《内核恐慌》听众群:https://t.me/pan_icu博物志 听众群:https://t.me/museelogue太医来了 听众群:https://t.me/taiyilaile味之道 听众群:https://t.me/joinchat/At5ANzuy5JM9yhPrmuGrcQ流行通信 听众群:https://t.me/joinchat/At5ANzuiD519i5bvwvZprA硬影像 听众群:https://t.me/joinchat/BpH28D58cUGp1jXFHWvpww無次元 听众群:https://t.me/joinchat/A4fzlAC1AatZACa_NSKqwg(Hi)story 听众群:https://t.me/HistoryCheap壁下观 听众群:https://t.me/ipn_bixiaguan疯投圈 听众群:https://t.me/crazycapital时尚怪物 听众群:https://t.me/ipn_fashionmonster科技聚变 TechFusion 听众群:https://t.me/TechFusionChat播客大家谈:https://t.me/bokecn「得意忘形」听众群:https://t.me/joinchat/Bx8JqQ33oVCrKSul-cHJGQ津津乐道听友交流:https://t.me/htnpodcastTelegramDurov’s Chat:https://t.me/durovschat官方翻译支持群 English:https://t.me/translation_en官方翻译支持群 简体中文 (聪聪):https://t.me/translation_zhcncc官方翻译支持群 简体中文:https://t.me/translation_zh_hans官方翻译支持群 简体中文(@zh_CN 版):https://t.me/translation_classic_zh_cn官方翻译支持群 简体中文(langCN):https://t.me/translation_zhlangcn官方翻译支持群 瓜体中文:https://t.me/translation_duang_zh_hans官方翻译支持群 繁体中文(香港):https://t.me/translation_zh_hant官方翻译支持群 繁体中文(台湾):https://t.me/translation_taiwan官方翻译支持群 喵体中文 （ @MiaoCN ）:https://t.me/translation_meowcn官方翻译支持群 郭桓桓的繁體中文語言包:https://t.me/translation_zhong_taiwan_traditional官方翻译支持群 文言:https://t.me/translation_chinese_ancientTG 简中交流（水）群:https://t.me/cnpubTelegram 討論區:https://t.me/PublicGroupForzhTelegram 新手帮助:https://t.me/newbie_chatTelegram X iOS:https://t.me/tgiostestsTelegram iOS Talk:https://t.me/TelegramiOStalkTelegram Android Talk:https://t.me/TelegramAndroidTalkTelegram X Android:https://t.me/tgandroidtestsTelegram macOS:https://t.me/macswiftTelegram macOS Talk:https://t.me/TelegramMacOsTalkTelegram Desktop Talk:https://t.me/TelegramDesktopTalkTelegram Windows Phone Talk:https://t.me/TelegramWPtalkTelegram Bot Talk:https://t.me/BotTalkTelegram Party:https://t.me/PublicTestGroupTelegram Android Themes:https://t.me/AndroidThemesGroupTelegram Desktop Themes:https://t.me/TelegramThemesTelegram X: Themes:http://t.me/tgx_perfectionTelegram Beta Chat:https://t.me/tgbetachatTentang Telegram:https://t.me/tentangtelegramInstant View Platform Chat:https://t.me/IVpublicTelegram 新手問答區:https://t.me/TGQNA電報群推廣:https://t.me/joinchat/FAir4j15AV8Q_x5zzoc8ywKeralaGram:https://t.me/keralagramTelegram 新手频道讨论组:https://t.me/newbie_tele_discussionCNBlacklistR 交流群:https://t.me/joinchat/FfbG_g9eWFL1-8vEhY4xlQ地区群成都:https://t.me/cheng_du深圳:https://t.me/shenzhenbot?start=join深圳:https://t.me/shenzhentg北京:https://t.me/beijingz上海:https://t.me/shanghai_tg广州:https://t.me/GuangzhouIT四川:https://t.me/civhuanglaoxiao川渝:https://t.me/chongqing_sichuang西安:https://t.me/XianCity南宁:https://t.me/NanNingTG滕州:https://t.me/tengzhou徐州:https://t.me/tgdxz烟台:https://t.me/yantaiinfo湖南:https://t.me/hunantg济南:https://t.me/jinan_tg郑州:https://t.me/zhengzhoutg武汉:https://t.me/joinchat/AAAAAEPsBibY4oIaHgjIwg西安:https://t.me/joinchat/FY1SJkRF6ubEQzU-3Mq3cw温州:https://t.me/joinchat/AAAAAApGjPVlDbXwYSj1IA宁波:https://t.me/joinchat/IDzvnxAU9yCEh6vx4RQrPg新冠肺炎 #nCoV 主群（疫区疫情新闻/互助）:https://t.me/joinchat/OElQrFZiBp5If1A90UCnsg #nCoV 武汉封城自由讨论区:https://t.me/joinchat/OElQrFKWIz_B1qtkNwE7qA #nCoV English discussion:https://t.me/WuhanCorona #nCoV 粤语/HK/繁體疫區疫情:https://t.me/joinchat/OElQrBQ_WvPb4juxJAJkgw #nCoV 美国疫情讨论区:https://t.me/US2019nCOV武汉肺炎新型病毒交流群:https://t.me/zhaook武汉肺炎疫情交流:https://t.me/wuhangroup武汉肺炎疫情交流讨论:https://t.me/SARSnew新冠肺炎(COVID-19)讨论群:https://t.me/CoronavirusDiscuss美国华人抗冠状病毒群:https://t.me/FightSARI其他Coder Offtopic 中文群:https://t.me/coder_otBoastTG:https://t.me/BoastTGSteam&amp;PlayStation&amp;Xbox&amp;Switch:https://t.me/ps4cn2數字權利 Digital rights:https://t.me/digital_rights绿岛之谜:https://t.me/joinchat/AAAAAELn2imDDoj2w9ueMQKoolProxy:https://t.me/joinchat/AAAAAD-tO7GPvfOU131_vg图话天下:https://t.me/joinchat/Ap7Q_zvEXX48wixHbtg79A要開/做/做開IT Projects嘅人:https://t.me/IT_projects_people烧饼博客粉丝群:https://t.me/sbfans圍觀設計師現場:https://t.me/lookingforqoliPureWriter’s Friends:https://t.me/joinchat/BSLnXkP8kEMg66CBcsUNGQCryptocurrency:https://t.me/joinchat/AAAAAENKOpO9tmbe5etMnARabi Coffee:https://t.me/rabicoffeeOfficial Counterparty Chat:https://t.me/Counterparty_XCPCasual ENGLISH Chat:https://t.me/joinchat/AAAAAEBz8Owuzgri6kB2UA一起玩「狼人」:https://t.me/cnwolf愚民小鎮:https://t.me/twWolfGPlusCard 交流群（非官方）:https://t.me/GPluscardIT之家:https://t.me/joinchat/0575a16a008fa17ec5457b81a4f15abeGentoo-zh:https://t.me/joinchat/0557494901586680e50d77eebd2986d2PDA 的Discovery版块:https://t.me/discoverys元朗區Pokemon:https://t.me/joinchat/DGASnj7QdwuW1LIo-5-80g今天你健身了吗:https://t.me/joinchat/AAAAAA6h4cV3PLgFQYrnCA骇客邦:https://t.me/hihackersS&amp;D两位先生:https://t.me/Science_Democracy欧美生活影视音乐圈Europe America:https://t.me/AJSCIEAARDR2 Group:https://t.me/HKRDR2抽奖机器人交流、反馈:https://t.me/BotFeedback共享资源站点翻车群:https://t.me/gxzyzdSdorica 萬象物語:https://t.me/sdoricaSit and Date:https://t.me/SitandRelaxGroup红米Note3交流群:https://t.me/Kenzo_CNCuniqUK电话卡交流群:https://t.me/CuniqUKMTP代理自助分享群:https://t.me/mtppubgMTP代理服务聊天吹水防走失群:https://t.me/joinchat/Li3nUVe9NvfwCsxZIhUtkQtg夸夸群:http://t.me/tgkkq黑产市场资源项目:https://t.me/heise888ACGN☆Taiwan:http://t.me/TaiwanAnime真是药丸:https://t.me/AllshadiaoUpperDoc Group:https://t.me/UpperDocGroup倒水,然后吹:https://t.me/joinchat/K5hKwle9NvfbSLOViD7M7giBreaking:https://t.me/iBreaking内涵段子之狼人杀:https://t.me/werewolfcn内涵段子 · 咕咕娱乐:https://t.me/DuanziGame内涵段子之闲聊群:https://t.me/OverseasChinese上帝是女孩:https://t.me/GodaregirlsTelegram 狼人杀群:https://t.me/langrensha888For Work 系列-裙子群:https://t.me/DressFWFor Work 系列-日麻群:https://t.me/MahjongFWFor Work 系列-反馈投稿摸鱼群:https://t.me/FishingFW闲聊NBA:http://t.me/bbNBATSU守望者调度交流群:https://t.me/yy688go_2019RSS屋:https://t.me/joinchat/HiIOAxV7g9JwNuLuThUsyQ@igapps 绿色应用:https://t.me/igappsTg音乐站:https://t.me/konghouTg云音乐:https://t.me/TgGeQu电报唱吧:https://t.me/changba_tg你自己的歌单群:https://t.me/laitingge柚酱的小屋:https://t.me/joinchat/I4oUNxLdCH4yj1cI7cvx-wTHKPGM’s 聊天群:https://t.me/thkpgmchatSPhard交流群:https://t.me/sphardLoreFree知识共享社区(CN/EN):https://t.me/lorefreecomios黑科技交流群:http://t.me/iosX007Netflix卡片小站:https://t.me/Leye166回形针PaperClip粉丝群:https://t.me/paperclipfans瘟疫难民254营:https://t.me/ckhunter254iShare 爱分享:https://t.me/iShareTG✈️ limboPro 🅥 TG 后花园里:https://t.me/limboprogroup璃颜&amp;红尘，伊人笑:https://t.me/liyanhongchen影视APP交流群:https://t.me/ysjlq搞笑视频:https://t.me/joinchat/AAAAAFe-j4P9-B1VgdAmJwHanan’s Group:https://t.me/hanhans2创造者日报:https://t.me/creatorsdailyTG云音乐:https://t.me/TgsongssTg唱吧总站:https://t.me/changba_tg尖叫指令:https://t.me/joinchat/LzJ_QBZg1QRICpNlKwZi4g4K影视屋-蓝光无损 Chat:https://t.me/yinshiwuZapro · 杂铺 HAPPY:https://t.me/tmioeTG科技无意义听众讨论组:https://t.me/technical_with_love8不求甚解:https://t.me/fakeye_clinic路亚🎣+养🌿🐚🦠🐟:https://t.me/fishlureOutage! Staging:https://t.me/OutageChatFaangbbs 北美程序员大群:https://t.me/faangbbs移民路上:https://t.me/OutOfTheSiegeEmperorTian吹水群:https://t.me/iOSAppJLQCount To 1 Million:https://t.me/CountToOneMillionNo U:https://t.me/NoUGroup\\o/:https://t.me/HuzzahGroup(ツ):https://t.me/ShrugGroupbboysoul:https://t.me/bboysoulcnAPPDO 数字生活指南:https://t.me/appdododo中国ChineseMasks口罩进出口:https://t.me/chinamasksFriendChCodeList:https://t.me/FriendChCodeList科学上网保护者:https://t.me/mango_channel动物森友会—无人岛串门计划:https://t.me/AnimalCrossing_CNJoyMusic:https://t.me/NetYunCunMusicAnime GIFs Collections:https://t.me/animationfans美股交流分享:https://t.me/USBullStock中国知识分子&amp;海外华人华侨&amp;聊天吹水:https://t.me/OpenNewWorld局 勢 分 析:https://t.me/joinchat/JLoGIlWLw06_eA6eHNp1Jgoooooohmygosh &amp; friends:https://t.me/omgfriends阿里云国际Alibaba Cloud:https://t.me/AlibabaCloudHKTingTalk - Group:https://t.me/tingtalkgroup一辆佛系合租车:https://t.me/HZQAM4Apps推广/抽奖/活动:https://t.me/AppsSweepstakes全球主机服务器交流中心群:https://t.me/chgggggg有价值与无价值-读者交流群:https://t.me/jiazhigroupNo.1 Manila_服务器优秀的服务器服务器托管租用_:https://t.me/PHmanila影音宝:https://t.me/joinchat/SLnVYRyWVJgxhPFaPcxOsAEXFLUX Networks - Chat:https://t.me/EXFLUX_GROUP麻瓜实验室:https://t.me/MugglesMagicHouseMuzik回聲古典:https://t.me/sonicwonderlandSZ 跨境卖家交流群:https://t.me/joinchat/R19cgUtMpN8dlwAYUalO8A智识社区:https://t.me/zhishiacLeetcode刷题:https://t.me/leetcode_discussLeetCode + Interview Prep 2021:https://t.me/leetcode_discussionLeetCode Uz Discuss:https://t.me/leetcodeuz_discuss验证码平台:https://t.me/wuyewanfuWildRift-英雄联盟手游:https://t.me/cnWildRift沙雕根据地:https://t.me/shadiaoo互喷群爱国粉红民主斗士互喷群:https://t.me/Stateanddemocracy大陆与港台澳互喷群:https://t.me/DLGTA大陆香港互喷群:https://t.me/cn0101装逼群(成功人士交流大本营):https://t.me/zhuangbicn地域黑互喷群:https://t.me/cityblackcn男生女生互喷群:https://t.me/boygirlVS锤粉锤黑互喷群:https://t.me/SmartisanClubssr与v2ray互喷群:https://t.me/joinchat/F_8vnkfFaoivwpZdGPt0ww前端后端程序员互喷群:https://t.me/joinchat/F_8vnkziKlPTn2PVzL2Vbg苹果华为小米oppovivo三星一加互喷群:https://t.me/joinchat/F_8vnlBNAdh4EwXc4H-ufg简体字正體字互喷群:https://t.me/joinchat/F_8vnkzmGs23y1IOyiWKXA淘宝京东互喷群:https://t.me/joinchat/F_8vnk6ABOTwIT9aWTKgTQ梅西C罗互喷群:https://t.me/joinchat/F_8vnkzMMVLfK0LQV2O1agTG微信互喷群:https://t.me/joinchat/F_8vnkc6mvUHAozhrPIQPQ肯德基麦当劳互喷群:https://t.me/joinchat/F_8vnkzTklgCJwjP1OM15Q网易云音乐QQ音乐互喷群:https://t.me/joinchat/F_8vnlFVJpjm0SkkW7-W7w主播互喷群:https://t.me/joinchat/F_8vnkrADCFwPB3j9o2C5A快手主播互喷群:https://t.me/joinchat/F_8vnk32rLM7pHbydfmndQ甜粽子咸粽子互喷群:https://t.me/joinchat/F_8vnkeiez7WnnJmocLS7w甜豆腐脑咸豆腐脑互喷群:https://t.me/joinchat/F_8vnkY4nSALn2MNZyN98g普通话与方言互喷群:https://t.me/joinchat/F_8vnkxxFhaoapKVxSHKLQOld school and trap互喷群:https://t.me/joinchat/F_8vnk1GIc8bmuMUAOWjRQ国产合资车互喷群:https://t.me/joinchat/F_8vnkoSC-PzKLkLOtEU6g无神论者与有神论者互喷群:https://t.me/joinchat/F_8vnkhMagnwTcVjHy-GGQ崔永元冯小刚互喷群:https://t.me/joinchat/F_8vnk47qc56WbNaRI92uw抖音快手互喷群:https://t.me/joinchat/F_8vnkeNYulaLdv6lvEajAAdidas Nike互喷群:https://t.me/joinchat/F_8vnkn5hgP6l1KGSE8ngg汤达人康师傅互喷群:https://t.me/joinchat/F_8vnkZOHonzN1n6URfBow农夫山朱怡宝互喷群:https://t.me/joinchat/F_8vnkxe96gSJUL-eybUKg可口可乐百事互喷群:https://t.me/joinchat/F_8vnkXyJIchDu6lqAvViw长发短发互喷群:https://t.me/joinchat/F_8vnkSi7hRX4ZYWIR7m1w摩拜ofo互喷群:https://t.me/joinchat/F_8vnkv6DO-NW8PAB6_yLg饿了么美团互喷群:https://t.me/joinchat/F_8vnkuyQEOJy6oRL2A82w全国喷北京群:https://t.me/joinchat/F_8vnlMFVp1iIId4M66uSg低端人口群:https://t.me/joinchat/F_8vnlE3eWQmDx2CUX31LQ打击流氓软件及APP群:https://t.me/joinchat/F_8vnlIqQCbjdhhMhwIu6w东西方文明互喷群:https://t.me/joinchat/F_8vnkS5h2ZktRJNO1d8_Q老板员工互喷群:https://t.me/joinchat/F_8vnlMpNxpMSOyAeznmaQ文科生理科生互喷群:https://t.me/joinchat/F_8vnlIVh0S1UHhRw2Hx6w中餐西餐互喷群:https://t.me/joinchat/F_8vnkweHskaXX2b4bcASw中医西医互喷群:https://t.me/joinchat/F_8vnkN1o4g8_cJV84fNiw12星座互喷群:https://t.me/joinchat/F_8vnk2RDL3LCVKlfXCH8A电信移动联通互喷群:https://t.me/joinchat/F_8vnkZcnV8IYQe1MvH7pw频道 ChannelTelegramDurov’s Channel（Telegram 创始人兼CEO 的频道）:https://t.me/durovTelegram 官方诈骗举报:https://t.me/notoscamTelegram-zh_CN Project:https://t.me/zh_CNTelegram 简体中文:https://t.me/Tele_zh_CNTelegram 繁体中文:https://t.me/Tele_zh_TWTelegram News:https://t.me/telegramTelegram Features:https://t.me/featuresTelegram Geeks:https://t.me/geekschannelTelegram Info:https://t.me/tginfoTelegram Apps:https://t.me/tgfilesTelegram APKs for Android:https://t.me/TAndroidAPKTelegram for macOS Updates:https://t.me/macos_stable_updates_filesTelegram Stable Releases:https://t.me/tgstableTelegram Beta:https://t.me/tgbetaTelegram X:https://t.me/tgx_androidTelegram Beta Blog:https://t.me/tgrambetaTelegram Designers:https://t.me/designersTelegram Contests:https://t.me/contestInstant View Contest News:https://t.me/IVcontestTelegram BotNews:https://t.me/BotNewsKatalog Telegram:https://t.me/katalogtelegramTelegram iOS Beta Slots:https://t.me/tgslotsTelegram Blog Secrets:https://t.me/tgblog_secretsTelegram 新手指南:https://t.me/newbie_guideTelegram 种植园:https://t.me/TelePlantingTelegram 新手入口:https://t.me/StartTGDesktop Themes Channel:https://t.me/themesTelegram Desktop Themes:https://t.me/desktopThemesTelegram Themes:https://t.me/themechannelTelegram Themes:https://t.me/themeschannelThemeTelegram X:https://t.me/ThemeTelegram_XAndroid Themes Channel:https://t.me/AndroidThemesTelegram Theme By Shana:https://t.me/ShanaThemesCancer Themes:https://t.me/cancerthemesVANILLA TELEGRAM THEMES:https://t.me/VanillaTGTelegram Stickers:https://t.me/TgStickerTelegram 新手频道:https://t.me/newbie_teleTelegram 文言翻譯之官方頻道:https://t.me/classical_chinese電報群組廣播:https://t.me/FOCUSTELEGRAMGROUPLINK電報新群推送:https://t.me/linkpushtg机器人推荐:https://t.me/tgbotlistTelegram Passport:https://t.me/TelegramPassportPlus Messenger official:https://t.me/plusmsgrKeralaGram [Official]®:https://t.me/KeralaGramChannelChallegram:https://t.me/ChallegramX Plus Channel:https://t.me/XPlus_ChannelNicegram:https://t.me/nicegramappNicegram Dev:https://t.me/nicegramdev捷报 News:https://t.me/JieBaoNews软件App 限免精选:https://t.me/appfansApp 资讯聚合:https://t.me/app_news_cniOS Releases:https://t.me/iOSUpdates限時免費 LimitFree:https://t.me/limitfreeApp限免&amp;TestFlight&amp;资讯聚合:https://t.me/AppcnAppinn Feed:https://t.me/appinnfeedThor 日常消息:https://t.me/thornoticeShu 使用技巧:https://t.me/shuskillAnubis 网络调试技巧:https://t.me/anubisskillGoogle Play Public:https://t.me/GooglePlayPublicSnipaste:https://t.me/snipasteSnipaste-Mac-Bugs:https://t.me/joinchat/BGyWwD-l6rbaO5NEsfYRQQiTele App:https://t.me/iteleofficialGitHub Trending:https://t.me/githubtrendingpython-telegram-bot:https://t.me/pythontelegrambotchannelMarkdownrobot Info:https://t.me/mrkdwnrbt简悦-SimpRead:https://t.me/simpreadMarginNote Channel:https://t.me/MarginNoteVivaldi Browser:https://t.me/vivaldibrowserZ-Turns:https://t.me/Z_TurnsStair Speedtest 更新频道:https://t.me/stairspeedtestThor 过滤器集散中心:https://t.me/f4thorPythonista 3 脚本通知频道:https://t.me/pythonista3jiaobenGoogle Play限免信息:https://t.me/playsalesUpperSoft软件发布: https://t.me/UpperSoft单向历:https://t.me/ows_calendarShortcutsCN 捷径社区:https://t.me/ShortcutsCNXposed框架:https://t.me/XposedCNMagisk-CN:https://t.me/magiskCN软件技术资源共享:https://t.me/SharedResourcesTelePlus - 免翻牆電報:https://t.me/TelePlus_ChannelNotion Twitter Bot:https://t.me/notion_twitter_botTestFlight:https://t.me/TestFlightXTestFlight:https://t.me/testflight_appsTestFlight.Center:https://t.me/TestFlightCenterPan Download官方频道:https://t.me/pandownloadNotion News:https://t.me/NotionNewsUnigram News:https://t.me/unigramUnigram Appx:https://t.me/unigramappxtg生态观察:https://t.me/tgsucksTGgeek TG极客:https://t.me/TGgeekTGgeek 新闻:https://t.me/TGgeekNewsTGgeek TG极客软件站:https://t.me/joinchat/AAAAAEeOCvpM8JSknojYeQ老司机必备工具箱:https://t.me/theguideoftelegram闲置软路由信息发布:https://t.me/supermarket66阿里云频道:https://t.me/supermarket985微软云频道:https://t.me/supermarket211谷歌云(GCP)供需对接市场:https://t.me/supermarket999利器部落 VIP 资源分享:https://t.me/Powerful_ToolsAppStoreCN:https://t.me/AppStore_CNwatchOS 应用推荐:http://t.me/watchOS_cntvOS 应用推荐:http://t.me/tvOS_cnAdGuard:https://t.me/adguardenAdGuard消息:https://t.me/AdGuardcnAdguard News:https://t.me/AdguardNewsOffice Tool Channel:https://t.me/otp_channelOpenWRT编译官方频道:https://t.me/opbypdopenwrt固件收藏:https://t.me/openwrtx86「Meeta」share:https://t.me/meetashareMac 应用推荐:https://t.me/mas_cnApp Store 应用推荐:http://t.me/AppStore_cnApp Store 游戏推荐:http://t.me/AppStore_GamesAescripts Channel:https://t.me/joinchat/AAAAAEysxC5w5mYhEI-1VAPi&amp;N1交流群新频道:https://t.me/NewPiN1ChannelApp 种草:https://t.me/appscaoElpass News:https://t.me/elpassnewsHi DerekCoder:https://t.me/Hi_DerekCoderx86_64软路由passwall固件:https://t.me/passwall笔记软件交流讨论 - 频道:https://t.me/joinchat/AAAAAFPA6feibNtwoeiZcwApp Store、Google Play礼品卡:https://t.me/iTunesGiftNewsZuragram:https://t.me/zuragramVVebo:https://t.me/vvebochannelGBox官方频道:https://t.me/GBoxTGCFastClip:https://t.me/fastclipgroupLifeAnalysis Lab 更新:https://t.me/lalabLifeAnalysis Lab Update:https://t.me/lalabengFastClip快讯:https://t.me/fastclipgroupRSSHub 布告栏:https://t.me/awesomeRSSHubDarker Sky ☔️ for Android:https://t.me/darkerskyandroid番羽土番毒药机场测速 SS/SSR:https://t.me/DuyaoSSV1 Blog 科技 生活 SpeedTest 主机评测:https://t.me/V1_BLOGV1 机场优惠通知:https://t.me/discount_shareBGP测速频道:https://t.me/BGP2020機場海外測速中心:https://t.me/BlacklotusChannel外星人测速频道:https://t.me/waixingrenspeedNet云评测:https://t.me/cloudtest机场测压实验室:https://t.me/cyssr品云☁️测速:https://t.me/Examine_Cloudss，ssr，v2ray机场测速:https://t.me/askahh秋水逸冰的个人频道:https://t.me/qiushuiyibingSurge 开发者的频道:https://t.me/yachmeSurge Official:https://t.me/surgeofficialSurge News:https://t.me/surgenewsSurge去广告:https://t.me/SurgeAdBlockDler Cloud News:https://t.me/dlercloud_newsShadowrocket News:https://t.me/ShadowrocketNewsQuantumult News:https://t.me/QuanXNewsQure for Quantumult X 图标:https://t.me/QureIconSetmini图标包 for Quantumult X:https://t.me/OrzminiQuantumult 的规则频道:https://t.me/useConfigQuantumultX &amp; Surge脚本收集:https://t.me/NobyDaQuantumult X JS 收集分享:https://t.me/QuanXJSQuantumult X 功能教学:https://t.me/HellCellZC123QuantumultX 教程&amp;API&amp;解析器 更新通知频道:https://t.me/QuanX_APINobyDa Script:https://t.me/joinchat/JtzRlVY-WyJPDavvhKjrbwChavy Scripts:https://t.me/chavyscriptsLiangYi🅥重写规则&amp;脚本:https://t.me/liangyiAnzw9314通知频道:https://t.me/nzw9314NewsW37°大飛频道:https://t.me/w37fhyNeteaseUnlock Channel:https://t.me/jiaowoyOKAB3脚本:https://t.me/OKAB3_Script_Channel神机规则:https://t.me/DivineEngine_ProfilesDivineEngine:https://t.me/DivineEngineCool Scripts:https://t.me/cool_scriptsTG规则脚本信息分享器:https://t.me/MRHXPJGGProject V 官方公告:https://t.me/v2msgExCloud News:https://t.me/ExCloudNewsNetch 版本发布频道:https://t.me/NetchXChannelPotatso Channel:https://t.me/potatsoSSR Backup Channel:https://t.me/ssr_backuplhie1/Rules Channel:https://t.me/rulenewsTempest TCN(rixCloud):https://t.me/TempestAppTrojan Qt5 News:https://t.me/TrojanQt5NewsServerCat 主机喵:https://t.me/servercatHyper SSR:https://t.me/hyperssrSurfboard News:https://t.me/surfboardnews逗比根据地 News:https://t.me/doubi_a老王公告区:https://t.me/wangvpn_user魅影极速官方频道:https://t.me/myjstw魅影极速轻量站ARK频道:https://t.me/arktochannel喵帕斯通知频道:https://t.me/joinchat/AAAAAD-w0xtKH55HW8GBCQFndroid的日常(Clash for Windows):https://t.me/fndroid_newsClash for Android Channel:https://t.me/clash_for_android_channelClashR News:https://t.me/ClashR_NewsclashR 公告:https://t.me/clashR_channelClash(R) for Windows 公告板:https://t.me/ClashR_for_Windows_ChannelACL4SSR:https://t.me/ACL4SSRStick Rules:https://t.me/usestick爱兔联盟公告通知:https://t.me/tuClubNews每日免费节点分发:https://t.me/freessrshadowsocks公益组织:https://t.me/ssfree无题（非clowwindy本人）:https://t.me/clowwindyESU.TV:https://t.me/esutvSocks5最新代理发布:https://t.me/socks5listSS节点免费发放:https://t.me/sslistSSR节点免费发放:https://t.me/ssrlistSSR节点国际共享:https://t.me/ShadowsocksRssrV2ray节点免费发放:https://t.me/v2listSSR SHARE 免费SSR:https://t.me/gyjclubGoogle Hosts:https://t.me/googlehostsGoogle Hosts 广播频道:https://t.me/googlehostsnewsGoogle Hosts Official Channel:https://t.me/googlehosts_news机场物价局:https://t.me/JCFBIMTP发布 tg代理:https://t.me/mtppubMTPROTO公益代理发放频道:https://t.me/onessrPharos Announcements:https://t.me/Pharos_x_AnnouncementsSSRPanel:https://t.me/ssrpanelFree Telegram proxy:https://t.me/proxymevAgent官方福利资源发布频道:https://t.me/everythingjustbeginss panel v3 mod 魔改修改版 News:https://t.me/sspanel_Uimss panel v3 mod 非官方水群:https://t.me/SSUnionBosLife:https://t.me/boslifenewsCoel SSR BroadCast:https://t.me/joinchat/AAAAAFiwPBlDTJJ-6xbWSgSTC_API:https://t.me/niconewbeeeapi从纯小白开始的翻墙冒险:https://t.me/chunxiaobaiSubConverter 更新频道:https://t.me/subconverterVPN测评-各类VPN相关资讯+真实测评:https://t.me/VPNceping火箭空间站 (TG代理):https://t.me/Rocketcool杂物:https://t.me/gugugugomielecV2:https://t.me/elecV2x86_64 ssrpOpenWRT软路由固件频道:https://t.me/ssrpOpenWRTXurge:https://t.me/Xurge科学上网与机场观察:https://t.me/jichangtjYtFlow β:https://t.me/YtFlowChannelMerlinClash猫咪爬梯:https://t.me/merlinclashcat媒体Telegram 中文 NEWS:https://t.me/YinxiangBiji_NewsVultr News:https://t.me/vultr_newsTelegram 抽奖活动导航: https://t.me/Lottery_home科技花（TestFlight）:https://t.me/TestFlightCN小道消息:https://t.me/WebNotesBackup小道消息:https://t.me/WebNotes2比特新声:https://t.me/bitvoice海龙说:https://t.me/haotalk不客观 Not Objective:https://t.me/notobjective卖桃者说（池建强）:https://t.me/mactalk澳门政府官方Telegram頻道:https://t.me/leehsienloong《澳門日報》官方Telegram頻道:https://t.me/macaodaily台灣隊長蔡英文:https://t.me/iingtw看鉴中国 OutsightChina:https://t.me/OutsightChina新闻实验室:https://t.me/newslab202060秒读懂世界:https://t.me/SharedResources突发新闻:https://t.me/breakingnews_t南方周末 / Southern Weekly:https://t.me/infzmPixelExperience - News:https://t.me/PixelExperience果核  Apple Nuts:https://t.me/AppleNuts Apple Spyder 果蛛 🕷️:https://t.me/AppleSpyderOnePlus™:https://t.me/OnePlus数码荔枝 lizhi.io:https://t.me/shumalizhi程序员技术资源分享:https://t.me/gotoshare大虾的编程资源库/码农/程序员资源:https://t.me/programmingsrchubMIUI 12 Updates:https://t.me/MIUI11_UpdatesIPN 播客网络:https://t.me/ipnpodcast一分世界:https://t.me/yifenshijie《無次元》博客:https://t.me/wuciyuan一天世界 博客:https://t.me/yitianshijie津津乐道播客:https://t.me/jinjinledao剩余价值:https://t.me/surplusvalueclub电丸科技AK:https://t.me/joinchat/AAAAAEWbURDTisztrTcwqA随机波动 StochasticVolatility:https://t.me/StochasticVolatilityPodcast精选中文播客:https://t.me/chinapodcastkindle电子书读书会:https://t.me/zebookpush『得到』电子书:https://t.me/dedao_eBook读舍 FM:https://t.me/bookcn新蛤社TG膜蛤专栏:https://t.me/XinHaNewsAgency电脑玩物:https://t.me/playpcesor回形针PaperClip&amp;灵光灯泡:https://t.me/papercliphubIngress官方频道:https://t.me/NianticOfficialSteam快讯:https://t.me/steamsteamLibra - Facebook Coin:https://t.me/Libra_infoProgrammer Jokes:https://t.me/programmerjokesBooksThief:https://t.me/BooksThiefCreative Motion:https://t.me/creativemotionGoogle:https://t.me/googleSolidot（奇客的资讯,重要的东西）:https://t.me/solidotReadHub:https://t.me/readhub_cnProduct Hunt Hot:https://t.me/product_hunt_hot少数派:https://t.me/sspaiXDA-Developers Hub:https://t.me/xdadevelopershubXDA-News [Official]:https://t.me/xdanews中国互联网交换中心 China-Internet-Exchange:https://t.me/googlessrrLinux中国:https://t.me/linuxdotcnBIGDONGDONG 频道:https://t.me/bigdongdongchannelGroupHub广播站:https://t.me/GroupHub数字优惠:https://t.me/DigitalSpecialDealsOne Pie:https://t.me/ssp1pTelegram安全使用方案:https://t.me/protecttelegramNyanChan’s Notebook (次糖糖):https://t.me/nyanchansnotebookHitiko’s Channel:https://t.me/HitikoWooMai’s Channel:https://t.me/WooMaiChannelMrKevin博客 资讯 分享 测评:https://t.me/hilinuxcnLeonn的博客:https://t.me/liyuansVPS仓-推荐/补货提醒:https://t.me/vpscangVps推荐:https://t.me/VPSRSSVPS信号旗播报:https://t.me/vps_xhqunwire.hk 生活科技頻道:https://t.me/unwire好奇心日报:https://t.me/qdaily好奇心日报:https://t.me/qdaily001互联网从业者充电站:https://t.me/https1024cnBeta.COM中文业界资讯站(简中):https://t.me/cnbeta_comcnBeta.COM中文業界資訊站(繁中):http://t.me/cnbeta_com_hk中国数字时代消息推送:https://t.me/cdtchinesefeedPSA-安全公告专栏:https://t.me/TGCNPSA网络安全事件SecEvents:https://t.me/SecEvents安全威胁收集和福利:https://t.me/safe2you网络安全技术频道:https://t.me/tg_InternetSecurityAffyun.com - 每日offers优选:https://t.me/affyunpushGoogle Drive 资源:https://t.me/gdurl帮找资源:https://t.me/lovesource书籍共享计划:https://t.me/booksharingplanLicenses Channel:https://t.me/Licensesss[合租通知] Netflix YouTube Spotify office365 Hbo Surge 美剧:https://t.me/hezu2拼车小组:https://t.me/PinCheStationnetflix spotify hulu vpn账号:https://t.me/zxc1017FreeTrial.Store:https://t.me/freetrialsellNew Hollywood English Movies HD:https://t.me/hollywood_new_english_hd_moviesTelegram movies II:https://t.me/TMoviesOfficial2NF^2 经典剧集频道:https://t.me/joinchat/AAAAAE3C8ftAes4Hlwdq1QNF^2 在播剧集频道:https://t.me/joinchat/AAAAAFV5bPMRFezYw2bdTwNF^2 原电影频道:https://t.me/joinchat/AAAAAEkxsGoVvgfKGi_QBANF^2 iOS 电影频道:https://t.me/joinchat/AAAAAFFZ44zzfAGVxxLkGwNF^2 Google Drive 发布频道:https://t.me/joinchat/AAAAAFFQ9jJ_upG0y6xKyg4K影视资源:https://t.me/Remux_2160P4K影视屋-蓝光无损电影:https://t.me/dianying4KDiscuss That!:https://t.me/DiscussThisYouTube-ImShuker文件及公告:https://t.me/shukerxiaoxiReddit 精选:https://t.me/RedditTopMETO 的涂鸦板:https://t.me/metoooooApple Upgrade:https://t.me/AppleUpgradeLinux Update:https://t.me/linuxUpdate跑路快讯:https://t.me/runningfaster电报时报:https://t.me/times001PUSH科技快讯:https://t.me/Pushings逆风社:https://t.me/nifengpress新纪元 新闻中心:https://t.me/xinjiyuan9长安街日报:https://t.me/thecaajournal噫~这世界:https://t.me/yizheshijie羊毛收割机 • 好物:https://t.me/ZHwool羊王🐑频道:https://t.me/yangwangpindao吾爱资源 薅羊毛·资讯中心:https://t.me/Pojieapp🎏「 彼岸情报🔎！」🎏薅羊毛情报见闻社:https://t.me/BaccanoSoul好物 • 羊毛信息发布:https://t.me/Yiwushop随手薅毛毛:https://t.me/get_cheap_goods🅻ihaiba资源羊毛分享🍭:https://t.me/lihaiba频道🏆资源福利分享:https://t.me/freemorebest全网福利收集:https://t.me/FuliListGoogle Play限免信息:https://t.me/playsalesDiscovery探索频道:https://t.me/tele_event_share扫地僧笔记:https://t.me/lover_links今日头条:https://t.me/jinritoutiaoScience:https://t.me/scienceUntitled TechTalk:https://t.me/UntitledTechTalk中国地震台网速报:https://t.me/BC_CEIC中国地震速报（≥4.5级）:https://t.me/dizhen公共交通部落:https://t.me/fhs_publictransport_zone地铁服务信息更新:https://t.me/Metro_Service_Update药丸时报:https://t.me/PillNewsGif Center:https://t.me/gifcenterWallpapers:https://t.me/AR72014Wallpapers/Обои:https://t.me/EZwallsWallpapers By Arthwork:https://t.me/arthworkWallPapers:https://t.me/WallpapersForYou_8k壁纸 wallpapers:https://t.me/bizhi123Hk3ToN:https://t.me/Hk3ToWallpaper@Winn 手工壁纸分享:https://t.me/WallpaperWinn最美壁纸©极简派:https://t.me/yidu520Wallpapers:https://t.me/awsiiqiWallpaper PC:https://t.me/iWallpaperPCAE Documents Room:https://t.me/joinchat/AAAAAEI59b4dQOYGvZdZRwTech Guide:https://t.me/TechGuideBoring Class:https://t.me/BoringClassThink Positive Words:https://t.me/thinkpositivewords小牛课堂之股市新手手册:https://t.me/KYWsharetraining燎原:https://t.me/liaoyuan胖客十袋:https://t.me/pankt涂抹:https://t.me/paint_film跑路快讯:https://t.me/runrunkuaixunTechCrunch中文版:https://t.me/techcrunchcn鳥的日用美學:https://t.me/Feuilletons乙烷日报:https://t.me/OverDaily碎琼乱玉 背风而行:https://t.me/ruanyuwwLetITFly News:https://t.me/LetITFlyW猪圈净化快讯:https://t.me/zhujuan2018科技圈广播:https://t.me/InternetNewsCN安全上网,注意事项:https://t.me/anquanshangwang360互联网安全中心:https://t.me/InternetSecurityCenterOf360苹果旧版应用发布频道:https://t.me/guooldHackerNews中文站:https://t.me/China_HackerNews竹新社:https://t.me/tnews365竹新资料库:https://t.me/kt_database海外媒体的中文新闻:https://t.me/chinanews001《維基人》官方推播頻道:https://t.me/the_Wikipedian中文維基新聞廣播頻道:https://t.me/wikinews_zh_broadcastReuters:World:https://t.me/ReutersWorldChannel内涵段子:https://t.me/duanzitg糗事百科:https://t.me/qiushibaike句子迷:https://t.me/kuaikanmanhuaPUSH科学快讯:https://t.me/pushings少数人知道的消息:https://t.me/csrinfo科技圈的日常:https://t.me/misakatech博闻社:https://t.me/bowenpress湾区日报 Official:https://t.me/wanqu_official逗比据地根 (频道):https://t.me/ToyooMessage免費資源網路社群 Free Group:https://t.me/Free_Group好物 · 羊毛收割机:https://t.me/ZH_wool三家村Flow:人文+科技:https://t.me/GoReading菲兹定律:https://t.me/prefocuson网络安全中心:https://t.me/tgdailigg61 的私人无主题分享:https://t.me/thisis61speakingiOS 越狱插件更新信息:https://t.me/Jailbreak_TweaksJailbreak:https://t.me/jailbreakJailbreak Notifications:https://t.me/jailbreaknotificationsCydia Updates:https://t.me/cydiaupdateSpotify News:https://t.me/spotifynews全网福利收集:https://t.me/AlltheChannel无限月读:https://t.me/moecao每日 AWESOME 观察:https://t.me/awesomeopensourceIT 那点事:https://t.me/InternetNewsCN即刻精选:https://t.me/jike_collection996 码农的觉醒:https://t.me/Awakenedeveloper远鉴字幕组发布频道:https://t.me/VisionarySub流浪防区 新闻台:https://t.me/China_irl_NewsDaily News:https://t.me/daily73机场防御测压实验室:https://t.me/ssrcyXDDOS压力测试:https://t.me/xddos2网站防御测试频道:https://t.me/webyc悟空干货集中营:https://t.me/daily5kongLIFETIME视界:https://t.me/lifetimecn电视机顶盒&amp;手机影视APP:https://t.me/tvbox001Cloudflare在中国频道:https://t.me/Cloudflare_CNTikTok:https://t.me/tiktokPT资讯频道:https://t.me/privatetrackernewsIyouport:https://t.me/iyouport主机百科资讯分享:https://t.me/zhujiwiki_infoo1xhack &amp; friends🥤 分享 思考 科技 生活:https://t.me/o1xinsightNewlearnerの自留地:https://t.me/NewlearnerChannelAwesome Collection:https://t.me/awesome_collectionPicacomic News:https://t.me/PicACGApple Tech News:https://t.me/appletechnews码力全开工作室:https://t.me/maliquankai一碗毒鸡汤:https://t.me/ywdjt数字移民:https://t.me/shuziyimin值物志:https://t.me/zhiwuzhi路透中文网:https://t.me/lutouzhongwen_rss纽约时报:https://t.me/niuyueshibao_rss美国之音:https://t.me/meiguozhiyin_rss知乎日报:https://t.me/zhihuribao_rssBBC中文:https://t.me/bbczhongwen_rssFT中文网:https://t.me/ftzhongwen_rss双语新闻:https://t.me/shuangyunews_rss法国 国际广播电台:https://t.me/rfi_rss德国 德国之声:https://t.me/dw_rss澳大利亚 广播公司:https://t.me/abc_rss俄罗斯 卫星通讯社:https://t.me/ru_rss新加坡 联合早报:https://t.me/sg_rss韩国 中央日报:https://t.me/korea_rss日本 日经中文网:https://t.me/jp_rss台湾香港 当地日报:https://t.me/ttww_rss每日早间新闻:https://t.me/zaobaoNews经济信息联播:https://t.me/eco_cnLearn SwiftUI:https://t.me/learnswiftui媒奇葩说:https://t.me/mtalk看理想 vistopia:https://t.me/ikanlixiangStreaming Link Station:https://t.me/streaming_link_station方可成的新闻实验室:https://t.me/newslab2020Wolley News:https://t.me/wolleynewsJustf News:https://t.me/justfNewHacker News:https://t.me/hacker_news_feedNewMobileLife:https://t.me/newmobilelife國家地理雜誌 中文版:https://t.me/natgeomedia你有一个打折需要了解:https://t.me/SteamNy无损音乐:https://t.me/wsmusic0Emby全能服务器体验（嘎鱼饭）:https://t.me/gayufanTrending Stickers:https://t.me/TrendingStickersKAIX.IN:https://t.me/kaix_inTSBBLOG:https://t.me/tsbblog中文播客精选:https://t.me/greatpodcasts每日一歌:https://t.me/dailymusich音乐世界:https://t.me/lumingguandj中文社科讲座资讯:https://t.me/chwebinars【ZERO】安全运营（DevSecOps）:https://t.me/zero_devsecops小报频道:https://t.me/FQnews维生素E:https://t.me/vitamineEpodcast新冠肺炎2019-nCoV疫情实时播报🅥:https://t.me/nCoV2019新型冠状病毒最新疫情推送频道:https://t.me/CoronavirusNews丁香园肺炎疫情播报:https://t.me/ncovPneumonia霍金斯大学nCoV全球实时数据:https://t.me/JHU_nCoV_APIWuhan Quarantine #nCoV #武汉封城:https://t.me/wuhanquarantinefrom202001232019-nCoV实况:https://t.me/CN2019nCoV2019-nCoV疫情相关资讯发布:https://t.me/WuHan2019nCoVFinancial Times: Coronavirus news:https://t.me/financialtimes全平台口罩放货监控:https://t.me/jdkzjk新型冠狀病毒肺炎疫情頻道:https://t.me/NCVMacao疫情趋势图&amp;信息图:https://t.me/nCoV2019GraphCoronavirus Info:https://t.me/corona印度:https://t.me/MyGovCoronaNewsdesk以色列:https://t.me/MOHreport哈萨克斯坦:https://t.me/coronavirus2020_kz马来西亚:https://t.me/cprckkm乌兹别克斯坦:https://t.me/koronavirusinfouz沙特:https://t.me/LiveWellMOH新加坡:https://t.me/govsg西班牙:https://t.me/sanidadgob乌克兰:https://t.me/COVID19_Ukraine俄罗斯:https://t.me/stopcoronavirusrussia香港:https://t.me/HKFIGHTCOVID19德国:https://t.me/corona_infokanal_bmg其他频道/群组/机器人分享:https://t.me/hao123fAnimated Stickers:https://t.me/AnimatedStickersAnimated Emojis:https://t.me/AnimatedEmojis本土創作的貼圖:https://t.me/LocalStickersStickers Channel:https://t.me/stickersChannelACG Stickers:https://t.me/ACGStickersTestFlight News:https://t.me/testflightsEnglish learners:https://t.me/English一加手机/OnePlus频道:https://t.me/onepluscnMy Desctop（Cool 4k, HD wallpapers）:https://t.me/PhoneDesctopBTSynChina中文资源分享:https://t.me/btsynchineseBtsync keys:https://t.me/btsyncGramip Channel:https://t.me/Gramip秘密文摘:https://t.me/secretofbody_degistSync资源更新:https://t.me/shenkey91yun优惠快讯:https://t.me/express91yunzrj766的频道:https://t.me/zrj96雷罗笔记:https://t.me/coolciOuterShare 独乐乐不如众乐乐:https://t.me/outershareVPS.TF 资讯聚合:https://t.me/joinchat/AAAAAFNDKWzkp5wyCL86jwHost Testing and evaluation:https://t.me/HostEvaluateFree網絡信息自由門:https://t.me/todayfreedomEH Forwarder Bot Support:https://t.me/EFBSupport今天份的微软药丸:https://t.me/microshitLWL 的基地台:https://t.me/lwlbaseIngress 中文:https://t.me/IngressChineseIngress Chengdu&amp;Chongqing:https://t.me/IngressChengduChongqingtsear.ch - Telegram SearchEngine:https://t.me/tgchansFindYanot Ch:https://t.me/findyanotch各种奇奇怪怪的优惠和专卖活动:https://t.me/joinchat/AAAAAEDHaeh76nlGWM6zhgDoggyStyle journal of U:https://t.me/djoyou北京空气质量每天推送:https://t.me/BeijingAir豆瓣精选:https://t.me/douban_read文杏馆（藏书分享）:https://t.me/BooksThatMakeYouThink【程序员之家】软件项目百例:https://t.me/useless_project_ideas新闻播报PDF:https://t.me/news_pdf好书分享:https://t.me/haoshufenxiang每周一书:https://t.me/weekly_books机械工业出版社资源:https://t.me/bookusefor1机械工业出版社计算机书籍:https://t.me/bookusefor3中信、清华大学、电子工业书籍资源:https://t.me/bookusefor2编程随想推荐书籍（非官方）:https://t.me/programthinkbook電書攤Ƹ̵̡Ӝ̵̨Ʒ:https://t.me/telebookstall好书分享频道:https://t.me/haoshufenxiang山巅出版社:https://t.me/shandian2084zread (推) - 什么书值得读:https://t.me/zreadpush微信搬运工:https://t.me/WeChatEssence蛋挞报:https://t.me/pincongessence台湾的一个可爱Sticker Channel:https://t.me/sticker_tw发猫频道猫奴必备:https://t.me/miaowu一个小圈子的画猫:https://t.me/miaopang今天 tg 打掉了几个ISIS bot:https://t.me/ISISwatch老毛子Padavan固件发布:https://t.me/pdcn1老毛子Padavan固件纯净交流群:https://t.me/pdcn0eSir Playground固件&amp;插件发布频道:https://t.me/joinchat/AAAAAE-8dVyO8ljrgQ5yCw王者荣耀:https://t.me/joinchat/Ddz9QT36eAcOR-AX7gHZdw图拉鼎的所见、所闻、所想:https://t.me/tualatrix_saysBetter Naming:https://t.me/rebornixscuinfo:https://t.me/scuinfoProducter Cast:https://t.me/producter_castZeroNet Feed:https://t.me/ZeroNet某不科学的DIYgod:https://t.me/awesomeDIYgod美剧资源推送:https://t.me/SSKMJBTSKindle 电子书降价信息:https://t.me/kindlePriceKindle 特价书:https://t.me/KindleBookDealsAmazon 降价信息:https://t.me/amazondropPremium 🇵 🇷 🇴💀:https://t.me/Premiumpro白板（一些有趣的文字、图片、视频）:https://t.me/mastergogogo共青团中央:https://t.me/comyouth嘴炮:https://t.me/zuipaoGMF:https://t.me/theGMFEntdaily:https://t.me/entdailyHacker News:https://t.me/another_hacker_news饭否每日精选:https://t.me/fanfou_daily饭否每周精选:https://t.me/fanfou_weeklyScale system:https://t.me/scalesystemFireball Newsletter:https://t.me/fireballnewsletter一任阶前点滴到天明:https://t.me/hearrain有趣的物有趣的事情:https://t.me/superliClassic Drama &amp; Novel:https://t.me/Drama暗之城 - 科学之城:https://t.me/cityofsciencechannelInbox收集箱:https://t.me/inbox_all冷眼向洋:https://t.me/lengyanxiangyang内涵段子TV:https://t.me/duanzizhijiaDribbble Popular Design 每日流行设计:https://t.me/designtaalkGoogle Voice 靓号:https://t.me/voice_googleApper:https://t.me/iappliance书店官方公告栏:https://t.me/bookshopleaf浮生笔记:https://t.me/fabulousleafAirplanes:https://t.me/Airplanese每日一句:https://t.me/meiriyiju开源游戏服务器框架 skynet 项目:https://t.me/skynetluaJailbreak News:https://t.me/jailbreaknotifications碎嘴老鼠:https://t.me/dms_share看看就好:https://t.me/swiminthedream线路爆炸:https://t.me/boomagain川普推文即时同步:https://t.me/realDonaldTrumpTwitter三仙炒面:https://t.me/sanxian大咕咕咕鸡:https://t.me/tgdaguguguji荔枝木:https://t.me/lycheewoodRuich97 Notice:https://t.me/ruich97_baseRuich97 Notice:https://t.me/gabriel_channelGroupOwnerBots:https://t.me/GroupOwnerBots一休儿的哲学讲座:https://t.me/yixiuer小破不入渠:https://t.me/forwardlikehell吾聊世界:https://t.me/wuliaoworldNetflix高分好剧推介:https://t.me/NetflixFansNetflix 影片介绍:https://t.me/NetflixFirstRARTV:https://t.me/rartv财经快讯:https://t.me/fnnew黑洞资源共享:https://t.me/tieliu翻车频道:https://t.me/banyungong666neoFelhz’s Channel 山雨欲来风满楼:https://t.me/neoFelhzWAlPlank:https://t.me/NaAlOH4_JokesAlPlank Ver Sion:https://t.me/NaAlOH4_Jokes_plusPrivacy Rules:https://t.me/PrivacyRulesNo Bug In:https://t.me/NoBugIn老梦杂货铺:https://t.me/littlesh0pSitandRelax’s Channel~NSFW:https://t.me/SitandRelaxLabs坐和云音乐:https://t.me/SitandMusicSitandRelax’s Channel:https://t.me/SitandRelaxLab红米Note3吐槽频道:https://t.me/RIP_KenzoJerry Zhāng 的频道:https://t.me/JerryZhangSaoDaye - TG频道:https://t.me/infosaodayeEMK Public Channel:https://t.me/JacobEMK摄神取念:https://t.me/LegolimensTG中文资源库共享中心:https://t.me/anruan123Drakeets:https://t.me/drakeetsUpperDoc:https://t.me/UpperDoc诚换通-二手交易频道:https://t.me/chenghuitongpindaoFor Work 系列-梗频道:https://t.me/JISFWFor Work 系列-图频道:https://t.me/GfWR16For Work 系列-读频道:https://t.me/NewsFWFor Work 系列-妹频道:https://t.me/GFW3DSFor Work 系列-NLP频道:https://t.me/NLPfWFor Work 系列-轨道群:https://t.me/RailwayFW@ATGWall ‘s Channel:https://t.me/ATGWall_ChannelSukka’s Notebook:https://t.me/SukkaChannelDavid’s YouTube 频道推荐:https://t.me/davidsyoutubetesla特斯拉/科技NEWS:https://t.me/Tesla_sharesaber的万事屋:https://t.me/sabershome鱼塔嘅台:https://t.me/Trumeet芝士和培根:https://t.me/KnowledgeHan中国辟谣:https://t.me/piyao学习网安知识:https://t.me/cy6ersec搞机日记:https://t.me/gcjiriji烤苹果(专业收集 bug):https://t.me/AppleCookedFoolish TraceWind:https://t.me/FoolishTraceWindtg机器人推荐:https://t.me/tgbotlistNetflix卡片小站频道:https://t.me/Leye169物与民胞:https://t.me/unicorn4kkDLK搞笑趣闻情报站:https://t.me/dlkqingbaozhan蝉鸣:https://t.me/chanming毒奶频道 🅥 limboPro.xyz:https://t.me/limboprossrACG/萌系/二次元资源、福利、资讯发放频道:https://t.me/MoeTheTG🔑win10密匙windows10激活码分享 微软:https://t.me/win10keymaxOurBits RSS频道:https://t.me/OurBits_RSS365知中国:https://t.me/knowchina365影视APP分享频道:https://t.me/ysappZUOLUOTV官方频道:https://t.me/zuoluotvofficial不求甚解:https://t.me/fakeye好书集:https://t.me/haoshuji煎蛋无聊图:https://t.me/jiandan_boreddotplayer订阅列表:https://t.me/dotplayerlists思想:https://t.me/sixiang每日沙雕墙:https://t.me/shadiaooo上班划水之沙雕图:https://t.me/goworkbitch心惊报:https://t.me/xinjingdaily🅢🅗🅐🅡🅔:https://t.me/WeShareSome微博热搜:https://t.me/weibo_hot🌏世界宇:https://t.me/sharedworld土味生活:https://t.me/tuweishenghuo初恋的感觉:https://t.me/chuliandeganjue笑掉大牙:https://t.me/xiaodiaodaya读者书摘:https://t.me/duzheshuzhaiZapro Notice:https://t.me/zaproshareThe Sociologist:https://t.me/thesoc科技无意义:https://t.me/technical_with_love𝐕 𝐀 𝐆 𝐔 𝐄 - 針:https://t.me/oz_senseiSean:https://t.me/SeanChannelVanHelSing Notification:https://t.me/ChujiuggOutvivid:https://t.me/outvividRss™:https://t.me/hubssrLEAPS Hedge:https://t.me/leapstradeReuters: World:https://t.me/ReutersWorldChannelzrj766的频道:https://t.me/zrj96IMG2D:https://t.me/IMG2D家庭网络资源共享频道:https://t.me/homenet9科研萌新的日常生活:https://t.me/records_of_my_daily_lifePT资讯频道:https://t.me/privatetrackernewsRachel 碎碎念:https://t.me/RachelBlahblahRachel 的消息发布站点:https://t.me/RachelNotice京东优惠:https://t.me/jdbuyTelegram China News:https://t.me/tgchinanews📊 Polls Channel:https://t.me/polls_channelGoogoCC:https://t.me/googoccEmperorTian资源推送:https://t.me/iOSAppTS往生路:https://t.me/wangshenglu翼起乐News:https://t.me/YiQiLeNews小艾先生说:https://t.me/xiaoaixianshengshuo福利线报:https://t.me/xiaoaixiansheng_fulixianbao影视资源:https://t.me/xiaoaixiansheng_yingshizhuanqu浅影随想:https://t.me/lightFantasy杂物:https://t.me/zaawuu螺莉莉的黑板报:https://t.me/im_RORIRI锤子🔨丨网球🎾丨圈❎:https://t.me/ThorHCCAPPDO 数字生活指南:https://t.me/appdodoPanoanDrive(离线下载自动转存Google Drive):https://t.me/PanoanChannel资源垃圾佬:https://t.me/allfree123Telegram China News:https://t.me/tgchinanews「每日更新」視頻分享频道:https://t.me/BLADE_CLUB_Media英语外刊推送:https://t.me/ENmagazine_push萦纡 / 潮过广陵半江愁 如何解思念瘦:https://t.me/huangxinn老梁故事汇:https://t.me/Laoliang666科学上网资源整合:https://t.me/ysl_channel自留 𝙘𝙝𝙖𝙣𝙣𝙚𝙡 &gt; 𝙢𝙖𝙞𝙘𝙤𝙤 / 𝙍𝙪𝙡𝙚𝙨:https://t.me/who_channel美剧←→blahblah (&amp; etc.):https://t.me/mytvseries澡堂随笔:https://t.me/showerblah政治哲学片段摘录:https://t.me/poliphy酷喵无损音乐:https://t.me/kugoumusicAll About RSS:https://t.me/aboutrssNS新闻转报:https://t.me/SwitchNewCNrynco libkadence:https://t.me/rynifTingTalk - Channel:https://t.me/tingtalkTelegram (非官方)香港支援頻道:https://t.me/tlgrmHK_chPDF资料:https://t.me/pdf_001我们的歌🎵:https://t.me/DDDDDDziApps推广/抽奖/活动:https://t.me/AppsSweepstakesNews有价值与无价值-科技数码:https://t.me/wuyongzhiyong懂TG - 海外大小事保护隐私自己事:https://t.me/dongTG边走边吃的夏天:https://t.me/deliciousxiamoke 的 日常分享、吐槽和动态:https://t.me/mokeyjay_channel造物指南:https://t.me/create_worlds肆意🅥资源推送:https://t.me/resourcepush_41EXFLUX Netowrks - News:https://t.me/exflux_news台灣蘋果同好群 - 佈告板:https://t.me/TWAppleFansAnnounce微信(Wechat)也要吃藥？:https://t.me/wechatpill麻瓜术士的魔法资产:https://t.me/ArtistModifyAsset今天份的微软药丸:https://t.me/microshit烤苹果:https://t.me/AppleCooked内核怕怕 - 辣鸡 Linux:https://t.me/kernelscared辣鸡咕鸽毁我信仰 #CurryMyLife:https://t.me/googleshitTG…药丸？:https://t.me/tgpill今天三桑爆炸了吗:https://t.me/SamsungBoom索尼大法孬:https://t.me/SonySucks微信(Wechat)也要吃藥？:https://t.me/wechatpill飛雞推特準備起飛了(?:https://t.me/Fly_Chicken_Twitter辣雞Adobe也有頻道:https://t.me/AntiAdobeNVIDIA F**k you:https://t.me/wtfnvidiaDiscord藥丸??:https://t.me/discord_pill路由黑洞:https://t.me/route_blackhole迟早药丸:https://t.me/metapill靠北網商:https://t.me/Anti_ISPJetBreaks 💊:https://t.me/jetbreaks🍝 Spotify 糊了:https://t.me/SpaghettifyCCTV -1001240015334&gt;IC 故事会:https://t.me/EEPill食屎啦 Niantic:https://t.me/shitofnianticArch 滚挂了吗？:https://t.me/btw_use_arch如何与沙雕相处:https://t.me/ruheyushadiaoxiangchu空空如也:https://t.me/MomoKCHMicrosoft-软粉论坛:https://t.me/microwinver免费挂机宝:https://t.me/freemach1ne85.60×53.98卡粉订阅/提醒:https://t.me/DocOfCard小林君家里的托尔:https://t.me/TooruchanNews托尔酱的梗图与FW:https://t.me/TooruChan_MemesCodingStartup 起碼課:https://t.me/codingstartup一些干货:https://t.me/youganhuo豆瓣知乎简书微信公众号:https://t.me/dbzhjs全球主流新闻媒体中文速览:https://t.me/allzhnews验证码平台:https://t.me/Telegram-zh_CN校长读报:https://t.me/XiaoZhangDuBaoMtpHub:https://t.me/mtphubGodly Noob:https://t.me/GodlyNews1每天趣事:https://t.me/Meitian奇趣百科:https://t.me/qiqubaike扣扣空间:https://t.me/qqqzone硬核小卒:https://t.me/yinghexiaozu机器人 Bot官方认证 BotBotFather 是所有机器人的 god 了,Telegram 官方管理；可以用它创建机器人和管理机器人,你可以利用机器人 API,帮你自己很多事情IFTTT ifttt 的官方机器人,可以很方便的和ifttt 里的其他服务连接,比如订阅某个网站的RSS,如果有更新就会自动把RSS内容推送到这个机器人,减少了频繁刷新网站来获取新的内容GmailBot 可以在这里就方便的收发GmailDiscussBot 官方出的评论机器人, 可以在频道每条消息下面点击添加评论MTProxy Admin Bot 设置和管理 Telegram MTProto 服务器.Stickers 使用此机器人创建贴纸并获取贴纸的使用统计数据.SpamBot 官方处理 spam 事务的机器人VerifyBot 官方认证账号的机器人Telegraph This bot can help you log in on Telegra.ph, manage your articles, and get page view statistics.Previews Use this bot to leave feedback about webpage previews generated for Telegram’s Instant View feature.Designers Bot This bot accepts UI layouts and animations intended to improve Telegram. Best contributions are published in @designersJobs Bot This bot lists career opportunities at Telegram and accepts candidates’ applications. Available at telegram.org/jobsGDPR Bot Telegram’s Official GDPR bot.GameBot I’m a demo bot for the Telegram Gaming Platform. I can get you a few fun sample games to play.ContestBot ContestBot is a way for Telegram to hold online competitions and find new members for the Telegram team.QuizBot Create a quiz with several multiple choice questions and test your friends.其他聪聪 Bot Telegram 知识/中文汉化,机场推荐,SS/SSR 下载,数码荔枝优惠劵,少数派 Power+ 2.0 优惠劵,Office 365 靠谱拼车,正版软件折扣…这个我知道 本机器人能够自动回复关键词对应的内容这个我删了 Bot 自动删除’推广/广告/菠菜’等等消息Vultr 助手 Bot 绑定 Vultr 账户, 定时提醒 Vultr 账户的余额和流量不足信息Telegram 权限管理 Bot Telegram 自动管理权限,指定时间自动关闭/打开群组权限中文趣群搜索机器人 Telegram 中文群组频道搜索机器人中文趣群搜索机器人 TG中文频道群组搜索机器人TGX-频道秘书 Telegram 中文群组索引导航新频道群组导航 新频道群组导航Translate Father 翻译消息Yandex.Translate 翻译消息Language Translator 翻译消息中英翻譯(English Chinese(Mandarin) translation) 翻译消息Sticker To GIF 贴纸下载,支持动态贴纸Sticker Downloader 贴纸下载StickerSetBot 贴纸下载TG Downloader GIF和贴纸下载Manybot Manybot lets you create your own bots. Send messages, create custom commands and menus. Press Send message to beginControllerBot Awesome bot for channel owners that helps you to create rich posts, view stats and more.vote 投票机器人,新建一个投票发布在群里,每一次投票都是实时显示结果的,结果会以十分直观的方式展示PTRankBot 可以帮助你搜索和分享 iOS/macOS 应用,只需要在聊天框输入 @PTRankBot 和关键字,等待几秒就会出现搜索结果.支持命令查看 Store 各种排名,如 /top_free 查看每周免费排行榜ehForwarderBot ehForwarderBot能够将微信和 Telegram 连接在一起,你可以在 Telegram 上收发微信消息,详情查看:https://meta.appinn.net/t/efb-v2-telegram-docker/10888.GitHub 地址: https://github.com/blueset/ehForwarderBotAirPollution_Bot 查询空气质量(AQI),数据来源为 aqicn.org,比如发送“/aqi 成都”就会立即返回你成都的空气质量temp_mail_bot 有效期10分钟临时邮箱服务,当你想要临时注册一个网站的账号时就可以用这种临时邮箱服务,避免自己的邮箱泄露也免于各种垃圾广告骚扰utubebot YouTube 视频下载或者音频转换服务,把YouTube 的链接发过去它就会帮你转换格式并为你提供文件,便于你下载此视频apkdl_bot Android APK 搜索和下载,输入App 名即可提供多个来自国外网站APK 下载链接,点Preview 可以查看图标LikeBot 一个很酷的机器人,用基于表情符号的按钮创建帖子,可以点击表情符号投票.Instasave_bot 下载Instagram 和YouTube 的图片和视频getidsbot 这个机器人可以告诉你”你的tg ID和注册时间”TGSoBot Telegram 中文圈内容搜索引擎,主要用于支持官方不友好的中文搜索,有任何资源该引擎可以做到秒回.TeleMe TeleMe is simple management &amp; analytics software for Telegram communities. TeleMe 是一个方便好用的Telegram 社群管理和统计Bot.Dr.Web 用于检测群组内的网页链接和文件,并在包含潜在威胁时发出警告.daixiahu_bot 智能合租机器人.合租 求租 智能机器人, 方便用户以最快的速度找到合适的车, 支持 Netflix, Spotify, Youtube 等cnLottery123_bot 抽奖助手:便好用、公平公正的 Telegram 群组抽奖工具.适用于群里抽奖、抽签抓阄等场景.tgLotteryBot 抽奖机器人sauweenbot 一个中文群组管理机器人, 内置一些全中文得简单操作letmebot Teach those pricks how to use a search engine properly.Doge Bot JPG.DOG 的上线 Doge Bot 图床机器人,只需私聊发送图片,即可自动上传图床并返回链接！areply_bot 自动解除频道消息在群组的同步置顶，附带群组日常维护常用小功能WuhanPneumoniaBot 武汉新型冠状病毒感染肺炎查询haoyybot 歌曲音乐搜索机器人，输入歌曲名或者歌手名，把TG变成音乐播放器！Send to Kindle Send to Kindle BotInstantViewBot 可以把文章都生成支持Instant ViewChnInstantViewBot 可以把文章都生成支持Instant ViewWebpageBot 强制刷新 Telegram 链接预览ReactBot 频道消息添加点赞和评论按钮CommentBot 频道消息添加点赞和评论按钮Like and Comment 频道消息添加点赞和评论按钮Channel Helper 频道消息添加点赞和评论按钮tgcnjoincaptchabot TGCN-CAPTCHA加群验证Jqs7ZweiBot 加群验证Captchat_Bot 加群验证WatchDoorBot 加群验证WooMaiBot 加群验证VideoTubeBot Downloads audio/video from YouTube.PronunciationBot 可以将84种语言文字转换成对应的语音 学习外语发音的利器Shorten URL 提供短网址 ShortenURL 服务,使用的网址为 ume.laTransferRobot 上传文件后提供下载链接,适合做图床和文件分享SpotifyMusicDownloaderBot Spotify Music DownloaderMinesweeper 扫雷游戏Combot 统计群消息情况,群成员情况NodeRSSBot A RSSBot written in Node.js https://github.com/fengkx/NodeRSSBot feel free to post issue or pull requestRustRssBot 中文 Telegram RSS 机器人TheFeedReaderBot RSS 机器人RSSchina_bot rss订阅机器人PdoRSS_bot 一个勤勤恳恳的RSS订阅器ComenBot 留言/评论机器人CommentsBot 留言/评论机器人get_id_bot get your telegram’s chat IDzh_groups_bot TGCN-群组频道狼GroupHub_bot tg中文圈优质群组TWBlackList_bot 登爺的名單,辅助管理群成员,帮你ban人CNBlackListRBot 辅助管理群成员,帮你ban人GroupButler This bot can help you in managing your group with rules, anti-flood, description, custom triggers, and much more!AntiServiceMessageBot 自动把入群和退群通知删除Anonymous Telegram Bot 群组匿名消息机器人.将机器人加入群组后,私聊机器人,可以通过机器人将文本、视频等匿名发送到群组内.AntiHyperlinkBot 自动删除包含有链接的消息AntiCommandBot 自动删除 /命令 的消息AntiArabicScriptBot removes all messages which contain arabic scriptGiphy GIF Search GIF 搜索Wikipedia Search Wikipedia 搜索Markdown Bot Markdown 格式编辑消息JPEGreenBot 图片劣化ImageBot This simple bot can fetch images and GIFs upon request.IMDb This bot automatically works in all your chats and groups, no need to add it anywhere. Simply type @imdb in any chatClassical Music This bot can help you find beautiful classical music.YouTube Bot This bot can help you find and share YouTube videos.GitHub Get notifications about events in your public GitHub repositories and post comments directly from Telegram.Shop Bot Try out the new Telegram Payments without actually paying anything.StickerBot This bot will help you find new relevant stickers for your favorite emoji.Gamee The best games on Telegram! Pick a game and challenge your friendsHot Or Bot Like others and let others like you.GetMediaBot Get any media file from any where…NoSticker 自动删除群里的StickersSpamMeNotBot 保护您的组免受垃圾邮件/攻击socks5_bot 免费获得Socks5 代理MahoNato_bot 森近真帆telegraph 管理Telegra.ph文章mdrobot Markdown 机器人referbot 提供短网址 Shorten URL 服务,使用的网址为ume.laLinkGeneratorBot 短地址服务QRCodeRoBot 二维码识别机器人,通过拍照和上传图片的方式识别thesafebot 一个利用 telegram 存储功能实现额外加密的云存储服务MyTeleCloudBot 另一个云存储服务,没有额外加密,不过功能还行topdf_bot 转换文件为 PDF 格式ssInstasave_bot 用来下载 instagram 的 botmy_ali_bot 用来在 AliExpress 上购物TrustedSleepBot 可信睡眠机器人ddoc_bot DDOS攻击器storebot 机器人商店,索引了各种机器人,可以寻找自己感兴趣的tchannelsbot 索引了很多 Channel,可以寻找自己感兴趣的 ChannelCostflowCryptoBot CryptocurrenciesCostflowCurrencyBot Real world currency rates/conventionstockprice_bot 中文股票机器人,A股 / 美股 / 港股LotteryBot 一个比特币抽奖的机器人todobot To do list managerrJailbreakBot Jailbreak Botiqdb_org_bot IQDB Botascii2d_bot Ascii2d Botwangjingze_bot 王境泽 Botyaplus_bot Yaplus Botkunsu_bot HandsUp Botyouqianbot 为所欲为 Botredpack_bot 红包 Botpenle_bot 喷了 Botjichou_bot 记仇 Botbugele_bot 不鸽了 Botjidubot 嫉妒 Botfavorite_stickers_bot 贴纸包 BotTelegram Bot ListTelegram Bot StoreTelegram Bots","link":"/2021/01/31/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%94%B5%E6%8A%A5%20Telegram%20%E7%BE%A4%E7%BB%84%E6%B1%87%E6%80%BB/"},{"title":"Java语言设计一教材电子版","text":"第**1**章 java 语言基础 本章内容**(**一般掌握 3%~5%) 本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。 Java 语言特点 Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个项目开发小组，目标是设计嵌在消费性电子产品的小型分布式系统软件，能够适用于异构网络、多主机体系结构，能实现信息安全传递。项目小组的最初设想是用 C++语言完成这个目标。由于 C++语言的复杂性和不安全性，不能胜任这项工作。为此，项目小组开发一个取名为 Oak 的语言。 Oak 语言在消费性电子产品市场上没有获得青睐。但在当时，Internet 开始流行，人们发明了一种网络传输协议， 这种协议可以在文本中插入图片和声音，能使单调的 Internet 世界变得图文并茂。虽然 Web 页面拥用图文和声音，但仍然是静态的，不具备交互性。要让页面拥有动态画面，并能交互，需要在 Web 页面中嵌入一会段程序。由于在 Internet 上运行的数以千计不同类的计算机，这就要求编写这种程序的语言必须具有平台无关性，并要求语言必须简练，支撑环境要小，而安全性却很高。Oak 语言恰好能够满足这些要求。 将 Oak 语言正式应用于 Internet 还需要进一步完善，还要求有一个支持它的 Web 浏览器。能用于编写浏览器，并获得浏览器扶持的新版本 Oak 语言取名 Java。Internet 得到 Java 语言的支持，可以实现真正的交互，人们使用浏览器能“漫游”丰富多彩的 Internet 世界。 Java 语言是适用于分布式计算环境的面向对象编程语言，它虽类似 C 和C++，但比 C++简单，忽略了许多为提高计算效率，初学者较难掌握的程序语言特性。 Java 语言主要有以下特点： 强类型 Java 语言是一种强类型语言，强类型能约束程序员必须遵守更多的编程规定，也能让编译器检测出程序中尽可能多的错误。 编译和解释 Java 语言是一种高级编程语言，用 Java 语言编写的源程序在计算机上运行需经过编译和解释执行两个严格区分的阶段。Java 语言的编译程序先将 Java 源程序翻译成机器无关的字节码(bytecode)，不是通常的编译程序将源程序翻译成计算机的机器代码。运行时，Java 的运行系统和链接需要执行的类，并作必要的优化后，解释执行字节码程序。 自动无用内存回收功能 Java 语言具有自动无用内存回收功能，程序可以按需使用内存，但不需要对无用内存显式地撤销分配。系统有一个垃圾收集器(garbage collector)，自动收集程序不再使用的内存。这样，能避免显式的撤销分配所引起的安全问题。Java 语言不再含有任何不安全的语言成分。例如，没有指针，数组元素都要检查下标是否越界。 面向对象 面向对象是程序员编写大型程序、有效控制程序复杂性的重要手段。Java 语言在面向对象方面，比 C++更“纯”，它的所有数据类型，包括布尔类型、整形、字符型等，都有相应的类，程序可完全基于对象编写。 面向对象语言主要有封装性、继承性和多态性三个特点。封装就是将实现细节隐藏起来，只给出如何使用的信息。数据及数据上的操作用类封装，对象是类的实例，外界使用对象中的数据及可用的操作受到一定的限制。继承体现众多的一种层次对象的特性，下一层的类可从上一层的类继承定义，从上一层类派生的类的对象能继承上一层对象的特性，同时可以改变和扩充一些特性，以适应其自身的特点。多态性的意义主要体现在逻辑上相同的不同层次上的操作，使用相同的操作名，根据具体对象，能自动选择对应的操作。Java 语言很实用地实现了这三种特性。 与平台无关 与平台无关是对程序可移植性最直接最有效的支持。Java 语言的设计者在设计时重点考虑了 Java 程序的可移植性，采用多种机制来保证可移植性，其中最主要的是定义了一种虚拟机(virtual machine),以及虚拟机使用的 java 字节码。在任何平台上,Java 源程序被 Java 编译器编译成虚拟机能够识别的字节码。这样，只要有 Java 虚拟机的平台，就能解释执行 java 字节码程序，从而实现 Java 与平台无关。另外，Java 语言还采用基于国际标准的数据类 型，在任何平台上，同上种数据类型是一致的。例如，用 int 标识 32 位二进制位(bit)整型数据，那么无论在哪一台计算机上，Java 的int 数据都是 32 位整数。相反，C 语言会随着硬软件平台的改变，用 int 标识的整数位数也可能不全相同。 Java 语言提高可移植性的代价是降低程序的执行效率。出于 java 语言也是一种解释执行的语言，Java 程序的执行速度与 C 程序的执行速度有较大的差别。不过，为了尽量弥补执行效率低的缺陷，java 的字节码在设计上非常接近现代计算机的机器码，这有助于提高解释执行的速度。 安全性 Java 是在网络环境中使用的编程语言，必须考虑安全性问题，主要有以下两个方面： 设计的安全防范：Java 语言没有指针，避免程序因为指针使用不当，访问不应该访问的内存空间；提供数组元素上标检测机制，禁止程序越界访问内存；提供内存自动回收机制，避免程序遗漏或重复释放内存。 运行安全检查：为了防止字节码程序可能被非法改动，解释执行前，先对字节码程序作检查，防止网络“黑客” 对字节码程序已作了恶意改动，达到破坏系统的目的。最后，浏览器限制下载的小应用程序不允许访问本地文件， 避免小应用程序破坏本地文件。 分布式计算 Java 语言支持客户机/服务器计算模式。Java 程序能利用 URL 对象，能访问网络上的对象，如同访问本地的文件一样，实现数据分布。另外，Java 的客户机/服务器模式也可以把计算从服务器分散到客户机端，实现操作分布。 多线程 线程是比进程更小的一种可并发执行的单位，每个进程都有自己独立的内存空间和其他资源，当进程切换时需要进行数据和资源的保护与恢复。若干协同工作的线程可以共享内存空间和资源，线程切换不需要数据的保护与恢复。 Java 的运行环境采用多线程实现，可以利用系统的空闲时间执行诸如内存回收等操作；Java 语言提供语言级多线程支持，用 Java 语言能直接编写多线程程序。 Java 应用程序和小应用程序 Java 程序可以是独立的应用程序和能在浏览器上执行的小应用程序(Applet)。两种 Java 程序都由一个或多个扩展名为“.class”的文件组成。都需要 java 虚拟机(JVM)载入并翻译。这两种程序的主要区别是：小应用程序只能在与 Java 兼容的容器中运行，可以嵌入在 HTML 网页内，在网络上发布，当网页被浏览时，在浏览器中运行。小应程序的运行还要受到严格的安全限制，例如，它不能访问用计算机上的文件。Java 应用程序没有这些限制，也不支持网页嵌入和下载运行。 小应用程序和应用程序在代码编写上也有很大差异。一个小应用程序必须定义成一个 Applet 类的子类，应用程序可以是 Applet 类的子类，也可以不是。应用程序必须在一个类中定义一个 main()方法，该方法代表应用程序的入口。而小应用程序不必定义 main()方法，它的执行由 Applet 类中定义的多个方法控制。 [例 1.1] 一个非常简单的应用程序。 public class Example1_1{//这是我的第一个应用程序public static void main(String []args){ System.Out.println(“你好!欢迎你学习 Java 语言。”); } } 上述 java 程序的执行将输出以下字样： 你好!欢迎你学习 Java 语言。 一个应用程序由若干个类组成，上面这个应用程序只有一个类，类的名字是 Example1_1。public 是 java 语言的关键字，表示声明的类 Example1_1 是公用的。class 也是关键字，用来声明类。最外层的一对花括号以及括号内的内容叫做类体。public static void main(String []args)是类 Example1_1 的一个方法。一个应用程序必须只有一个类含有main()方法，这个类是应用程序的主类。public static void 是对 main()方法的说明。应用程序的 main()方法必须被说明成 public static void。表示 main()方法的访问权限是公有的，它是一个类方法，没有结果返回，参见第 3 章。String []args 或 String args[]，声明 main()方法的参数是一个字符串数组，参见第 4 章。 Java 源程序命名受**严格的限制。Java 源文件的扩展名必须是“**.java”如果源文件中有多个类，那么**只能有一个**public 类；如果源文件中有 public 类，那么源文件的**名字必须与这个类的名字完全相同**。例如，例 1.1 应用程序的源文件名必须是 Example1_1.java。如果源文件没有 public 类，那么源文件的名字只要和某个类的名字相同即可。 [例 1.2]一个简单的小应用程序，用一同颜色显示两行文字： 欢迎你学习 Java 语言。 只要认真学习，多上机实习，一定能学好 Java 语言。import java.applet.*; import java.awt.*; public class Example1_2 extends Applet{ public void paint(Graphics g){ g.setColor(Color.blue);//设置显示的颜色为 blue g.drawString(“欢迎你学 Java 语言”,30,20); g.setColor(Color.red);//设置显示的颜色为 red g.drawString(“只要认真学习，多上机实习，一定能学好 Java 语言。”,30,50); } } 一个小应用程序也出若干个类组成，其中必须有一个类，它继承系统提供的 Applet 类，这个类是小应用程序的主类。 主类必须是 public 的，源文件名必须与小应用程序的主类名相同。上述程序的源文件名必须是 Example1_2.java。小应用程序的结构参见 3.5 节。 在结束这一节之前，先讨论一下程序中经常出现的注释。注释是程序中的说明文字，用于帮助阅读程序，它不是语句，不会影响程序的执行效率。Java 语言的注释有三种形式： 行注释 // 变量 r 是贺的半径 块注释 / 以下程序段是采用冒泡排序对数组元素实现从小到大排序 / 文档注释 / 类 Student 是学生类*/ 行注释用于简短地说明前面代码的意义或功能。注释内容至行末结束，不能跨行。例如： int fontsize =30 ;//标题字体大小 块注释是多行注释，用于说明下面程序段的算法、功能等，块注释不可嵌套使用。文档注释能被实用程序 javadoc 接受，它能自动生成程序的 HTML 文档。 Java 程序的开发过程 Java 程序的开发过程如图 1.1 所示。对于 Java 应用程序，先编写 Java 源程序，源程序经 Java 编译器编译后产生码文件，最后由 Java 解释器解释执行字节码文件。对于小应用程序，先编写源程序，然后经 Java 编译器编译后，产生字节码文件，最后由 Web 浏览器解释执行字节码文件。 以下以使用 SUN 公司提供的 Java JDK(java Developer’s Kit)为例，并假设 Java JDK 安装在 d:\\java 目录下，则在该目录下还应包含以下几个文件和子目录： 子目录 d:\\java\\bin,这个子目录是 Java JDK 的核心，其中最主要的可执行文件有： javac—编译器 java—解释器 jdb—调试器 appletviewer—java Applet 解释器 子目录 d:\\java\\lib，这个子目录存储的是函数库。 编写源程序时，使用一个文字编辑器，输入源程序文件，并保存。键入编译命令，使用 Java 编译器编译 Java 源程序。键入解释命令，通过解释器解释执行 Java 应用程序的字节码文件。对于小应用程序需通过支持 Java 的浏览器解释执行字节码文件。 设输入前面所述 Java 程序，源文件名为 Example1_1.java，保存在 D：\\java 目录下。Java 编译器的使用格式是： javac [选项] 源文件 例如，可用以下命令编译以上输入的 Java 应用程序： javac d:\\java\\Example1_1.java 编译时，可能编译器指定选项，java JDK 编译器的选项参见表 1-1。 选项 说明 -classpath&lt;路径&gt; 引用类的路径表 -d&lt;目录&gt; 编译后类文件存放的目录 -g 生成调试信息表 -ng 不生成调试信息表 -nowarn 关闭编译器警告功能 -o 优化类文件 -verbose 显示编译过程中的详细信息 Java 解释器 java.exe 用来解释执行 Java 类文件，解释器的使用格式为： java [选项]类名[参数] 其中，类名指定的类必须是 main()方法的，即是一个 Java 应用程序。 对于使用开发环境情况来说，编辑源程序、编译、执行和调试直接使用环境提供的工具，使开发程序变得非常简单。例如，使用 Eclipse 开发环境。在 eclipse 环境下开发 Java 程序的方法请参见附录 F。 标识符和关键字 如同别的程序语言一样，Java 语言也有基本符号，由基本符号按一定的构词规则构成标识符等基本词汇，再由基本词汇和关键字按语言的句法构成 Java 程序。 字符集 Java 语言使用 Unicode 字符集，共有 65535 个字符，包括： (1) 数字符 10 个(0~9)。 英文字母大、小写字符各 26 个(A~Z 和 a~z)。 下划线字符，美元符号。 文字字符，(汉字，日文片假名、平假名和朝鲜文字等)。 其他用于构成特殊符号的字符集。 标识符 标识符用于命名程序对象。例如，类名、变量名、方法名等。Java 语言的标识符可以按以下规则任意命名： 由字母(包括英文字母、下划线字符、美元字符、文字字符)和数字字符组成。 限定标识符的第一个字符不能是数字符。 例如，下列 4 个字符串都可以个为标识符： Boy_$、$63Girl、颜色、小伙子 而以下 4 个字符不能作为标识符： 46A、%Val、c+2、Hello! 前两是因为首字符不合理，后两个含有不允许在标识符中出现的字符。除了按上述规则命名的习惯约定： 一般变量名、方法名用小写英文字母开头；文字和常数用大写字母命名；类名首字母用大写字母；包名全部用小写字母。命名习惯是一种公共约定，Java 语言的语法并没有这种限制，但是培养良好的编程习惯有利于程序维护和协作开发。 关键字 为了表示程序结构、定义和修饰等，Java 语言引入一组关键字，参见附录 A。关键字是上些英文单词，在语言中， 关键字已经被赋予特定的意义，不能用这些关键字作为标识符命名程序对象。在 Java 语言中，关键字的作用有以下多个方面： 描述程序结构、声明类、定义类的成员、简单数据类型、值和变量、异常情况处理、实例(对象)的创建和检验、流程控制等。 Java 语言中所有关键字均由小写字母组成。每个关键字在程序中出现有特定位置和使用方法的要求。关键字不可以用做变量、方法、类或标号的标识符(名字)。 基本数据类型 Java 语言是强类型语言，每个变量和表达式都有确定的类型，在变量赋值时要进行类型兼容性检验。数据类型可分 为基本数据类型和非基本数据类型两大类。 基本数据类型也称为原始数据类型，是系统预先规定的一些常用类型。它们是：整数类型、浮点数**(实数)类型、字符(文字)类型、逻辑类型(布尔型)**。 非基本数据类型也称为复合数据类型，是由基本类型组合的新类型。非基本数据类型分为：数组、字符串、类、接 口。 本小节只介绍基本数据类型，非基本数据类型将在以后章节中分别介绍。 逻辑类型 逻辑类型用关键字 boolean 标识，所以也称布尔型。逻辑类型只有真和假两个值，true 表示真,false 表示假。以下是逻辑变量定义的例子： boolean b; boolean bool; boolean flg1,flg2, 美丽；//一次定义多个变量 boolean b1 = true,b2= false,丑=false;//定义时可以赋初值 逻辑变量用于记录某种条件成立与否，也用语句中作条件判断。 字符类型 字符类型用关键字 char 标识。字符型数据是一个字符2个字节，内部表示是字符的 Unicode 代码，共用 65535 个不同 的字符。在 Java 程序中，字符常量有普通字符和转义字符常两种。 用单引号括住一个字符，表示一个普通字符常量。例如，’a’、’B’、’$’、’国’。对于被语言用作特定意义的字符，或者不能显式显示的字符，需用转义字符标记它们。 例如，换行符用\\n 标记，水平制表符用\\t 标记。常用的转义字符的标记方法见表 1-2。其中，\\nnn 是用八进制代码表示的字符，\\unnnn 是用十六进制代码表示的字符。例如：\\141 表示字母 a，\\u0061 也表示字母 a.以下是字符变量定义的例子： char ch; char ch1,ch2,漂亮; char ch3 = ‘A’,ch4 = ‘家’,丑=’假’;//定义时可以赋给初值表 1-2 转义字符及其含义 转义符 含义 \\b 退格(Backspace 键) \\n 换行符，光标位置移到下一行首 \\r 回车符，光标位置移到当前行首 \\t 水平制表符(Tab 键) \\v 竖向退格符 \\f 走纸换页 \\ 反斜杠符\\ \\’ 单引号符’ \\” 双引号符” \\nnn n 为 8 进制数字，用八进制数据表示字符的代码 \\unnnn n 为 16 进制数字，用 16 进制数据表示字符的代码 整数类型 整数是不带小数点和指数的数值数据。由于计算机只能表示整数的一个子集，表达更大范围内的整数需要更多的二进制位，Java 语言将整型数据按数值范围大水不同分成四种： (1) 基本型：用 int 标识。4 个字节，32 位，取值范围是-231~231 -1，即-2147483648~2147483647。 字节型：用 byte 标识。1 个字节，8 位，取值范围是-27~27 -1，即-128~127。 (3) 短整型：用 short 标识。2 个字节，16 位，取值范围是-216~216 -1，即-23768~32767 (4) 长整型：用 long 标识。8 个字节，64 位，取值范围是-264~264 -1，即-923372036854775808L~923372036854775807L 每种**整数类型处理不同范围的整数值，并且都是带符号**的。 整型常量有十进制、八进制和十六进制三种写法。如下 面的示例所示： 1234(十进制)，0777(八进制，以数字 0 开头)，0x3ABC(十六进制，以 0x 开头，后随数字符和英文 A 到F)，5333L 或 5333l(以字母 L 或l 结尾是长整数)。 以下是整型变量定义的实例： int I；int x,积;byte 字节变量;//一个字节整型变量，该变量的名为字节变量 long z,sum;int w =12,len =-1230;long big = 9876L;//定义同时可以赋初值。 浮点数类型 浮点数类型也称实型，浮点数是带小数点或指数的数值数据。 Java 语言的浮点数有单精度和双精度两种。 单精度型 单精度型 用float 标识，占 4 个字节，32 位，取值-1038~1038。float 型常是的书写的方法是在实数之后加上字母 F**或**f.例如：23.54f,12389.987F。 双精度型 双精度型 用double 标识，占 8 个字节，64 位，取值-10308~10308。double 型常是的书写的方法有两种： 一种是直接写一个实数，或在实数后面加上字母 D 或**d.**例如：123.5439、123.5439D, 123.5439d。另一种是科学计数法，用 10 的方幂表示(用字符 e 或E 表示幂底 10)。例如：123.24e40(科学计数法表示，值为 123.24 乘 10 的 40 次方)。 以下是浮点数类型变量定义的例子: float x,y; double v=12.86,u=2431098.987D; float u=12.36f; 浮点数类型与整数不同，当执行运算时如果出现某种不正常的状态，浮点数类型不会抛出异常。例如， 如果用 0 除浮点数类型的变量，则计算结果是一个特别的无限值。 习题 指出 Java 语言的主要特点和 Java 程序的执行过程。答：主要特点： 强类型，(2) 编译和解释，**(3) 自动无用内存回收功能，(4**) 面向对象， (5**) 与平台无关，(6)安全性，(7)分布式计算，(8)**多线程。 Java 程序的执行过程：是解释执行。**1.javac [选项] 源文件==编译** java [**选项**] 类名**[参数] ==**执行 说出开发与运行 Java 程序的主要步骤。 对于 Java 应用程序，先编写 Java 源程序，源程序经 Java 编译器编译后产生字节码文件，最后由 Java 解释器解释执行字节码文件。对于小应用程序，先编写源程序，然后经 Java 编译器编译后，产生字节码文件，最后由 Web 浏览器解释执行字节码文件。 如何区分应用程序和小应用程序？ (1)小应用程序只能在与 Java 兼容的容器中运行，可以嵌入在 HTML 网页内，在网络上发布，当网页被浏览时，在浏览器中运行。小应程序的运行还要受到严格的安全限制，例如，它不能访问用计算机上的文件。Java 应用程序没有这些限制，也不支持网页嵌入和下载运行。 (2)一个小应用程序必须定义成一个 Applet 类的子类，应用程序可以是 Applet 类的子类，也可以不是。应用程序必须在一个类中定义一个 main()方法，该方法代表应用程序的入口。而小应用程序不必定义 main()方法，它的执行由 Applet 类中定义的多个方法控制。 说出 Java 源文件的命名规则。 Java 源文件的**扩展名必须是“.java”如果源文件中有多个类，那么只能有一个public 类；如果源文件中有 public 类，那么源文件的名字必须与这个类的**名字完全相同 选择一种上机环境，参照实例，编写一个输出“hello world!”字样的 Java 程序。 Java 语言使用什么字符集？共有多少个不同的字符？ Java 语言使用 Unicode 字符集，共有 65535 个字符 (1)数字符 10 个(0~9)。 (2)英文字母大、小写字符各 26 个(A~Z 和 a~z)。 (3)下划线字符，美元符号。 (4)文字字符，(汉字，日文片假名、平假名和朝鲜文字等)。 (5)其他用于构成特殊符号的字符集。 Java 语言标识符的命名规则是什么、 1.由字母(包括英文字母、下划线字符、美元字符、文字字符)和数字字符组成。 2.限定标识符的第一个字符不能是数字符。 Java 有哪些基本数据类型，它们的常量又是如何书写的？ 整数类型、浮点数**(实数)类型、字符(文字)类型、逻辑类型(布尔型)**。 指出下列内容哪些是 Java 语言的整型常量，哪些是浮点数类型常量，哪些两者都不是。1)E-4, 都不是 2)A423, 都不是 3)-1E-31, double类型 4)0xABCL, long类型整型 5).32E31, double类型 6)087,十进制整型 7)0xL, 都不是 8)003, 八进制整型 9)0x12.5, 都不是 10)077, 八进制整型 11)11E, 都不是 12)056L, long类型整型 13)0., double类型 14).0 double类型 0.、.0 、.32E31、-1E-31是baidouble类型； 0x12.5、11E、0xL、A423、E-4是非法的数据； 056L、0xABCL是long类型整型； 077、003是八进制整型； 087是十进制整型； 第 2 章 运算和语句 本章主要内容(**次重点 10%)** 数据运算 语句 Java 程序实例 本章重点：算术运算、自增和自减运算、关系运算和逻辑，Java 语句以及 java 程序实例。 本章难点：自增和自减运算、位运算和移位运算，while 语句、do…while 语句、for 语句和 Java 程序实例。 数据运算 在高级语言中，运算由表达式表示。表达式由运算符**和运算分量组成，运算分量可以是常量、变量和方法调用。Java 语言的基本运算可分成以下几类：赋值运算，算术运算，自增和自减运算，关系运算，逻辑运算，条件运算和字符串连接运算**等。 赋值运算 在 Java 语言中，符号“=”是赋值运算符，不是“相等”(相等运算符是“==”，见关系运算符的叙述)。赋值运算分为两类：一是简单赋值运算；二是复合赋值运算。 简单赋值运算 简单赋值运算的一般形式如下： 变量 = 表达式 赋值运算的执行过程是： 计算赋值运算符的右端的表达式。 当赋值运算符两侧不一致时，将表达式值的类型自动转换成变量的类型。 将表达式的值赋值给变量，即存储到与变量对应的存储单元中。 完成一个赋值运算的表达式称为赋值表达式，赋值表达式是先计算表达式的值，然后将表达式的值赋值给变量。例如，表达式 x=x+1，表示完成表达式 x+1 的计算，将计算结果赋值给变量 x。 这里的类型转换是指数值数据的类型自动转换，这样的自动转换**只．能．由．简单类型向复**杂类型转换，不能**从复杂的转换成简单的**。即如下所示的从左到右转换： byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double 例如，以下代码说明 int 类型能自动转换成 double 类型： int j=3; double y=2.0; y=j;//j 的值为 3，y 的值为 3.0 以下则是不正确的代码，double 类型不能自动转换成 int 类型。j=y; Java 语言约定赋值运算也有值，它的值就是赋予变量的值，因此，赋值运算的结果可以继续赋值。例如： int j; double y=2.0; y=j=3;//j 的值为 3，,y 的值为 3.0 赋值运算符结合性“自右至左”，当连续有多上赋值运算时，是从右至左逐个赋值。 复合赋值运算 在程序中，经常遇到在变量现在值的基础上作某种修正的运算。例如x=x+5 这类运算的特点是：变量既要参与运算，又要接受赋值。为避免对同一个变量的地址重复计算，引入复合赋值运算符。常用的复合赋值运算符有： +=、-=、*=、/=、%= 例如： x+=5;//等价于 x=x+5 x =u+v;//等价于 x=x(u+v),这里括号不能省略a+=a-=b+2;//等价于 a=a+(a=a-(b+2)) 记θ 为某个双目运算符，复合赋值运算 xθ=e 的等效表达式为x= xθ(e) 当**e 是一个复杂表达式时，等效表达式的括号是必需**的。 算术运算 算术运算要求运算分量的类型是数值类型的(整数类型和浮点数类型)。运算时，只需一个运算分量的是单目运算，需两个运算分量的是双目运算。算术运算的运算符是： 单目算术运算符：＋（取正）、－（取负） 双目算术运算符：＋（加）、－（减）、＊（乘）、/（除）、％（求余数） 说明： 加、减、乘、除和求余数运算都是双目运算符，结合性都是从左至右。取正和取负是单目运算符，结合性是从右至左，其优先级高于＋、－、＊，％等双目运算符。 “/”为除法运算符，当除数和被除数均为整数类型数据时，则结果**也是整数类型数据**。例如７/4 的结果为１。 “％”为求余数运算符，求余数运算所得**结果的符号与被除的符号相同**。例如：５％３的结果为２，－５％３ 的结果为－２，５％－３的结果为２。 用算术运算符、运算分量和括号连接起来，符合 Java 语言语法规则的计算式，称为算术表达式。例如，如果变量 x 和y 已经被正确声明，并且已经赋予初值，则以下的式子就是一个正确的算术表达式： X2+y(x-5) 自增和自减运算 自增运算符“++”和自减运算符“–”是单目运算符，要求运算分量是数值类型的变量。其作用是变量的值增１或减１。这两个运算符与变量结合有以下四种可能形式： ++i 前缀形式，表示在引用变量 i 之前，先使 i 加１，以加１后的 i 值为运算结果。 –i 前缀形式, 表示在引用变量 i 之前, 先使i 减１，以减１后的 i 值为运算结果。 i++ 后缀形式，表示在收用变量 i 之后，才使 i 加１，即以增１前的 i 值为运算结果。i– 后缀形式，表示在引用变量 i 之后，才使 i 减１，即以减１前的 i 值为运算结果。例如： i=4;j=++i;//i 结果为５，j 的结果为５ i=4;j=i++;//i 结果为５，j 的结果为 4 i=4;j=–i;//i 结果为 3，j 的结果为 3 i=4;j=i–;//i 结果为 3，j 的结果为 4 上述例子说明，对变量采用自增或自减，用前缀形式或用后缀形式，对**变量本身来说，效果是相同的，但表达式的值不相同。前缀形式是变量运算之后的新值，后缀形式是变量运算之前的值。** 自增自减运算能使程序更为简洁和高效，但在使用时需注意“＋＋”和“――”运算的运算只能是变量，不能是**常**量或表达式。例如，４++或（i+j）++都不是合法的。 关系运算 关系运算用来表达两个表达式值的比较，运算结果是布尔型。有６种关系运算符： ＜（小于）、＜＝（小于等于）、＞（大于）、＞＝（大于等于）、＝＝（等于）、！＝（不等于） 关系运算对左右两侧的值进行比较，如果比较运算的结果成立，则值为 true；不成立为 false. 上述６个关系运算符的优先级不完全相同。＜、＜＝、＞、＞＝的优先级高于＝＝，！＝。 例如，表达式 x&gt;y==c&lt;d,等价于(x&gt;y)==(c&lt;d)。该表达式的意义是 x&gt;y 与 c&lt;d,或同时成立或同时不成立。关系运算符的优先级低于算术运算符的优先级。 例如：x&gt;u+v,等价于 x&gt;(u+v). 关系运算符的结合方向是自左至右。 逻辑运算 逻辑运算用于描述逻辑表达式，实现连续多个条件的逻辑与、逻辑或、逻辑否定的判定。有３个逻辑运算符： ＆＆（逻辑与）、||（逻辑或）、！（逻辑否定） 其中：运算符＆＆和||是双目运算符、运算符！是单目运算符。逻辑运算的操作数必须是布尔型的，结果也是布尔型的。 逻辑否定“！”的优先级高于**算术运算符的优先级。逻辑与“＆＆”和逻辑或“||”的优先级低于**关系运算符的优先 级。 表２-1 是逻辑运算的“真值表”，表中列出当运算分量 a 和b 的值在不同组合情况下，各种逻辑运算的结果。表２-1 逻辑运算真值表 a b !a !b a&amp;&amp;b a\\ \\ b true true false false true true true false false true false true false true true false false true false false true true false false 例如： a&gt;b&amp;&amp;x&gt;y 等价于 (a&gt;b)&amp;&amp;(x&gt;y) a!=b||x!=y 等价于(a!=b)||(x!=y) x==0||x&lt;y&amp;&amp;z&gt;y 等价于(x==y)||((x&lt;y)&amp;&amp;(z&gt;Y)) !a&amp;&amp;b||x&gt;y&amp;&amp;zy)&amp;&amp;(z&lt;y)) 逻辑运算符用来描述逻辑表达式。例如，闰年的条件是：每４年一个闰年，但每１００年少一个闰年，每４０ ０年又增加一个闰年。如果年份用整数类型变量 year 表示，则 year 年是闰年的条件是： （year 能被４整除，但不能被１００整除）或（year 能被４００整除） 用逻辑表达式可描述如下： （year/%4==0&amp;&amp;year%100!=0）||year%400==0 需要特别指出的是，逻辑与和逻辑或的运算符有以下性质，**Java 语言利用这些性质，在进行连续的逻辑运算时， 不分逻辑与和逻辑或的优先级**进行计算，而是顺序进行逻辑与和逻辑或的计算，一旦逻辑子表达式或逻辑子表 达式或逻辑表达式能确定结果，这不再继续计算。 （１） 对表达式 a&amp;&amp;b,当 a 为 false 时，结果为 false，不必再计算 b；仅当 a 为 true 时，才需计算 b。 （２） 对表达式 a||b，当 a 为 true 是，结果为 true，不i再计算 b;仅当 a 为 false 时，才需计算 b。 例如：设有 a=b=c=1,计算++a&gt;=1||++b&lt;++c。从左到右顺序逻辑或表达式，先计算子表达式++a&gt;=1,变量 a 的值变为２，++a&gt;=1 为 true,整个逻辑或表达式的值已经为 true，不再计算右边的子表达式++b&lt;++c。因而变量 b 和c 的值不变，仍为１。 在具体编写程序时，也应利用以上性质。用逻辑与表达两个条件必须同时成立时，如果条件不成立，条件２的值不便计算，则逻辑表达式应写成： 条件１＆＆条件２ 避免在条件１不成立情况下，计算条件２。例如，要表示 y/x&gt;2 和 x!=0 同时成立，应写成： x!=0&amp;&amp;y/x&gt;2 当x 为０时，不会 y/x。而写成： y/x&gt;2&amp;&amp;x!=0 是不正确的，因为当x 为０时，不能计算 y/x。对于逻辑或也有类似情况。 条件运算 条件运算是一个三目运算，一般形式如下： 逻辑表达式？表达式１：表达式２ 条件运算的执行过程是： 计算逻辑表达式 如果逻辑表达式的值为 true，则计算表达式１，并以表达式１的值为条件运算的结果（不再计算表达式２） 如果逻辑表达式的为 false,则计算表达式２，并以表达式２的值为条件运算的结果（未计算表达式１）。例如： x&gt;y ? x+5 : y-4 如果 x&gt;y 条件为 true，则上述表达式取 x+5 的值，否则取 y-4 的值。 条件运算符（？：）的优先级高于赋值运算符，低于逻辑运算符，也低于关系运算符和算术运算符。例如：max = x&gt;y ?x+5:y-4 等价于：max = ((x&gt;y)?x+5:(y-4)) 条件运算符的性为“自右至左”。例如 x&gt;y?x:u?v?u:v 等价于：x&gt;y?x:(u&gt;v?u:v) 条件表达式的返回值类型由表达式１和表达式２的类型确定。如果表达式１值的字节数比表达式２的值的字节数多， 则条件表达式值的类型与表达式１的类型相同；反之，则与表达式２的类型相同。 其他运算 除前面介绍的运算外，还有许多运算，本节只介绍位运算和移位运算。位运算和移位运算实现对二进制位串数据的运算，主要应用于与计算机内部表示直接有关的运算，读者可以跳过这些内容。 语句 一个计算过程由一系列计算步骤组成。一个计算步骤或用一个，或用一个计算流程控制实现。程序语言用描述计算步骤。在 Java 语言中，语句分为**基本语句、控制结构语句以及 package 语句和**import 语句等。其中控制结构语句包括复合语句、if 语句、switch 语句、循环语句和 try…catch 语句。其中循环语句有 while 语句、do…while 语句、for 语句三种。 基本语句 基本语句主要有表达式语句、空语句、break 语句、continue 语句、return 语句等。基本语句都以分号为结束符。 表达式语句 在赋值表达式、自增自减表达式和方法调用表达式之后加上分号即变成语句，称它们是表达式语句。例如，表达式“k++”,写成 “k++;”就是一个表达语句。最典型的表达式语句是赋值表达式构成的语句，譬如： k=k+2; m=n=j=3; 赋值表达式语句在程序中经常使用，习惯又称为赋值语句。 另一个典型的表达式语句是方法调用表达式之后接上分号： 方法调用； 该表达式语句虽未保留方法调用的返回值，但方法调用会引起实参向形参传递信息和执行方法体，将使变量获得输入数据；调用输出方法使程序输出计算结果等。 空语句 空语句是只有一个分号的语句，其形式为 ； 实际上，空语句是什么也不做的语句。语言引入空语句是出于以下实用上的考虑。例如，循环控制结构的句法需要一个语句作为循环体，当要循环执行的动作由循环控制部分完成时，就不需要有一个实际意义的循环体，这时就需要用一个空语句作为循环体。另外，语言引入空语句使语句序列中连续出现多个分号不再是一种错误，编译系统遇到这种情况，就认为单独的分号是空语句。 break 语句 break 语句必须出现在多路按值选择结构或循环结构中，break 语句的执行强制结束它所在的控制结构，让程序从这个控制结构的后继语句继续执行。break 语句的书写形式是 break; break 语句的应用，将在介绍 switch 语句和循环语句时作进一步讨论。 continue 语句 continue 语句只能出现在循环结构中，continue 语句的执行将忽略它所在的循环体中在它之后的语句。如果continue 语句在 while 语句或 do…while 语句的循环体中，使控制转入对循环条件表达式的计算和测试；如果出现在 for 语句的循环体中，使控制转入到对 for 控制结构的表达式 3 的求值。简单地说，continue 语句提早结束当前轮次循环，进入下一轮次循环。continue 语句的书写形式是 continue; continue 语句的应用，将在循环语句中进一步讨论。 return 语句 return 语句只能出现在方法体中，return 语句的执行将结束方法的执行，将控制返回到方法调用处。return 语句有两种形式： return ; 或 return 表达式； 第一种形式只有用于不返回结果的方法体中，第二种形式用于有返回结果的方法体中。执行第二种形式的 return 语 句时，方法在返回前先计算 return 后的表达式，并以该表达式值作为方法返回值，带回到方法调用处继续计算。 复合语句 复杂计算经常被分解为一个计算步骤序列。整个计算步骤序列在逻辑上是一个整体，要求计算机从计算步骤序列的第一个计算步骤开始，顺序执行每个计算步骤，直至最后一个计算步骤。 在 Java 语言中，用花括号括住一个顺序执行的计算步骤序列描述顺序结构，这样的顺序结构称作复合语句。复合语句中的每个计算步骤可以是单个语句，也可以是一个控制结构，特别情况也可以为空。 以交换两个整型变量 x 和y 的值为例，实现变量 x 和y 值的交换可分解为以下顺序执行的三个赋值步骤： temp =x; x=y; y=temp; 把交换变量 x 和y 的值作为一个不可分割的整体来考虑，应把上述 3 个语句写成如下形式的复合语句: { int temp; temp = x; x =y; y=temp; } 在构造复合语句时，这完成指定的工作，可能需要临时工作变量。例如，以上例子中的 temp 变量。在语句序列中插入变量定义，引入只有复合语句内的语句可使用的临时变量。用复合语句描述计算步骤序列，并定义自己专用的局部变量，使复合语句有很强的独立性，它不再要求外面为它定义专用变量。一个计算步骤序列用复合语句描述后， 它已经是一种单个语句。复合语句常被用作其他控制结构的成分语句。 if 语句 根据当前情况选择不同的计算，需用选择控制结构实现。有两种选择控制结构：两路条件选择结构和多路按值选择结构。 两路条件选择由一个条件和两个供选择的分支语句执行。 两路条件选择结构用 if 语句描述。if 语句根据条件表达式的值为 true 或 false，从两个语句中选取一个语句执行。if 语句的一般形式为 if(条件表达式) 语句 1 else 语句 2 if 语句的执行过程是： 计算条件表达式的值。 测试表达式的值并选择语句执行。如果表达式的值为 true，则执行语句 1；否则执行语句 2 。注意，无论条件表达的值是 true 还是 false，只执行语句 1 或语句 2 中的一个，不会两个都执行。 当if 语句中的语句 2 为空语句时，可简写成： if(条件表达式) 语句 这种形式的 if 语句的执行过程是： 计算表达式的值 测试表达式的值。若表达式的值为 true，则执行它的成分语句后结束 if 语句。否则，立即结束 if 语句。 在if 语句中的语句 1、语句 2 可以是任何语句。当它们中的某一个是由多个语句组成时，必须将它们用花括号括住。 当if 语句中供选择的语句又是 if 语句时，if 语句就呈嵌套的形式，这时应注意 else 与if 的对应关系。java 语言约定：else 与它前面最接近的 if 对应。 switch 语句 经常遇到这样的选择控制，对变量表达式的每一个可能的值分别作不同的计算。如果用两路条件选择结构描述这样的选择控制，由于要逐一测试是否等于某个值，if 语句嵌套的层次就很深，程序的可读性和可修改性也很差。多路按值选择结构可避免这个问题。表达式的值的类型只能是 char,byte short int 类型**。** 在 Java 语言中，用switch 语句描述多路按值选择结构。switch 语句包含一个表达式，用于按表达式值的不同作相应选择。另外，还有一系列由 case 开头的子句和一个可选的 default 开头的子句，每个子句有一个可能为空的语句序列。switch 语句一般形式为：() switch(表达式){ case 常量表达式 1：语句序列 1;break; case 常量表达式 2：语句序列 2;break; case 常量表达式 n: 语句序列 n;break; default: 语句序列 n+1;break; } 2.2.5 try…catch 语句try{ 语句块//执行该语句块，可能会发生异常 }catch(异常类型 e){ 异常发生时要执行的语句； }，{ 无论异常发生与否，都要执行的语句。 } 一个try 可以有多个 catch 和它标识的语句块。catch 的内容可以为空，但是**{}**不可省。 while 语句。 do…while 语句。 for 语句 嵌套的循环结构 循环体内的 continue 和break 语句 package 语句package 包名； package 语句必须出现在源程序文件的起始行，表示出现在该文件中的所有类都属于这个程序包。如果有多个源程序的程序包声明使用相同的包名，则表示这些源程序文件中的全部类都属于这个程序名。包名是一个目录名，其中也可以有路径。如果 源程序文件的首行没有 package 语句，则被默认为是无名包，存于当前目录中。 import 语句 import 语句用于引入所需要的类。import 语句的格式为： import 包名.类名； 如果要从一个包中引入多个类，则可以用通配符“* ”。 在一个 Java 源程序中可以有**多个 import 语句**，它们必须出现在 package 之后**，类的定义之前。** java 应用程序的基本结构[package 包名；] import 包名.类名； … [public] class 类名{ int val= … public static void main(String args[]) { … } } java 程序由**类和对象构成，而类又由方法和成员变量构成。java 的方法由语句构成，而语句又由标识符和运算符构成。** java 程序实例 第３章 面向对象编程基础 本章主要内容**(重点内容：15%)** 面向对象的基本概念 Java 的类和对象接口 基本类 Java 小应用程序基础 本章重点：Java 语言的类、对象、继承、接口以及 Java 小应用程序基础本章难点：继承、多态性、接口 3**．１面向对象的基本概念** 自计算机诞生到现在，程序设计语言发展经历了面向机器、面向过程和面向对象３个阶段。面向机器阶段用机器指令，即机器语言，或用助记符代替机器指令的汇编语言编写程序。使用面向机器的语言编写程序，编程模式是： 程序＝数据＋指令 编程时，需要考虑的内容包括计算机的硬件特性、数据位置安排、Ｉ/Ｏ设备的控制细节等。这类程序的缺陷是程序的可读性、可维护性、可移植性极差，因此编程效率很低。面向机器语言主要应用于一般的科学计算和简单控制处理。面向过程阶段是使用高级程序设计语言编程，有代表性的语言有 FORTRAN、PASCAL、C、COBOL 等。用面向过程语言 编程，编程模式是： 程序＝数据结构＋算法 编程时，需要考虑的内容是程序做什么、怎么做，重点考虑每个实现细节。采用的主要技术是结构化控制结构和模块化设计。这类程序除科学计算外，大量应用于一般的应用程序开发。这种编程技术的缺陷是不适宜应用于图形用户界面、事件驱动编程，难以开发超大规模的应用程序，特别是随着程序规模的进一趟扩大，系统变和非常难以维护。 面向对象阶段是目前正广泛流行的编程方法。面向对象编程语言有 Smalltalk、C++、Java 等。面向对象编程语言提供一种全新的编程技术。用面向对象编程，编程模式改为： 程序＝对象＋消息 程序设计者考虑的是对象的描述、对象间的关系、类的管理、什么时候和什么地方调用对象的哪一种方法。面向对象编程的适应范围大大扩大，能适用于大规模应用程序的解决方案、网络计算等。对于编程者来说，最大的优点是面向对象编程能有效支持重用，使超大规模的程序也变行相对容易维护。 面向对象程序设计语言引入许多概念和机制，包括抽象、对象、消息、类、继承、多态性等。本节先介绍这些概念和机制，随后将详细介绍 Java 语言如何体现和应用这些概念和机制。 抽象 抽象（abstraction）是程序设计中最经常使用的技术之一，因为抽象**是有效控制程序复**杂性的重要手段。在设计初始阶段，采用自顶向下的设计方法，暂时不关心具体细节，首先设计出抽象的算法；随后，抽象的算法步骤逐步被具体的实现替换。程序设计中利用抽象，在面向过程阶段，系统按函数和模块进行设计。在面向对象阶段，利用抽象按类设计。类是目前支持抽象的最好工具。 对象 在实际生活中，人们每时每刻与对象打交道，例如，汽车、自行车，在特定的应用领域都是对象（Object）。这些现实世界中的对象都有状态、行为和名称。例如，自行车的品牌、两个轮子的尺寸、行进中的速度等能描述自行车的状态；自行车提供包括加速、减速、刹车等行为。在面向对象语言中，对象的名称用于程序引用对象，对象的成员变量，用于存储对象的状态信息，对象的方法用于描述对象的行为。 消息 一个应用程序总会包含许多对象，通过这些对象之间的交互，实现更高级、更复杂的行为。例如，小张用他的自行车上学读书，在上学的过程中，小张骑着自行车，一会儿让车加速，一会儿让车减速，一会儿又刹车。总之， 一路上，小张与他的自行车一直在进行交互，直到学校。 在程序系统中，对象之间的交互通过相互发送消息（Message）实现。当对象Ａ希望对象Ｂ执行Ｂ的一个方法时，用对象Ａ发送消息给对象Ｂ来实现。消息发送时，如果还需要其他参数，消息可带参数一起发送。 类 通常程序系统中会有许多同样类型的对象。例如，每个同学都有一辆自行车。尽管每辆自行车的主人不同，各自行车当时所处的状态不同，但是，自行车所包含的属性、自行车能提供的行为是相同的人们可以统一给出同类对 象的各项属性和能提供的所有行为，据此，区别自行车和汽车是不同种类的对象。如同避免重复描述每辆自行车的属性和行为一样，为了避免程序逐一描述同类中的每个对象的所有属性，详细给出对象的每个方法的描述，把同一**类对象的所有共同的属性和行为放在一起描述。这种声明对象共有属性和行为的机制称为**类。类的声明定义了类的 所有对象的共有的属性和方法。这样，如果程序声明了自行车类的共有属性和方法，则小张的自行车是自行车类一个实例。如果程序需要，可随时由自行车类创建小王的自行车、小李的自行车等。所以类是对一组相同对象的描述， 类概括了同类对象的共有性质：**数据和方法。类的每个对象都有自己的标识，但它们具有相同的一组属性和提供相 同的一组方法**。 继承 除对象按类划分外，不是同一类的对象可能会存在某些相似性。继承（Inheritance）就是在已有类基础上，扩充属**性，或扩充与改写其某些方法，生成新的类，这个方式称为**继承。继承定义的类称为子类，被继承的类称为超类**（父类**），子类自动含有父类具有的属性和方法。继承具有传递性。例如，自行车可分为山地自行车、比赛用自行车等。山地自行车、比赛用自行车都是自行车类的子类。所之，自行车类是山地自行车、比赛用自行车的超类。超类声明**定义共同的特性，子类继承超类的共有特性，还可增加某些特殊性，并可扩充和修正部分行为。如同大家非常熟悉的几何图形，抽象的几何图形有位置、面积等共同特性，有求面积等方法。四边形、三角形、点都是几何图形的子类。同样四边形又可以有普通的四边形、长方形、菱形等。采用继承声明定义的子类可以有父类的属性和方法，也可以增加新的属性和方法，并可以对父类的某些方法给出新的定义。例如，各种类别的几何图形有不同的求面积的方法。继承的最大好处是对象能按层次划分**，并在子类中，与父类相同的属性和方法可以不再重复声明。继承体现了面向对象方法与现实世界中人们的抽象思维方式保持一致。 多态性 多态性（Polymorphism）有多种表现形式，这里所说的多态性**是指类型适应性多态性，这来自继承，不同继承**层次的对象对同样的方法有不同的实现。类型适应性多态性要求自动按对象的实际类型正确调用它的方法。例如， 各类几何图形构成一个继承体系，每种几何图形有特定的求面积方法。一个以几何图形对象为参数的方法 f()运行时，如果需要求这个参数对象的面积，系统根据对象的实际类型，自动按实际对象的类型选取正确的求面积方法。在方法 f()运行之前，只知道参数将对应一个几何图形对象，不知道它是三角形、圆，还是其他别的几何图形。这样，在方法 f()运行之前不能确定参数的求面积方法。这种多态性要求直至方法 f()运行时，知道了与参数对应的实际对象的类型，才确定求面积方法。这种类型适应性的多态性需要采用动态联编（Dynamic Binding）技术实现。 联编是将发送给对象的消息与含执行该消息方法的对象连接起来。当联编在编译和连接阶段**实现时，这样的联编过程称为静态联编；当联编推迟至运行时间**实现时，该联编过程称为动态联编。动态联编是面向对象语言必须具有的一种能力，是实现上述多态性的技术基础。 ３．２ Java 的类和对象 本节介绍 Java 语言的面向对象机制，内容包括类和对象，以及支持面向对象编程提供的一些机制。３．２．１ 类 类是一种类型，类封装对象的属性和方法，是同一类对象的模板。Java 程序的主要部分是描述类。１．类的声明 声明一个新类的基本格式如下： class 类名//声明新类的基本格式 { 类体 ｝ 其中关键字 class 引导一个类的声明，类名是一个标识符。类体给出类的成员变量定义和方法定义，其中类的成员变量用于存储对象的属性，方法描述对象的行为。类体中不能有**独立的执行代码，所有的执行代码只能出现在方法中。**[例 ３.1]学生类 Student 的声明。 class Student{ float height,weight; String name,sex,no; void setStudent(String n, String s, String o){ name= n;sex =s;no=o; System.out.println(“name:”+name); System.out.println(“sex:”+sex); System.out.println(“no:”+no); } void setWH(float w,float h){ weight = w; height = h; } } 在类 Student 中，定义了５个成员变量：height、weight、name、sex 和 no;２个方法：setStudent()和 setＷＨ()。２．成员变量 成员变量定义的一般形式如下： [修饰字] 类型 变量名； 其中，修饰字可以空缺，修饰字用于对成员变量限制其访问权限，成员的访问权限有４种：private**、protected、**public 和友好的，参见 3.2.5 节。变量的类型可以是任何数据类型，变量的名字是一个标识符。Java 中成员变量的名字**可以与类的方法的名字**相同。 成员变量对类内定义的方法都有效。类的方法中也可定义变量，这种变量称为局部变量，局部变量只在定义它的方法中有效。以下代码示意引用成员变量和局部变量的合法性： class A{ int x; int f(){ int a = 1; x = a; } int g() { } ３．方法 int y; y= a+x; } 方法给出对象的行为，方法的声明如同Ｃ语言函数定义。方法声明的一般形式如下： 返回值类型 方法名（类型 参数名，…，类型 参数名） ｛ 方法体 } 返回值类型声明方法返回值的数据类型。如果方法无返回值，就用 void 关键字。方法可以没有参数，多个参数用逗号分隔，参数类型可以是任何数据类型。 [例 3.2]方法的例子，类Ｂ有方法 u()和 v()。class B{ double x,y; int u(int x,int y){ return xx+yy+1; } float v(int a, float b){ return ax+by; } } 如果某方法中的参数名或局部变量的名**与**类的成员变量的名相同，则成员变量在这个方法内暂时被隐藏。例如， 在以下类Ｂ的声明中，方法u()中的参数x 和y 与成员变量x 和y 同名，方法u()中的x 和 y 引用的参数 x 和 y。如果**成员变量在方法内被隐藏**，又在方法中要引用成员变量，必须使用 this（参见 3.2.7 中关于关键字 this 的叙述），thi**s 表示调用该方法的**当前对象。 class Jerry{ int x,z; void g(int z){ int x = 5+z; this.x = x; this .z = z; } } 参数名和局部变量名可随意命名，建议尽量使用互不相同的名。 在 Java 程序中，类的方法可以重载。方法重载是指在一个类中**定义多个相同名字的方法，但这些方法或者参数个数不同或者顺序参数的**类型不同。 [例 3.4]方法重载的例子，类Ｃ的４个 fun（）方法或因参数个数不同，或因参数的类型顺序不同，是４个合理的重载方法。 class C{ float fun(float s){ return s*s; } float fun(float x,int y){ return xx+yy; } float fun(int x,float y){ return xx+yy; } float fun(float x,float y){ return xx+yy; } } 编译器将根据方法调用时的参数个数和参数类型及顺序确定调用的是哪一个方法。例如，调用方法 fun()时， 如果提供一个 float 参数，则是调用第一个 fun()方法，如果参数有两个，且第一个是 float 参数，第二个是int 参数，则是调用第二个 fun()方法。方法参数的名称不能用来区分重载方法。 ４．构造方法 构造方法是一种特殊的方法，这种方法的名与它的类名相同，并且不返回结果，也不写上 void 关键字。构造**方法的作用是创建类的对象，并给对象初始化。构造方法是**公共方法，但程序**不能显式调用**构造方法。程序运行时 ，当有对象要创建时，由系统自动调用构造方法。 [例 3.5]类内定义构造方法的例子。类 Point 定义了两个构造方法。class Point{ int x,y; Point(){ x=10;y=20; } Point(int x,int y){ this.x=x; this.y=y; } int getX(){return x;} int getY(){return y;}; } 如果类的声明没有定义构造方法，系统就增补一个没有参数的默认构造方法。 ３**.2.2 对 象** 类被声明后，就可用类创建对象，被创建的对象称为类的实例。程序使用对象需依次经历４个步骤：声明**对象、创建对象、使用对象和撤销**对象。 １．声明对象 由于类是一种引用类型（参见节后面叙述的对象的内存模型），声明对象只是命名一个变量，这个变量能引用类的对象。由于对象还没有创建，所以也暂不要为对象分配内存。声明对象的一般形式为： 类名 对象名； 例如，代码： Point p1,p2; 这里的 Point 是前面声明的类名，上述代码声明 p1,p2 两个对象。２．创建对象 创建对象就是为对象分配内存，为对象分配内存也称为类的实例化。一般形式为： new 构造方法([参数表]) 其中参数被构造方法用于给对象设置初值。例如，代码： p1 = new Point();p2= new Point(30,40); 对象p1 用无参数的构造方法初始化，使 p1 的x 坐标为 10,y 的坐标为 20，对象 p2 用带两个参数的构造方法初始化，使 p2 的x 坐标为 30,y 坐标为 40。 对象创建的两个也可一起完成，一般格式为： 类名 对象名 ＝ new 构造方法（[参数表]） 例如，代码： Point p3 = new Point(),p4=new Point(60,70); 同时创建两个 Point 对象，p3 的坐标为 10，y 的坐标为 20;p4 的坐标为 60,y 坐标为 70。３．对象的内存模型 Java 语言将类型分成基本类型和引用类型两种。第２章介绍的整型、浮点型、字符型等是基本类型，程序引用这种类型的变量，采用直接访问形式。 在 Java 语言中，数组类型和类类型是引用类型。程序访问引用类型的变量采用间接访问方式。４．使用对象 程序使用对象有多种情况：或为对象设置状态、或获取对象的状态、或改变对象的状态、或应用对象的某种方法。前三种需要访问对象的成员变量，最后一种要调用对象的方法。程序通过操作符“.”对某对象的成员变量进行访问和方法调用。一般形式为： 对象名.成员变量 对象名.方法（[参数表]） 参见例３.6，程序首先创建对象 p1 和p2，并利用对象提供的方法 getX()和 getY()，用代码 p1.getX()获得对象 p1 的属性值，p2.getY()获得对象 p2 的y 属性值。由于类 Point 声明中，成员变量是 public 的（参见 3.2.5 访问权限），程序也可以直接用代码 p1.x 获得对象 p1 的x 属性值；用代码 p2.y 获得对象 p2 的y 的属性值。 [例 3.6]使用对象的程序例子public class Examle3_1{ public static void main(String []args){ Point p1,p2,p3; p1 = new Point(); p2 = new Point(40,50); p3= new Point(p1.getX()+p2.getX(),p1.getY()+p2.getY()); System.out.println(“p3.x=”+p3.getX()+”,p3.y=”+getY()); Point p4 = new Point(p1.x,p.y); System.out.println(“p4.x=”+p4.x+”,p4.y=”+p4.y); } } //这里是类 Point 声明代码，限于篇幅，这里不再给出，参见３.5 中 Point 类的定义。 3.2.3 实例变量和类变量 类的成员变量又分为实例变量和类变量。在定义成员变量时，用关键字 static 修饰的是类变量，定义时未用**static 修饰的是实例变量**。例如，以下代码定义成员变量 x 是实例变量，成员变量 y 是类变量。 class D{ float x; static int y; … } 由前面的示例程序看出，程序定义的每个对象都有自己的实例变量。例如，前面程序中，对象 p1,p2,p3 和 p4 都有自己的实例变量 x 和 y。类变量是类的所有对象共享成员变量，一个类变量在类中只有一个，它属于整个类， 而不属于类的某个对象。引用**类变量途径有两条，或通过类，或通过对象**，格式如下： 类名**.类变量名 或 对象名.类变量名** 不同对象的实例变量将被分配不同的内存空间。改变类的某一个对象的实例变量的值不会影响其他对象的实例 变量。 类变量的**内存只有一处**，让类的所有对象共享。从类的任一对象改变类变量，类的其他对象都能发现这个改变。 ３．２．４ 实例方法和类方法 如同类的成员变量有实例变量和类变量两种一样，类的方法也有两种：实例方法和类方法。在方法定义时，冠以修饰字static 的方法称为类方法，没有冠以 static 修饰字的方法是实例方法。 [例 3.7]类 D 定义了一个实例方法，两个类方法。class D{ int a;//实例变量static int c;//类变量 float max(int x,int y)//实例方法 ｛a = x&gt;y?x:y;｝ static int setCount(int c0)//类方法 { c=c0;} static void incCount(int step)//类方法 ｛c+=step;｝ } 类中的实例方法可以互相调用，并可调用类方法。类方法也能相互调用，但不能直接调用实例方法，除非类方法引**入局部对象，然后通过局部对象调用实例方法。另外，类方法能直接引用类变量，不能引用**实例变量。实例方法可引用 实例变量，也可引用类变量。例如 ，例 3.8 给出的类声明中有些是合法的代码，而有些是不合法的代码。 [例 3.8]含不合法的代码的例子。程序的注释指明合法和不合法的原因class E{ float u; static float v; static void setUV(boolean f){ u = s_m(f);// 非法，类方法不可以调用实例变量 u v = s_m(f);//合法，类方法可以调用类方法 v = r_m(!f);//非法，类方法不能直接调用实例方法。 } static float s_m(boolean f){ return f?u:v;//非法，类方法只能 类变量 } float r_m(boolean f){ return f?u:v;//合法，实例方法能引用实例变量和类变量 } } 实例方法可以访问类变量和当前对象的实例变量。实例方法必须通过对象调用，不能通过类名调用。类方法只能类变量， 不能够访问实例变量。类方法除了可以通过实例对象调用之外，还可以通过类名调用。 [例 3.9]说明类变量用法的，应用程序。改写 Point 类的声明，在 Point 类中增加一个类变变量 pCount,它的初值为 0。在构造方法中，有类变量 pCount 增 1 的代码，这能记录类的对象个数。 public class Example3_2{ public static void main(String args[]){ Point p1,p2,p3; p1 = new Point(); p2 = new Point(40,50); p3 = new Point(p1.getX()+p2.getX(),p1.getY()+p2.getY()); System.out.println(“p3.x=”+p3.getX()+”,p3.y=”+p3.getY()); Point p4 = new Point(p1.x,p2.y); System.out.println(“p4.x=”+p4.x+”,p4.y=”+p4.y); System.out.println(“程序共有 Point 对象”+Point.pointNum()+ “个”); } } class Point{ int x,y; static int pCount =0; Point(){ x=10; y=20; pCount++; } Point(int x,int y){ this.x = x; this.y=y; pCount++; } static int pointNum(){return pCount;} int getX(){ return x; } int getY(){ return y; } } 由于 java 系统内设废弃内存回收程序，所以一般情况下，一个对象使用结束后，程序不必特别通知系统撤销对象。但有时为提高系统资源的利用率，程序也可通过调用方法 finialize()显式通知系统，请求系统撤销对象。 访问权限 访问权限实现访问控制。在类的成员中引入权限控制，保护类的成员不在非期望的情况下被引用。在类声明中，除了类中方法总能访问类的成员变量外，Java 语言为其他类的方法访问本类成员变量和方法，提供以下 4 种访问权限： public:设置没有限制的访问权限，其他类的方法都能访问。private：设置最强限制的访问权限，其他类的方法都不能访问。protected:只限于子类和同一包中的类的方法能访问。 ：(无修饰，友好的)只允许同一包中类的方法访问。 public(**共有**) 类的成员变量被设置成 public 访问权限，则类外的任何方法都能访问它。这样的成员变量就没有任何安全性，在应用程序中很少使用。通常，只有为对象设定的功能性方法被设置 public 访问权限，让类外的方法可以通过对象调用这样的方法，让对象完成它的服务功能。 private(**私有**) 类的成员变量被设置 private 访问权限，则类外的任何方法都不能访问它。方法被设置成私有的，通常这些方法是类内部专用的方法。类通常另定义一些 public 访问权限的方法，通过这些方法访问的成员变量，这样的成员变量的安全性能得到有效的保证。 protected**(受保护)** 受保护访问权限是一种公有权限和私有权限之间的访问权限。例如，在类 A 的声明中，成员 x 被定义成是受保护的， 则类A 的子类和与类 A 同一包中的别的类可以访问类 A 的受保护成员 x；但对于不是类 A 的子类或与类 A 不在同一包中别的类来说，不可访问受保护成员 x。通常同一包中的一些类与定义受保护成员的类有许多相关性，为了提高系统的效率，让这些相关类的方法可直接访问，这样的成员可考虑设置受保护访问权限。 友好变量和友好方法 没有修饰的成员变量和方法称为友好变量和友好方法。与受保护访问权限比较，如果只允许同一包中的相关类的方法访问，不让类的子类和其他类的方法访问时，可设置成友好变量和友好方法。 在同一源程序文件中的类，总是在同一包中，如果声明类 A 的源文件中用 import 语句引入了另外一个包中的类C，并用类 C 创建了一个对象 c，那么对象 c 将不能访问类 A 的友好变量和友好方法。如果一个类被修饰为 public 的，那么可以在任何另外一个类中使用该类创建对象。如果一个类不加任何修饰，那么在另外一个类中使用这个类创建对象时，要保证它们是在同一包中。 访问权限说明能访问的范围，表 3-1 是访问权限表，其中打勾的表示可访问，没有打勾的表示不可访问。 表 3-1 访问权限表 同类 同包的其他类 所有其他类 不同包的子类 public YES YES YES YES private YES protected YES YES YES &lt;无修饰&gt;(友好) Yes Yes 继承 继承是面向对象语言的重要机制。借助继承，可以扩展原有的代码，应用到其他程序中，而不必重新编写这些代码。在 java 语言中，继承是通过扩展原有的类，声明新类来实现的。扩展声明的新类称为子类，原有的类称为超类(父类)。继承机制规定，子类可以拥有超类的所有属性和方法，也可以扩展定义自己特有的属性，增加新方法和重新定义超类的方法。 java 语言不支持**多重继承，限定一个类只能有一个超类。在子类声明中加入 extends** 子句来指定超类。格式如下： class 子类名 extends 超类名 { 类体 } 例如，代码： class E extends D {…} 声明类 E 的超类是类 D，这里假定类 D 已在某处声明。类声明时，如果缺省 extends 子句，未指定超类，则该类的超类是系统声明的类 java.lang.Object. 子类对父类的继承性，java 语言作以下规定： 子类自然地继承其父类的**不是 private 的成员变量作为自己的成员变量，并且自然地继承父类中不是 private 的方法**作为自己的方法。 [例 3.10]继承声明子类的例子 程序先声明 Mother 类，定义了一些成员变量和方法。类 Daughter 继承类 Mother,并增加了一些成员变量和方法。 通过Daughter 类对象 girl，能调用从 Mother 类继承的方法，也能调用 Daughter 类新增的方法，或重新定义的方法。class Mother{ private int money; float weith,height; String speak(String s){return s;} float getWeitht(){return weight;} float getHeight(){return height;} String dance(){return “我会跳舞”;} } class Daughter extends Mother{ String cat; String sing(String s){return s;} String dance(){return “我是小舞蹈演员”;} } public class Example3_10{ public static void main(String argc[]){ Daughter girl =new Daughter(); girl.cat=”漂亮的帽子”; girl.weight = 35.0f; girl.height =120.0f; System.out.println(girl.speak(“ 我 是 女 儿 ”)); System.out.println(girl.speak(“我像母亲一样很会说话”)); System.out.println(girl.speak(“我重”+girl.weight + “公斤”)); System.out.println(girl.speak(“我高”+ girl.height + “公分”)); System.out.println(girl.speak(“我还比母亲多一顶”+girl.cat)); System.out.println(girl.sing(“ 我 还 能 唱 歌 ”)); System.out.println(girl.dance()); } } 程序的输出结果是： 我是女儿 我像母亲一样很会说话我重 35.0 公斤 我高 120.0 公分 我还比母亲多一顶漂亮的帽子我还能唱歌 在例 3.10 的程序中，子类 Daughter 中声明的方法 dance()，跟超类中的方法 dance(),方法的名字、参数的个数和类型完全相同，超类的 dance()**方法在子类中就被隐藏。当子类对象调用方法 dance()时，自然调用子类的 dance()方法。超类方法在子类中隐藏称为**重写或置换。当子类中定义的成员变量和超类中成员变量同名时，超类的成员变量同样会在子类中被隐藏。子类对成员变量的隐藏和方法的重写可以把超类的状态和行为改变为自身的状态和行为。对于子类对象， 如果子类重写了超类的方法，则子类对象调用这个方法时，调用子类方法。如果子类继承了超类的方法(未重写)，则会调用超类方法。 多态性 参见例 3.11，程序声明表示几何形状的类 Shape，通过继承类 Shape 声明圆类 Circle 和长方形类 Rectangle.这 3 个类都定义了求面积方法 area()。另在主类 Example3_11 中定义了一个方法 returnArea()，该方法以 Shape 类对象为参数，利用参数对象求出几何图形的面积。 面向对象语言规定，子类对象**也是**超类对象，凡超类对象可以应用的地方，子类对象也适用。将子类对象交给原本处理超类对象的方法 returnArea()时，方法 returnArea()也一样能正确工作。这样，调用方法 returnArea()时，可以提供Shape 类的对象，也可 Circle 类对象，或 Rectangle 类对象。即程序分别用Circle 类对象c 和 Rectangle 类对象r 调用方法 returnArea()也能正确执行。 上述要求，给编译系统带来了一个新问题。因为方法 reaturnArea()在被调用之前，是不知道调用的参数对象具体是哪一种类型，编译暂时不能利用参数s 的类型是Shape,就推断代码 s.area()是调用 Shape 类的求面积方法。如是这样，就会产生错误结果。这种编译时暂不绑定调用哪个方法，必须在运行时才绑定调用方法的技术称为**动态**联编。而代码 s.area()根据 s 在执行时实际对象的类型不同，调用同名的不同方法，是面向对象语言的一种多态性。解决这种多态性必须采用动态联编技术。由于 Java 语言采用动态联编技术，保证以下程序能得到希望的结果。 有人也将调用重载方法作为多态性之一。重载能由调用时提供的参数个数和参数的类型顺序，在编译时就能确定被调用的方法，这种多态性不需要动态联编技术的支持。 [例 3.11]说明多态性的程序例子 class Shape{ float area()// {return 0.0f;} } class Circle extends Shape{ float R; Circle(float r) { R = r; } float area() {return 3.1415926fRR;} } class Rectange extends Shape{ float W,H; Rectangle(float w,float h) {W=w;H=h;} float area()// {return W*H;} } public class Example3_11{ public static void main(String args[]){ Circle c; Rectangle r; c = new rectangle(3.0f,4.0f); System.out.println(“ 圆 面 积 =”+returnArea(c)); System.out.println(“长方形面积=”+returnarea(r)); } static float returnArea(Shape s){ return s.area(); } } 程序的输出结果是： 圆面积=31.415925 长方形面积=12.0 多层继承 继承声明的新类，又可被其他类再继承，从而构成多层继承。参见例 3.12，程序首先声明交通工具的类(Vehicle)， 再利用交通工具类，继承声明一个飞行器子类(Aircraft); 又从飞行器(Aricraft)类继承声明两个子类，螺旋直升机(Whirlybird)类和喷气机(Jet)类。这样，Whirlybird 类和Jet 类就是多层继承的类。 [例 3.12]一个多层继承的例子。class Vehircle{ public void start(){System.out.println(“Starting…”);} } class Aricraft extends Vehicle{ public void fly(){System.out.println(“Flying…”);} } class Whirlybird extends Aircraft{ public void whirl(){System.out.println(“Whirling…”);} } class Jet extends Aircraft{ public void zoom(){System.out.println(“Zooming…”);} } 多层继承中构造方法的调用顺序 参见例 3.13，类D 继承类 C，类C 继承类 B，类B 继承 A。当创建一个类 D 的对象 obj 时，由于类 D 的继承性，对象obj 含有它所继承的各超类的成员变量，需要调用所继承各超类的构造方法。问题是这样构造方法的调用顺序是怎样的。例子说明构造方法的调用顺序与类的继承顺序一致，从最高层次的超类开始，按继承调用各类的构造方法，如果子类的构造方法要调用超类的构造方法，就从超类继承的成员变量初始化，用代码 super(参见 3.2.7 关于关键字super 的叙述)，并且代码必须是**构造方法的第一条语句**。 [例 3.13］说明多层继承中构造方法调用顺序的例子class A{ int a; A(int a) {this.a = a; System.out.println(“Constructing A”);} } class B extends A{ int b; B(int a,int b) {super(a);this.b=b;System.out.println(“Constructing B”);} } class C extends B{ int c; C(int a,int b,int c) {super(a,b);this.c = c;System.out.println(“Constructing C”);} } class D extends C{ int d; D(int a,int b,int c,int d) {super(a,b,c);this.d = d;System.out.println(“Constructing D”);} } class Example3_13{ public static void main(String args[]){ D obj = new D(1,2,3,4); System.out.println(“对象 obj 的值是:”+obj.a+ “,”+obj.b+ “,”+obj.c + “,”+obj.d); System.out.println(“Main Program!”); } } 程序的输出结果是： Constructing A Constructing B Constructing C Constructing D 对象obj 的值是：1，2，3，4 Main Program! 3.2.7 Java 面向对象的其他机制 为了构造和编写面向对象程序的需要，Java 语言还引入一些非常用用的机制。本小节介绍其中对程序构造和编写比较有用的一些机制。 ​ 1. final 类、**final 方法和 final 变量** final 的意义是最终的，用于修饰类、方法和变量，其意思是“不能改变”。禁止改变可能是考虑到“设计”和“效率”两个方面。 在类声明之前用 final 修饰，声明类是 final 类，final 类是不能被再继承的类，即它不能再有子类。例如，以下代码声明类C 是 final 类： final class C{ … } 用 final 修饰的变量，声明该变量的值不能被改变。不能被改变的变量相当于一个常量。final 变量主要用于以下两**个方面：或是一个编译期的常数，它永远不会改变；或在初始化后，不希望它再改变**。例如，以下代码声明 FINALVAR 是一个 final 变量： final int FINALVAR = 100; final 局部变量在定义时可以暂不设定初值，但是一经初始化，以后就不能再改变。例如，以下代码： final int AFINAL; … …//假设这里的代码没有对 AFINAL 赋值AFINAL=1;//以后不能再给 AFINAL 再赋值 常用 final 声明常量，常量名习惯全部用大写字母命名。 abstract 类和 abstract 方法 abstract 类称为抽象类。抽象类只声明一种模板，没有具体实现代码的类。只有它的子类才能是有实际意义的类。所以抽象类**不可**有实例。即不能用抽象类声明或创建对象。 abstract 方法称为抽象方法。抽象方法只能出现在抽象类中，抽象方法没有实现的代码。如果一个类是抽象类的子类，则必须具体实现超类的抽象方法。抽象类**可以没有**抽象方法，但有抽象方法的类**一定**是抽象类。 [例 3.14]含抽象类和抽象方法的程序。abstract class Shape{ int x,y; void MoveTo(int newx,int newy){x = newx;y=newy;} Shape(int newx,int newy){x=newx;y=newy;} abstract void Draw(); } class Square extends Shape{ int len; Square(int px,intpy,int l){super(px,py);len =l;} void Draw(){ System.out.print(“我是正方形”); System.out.print(“我的中心位置是：”+”(“+x”,”+y+”),”); System.out.println(“我的边长是：”+len); //以x,y 为中心，边长 len 的正方形 } } class Circle extends Shape{ int radius; Circle(int px,int py,int r){super(px,py);radius=r;} void Draw(){ System.out.print(“我是圆形”); System.out.print(“我的中心位置是：”+”(“+x”,”+y+”),”); System.out.print(“我的半径是:”+radius); //以 x,y 为圆心，半径为 radius 的圆 } } class ShapeDraw{ void draw(Shape obj) {obj.Draw();}//利用动态联编，按实际对象调用相应的 Draw()方法 } public class Example3_14{ public static void main(String args[]){ ShapeDraw sd = new ShapeDraw(); Square s = new Square(10,10,5); Circle c = new Circle(30,30,5); sd.draw(s);//以 s 为实参调用 sd 的 draw 方法sd.draw(c);//以 s 为实参调用 sd 的 draw 方法 } } 程序的输出结果是： 我是正方形，我的中心位置是：(10，10)，我的边长是：20 我是圆形，我的中心位置是：(30，30)，我的半径是 5 关键字 super 子类隐藏了超类的成员变量或者覆盖了超类方法后，利用关键字 super，子类方法可以引用超类的成员变量和被覆盖的方法。使用 super 有 3 种情况：使用 super 调用超类的构造方法，参见多层继承中构造方法的调用顺序；使用 super 调用超类被子类覆盖的方法；使用 super 访问超类被子类隐藏的成员变量。 [例 3.15]使用 super 调用超类构造方法、超类方法和超类成员变量的程序。class A{ int x; A( int inf){x = inf;} void method(){System.out.println(“我是类 A 的方法!值是”+x);} int getX(){return x;} } class B extends A{ double x; B(int a,double b) { super(a); x = b; } void method(){System.out.println(“我是类 B 的方法!值是”+x);} } class C extends B{ char x; C(int a,double b,char c){ super(a,b); x=c; } void method(){ char chCx =x; int iAx = this.getX(); super.method(); System.out.println(“我是类 C 的方法!值是”+x); System.out.println(“我获得的信息是：”+“chCx=”+x+chCx+”,dBx=”+dBx+”,iAx=”+iAx); } } public class Example3_15{ public static void main(String args[]){ C c = new C(2,3,0,’C’); c.method(); } } 程序的输出结果是： 我是类 B 的方法!值是 3。0 我是类 C 的方法!值是 C 我获得的信息是：chCx=CC,dBx=3.0,iAx=2 关键字 this 关键字 this 用来指对象自己。this 的作用有多种，例如，将对象自己作为参数，调用别的方法；当方法的局部变量**隐藏成员变量时，利用 this 引用成员变量；在构造函数内调用**另一构造函数等。参见以下示例。 Class B{ int b,c; B(){this(2,3);} B(int x,int y){b =x ;c=y;} } 类之间的 is-a 和 has-a 关系 在两个相关的类之间，例如，类 A 和类 B，可能会有 is-a 和 has-a 关系。参见例 3.16，类 A 是继承扩展类B，则子类A 和超类 B 之间是 is-a 关系，类 B 的所有成员类 A 也有，类 A 也是一个类 B。 [例 3.16]类 A 继承扩展类 B，类 A 和类B 之间有is-a 关系。class B{ int b; B(int x){b =x;} void write(){System.out.println(“这是来自 B 的输出!”);} } class A extends B{ int a; A(int x,int y){ super(x); a = y; write(); System.out.printn(“我是子类 A!”+ “b=”+b+ “,a=”+a); } } public class Example3_16{ public static void main(String args[]) { a obj = new A(1,2); } } 程序的输出结果是： 这是来自类 B 的输出! 我是子类 A!b=1,a=2 如果类A 的某个成员变量的类型是B，则类A 和类B 之间是has-a 关系，即类**A 包含有类 B**。例 3.17 是 has-a 关系例子，类 A 中成员变量 b 的类型是 B。 [例 3.17]类 A 的某个成员变量的类型是 B，类 A 和类B 之间是 has-a 关系。 class A{ B b; int a; A(int x,int y,int z){ b = new B(x,y); a = z; b.write(); } } class B{ int b1,b2; B(int x,int y){ b1= x;b2=y; } void write(){ System.out.println(“这是来自类 B 的输出!”); } } public class Example3_17{ public static void main(String args[]){ A obj = new A(1,2,3); } } 程序输出结果是： 这是来自类 B 的输出! 内部类(inner class) Java 语言也允许在类声明内部嵌套类声明。嵌套的类可以是静态的或者是非静态的。静态类**不能直接引用其包含类的成员，**必须实例化，所以不经常使用。非静态的嵌套类，因为需要进行事件处理，非常流行。参见例 3.18，类 B 在类A 的内部声明，而且在类 A 的构造方法中实例化一个类 B 的内部对象。 [例 3.18]一个含内部类的程序class A{ B obj; A(){obj = new B(); obj.print();} class B{ public void print(){ System.out.println(“内部类 B…”); } } } public class Example3_18{ public static void main(String args[]) { A obj = new A(); } } 接口 Java 程序中的类只能继承一个类，这种继承称为单继承。Java 语言虽不允许一个类继承多个类，但允许一个类实现多个接口。接口(Interface)有与类相似的基本形式。接口有常量定义和方法定义，但没有方法的实现代码。可以将接口想象为一个“纯“抽象类。接口给出某种特定功能的一组方法的规范，而并未真正地实现每个方法，方法的实现要在实现这个接口的类中完成。接口也是对一些类为实现某些控制所建立的一个”协议“。例如，为键盘操作建立一个键盘操作， 定义了响应键盘操作的一组方法，给出每个方法的规范：方法的名称、返回值类型，参数个数与参数类型。实现键盘控制的一些类，加为它们对键盘操作的目的各有不同，各有不同的实现方案，但都必须按接口给定的规范给出自己的实现。形象地说，接口对实现接口的类提出这样的要求：“实现我的所有类，都应该包含像我现在这种样子，并给出方法的全部实现 ”。 类除了能继承一个类之外，还可实现多个接口。这样，对有继承并实现接口的类来说，实际上有了多个超类，实现有控制的多重继承。 接口的优点是很明显的。例如，在程序开发的早期建立一组协议而不给出具体实现，便于设计更合理的类层次。所以， 接口比多继承更强、更容易控制。 接口的定义 接口定义包括接口声明和接口体两部分。一般形式如下？ [public]interface 接口名 [extends 超接口表]{ 接口体 } 接口名通常以 able 或 ible 结尾，意指能做什么。接口是一种只由常量定义和抽象方法组成的特殊类。public 修饰的类是公共接口，可以被所有的类和接口使用；而没有 public 修饰的接口只能被同一个包中的其他类和接口使用。 接口体 接口体中的内容是一系列常量定义和方法定义。其中方法定义是一种方法声明，不提供方法的实现(没有方法体)， 用分号“；”结尾。方法的实现在“使用”这个接口的各个类中，故称使用接口的类为接口的实现。以下是一个 接口定义的示例： interface Sleepable{ final int max=100; void sleepSometime(int deltaT); float work (float x,float y); } 接口 的**所有变量**都默认为 final static 属性；所有的**方法**都默认为是 public abstract 属性。 一个类通过使用关键字 implements 声明自己使用一个或多个接口。实现多个接口时，接口名之间用逗号隔开。以下示例代码说明类 Pig 继承类 Animal 并实现两个接口 eatable 和 sleepable。 class Pig extends Animal implements Eatable, Sleepable {…} 如果一个类要实现某个接口，那么这个类**必须实现该接口的所有方法**，为这些方法实现的方法体。在实现接口 的方法时，方法的名字、返回值类型、参数个数及类型必须与接口中的定义的方法完全一致，并**一定要用 public 修饰**。如果接口的方法的返回值类型不是 void,那么在实现该方法的体中至少要有一个 return 语句；如果方法不返回值，则为 void 类型，类体除了两个大括号外，可以没有任何语句。 [例 3.19]声明接口和类实现接口的例子。interface Computable{ final int MAX =100; void speak(String s); int f(int x); int g(int x,int y); } class A implements Computable{ int no; public int f(int x){ int sum = 0; for(int i=0;i&lt;=x;i++){sum =sum+i;} return sum; } public int g(int x,int y) { return x*y; } public void speak(String s){ } } class B implements Computable{ int no; public int f(int x){ int sum =0; for(int i=0;i&lt;=x;i++){sum = sum+i*i;} return sum; } public int g(int x,int y){return x+y;} public void speak(String s){ } public class Example3_19{ public static void main(String args[]){ A Li; B Tom; Li = new A(); Li.no =951898; Tom = new B();Tom.no = 951899; System.out.print(“Li 的编号：”+Li.no+ “,最大值：”+Li.MAX); System.out.print(“, 从 1 到 100 求 和 =”+Li.f(100)); System.out.print(“,3 与 4 的 积 =”+Li.g(3,4)); System.out.print(“,Tom 的编号：”+Tom.no+ “，最大值：”+ Tom.MAX); System.out.print(“, 从 1 平 方 加 到 9 平 方 =”+Tom.f(9)); System.out.print(“,5 与 6 的和=”+Tom.g(5,6)); } } 程序的输出结果是： Li 的编号：951898，最大值：100，从 1 到 100 求和=5050，3 与 4 的积=12 Tom 的编号：951899，最大值：100，从 1 平方加到 9 平方=285，5 与 6 的和=11 基本类 Java 语言为一些基本类型设有对应的基本类，如表 3-2 所示。表 3-2 基本类型与基本类 基本类型 对应的基本类 基本类型 对应的基本类 boolean Boolean int Integer char Character long Long byte Byte float Float short Short double Double 基本类型值与对应基本类对象能相互转换。可以利用以下形式的基本类构造方法，由基本类型值得到对应基本类对象： public 基本类(基本类型 v) 例如，以下代码得到一个 Integer 对象，其值是 123 Integer n = new Integer(123); 也可以由基本类对象得到基本类型值。实现方法如以下例子所示： 设有 Double 类对象 dObj，Boolean 类对象 bObj,代码： double d = dObj.doubleValue(); 使得 dObj 对象的值赋值给 double 类型变量d。代码： boolean b = bObj.booleanValue(); bObj 对象的值赋值给 boolean 类型变量 b。类似的代码可以用于其他类对象与对应的基本类型变量。 Java 小应用程序基础 Java 小应用程序即 Java Applet，是嵌入在 Web 面上供浏览器运行的程序，可放在服务器上供客户端下载使用。小应用程序的主要功能是显示图形、动画、播放声音、响应用户事件等。每个小应用程序都继承 java.applet.Applet 类。 如果小应用程序已用 import java.applet.Applet 导入系统的 Applet 类，小应用程序的主类必须按以下形式声明： public class 主类名 extends Applet 如果没有用 import 导入系统 Applet 类，则主类的声明应写成： public 类名 extends java.applet.Applet 为了系统的安全，对小应用程序有一定限制:不能**调用本地的应用程序和运行时的**动态连接库；不能**访问**本地文件，如读、写文件；除原小应用程序所在的位置(站点)外，不能再做**网络连接与 WWW 建立联系，不能**获得任何有关系统设置的信息。 小应用程序的建立和运行 例 3．20 是一个简单的小应用程序的例子，说明小应用程序的建立和运行的步骤。 [例 3.20]说明小应用程序的建立和运行步骤的小应用程序。有关图形界面的内容参见第 5 章。类中各方法参见后面关于Applet 类的方法的叙述。该程序启动后，如果不断地切换屏幕，文字的显示位置会往下移动。 import java.applet. import java.awt.; public class Example3_20 extends Applet{ int pos; public void init(){pos =5;} public void start(){repaint();} public void stop(){} public void paint(Graphics g){ g.drawString(“我们正在学习 java 程序设计”，20，pos+10); pos = (pos+20)%100+5; } } 一个小应用程序从建立到运行需经历 4 个步骤： 用 Java 语言编写小应用程序的源程序。 小应用程序由若干类组成，在源程序中必须有一个类继承 java.applet.Applet 类，这个类是小应用程序的主类。小应用程序的主类，用 public 关键字修饰。小应用程序的源文件名必须与它的主类名完全相同。 把小应用程序的源程序编译成字节码**.class 文件。** 如果源文件有多个类，那么经编译后将生成多个.class 文件。 将小应用程序的字节码文件嵌入在 Web 页中，设计一个指定小应用程序的 HTML 文件.html。以下是启动小应用程序的 HTML 文件结构： String named by Programmer [CODE BASE =Applet 的 路 径 ] CODE = Applet 的字节码文件名WIDTH = Applet 在 Web 页中的宽度HEIGHT = Applet 在 Web 页中的高度[][&lt;!注释&gt;][可选的辅助文本] ​ (4) 在支持 Java 的浏览器上运行。 或用观察器 appletviewer，或用 Netscape、Hotjava、IE 等。如果采用某个 Java 开发环境。也可在开发环境下执行小应用程序。 Applet 类的基本方法**(1)init()**方法 初始化，由浏览器载入内存时调用 init()方法，该方法**只运行一次**。其用途是创建所需要的对象、设置初始状态、装载力图像、设置参数等。 start()**方法** 初始化后，紧接着调用 start()**方法、启动小应用程序主线程，或当用户从小应用程序所在的 Web 页面转到其他页面， 然后又返回该页面时，start()**方法将再次被调用 。 stop()**方法** 当浏览器离开小应用程序所在的页面转到其他页面时，调用 stop()方法，挂起小应用程序的执行。(4)destroy()**方法** 当关闭浏览器时，系统调用 destroy()方法，结束小应用程序的生命，关闭线程释放对象资源。 paint(Graphics g)**方法** 该方法用于在屏幕窗口上显示某些信息。如文字、色彩、背景和图像等。当小应用程序启动时，浏览器产生一个 Graphics 类的对象，供小应用程序使用，并以参数g 传递给方法 paint()。小应用程序可以把 g 理解为一支画笔。 小应用程序主类的程序结构如下： public class AppletName extends java.applet.Applet{ public void init(){…} pulic void start(){…} public void stop(){…} public void destroy(){…} public void paint(Graphics g){…} … } repaint()**方法** 为在 java 页面上显示动态效果，需要 repaint()方法，repaint()调用 update(),repaint()先清除 paint()方法以前所画的内容，然后再调用 paint()方法。 在例 3.20 的小应用程序中，start()方法调用 repaint()方法，因此每当小程序调用 start()方法时，将会导致以前用paint()方法所画的内容消失，并紧接着再调用 paint()方法。由于 paint()方法对显示字符串的位置有修改，这样每当调用 start()方法时，字符串的显示位置会移动。 update()**方法** 调用 repaint()方法时，系统会自动调用 update()方法。update(Graphics g)方法是从父类 Applet 继承来的，该方法的功能是清除 paint()方法以前所画的内容，然后再调用 paint()方法。小应用程序重写 update()方法，可以达到特定的要求。参见 7.2.1 例 7.3。 小应用程序的生命周期**(执行过程)** (1)下载并实例化小应用程序，系统调用 init()方法。(2)启动，系统调用 start()方法。 小应用程序暂停执行，或因Browser 转向其他网页，或小应用程序调用stop()方法，或小应用程序执行paint(Graphics g)方法 重新启动，或重新进入小应用程序所在页面，重新激活小应用程序，或小应用程执行 paint(Graphics g)方法完成。(5)终止，或退出浏览器，或执行 destroy()消亡方法。 当浏览器打开超文本文件，例如 Example3_20.html,发现有 APPLET 标记时，就创建主类 Example3_20 对象，该对象是小应用程序主类的实例，具体表现是一个视窗。视窗是一个容器，它的大小由超文本中的 width 和 height 来确定，参见第5 章。 小应用程序数据输入输出 小应用程序的数据输入有多种方式。从图形界面的文本框、文本区输入；也可以采用系统标准输入；还可以由 HTML 文件 中的参数导入。 这里只小应用程序从它的 HTML 文件导入 参数的方法。设小应用程序有以下成员变量定义： int sleepTime;String filename; 该小应用程序的 HTML 文件 用以下形式的代码指定小应用程序主类成员变量 sleepTime 与 fileName 的值： 小应用程序在 init()方法中可帮以下代码读取上述两个成员变量的值： String s = getParameter(“sleeptime”); sletpTime = Integer.parseInt(s); fineName = getParameter(“filename”); 小应用程序在窗口中输出数据，需要重新设计 paint()方法。该方法主要调用 drawstring()方法。调用 drawString() 方法的格式如下： g.drawString(string,xPos,yPos); 参数 string 是要输出的字符串，xPos 和 yPos 是字符串在输出窗口的像素坐标。 习题 什么是面向对象技术？它有什么优点？ 面向对象的程序设计与面向过程的程序设计有什么区别？ 在程序中类和对象有什么区别？ 举例说明类方法和实例方法，以及类变量和实例变量的区别。什么情况下用实例变量？什么情况下用类变量？ 子类继承超类的哪些成员变量和方法？ 子类在什么情况下能隐藏超类的成员变量和方法？ 在子类中是否允许有一个方法和超类的方法名字相同，而类型不同？ 试说出对象、类、继承和多态性的概念。 为什么要定义抽象类？为什么抽象类没有具体的对象？ 试比较接口和抽象类的异同。使用接口有哪些注意事项？ 指出 Applet 的程序结构及各方法的作用。 以下程序有什么错误？","link":"/2020/11/06/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%95%99%E6%9D%90%E7%94%B5%E5%AD%90%E7%89%88/"},{"title":"中国近现代史纲要","text":"中国近现代史纲要第一章反对外国侵略的斗争 一、鸦片战争前的中国与世界 1、中国封建社会的主要矛盾：地主阶级同农民阶级的矛盾P2 2、中国封建社会的基本特点：P2 1) 在经济上，封建土地所有制占主导地位； 2) 在政治上，实行高度中央集权的封建君主专制制度； 3) 在文化上，以儒家思想为核心； 4) 在社会结构上，是族权和政权相结合的封建宗法等级制度。 3、中国封建社会由盛转衰的主要表现:P3 1) 政治上，中央集权进一步强化，官僚职能扩大； 2) 经济上，人口大增长、各级官吏和地主大肆兼并土地，广大农民生活日渐困苦； 3) 思想文化上，厉行专制主义，大兴文字狱； 4) 军事上，军力衰败，军备废弛； 5) 对外关系上，实行闭关锁国政策，严格限制对外贸易，使中国处于与世隔绝的状态。 4、资本主义制度在欧美主要国家的确立以及殖民扩张对中国的威胁P3-4 （1）鸦片战争前，欧美主要国家先后确立了资本主义制度。通过工业革命，资本主义发展迅速。 1640年英国资产阶级革命标志着世界进入了资本主义时代。美国、法国等相继确立资本主义制度。资本主义制度建立后发生了工业革命。高效率的大机器生产取代了原来的低效率的手工工场生产。 （2）资本主义国家对外发动侵略战争，实行殖民扩张。 资本主义商品生产需要原料和产品市场，资本主义制度确立后，西方资本主义国家靠殖民主义的军事、政治、经济和文化侵略方式把一些国家变为其资本主义市场的一部分。中国成为其扩张对象的命运已在所难免，战争不可避免。 二、资本——帝国主义对中国的侵略及近代中国社会的演变 1、（1）资本—帝国主义列强发动侵华战争以及迫使清政府签订的一系列不平等条约。P5-6 侵华战争主要有：第一次鸦片战争、第二次鸦片战争、中法战争、中日甲午战争、八国联军侵华战争； 不平等条约主要有：《南京条约》、《天津条约》、《北京条约》、《马关条约》、《辛丑条约》。 （2）资本—帝国主义列强制造的屠杀中国居民的惨案：P6 1894年日本在中国的旅顺大屠杀； 1900年八国联军在北京庄王府杀害义和团和平民； 1900俄国制造的“江东六十四屯”惨案。 （3）教案：中国人民反对宗教侵略而被中外勾结所镇压的事件。P8 （4）通商口岸：P9 1842年《南京条约》开：广州、厦门、福州、宁波、上海； 1858年《天津条约》开：牛庄（营口）、登州（烟台）、台湾（台南）、淡水、潮州（汕头）、琼州、汉口、九江、南京、镇江； 1860年《北京条约》开：天津； 陆路开：伊犁、喀什噶尔。 （5）近代中国半殖民地半封建社会的特点：P12-13 1) 资本－帝国主义日益成为支配中国的决定性力量。 2) 中国的封建势力同外国侵略势力相勾结。 3) 中国自然经济的基础虽然遭到破坏，但是封建地主的土地所有制依然存在。 4) 中国资本主义有所发展，但没有成为中国社会经济的主体。 5) 近代中国各地区经济、政治和文化发展是极不平衡的。 6) 人民毫无政治权利和生活的极端贫困化。 2、（1）资本－帝国主义列强对中国的政治控制:P7-8 1) 控制中国内政； 2) 操纵中国外交； 3) 享有领事裁判权； 4) 把持中国海关； 5) 勾结清政府、镇压人民反抗； 6) 扶植、收买代理人。 （2）资本－帝国主义列强对中国的经济掠夺：P9-10 1）控制中国通商口岸； 2）剥夺中国关税自主权； 3）对华倾销商品； 4）对华资本输出； 5）操控中国经济命脉。 （3）资本－帝国主义列强制造的侵略中国的舆论：P10-11 利用宗教进行渗透和侵略，鼓吹侵略有功和“种族优劣论”，为侵略战争制造舆论。 3、（1）近代中国资产阶级的产生及其两部分P13 资产阶级是近代中国新产生的阶级，是在外国资本主义入侵的影响和刺激下，主要由一些买办、商人、地主、官僚投资新式企业转化而来。分为：1）官僚买办资产阶级；2）民族资产阶级。 （2）近代中国工人阶级的形成以及特点P14 近代中国诞生的被压迫阶级是工人阶级。诞生在外国在华企业中，比中国资产阶级年龄和资格更老，社会基础和社会力量更大。 中国工人阶级的自身特点： 1）受帝、封、资三重压迫，革命性最强； 2）人数虽少，却相对集中（地域上集中在沿海沿江的通商口岸城市、行业上主要集中在纺织、采矿、铁路、航运等行业），易于组织并便于形成革命的力量和传播先进思想； 3）大多来由破产农民和家庭家庭手工业者转化而来，与农民有天然联系，便于结成工农联盟。所以，中国工人阶级最先进、最革命、最有力量。 半殖民地半封建社会的主要矛盾与近代以来中华民族面对的两大历史任务及其关系P14-16 主要矛盾：1）帝国主义同中华民族的矛盾，是最主要的矛盾；2）封建主义同人民大众的矛盾 关系：两对主要矛盾相互交织在一起，贯穿整个半殖民地半封建社会的始终，并对中国社会的发展变化起着决定性作用。 1）当外国列强向中国发动侵略战争时，为避免亡国灭种的危险，中国内部各阶级，除了汉奸、卖国贼外，能够暂时团结起来共同对敌，阶级矛盾降到次要地位，而民族矛盾上升到主要地位（鸦片战争、中法战争、中日甲午战争、八国联军侵华等）； 2）当外国侵略者同中国封建政权相勾结，共同镇压中国革命，尤其是封建地主阶级对人民的压迫特别残酷时，中国人民往往用战争的形式反对封建政权，这时阶级矛盾就上升为主要矛盾（太平天国农民起义、辛亥革命）； 3）国内战争发展到直接威胁帝国主义在华利益以及中国封建地主阶级统治时，外国列强往往直接出兵，镇压中国人民，援助中国反动派，这时帝国主义和国内封建主义完全公开站在一条战线上（太平天国农民起义后期中外反动势力的勾结）。 两大历史任务：一是求得民族独立和人民解放；二是实现国家富强和人民共同富裕。 二者的关系：既相互区别，又相互联系。 区别：主体、内容不一样。前者要改变民族受压迫、人民受剥削的地位和状况，要从根本上推翻半殖民地半封建的社会统治秩序，解决生产关系问题；后者是要改变近代中国经济文化和社会落后的地位和状态，是要充分发展近代民族工商业，解决生产力问题。 联系：完成第一大任务是为第二大任务完成创造条件。 一方面，前者是前提条件，只有实现民族独立人民解放，才能废除列强强加的不平等条约，才能推翻封建专制制度，改变买办和封建生产关系，解放生产力，开辟走向现代化的道路。 另一方面，争取民族独立和人民解放的最终目的是使中国走向现代化，实现国家繁荣和人民共同富裕，是中华民族自立于世界民族之林。 三、抵御外来侵略、争取民族独立的斗争 1、（1）三元里人民抗英斗争：1841年5月，广州三元里人民抗英斗争，是中国人民在近代史上最早的反侵略武装斗争。P16 （2）台湾人民的反侵略斗争：P16-17 1）1867年，美海军入侵台湾，副舰长马肯基被击毙； 2）1874年，日陆军入侵台湾，高山族人民迎头痛击； 3）1895年，台湾人民与刘永福率领黑旗军共同抗击日本侵略； 4）1895年，台湾军民对抗日军两个近代化师团和一支海军舰队，日军死伤惨重。 （3）为国捐躯的清政府爱国将领：P17 第一次鸦片战争中：广东水师提督关天培、江南提督陈化成； 第二次鸦片战争中：大沽炮台提督史荣椿、乐善； 中日甲午海战中殉国的将领：左宝贵、北洋舰队统帅丁汝昌、管带邓世昌、林永升、刘步蟾。 （4）林则徐、魏源与睁眼看世界：P20 林则徐成为近代中国睁眼看世界的第一人。 魏源编纂了《海国图志》，提出了“师夷长技以制夷”的思想。 （5）严复与“救亡”口号：P21 1895年，严复在《救亡决论》一文中响亮的喊出“救亡”口号。 2、19世纪末帝国主义瓜分中国的图谋及其失败的原因P18-19 图谋：19世纪70年代到90年代，自由竞争的资本主义向垄断资本主义即帝国主义过渡出现列强争夺殖民地狂潮。19世纪70年代至80年代使中国陷入“边疆危机”。列强瓜分中国的图谋在1894年中日甲午战争爆发后达到高潮。 失败原因： 1）帝国主义列强之间的矛盾和相互制约。 2）中国人民不屈不挠的反侵略斗争。（根本原因） 3、近代中国人民反侵略斗争失败的原因P19-20 1）社会制度的腐败。这是根本原因。清政府统治在进入近代以后，社会制度未变，更腐败。后还与侵略者勾结起来，把广大中国人民视为最主要的敌人。人民的反侵略战争和爱国官兵的抵抗常常因此导致失败。 2）经济技术落后是中国人民反侵略战争失败的有一个重要原因。西方工业革命后经济技术和军事装备飞速发展，中国经济总量小，工业技术落后，必然被动挨打。经济技术落后必然影响的武器装备、军队素质、综合实力等方面远不如人。 4、第一次鸦片战争至辛亥革命前夕，先进中国人民族意识的觉醒P20-21 鸦片战争前大夫和一般中国人的观念：上朝天国。鸦片战争后开始逐步变动，产生了民族意识的觉醒 1)“师夷长技以制夷”的主张和早期的维新思想。林则徐成为近代中国睁眼看世界的第一人。魏源编纂了《海国图志》，提出了“师夷长技以制夷”的思想。主张学习外国先进的科学技术，以期国家富强来抵御外国侵略。开创了中国近代学习西方的先河。洋务运动中有马建忠、王韬、郑观应等的早期维新思想，主张变革封建专制制度。 2)救亡图存与振兴中华。1895年，严复在《救亡决论》一文中响亮地喊出了“救亡”的口号。康有为亦要求中国人发愤自救。 3)民族危机激发了中华民族的觉醒，增强了中华民族的凝聚力，救亡图存成了时代的主旋律。孙中山创立革命团体——兴中会，喊出了“振兴中华”这个时代的最强音。 4)近代以来志士仁人，就是在怀着强烈危机感和民族意识下，在救亡图存，振兴中华大旗下，探索挽救中华民族的道路的。 第二章对国家出路的早期探索 一、农民群众斗争风暴的起落 1、（1）洪秀全与金田起义：P24-25 金田起义：1851年1月，洪秀全率领拜上帝教教众在广西省桂平县金田村发动起义，建号太平天国。 （2）天京事变：P27 天京事变：1856年9月，发生了天京事变，东王杨秀清、北王韦昌辉先后被杀，翼王石达开率部出走后败亡。 2、（1）《天朝田亩制度》的性质和主要内容P25-26 性质：最能体现太平天国社会理想和这次农民战争特点的涉及政治经济和社会生活的纲领性文件。 主要内容：确立了平均分配土地的方案。规定了农副业产品的生产与分配。《天朝田亩制度》涵盖了从经济基础到上层建筑的多方面问题。 （2）《资政新篇》的性质和主要内容P26-27 性质：是一个带有鲜明的资本主义色彩的改革与建设方案。但是，通篇未涉及农民问题和土地问题。 主要内容： 1）在政治方面，主张“禁朋党之弊”，加强中央集权；学习西方，制定法律、制度。 2）在经济方面，主张发展近代工矿、交通、邮政、金融等事业；吸取外国的科学技术，奖励科技发明和机器制造；提出“准富者请人雇工”，即提倡资本主义的雇佣劳动制。 3）在思想文化方面，提出设新闻官、设“暗柜”，用以监督官员，改革弊政；主张革除缠足、溺婴等社会陋习；提倡兴办学校、医院和社会福利事业。 4）在外交方面，主张同世界各国交往、通商；强调允许外国人为天国献策，但不得诽谤国法。 3、太平天国失败的原因和教训P29 失败原因：根本原因是缺乏先进阶级的领导； ●不能提出完整、正确的政治纲领和社会改革方案 ●没有科学理论的指导。 ●无法长期保持领导集团的团结，无法制止统治集团内部腐化现象和封建等级制思想的的滋生 ●在对外问题上，对外国资本主义列强侵华实质缺乏理性的认识。 经验教训：太平天国起义的发生和失败表明，在半殖民地半封建社会，农民具有伟大的革命力量，但它不能担负起领导反帝反封建斗争取得胜利的重任。 4、太平天国的历史意义P28 太平天国起义虽然失败了，但它具有重要的历史意义。 第一，它沉重打击了封建统治阶级，强烈撼动了清政府的统治根基。1）从规模、持续时间（14年之久）、影响的深度上看，均大于以往历次农民起义。2）在太平天国起义的影响下，各地各族反清起义风起云涌（如天地会起义，捻军起义及各族起义等）。加速了清王朝的衰败过程。 第二，它是中国旧式农民战争的最高峰，具有了不同于以往农民战争的新的历史特点。1）最高峰：太平天国建立了自己的政权，提出了《天朝田亩制度》，比较完整地表达了千百年来农民对拥有土地的渴望。2）新特点：《资政新篇》则是中国近代史上第一个具有资本主义色彩的方案，反映出太平天国具有了不同于以往农民战争的历史特点。 第三，太平天国严厉批判孔子及儒家经典，一定程度上削弱了封建统治的精神支柱。（联系封建社会特点中的文化特征理解） 第四，太平天国农民战争有力地打击了外国侵略势力。太平天国领袖们拒绝不平等条约，严禁鸦片贸易。当中外反动势力勾结共同镇压太平天国时，太平天国将士们进行了英勇的斗争。 第五，在19世纪中叶的亚洲民族解放运动中，太平天国农民战争也属于时间最长、规模最大，它和其他亚洲国家的民族解放运动汇合在一起，冲击了西方殖民主义在亚洲的统治。 二、地主阶级统治集团“自救”活动的兴衰 1、（1）奕与洋务派：P30 奕是倡导洋务的首领； 封建统治阶级中的部分成员如奕、曾国藩、李鸿章、左宗棠、张之洞、刘坤一等，主张学习西方的武器装备和科学技术，以“自强”、“求富”为目标，兴办洋务，这些官员被称为洋务派。 （2）总理各国事务衙门：P30 1861年，清政府成立总理各国事务衙门，作为综理洋务的中央机关。 2、洋务派举办的洋务事业P31-32 一是兴办近代企业（包括军用工业和民用工业）； 二是建立新式海军； 三是创办新式学堂、派遣留学生。 3、洋务运动失败的原因P33-34 1）洋务运动具有封建性。洋务运动的指导思想是“中学为体，西学为用”，维护封建的上层建筑、经济基础的条件下学习西方发展一些近代企业。 2）洋务运动对西方列强具有依赖性。●在中国近代半殖民地半封建进程日益深重的情况下，越是积极引进西方的“船坚炮利”，也就越加深了对西方列强的依赖性。●西方列强通过扶植洋务派，达到控制和操纵清廷的目的。 3）洋务企业的管理具有腐朽性。洋务派所办的新式企业在管理方面仍采取封建衙门式的管理方法，使洋务企业缺乏应有的生机和活力。企业内部官僚化、贪污中饱、挥霍浪费等现象十分严重。 清朝统治集团中的顽固势力的阻挠也是原因之一。 4、洋务运动的历史作用P32-33 1）在客观上促进了中国早期工业和民族资本主义的发展。洋务派继承了魏源的“师夷长技以制夷”的思想，以“求强”、“求富”为目标，发展军事工业，发展若干民用企业，使资本主义经济成份在社会经济中明显增长。 2）成为中国近代教育的开端。为了培养新式外交、军事、科技人才，洋务派开办了一批新式学堂，派出了最早的官派留学生，这是中国近代教育的开始。 3）传播了新知识，打开了人们的眼界。洋务派翻译了一批西学的书籍，介绍西方近代的科学文化知识，给当时的中国带来新知识、新学问，开阔了人们的眼界。 4）引起了社会风气和价值观念的变化。随着洋务运动的兴起和资本主义生产方式的出现，传统的价值观念也受到冲击，社会风气也有所改变这都有利于资本主义的发展，有利于社会风气的转变。 三、维新运动的进行和夭折 1、（1）康有为、梁启超与维新派：P34-35 资产阶级维新派的主要代表人物：康有为（旗手）、梁启超、谭嗣同、严复等； （2）“百日维新”：P36 1898年6月11日，光绪皇帝颁布《明定国是诏》为开始标志，1898年9月21日慈禧太后发动“戊戌政变”，为结束标志。 （3）“戊戌六君子”：P37 谭嗣同、刘光第、林旭、杨锐、杨深秀、康广仁； 2、（1）维新派宣传变法的维新主张的活动P35 1）向皇帝上书； 2）著书立说； 3）介绍国外变法； 4）办学会、办报纸、设学堂。 （2）维新派与守旧派的论战P35-36 1）要不要变法； 2）要不要兴民权、设议院，实行君主立宪； 3）要不要废八股、改科举和兴学堂。 实质是资产阶级思想与封建主义思想在中国的第一次正面交锋，为维新变法运动作了思想舆论的准备。 3、戊戌维新运动失败的原因和教训P38-39 原因： 1）主要原因在于维新派自身的阶级局限（中国民族资本主义经济力量十分弱小，民族资产阶级的社会基础相当狭窄，这是根本原因）和以慈禧太后为首的强大的守旧势力的反对。 2）具体原因： ●不敢否定封建主义。在政治上不敢根本否定封建君主制度；经济上没有触及封建主义的经济基础——封建土地所有制；思想上借孔子之名“托古改制”。 ●对帝国主义抱有幻想。一直幻想西方列强帮助自己变法维新。 ●脱离人民群众。维新派的活动范围很有限，基本上局限于一些官僚士大夫和知识分子，没有得到广大人民群众的支持。而且害怕人民群众。 教训：戊戌维新是中国民族资产阶级登上政治舞台的第一次表演。戊戌维新的失败不仅暴露出这个阶级的软弱性，同时也说明在半殖民地半封建的中国，企图通过统治者进行自上而下的改良的道路，是行不通的。要想实现国家的独立、民主、富强，必须采用革命的手段。 4、戊戌维新运动的历史意义和影响P37-38 戊戌维新运动虽然失败了，但却具有进步的历史意义和影响。 （1）戊戌维新运动是一次爱国救亡运动。维新派在国难当头、瓜分危机迫在眉睫的关头挺身而出，掀起了变法图存、维护民族独立和发展资本主义的救国运动，反映了时代的要求。 （2）戊戌维新运动是（中国最早的）一场资产阶级性质的政治改革运动。冲破了洋务派“中体西用”思想的局限，鼓吹民权，提倡设议院，主张用君主立宪制来取代君主专制制度。尽管维新运动未能成功，但（在新的角度上）冲击了封建制度。 （3）戊戌维新运动是一场思想启蒙运动。维新派大力传播西方的社会政治学说，宣传天赋人权、自由平等、社会进化等观念，批判封建君权和封建纲常伦理，有利于民主主义思想在中国的传播。在维新派的推动下，形成广泛的文化革新运动，并对近代教育发展起了积极作用。 （4）戊戌维新运动在改革社会风气方面也有不可低估的意义。维新派主张革除吸食鸦片及妇女缠足等陋习，主张“剪辫易服”，倡导讲文明、重卫生、反跪拜等。 第三章辛亥革命 一、举起近代民族民主革命的旗帜 1、（1）孙中山与兴中会的建立P43 1894年，孙中山在檀香山成立兴中会，是中国第一个资产阶级革命组织； 1895年，在香港成立总部，“驱除鞑虏，恢复中华，创立合众政府”为誓词。 （2）中国同盟会P44 1905年8月，在东京成立同盟会。同盟会以“驱除鞑虏，恢复中华，创立民国，平均地权”为纲领，机关报为《民报》。是近代中国第一个全国性资产阶级性质政党。 2、（1）三民主义学说的基本内容P44-45 三民主义学说包括民族主义、民权主义、民生主义。 1）民族主义内容：驱除鞑虏，恢复中华。 2）民权主义内容：“创立民国”，即推翻封建君主专制制度，建立资产阶级的民主共和国。 3）民生主义内容：“平均地权”。 （2）资产阶级革命派的阶级基础和骨干力量P42 1）中国资产阶级民主革命派的阶级基础是中国民族资产阶级。 2）资产阶级革命派的骨干力量是一批资产阶级、小资产阶级知识分子。 3、清末“新政”及其破产P41-42 1901年4月设立督办政务处，宣布实行“新政”； 1906年宣布“预备仿行宪政”，1908年颁布《钦定宪法大纲》，制定了一个学习日本实行君主立宪的宪法，但又规定了9年的预备立宪期限。预备立宪并没有能够挽救清王朝，反而激发了社会矛盾，加重了危机。 4、革命派与改良派的论战及其意义P45-46 论战：1905年至1907年，以孙中山为代表的革命派与以康有为为代表的改良派，分别以《民报》和《新民丛报》为主要舆论阵地展开论战。 1）要不要以革命手段推翻清政府，这是论战焦点。 2）要不要推翻帝制、实行共和； 3）要不要进行社会革命 意义：这场论战以革命派胜利告终，具有重要的意义。 1）论战划清了革命与改良的界限，使人们清楚地认识到实行民主革命的必要性，参加到革命的行列。 2）论战使资产阶级民主思想和三民主义思想得到了更加广泛的传播，促进了革命力量的壮大，为推翻清朝统治的革命斗争奠定了思想基础。 局限性：由于阶级的和历史的局限性，革命派未能对中国民主革命一系列根本问题作出完全正确的回答。 1）革命派未能认清帝国主义的本质，不仅不敢旗帜鲜明地提出反帝口号，反而希望争取帝国主义的支持。 2）革命派停留在对民主制度的形式理解上，缺乏对民主建政的深入认识，其方案也不十分具体和具有可操作性。 3）革命派未能把土地制度改革和反对封建主义联系起来，从而无法真正解决农民土地问题。 二、辛亥革命的胜利与失败 1、（1）保路风潮P47 1911年，反对清政府出卖粤汉、川汉铁路路权给帝国主义的运动。四川省最为激烈，成为武昌起义的导火索。 （2）武昌起义P47 1911年10月10日，新军中的革命党人打响了武昌起义的第一枪，随即全国响应，从此掀起辛亥革命的高潮。 （3）《中华民国临时约法》P48 1912年3月，临时参议院颁布，是中国历史上第一部具有资产阶级共和国宪法性质的法典。它确认了资产阶级共和国的政治制度。 （4）袁世凯与复辟帝制P50-52 1916年元旦，袁世凯称洪宪皇帝。在人民的反对声中，于83天后取消。 （5）“二次革命”P53 1913年因袁世凯刺杀宋教仁和“善后大借款”而起，因战场主要在九江和南京而被称作“赣宁之役”，又称“二次革命”。 2、（1）中华民国南京临时政府的性质P48 南京临时政府是一个资产阶级共和国性质的革命政权。各项政策措施集中体现了中国民族资产阶级的愿望。 1）在人员构成上，资产阶级革命派控制着这个政权。革命党人和中同盟会会员担任着政府重要部门的主要职务； 2）在实行的各项政策措施上，集中体现了中国民族资产阶级的愿望和利益，也一定程度上符合广大中国人民的利益； 南京临时政府也有局限性。一是承认清政府与列强所定的一切不平等条约和所欠的一切外债。二是没有提出可以满足农民土地要求的政策和措施。 （2）旧民主主义革命的终结P53 第二次护法战争的失败，标志着中国旧民主主义革命的终结。 1919年10月，孙中山将中华革命党改组为中国国民党，讨伐桂系军阀，后恢复军政府，领导第二次护法大战，但陈炯明的叛变导致失败。 3、北洋军阀的统治以及孙中山反对北洋军阀的斗争P50-54 北洋军阀的黑暗统治 1）在政治上，北洋政府实行军阀官僚的专制统治。一方面，大力扩充军队，建立特务、警察系统，剥夺人民的言论、出版、集会、结社等各种政治权利，任意逮捕、杀害革命党人和无辜民众。另一方面，毁弃辛亥革命过程中孙中山苦心缔造的资产阶级民主制度。 2）在经济上，北洋政府竭力维护帝国主义、地主阶级和买办资产阶级的利益。 3）在文化思想方面，北洋政府尊孔复古。 以孙中山为首资产阶级革命派对革命果实的捍卫： 1）发动“二次革命”，反对袁世凯对民主制度的摧残。 2）组织中华革命党，反对袁世凯专制统治。 3）发动护国战争，反对袁世凯称帝。 4）发动第一次护法运动，反对段祺瑞破坏《临时约法》、拒绝恢复国会。 5）发动第二次护法运动。第二次护法战争的失败，标志着中国旧民主主义革命的终结。 4、辛亥革命胜利的历史意义以及局限性P49-50 历史意义：辛亥革命是一次比较完全意义上的资产阶级民主革命，是中国人民救亡图存、振兴中华的一个里程碑，具有伟大历史意义。 1）它推翻了清王朝，沉重打击了中外反动势力； 2）结束了中国两千多年的封建君主专制制度，创立了中华民国； 3）是一场思想解放运动，开启了思想进步和民族觉醒的大门； 4）促使社会经济、思想习惯和社会风俗等发生新变化； 5）打击了帝国主义在华势力，为亚洲各国人民革命斗争提供范例，并推动民族解放运动的高涨。 局限性：资产阶级革命派自身的软弱性。 1）没有提出彻底的反对帝国主义和反对封建主义的革命纲领。没有明确的反帝纲领，幻想以妥协退让来换取帝国主义的承认和支持。他们只强调反满和建立共和政体，没有认识到反对整个封建统治阶级，最终把政权交给了同是封建势力代表袁世凯。 2）没有充分发动和依靠民众。不敢依靠反封建的主力军农民群众，甚至压制人民的革命行动。 3）没有建立坚强的革命政党，发 挥团结一切革命力量的强有力的核心作用。同盟会的组织松懈，派系纷杂。辛亥革命后，有的主张解散同盟会，有的另建党派、自立山头。“革命军起，革命党消”。 经验教训：中国资产阶级革命派的软弱性以及由此而来的辛亥革命的局限性，使辛亥革命难以摆脱失败的命运。辛亥革命只推翻一个清朝政府，而没有推翻帝国主义和封建主义的压迫和剥削，没有完成反帝反封建的根本任务。 辛亥革命的失败表明，资产阶级共和国的方案没有能够救中国，先进中国人需要进行新的探索，为中国谋求新的出路。 第四章开天辟地的大事变 一、新文化运动与五四运动 1、（1）陈独秀与新文化运动的兴起P57 1915年9月陈独秀在上海创办《青年杂志》（后改名为《新青年》），成为新文化运动兴起的标志。 （2）五四运动P59 五四运动爆发的直接导火索：巴黎和会和中国的外交失败。 1919年5月4日至6月3日前，学生为主力，中心在北京；6月3日后到6月下旬，工人阶级为主力，中心在上海。 2、（1）俄国十月革命对中国革命的影响P58 十月革命推动中国先进分子从资产阶级民主主义转向社会主义。 李大钊最先由民主主义者转变为共产主义者，成为中国最早的马克思主义者。 （2）五四运动爆发的社会历史条件P59 1）新的时代条件。它发生在俄国十月革命所开辟的世界无产阶级社会主义革命的新时代。 2）新的社会力量——中国工人阶级的成长。随着第一次世界大战期间民族资本主义经济迅速的发展，中国的工人阶级和民族资产阶级的力量也进-步壮大起来。（1919年五四运动前夕，中国产业工人已达200万人左右） 3）新文化运动——思想解放潮流的推动。为五四运动准备了最初的群众基础和骨干力量。 3、（1）五四以前新文化运动的局限P58 由于历史条件的局限，五四以前的新文化运动也存在明显的缺点。 1）（脱离现实经济基础）新文化运动的倡导者没有揭示封建专制主义得以存在的社会根源；脱离经济而把资产阶级共和国方案失败的根本原因归之于思想文化，是错误的（有唯心主义之嫌）。他们提倡的资产阶级民主主义，不能有效地对中国社会进行改造。 2）（脱离广大劳动群众）他们把改造国民性置于优先地位，但是又脱离改造产生封建思想的社会环境的革命实践，没有把运动普及到工农群众中去，仅仅依靠少数人的呐喊，其目标就难以实现。 3）（思想方法形式主义）少数人在思想方法上存在绝对肯定或绝对否定的形式主义偏向（有形而上学之嫌）。 （2）五四运动的直接导火线即直接斗争目标P59 巴黎和会上中国外交的失败是五四运动爆发的直接导火线。 1919年5月4日至6月3日前，学生为主题，中心在北京，高呼“外争国权，内除国贼”、“拒绝合约签字”、“取消二十一条”、“还我青岛”、“诛卖国贼曹汝霖、章宗祥、陆宗舆”等口号；6月3日后到6月下旬，工人阶级为主力，中心在上海。北洋军阀政府于6月10日释放学生，罢免曹、章、陆职务，6月28日未出席巴黎和约签字。 4、（1）新文化运动的主要内容及历史意义P56-57 主要内容：提倡民主和科学。 1）民主主要是指资产阶级的民主思想和民主制度，倡导造就法国式的资产阶级共和国；民主还提倡个性解放，平等自由，造就自主、自由的人。 2）科学主要指自然科学，提倡以科学的精神和科学的方法来研究社会。 历史意义：是一场有民主主义知识分子领导的资产阶级民主主义革命性质的思想启蒙运动，具有重要历史意义。 1）它是资产阶级民主主义的新文化同封建主义旧文化的斗争，是辛亥革命在思想文化领域的延续，沉重打击了封建专制主义。 2）它大力宣传了民主和科学，启发了人们的理智和民主主义觉悟，将人们从封建专制所造成的蒙昧中解放出来，开启了思想解放的潮流。 3）它为中国先进分子接受马克思主义作了准备，为以五四运动为开端的中国新民主主义革命创造了思想文化上的条件。 （2）五四运动的历史意义P60 五四运动是在新的时代和新的社会历史条件下发生的，具有以辛亥革命为代表的旧民主主义革命所不具备的历史特点和历史意义。 1）是中国近代史上一次彻底的反帝反封建的革命运动，表现了反帝反封建的彻底性。把中国人民反帝反封建的斗争提升到一个新的水平线上。 2）是一场真正的群众性的革命运动。青年学生起了先锋作用，中国工人阶级开始登上政治舞台，在运动后期发挥了主力军作用。 3）促进了马克思主义在中国的广泛传播，促进了马克思主义同中国工人运动的结合，为中国共产党的成立作了思想和干部上的准备。一方面，工人阶级运动促进知识分子寻找同其结合的方式。另一方面，具有初步共产主义思想的知识分子在实际斗争中逐步转变成为马克思主义者。 4）五四运动是中国新民主主义革命的伟大开端。五四运动发生在俄国十月革命之后，中国革命逐渐成为世界无产阶级社会主义革命的一部分。五四运动以后，无产阶级逐渐代替资产阶级成为近代中国民族民主革命的领导者。 二、马克思主义传播与中国共产党的诞生 1、（1）李大钊与马克思主义在中国的传播P61 1919年11月李大钊发表的《我的马克思主义观》。 （2）中国共产党早期组织P62 中国第一个地方共产党组织：上海共产主义小组，1920年8月成立，是党的发起组和联络中心 （3）中共一大P64 中国共产党一大：1921年7月23日在上海召开。大会通过了中国共产党第一个纲领和第一个决议。 （4）中共二大P65 中国共产党二大：1922年7月在上海召开。通过的大会宣言中，强调了一大提出的最高纲领，首次针对本殖民地半封建国情的分析，提出了党的反帝反封建的最低纲领。解决了个革命的对象和动力，分清了敌我。 2、（1）早期马克思主义思想运动的历史特点P61-62 1）重视对马克思主义基本理论的学习，明确地同第二国际的社会民主主义划清界线。中国的马克思主义思想运动一开始就坚持了马克思主义的革命原则和正确方向。 2）注意从中国的实际出发，学习、运用马克思主义的理论。（中国早期马克思主义者已经在实际上初步形成了马克思主义应当与中国实际相结合的思想，尽管在当时还没有明确提出这个命题。） 3）开始提出知识分子应当同劳动群众相结合的思想。（李大钊主张知识分子要忠于民众、作民众的先驱，要到民间去，向农村去。） （2）中国共产党成立初期领导发动的工农运动P66-67 1）工人运动方面：1921年8月，中国共产党在上海成立中国劳动组合书记部，这是党领导工人运动的专门机关。1922年1月香港海员举行大罢工。1922年9月，安源路矿工人举行大罢工。1923年2月京汉铁路工人举行大罢工。全国发生大小罢工187次，参加人数在30万以上。 2）农民运动方面：积极成立农民协会，组织农民开展反抗地主压迫与剥削的斗争。1921年9月，沈定一等在浙江萧山成立第一个农民协会，彭湃在广东省海丰县成立海丰县总农会，毛泽东在湖南开展农民运动。 3、（1）中国共产党的早期组织及其活动P62-64 1920年2月，陈独秀、李大钊筹建； 中国第一个地方共产党组织：上海共产主义小组，1920年8月成立，是党的发起组和联络中心；北京、上海、武汉、长沙、济南、广州等也成立了早期组织；日本、法国有中国留学生组成共产党早期组织。 1）进一步研究和宣传马克思主义。 注重马、恩、列宁原著学习，宣传马克思主义和俄国革命的经验。三次论战：“问题与主义”论战“；关于社会主义的论战；同无政府主义的论战，扩大了马克思主义的影响力。 2）大力组织和开展工人运动，到工人中去开展宣传和组织工作。 出版适宜工人的通俗刊物，创建工会和劳动学校等，中国共产党早期组织领导的第一个产业工会：1920年11月李中主持成立的上海机器工会。 3）进行关于建党问题的讨论和实际组织工作。 上海共产党发起组制定了《中国共产党宣言》，社会主义青年团在上海成立，成为共产党的后备力量，蔡和森给毛泽东的信探索了建党的问题。 共产党早期组织的活动，进一步促进了马克思主义同中国工人运动的结合，为中国创建统一的工人阶级先锋队组织准备了条件。 （2）中国共产党制定的民主革命纲领及其意义P66 党的二大宣言规定了中国共产党的最高纲领和最低纲领。 最高纲领：实现社会主义、共产主义； 最低纲领：消除内乱，打倒军阀，建设国内和平；推翻国际帝国主义的压迫，达到中华民族完全独立；统一中国为真正的民主共和国（民主革命阶段时期）。 意义：在是中国近现代历史上第一次明确的提出了反帝反封建的民主革命纲领。中国共产党开始采取走群众路线的革命方法，“打倒列强，除军阀”逐渐成为广大群众的共同呼声。 4、中国共产党成立的历史特点和意义P64-65 特点：中国共产党是在特殊的社会历史条件下成立的，具有以下两方面特点： 1）（“原汁原味”）是直接承继列宁主义而来，没有受到修正主义影响。中国共产党是按照列宁的建党原则建立起来的。所接受的是没有被修正主义阉割的马克思主义的完整的科学世界观和社会革命论，是科学社会主义； 2）（“根正苗红”）是在半殖民地半封建中国的工人运动基础上产生的。中国工人阶级具有坚强的革命性，不存在欧洲那种工人贵族阶层，没有社会改良主义的基础； 所以，中国共产党一开始就是一个以马克思列宁主义理论为指导思想的党，是一个区别于第二国际社会改良党的新型工人阶级革命政党。 意义：中国共产党的成立是一个“开天辟地的大事变” ，使中国革命的面目就焕然一新了。具有划时代的伟大意义。 1）中国革命终于有了一个坚强的领导核心。中国共产党不仅代表着中国工人阶级的利益，而且代表着中国人民和中华民族的利益。它的成立使中国革命有了可信赖的组织者和领导者，使中国工人阶级有了自己的司令部；（比较以往农民阶级和资产阶级政党） 2）中国革命从此有了一个科学的指导思想。中国共产党以马克思列宁主义基本原理观察和分析中国的问题，为中国人民指明了斗争的目标、革命的前途和走向胜利的道路；（比较以往农民阶级和资产阶级指导理论） 3）沟通了中国革命与世界革命的联系，把中华民族的解放运动同世界无产阶级社会主义革命运动相联结并成为其中一部分，使中国革命有了新的前途；（以往是以资本主义为奋斗目标和前途） 总之，如毛泽东指出，自从有了中国共产党，中国革命的面目就焕然一新了。 三、国共合作与国民革命 1、（1）中共三大P68 1923年6月在广州召开。会议决定全体共产党员和共青团员以个人名义加入孙中山的国民党，确立了建立个革命统一战线的方针政策。 （2）国民党一大P68 1924**年1月在广州召开。大会宣言对三民主义作了新的阐释，确立了联俄、联共、扶助农工三大政策**，成为第一次国共合作的政治基础。大会的成功召开，标志着以第一次国共合作为基础的革命统一战线正式形成。 （3）北伐战争P70 1926**年5月**，叶挺独立团等北伐先遣军进入湖南，揭开了北伐战争序幕。1926年7月9日，国民革命军举行誓师典礼，北伐战争正式开始。 （4）中共四大P70 1925年1月召开。提出了民主革命中无产阶级领导权和工农联盟问题。 2、（1）第一次国共合作的政治基础及组织形式P68-69 1924年1月，中国国民党第一次全国代表大会确立了联俄、联共、扶助农工三大政策，成为第一次国共合作的政治基础。 大会宣言对三民主义作了新的阐释，新三民主义和中共在民主革命时期的纲领在基本原则上是一致的，成为国共合作的政治基础和革命统一战线的共同纲领 （2）国民革命的兴起P69 中共西湖特别会议和中共三大的召开。孙中山改组国民党。国民党一大通过的宣言对三民主义作了新的解释，成为国共合作的政治基础和共同纲领；改组后的国民党成为四个阶级的革命联盟。国民党一大标志着第一次国共合作的正式形成，国民革命由此兴起。工农群众运动的恢复和发展，黄埔军校的创办，冯玉祥的北京政变及孙中山的北上。中共四大提出了无产阶级在民主革命中的领导权以及工农联盟问题。五卅运动开始的全国范围大革命风暴，省港工人大罢工是中国工人运动史上前所未有的壮举，对大革命高潮的形成起了重要推动作用。 3、北伐战争的胜利进展及其原因P70 胜利进展：北伐军制定了集中兵力、各个歼敌的战略方针：以主力进军两湖，消灭吴佩孚；引兵东向，消灭孙传芳；北上解决张作霖。革命势力从珠江流域推进到长江流域和黄河流域，“打倒列强，除军阀”歌声响彻大江南北。 原因： 1）国共合作的实现，革命统一战线的建立，特别是共产党员和共青团员的先锋模范作用是北伐胜利的重要原因； 2）北伐军得到广大工农群众的大力支持； 3）北伐战争得到苏联政府的多方面援助，特别是派出的军事顾问帮助北伐军制定了正确的军事战略战术。 4、国民革命的意义以及失败的原因与教训P72-73 意义：尽管失败了，但具有不可磨灭的历史意义。 1）它沉重打击了帝国主义和封建主义的统治势力，中国人民的觉悟程度和组织程度有了明显的提高，是迎接未来革命胜利的一次伟大的演习； 2）它扩大了中国共产党在中国人民中的政治影响，宣传了党在民主革命阶段的纲领，使党经受了一次大革命的洗礼，积累了初步的经验。中国共产党人正是从这场革命的失败中汲取教训，开始懂得进行土地革命和掌握革命武装的重要性，为把中国革命推进到新的土地革命战争阶段准备了必要的条件。 原因： 1）客观上，帝国主义和中国封建主义势力的联合力量大大超过刚刚兴起的革命联合力量，敌我力量悬殊；革命统一战线内部出现剧烈分化，蒋介石、汪精卫先后分裂统一战线，制造反共政变，使革命力量遭到严重损失； 2）主观上，以陈独秀为首的中共中央领导机关在大革命后期犯了右倾机会主义错误，放弃了无产阶级对于农民群众、城市小资产阶级和民族资产阶级的领导权，尤其是武装斗争的领导权； 总体上讲，中国共产党处于幼年时期，缺乏对中国社会和中国革命基本问题的深刻认识，缺乏革命经验尤其是处理同资产阶级的复杂关系的经验，还不善于把马克思主义基本原理和中国革命的实践结合起来。当时的中国共产党作为共产国际的一个支部，直接受共产国际的指导。共产国际及其在中国的代表虽然在这次大革命中起了积极的作用，但也出了一些错误的主意。共产国际的错误指导，对酿成陈独秀右倾机会主义错误有直接影响。 第五章 中国革命的新道路 一、国民党在全国的统治和中间党派的政治主张 1、（1）东北易帜 P76 张学良1928年12月29日宣布东北遵守三民主义，服从国民政府，改易旗帜。北洋军阀时代结束，国民党就在全国范围内建立自己的统治 。 （2）官僚资本 P78 和国家政权结合在一起的国家垄断资本；同外国帝国主义、本国地主阶级密切地结合着，成为买办的封建的国家垄断资本；是蒋介石反动政权的经济基础。 2、中间党派及其社会基础 P80 中间党派是20世纪二三十年代活跃在中国政治舞台上，处于国共两党之间的党派。 社会基础：民族资产阶级和上层小资产阶级及其知识分子。 3、（1）国民党的独裁统治 P76-77 1）为了镇压人民和消灭异己力量，国民党建立了庞大的军队。广大人民被置于国民党武装的严密控制和监视之下； 2）为了镇压人民和消灭异己力量，国民党还建立了庞大的全国性特务系统。（“中统” “军统”），反对共产党，破坏革命运动，绑架或暗杀革命者和异己分子； 3）为了控制人民，禁止革命活动，国民党还大力推行保甲制度。“将广大人民被禁锢在保甲制度之内； 4）为了控制舆论，剥夺人民的言论和出版自由，国民党还厉行文化专制主义； 国民党政府主要就是通过这些方法，来维护帝国主义、封建主义、官僚资本主义的利益，巩固自身统治的。 （2）中国国民党临时行动委员会 P80 中国国民党临时行动委员会（“第三党”） 1930年8月建立，由一部分国民革命时期的国民党左派和一些国民革命失败后因为各种原因脱离共产党组织的人士组成。 立场和主张： 1）一方面不满国民党当局的内外政策；另一方面又错误地认为中国共产党的革命主张不适合中国国情。希望国共之间另立一个新党，走另一条“复兴中国革命” 的道路； 2）政治上主张进行“平民革命”，推翻国民党的独裁统治，建立各级平民政权；经济上主张实行土地国有，实现“耕者有其田”。 4、国民党统治下的中国社会经济 P77-79 1）帝国主义控制更紧：国民党政府是在帝国主义的支持下建立的，从1927年国民党政府成立到1937年，帝国主义的经济势力在中国得到进一步扩展，并且牢牢地掌握了中国的经济命脉。国民党内蒋介石集团从总体上看是以英美为自己的靠山； 2）封建地主经济仍占优势：国民党统治时期，在中国的社会经济生活中占优势地位的，仍然是封建经济； 3）官僚资本迅速膨胀：官僚资本是中国的垄断资本，它控制了全国的经济命脉，和国家政权结合在一起，成为国家垄断资本，是蒋介石反动政权的经济基础。官僚资本的垄断活动主要靠控制金融、商业投机、垄断工业，挤压排斥民族工商业的发展。 综上所述：国民党的反动统治代表着帝国主义、封建主义和官僚资本主义的利益，在本质上是与北洋军阀一样的。因此，在当时，推翻国民党的反动统治成为新民主主义革命的主要目标。 二、中国共产党对革命新道路的艰苦探索 1、（1）八七会议 P82 1927年8月7日在汉口召开的中央紧急会议。结束了陈独秀右倾机会主义错误，确定了土地革命和武装斗争的方针，是大革命失败到土地战争兴起的历史转折点。 （2）毛泽东与湘贑边界秋收起义 P83 1927年9月，毛泽东领导发动湘赣秋收起义。 （3）《星星之火，可以燎原》 P85 1930年1月，毛泽东提出了乡村为中心的思想，初步形成了农村包围城市、武装夺取政权的理论。 （4）兴国土地法 P87 1929年4月，毛泽东在兴国发布第二个土地法，是对井冈山土地法的原则性改正：将“没收一切土地”改为“没收一切公共土地及地主阶级的土地”。 2、（1）南昌起义的意义P83 1）打响了武装反抗国民党反动统治的第一枪。体现了中国共产党人为实现中国人民的根本利益和中华民族的解放事业而前赴后继的革命精神； 2）成为共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端； 3）它揭开了土地革命战争的序幕。 （2）井冈山革命根据地创建的意义 P83 井冈山农村革命根据地的建立及意义 1）点燃了“工农武装割据”的星星之火,为共产党领导的其他各地的起义武装树立了榜样； 2）从实践上开辟了一条在敌我力量悬殊的情况下，共产党深入农村保存和发展革命力量的正确道路； 3）代表了1927年革命失败后中国革命的发展方向。 （3）红军反“围剿”作战的胜利 P86 1）1930年10月至1931年7月，在毛、朱等指挥下，贯彻积极防御的方针，实行“诱敌深入”、“避敌主力、打其虚弱”等一整套行之有效的战术，连续粉碎了国民党军队的三次“围剿”； 2）三次反“围剿”作战的胜利，使赣南、闽西根据地连成一片，形成拥有21座县城、250万人口、5万平方公里的中央革命根据地； 3）同时，鄂豫皖、湘鄂西等根据地的反“围剿”战争也取得重大胜利，根据地得到了发展。 （4）土地革命中的阶级路线和土地分配方法 P86-87 1）1931年2月，毛泽东等人还规定了土地革命中的阶级路线：即坚定地依靠贫农、雇农，联合中农，限制富农，保护中小工商业者，消灭地主阶级； 2）土地分配方法：即以乡为单位，按人口平分土地，在原耕地的基础上，实行抽多补少、抽肥补瘦。土地革命的开展，充分调动了根据地农民发展生产和参军参战的积极性。 3、（1）中国红色政权存在和发展的原因及条件 P85 1）中国是几个帝国主义国家间接统治的政治经济发展极端不平衡的半殖民地半封建的大国；（根本原因） 2）国民革命的影响和全国革命形势的继续向前发展；（客观条件） 3）相当力量的正式红军的存在； 4）共产党组织的坚强有力和各项政策的正确贯彻执行；（主观条件） （2）“工农武装割据” P85 1）1928年，毛泽东在《中国红色政权为什么能够存在？》和《井冈山的斗争》两篇文章中第一次明确提出了“工农武装割据”的思想 2）阐述了共产党领导的土地革命、武装斗争与根据地建设三者之间的辩证统一关系，强调“工农武装割据”的思想，是共产党和割据地方的工农群众必须具备的一个重要思想。 4、中国共产党人对革命新道路的艰辛探索。 P84-85 1）土地革命战争的兴起和人民军队的创建，中国共产党发动武装斗争和土地革命。 2）农村包围城市，武装夺取政权道路的开辟，红军反“围剿”作战的胜利与土地革命的深入。(或者) 开展武装反抗国民党统治的斗争 A、1927年8月，中共中央在汉口召开紧急会议（八七会议），彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党方针。八七会议以后，举行了南昌起义、湘赣边界秋收起义、广州起义。中国革命由此发展到了一个新阶段。 B、走农村包围城市的革命道路??以农村为重点，到农村去发动农民，进行土地革命，开展武装斗争，建设根据地，这是1927年以后中国革命发展的客观规律所要求的。农村包围城市、武装夺取政权这条革命心道路的开辟，依靠了党和人民的集体奋斗，凝聚了党和人民的集体智慧。而毛泽东是其中的杰出代表。 C、毛泽东不仅在实践中首先把革命进攻的方向指向了农村，而且从理论上阐明了武装斗争的极端重要性和农村应当成为党的工作中心的思想??1928年，毛泽东写了《中国的红色政权为社么能够存在？》、《井冈山的斗争》等文章，明确指出以农业为主要经济的中国革命，以军事发展暴动，是一种特征；还科学阐明了共产党领导的土地革命、武装斗争于根据地建设这三者之间的辩证统一关系。1930年，《星星之火可以燎原》一文中，毛泽东指出：红军、游击队和红色区域的建立和发展，是半殖民地中国在无产阶级领导下的农民斗争的最高形式，和半殖民地农民斗争发展的必然结果，并且无疑议的是促进全国革命高潮的最重要因素。 D、农村包围城市，武装夺取政权理论，是对1927年革命失败后中国共产党领导的红军和根据地斗争经验的科学概括。它是以毛泽东为代表的中国共产党人同当时党内盛行的把马克思主义教条化、把共产国际和苏联经验神圣化的错误倾向做坚决斗争基础上形成的。??农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义：毛泽东思想的初步形成。 E、随着革命心道路的开辟，中国革命开始走向复兴。中国共产党领导的红军和根据地逐步发展起来。红军游击战争实际上已经成为中国革命的主要形式，农村根据地成为积蓄和锻炼革命力量的主要战略阵地。 三、中国革命在探索中曲折前进 1、（1）中华苏维埃第一次全国代表大会 P88 1931年11月,中华苏维埃第一次全国代表大会在江西省瑞金举行，成立中华苏维埃共和国临时中央政府，毛泽东当选为主席。 （2）“贑南会议” P90 1931年11月召开的中央苏区党组织第一次全国代表大会，会议取消了毛泽东同志在中央根据地红军中的领导地位。 （3）反福建“罗明路线”的斗争 P90 对坚持贯彻毛泽东的路线的福建省党的领导人罗明进行了错误的批判 （4）中央红军的战略大转移 P91 1934年10月中旬，中共中央机关和中共中央红军8.6万人撤离根据地，向西突围转移，开始震惊中外的长征。 2、（1）革命根据地的建设 P88-89 1931年11月,中华苏维埃第一次全国代表大会在江西省瑞金举行，成立了中华苏维埃共和国临时中央政府；中华苏维埃共和国实行各级工农兵代表大会制度，是中国历史上第一次有了真正代表人民利益的政府。 1）动员和组织根据地军民大力发展农业生产，组织开展互助合作运动，成立劳动互助社、犁牛合作社，合理调节人力、物力，提高劳动生产率； 2）同时积极进行经济建设，随着农业生产的恢复和发展，手工业也有了长足发展，公营的军需工业、厂矿企业也建立起来； 3）创办学校，注重文化教育事业的发展，提高工农群众的的文化水平。 （2）20世纪二三十年代中国共产党内连续出现“左”倾错误的原因 P90 在20世纪20年代后期和30年代前期，中共党内先后出现了“左”倾盲动主义、“左”倾冒险主义和“左”教条主义错误，其原因是多方面的。 1）八七会议以后，党内一直存在着的浓厚的近乎拼命的冲动，始终没有能够从指导思想上得到认真的清理； 2）全党的马克思主义理论准备不足，理论素养还不高，实践经验也很缺乏，王明又时时搬出马克思主义的词句来吓唬人，容易使一些干部受到蒙骗。 3）共产国际的干预以及对王明的全力支持，更使许多人失去了识别和抵制能力。 3、王明“左”倾教条主义的主要错误及其危害 P89-90 主要错误： 1）在统一战线问题上，民族资产阶级视为中国革命最危险的敌人，一味排斥和打击中间势力； 2）在革命道路问题上，继续坚持以城市为中心，将准备城市工人的总同盟罢工和武装起义作为共产党最主要的任务，指令根据地的红军采取“积极进攻的策略”，配合攻打中心城市； 3）在土地革命的问题上，提出坚决打击富农的主张； 4）在反“围剿”的军事斗争问题上，实行消极防御的方针； 5）在党内斗争和组织问题上，推行“残酷斗争，无情打击”方针。 危害： 1）使中国共产党及其领导的中国革命又一次陷入困境，党的六届四中全会后，共产党在国民党统治区的工作出现一片混乱，党的组织遭到严重破坏； 2）对坚持正确路线的毛泽东及支持毛的中央根据地干部实行排挤和打击政策； 3）1933年蒋发动第五次“围剿”，博古依赖共产国际军事顾问，主张“御敌于国门之外”，采取消极防御方针导致反“围剿”失败，这是“左”倾错误进一步发展的恶果。 4、（1）遵义会议的召开及其意义 P92 召开：1935年1月15日至17日，中共中央政治局在遵义召开扩大会议。会议集中全力解决了当时具有决定意义的军事和组织问题。 1）经过激烈的争论，多数人同意毛泽东为代表的正确意见，批评了博古、李德在第五次反“围剿”中的错误； 2）会议增选毛泽东为中央政治局常委。会后不久，成立了由毛泽东、周恩来、王稼祥组成的新的三人团，全权负责红军的军事行动。 意义： 1）遵义会议在极其危急的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命，开始确立了以毛泽东为代表的新的中央的领导，成为中国共产党历史上一个生死攸关的转折点；（“三个挽救，一个转折”） 2）标志着中国共产党在政治上走向成熟。（遵义会议的一系列重大决策，是在中国共产党同共产国际中断联系的情况下，独立自主地作出的。） 3）证明中国共产党是具有自我净化（具有自身纠错能力）和自我发展的能力的，通过总结成功的经验和失误的教训，不断地把党及党所领导的革命事业不断推向前进的。 （2）红军长征的胜利及其意义 P92-93 1934年10月开始到1936年10月，红二、四方面军先后同红一方面军在甘肃会宁、静宁将台堡会师，胜利结束长征。 1）它粉碎了国民党“围剿”红军、消灭革命力量的企图，是中国革命转危为安的关键； 2）通过长征，把中国革命的大本营放在了西北，这为迎接中国人民抗日救亡的新高潮准备了条件； 3）长征保存并锤炼了中国革命的骨干力量。尽管经过长征，革命的力量遭受严重损失，但是，这些保存下来的、经历了千锤百炼的骨干，是党和红军极为宝贵的精华； 4）长征播撒了革命的火种。它向沿途的人民群众宣布，“只有红军的道路，才是解放他们的道路”，只有在中国共产党的领导下，中国各族人民才能翻身得解放； 5）长征铸就了伟大的长征精神。长征精神，就是把全国人民和中华民族的根本利益看得高于一切，坚定革命的理想和信念，坚信正义事业必然胜利的精神；就是为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲的精神；就是坚持独立自主、实事求是，一切从实际出发的精神；就是顾全大局、严守纪律、紧密团结的精神；就是紧紧依靠人民群众，同人民群众生死。 第六章中华民族的抗日战争 一、日本发动灭亡中国的侵略战争 1、（1）九一八事变 P96 1931年9月18日，日本在东北沈阳制造借口而发动，是日本发动侵华战争的开始。 （2）华北事变 P97 1935年，日本在华北制造了一系列事端，向中国政府提出华北政权“特殊化”的要求，这一系列事件被称作“华北事变”，是进一步侵华的事变。 （3）卢沟桥事变 P97 1937年7月7日，驻丰台日军借口一名士兵失踪，炮轰宛平城，挑起卢沟桥事变，发动全面侵华战争。中国驻军奋起反抗，中国人民抗日战争进入全民族抗战的新阶段。 （4）伪“满洲国” P98 1932年3月在长春建立，溥仪为形式上的首脑，实权控在日本手中，东北实际沦为日本的殖民地。 2、日本灭亡中国的计划及其实施 P96-97 1）田中义一主持的“东方会议”将对外扩张的“大陆政策”具体化； 2）日本制造九一八事变、华北事变、卢沟桥事变，发动全面侵华战争； 3）日军占领广州、武汉后，被迫停止对正面战场的战略性进攻，实施“以华治华”和“以战养战”策略。 3、日本在中国占领区的殖民统治 P98 日本发动侵华战争后，在占领区扶植傀儡政权，实行极端残暴的军事殖民统治。 1）对台湾的殖民统治。自1895年《马关条约》，日本开始了对台湾50年的殖民统治，日本驻台湾总督掌握立法、行政、司法、军事权； 2）对东北的殖民统治。九一八事变后，日本在中国东北实行了14年的殖民统治。1932年3月建立的伪“满洲国”实权控制在日本手中； 3）扶植汪伪政权。1938年12月，中国国民党副总裁汪精卫叛国投敌。1940年3月，在日本的操纵下，汪精卫在南京成立伪“中华民国国民政府”，其实质是日本独占殖民地。 4、日本侵略者给中华民族造成的深重灾难 P98 日本对中国的大规模武装侵略和在其占领区的殖民统治，给中华民族造成了极为深重的灾难。 1）制造了惨绝人寰的大屠杀。1937年12月，“南京大屠杀”死者达30万人以上；在其他地方制造许多屠杀惨案，对抗日根据地开展大规模的“扫荡”， 实行“杀光、烧光、抢光”的“三光”政策； 投放有毒病菌，大量中国居民死亡；用中国人进行“活体解剖”；掳掠大量的中国劳工，强迫一些中国妇女充当“慰安妇”。 2）疯狂掠夺中国的资源与财富。 在东北，独占了东北全部重工业和铁路交通，控制了东北的经济命脉，掠夺矿产资源；在关内，对华北和华中的经济掠夺；日本侵略者还大肆掠夺占领区的土地及农产品。 3）强制推行奴化教育。目的是泯灭中国民众的民族意识和反抗精神、维护其殖民统治。 4）损失数字：战争期间，中国军民伤亡3 500多万人；按1937年的比值折算，中国直接经济损失1 000多亿美元，间接经济损失5 000多亿美元。 二、从局部抗战到全国性抗战 1、（1）蔡哈尔抗日同盟军 P101 1933年5月，原西北军将领冯玉祥在张家口成立。同盟军北路前敌总指挥吉鸿昌是中国共产党员（后被国民党当局杀害）。 （2）国民党第十九路军抗日反蒋事变 P100-101 1933年11月，国民党第十九路军将领蔡廷锴、蒋光鼐以及国民党内李济深、陈铭枢等反蒋爱国人士在福州举行抗日反蒋事变，组建政权。此前，第十九路军代表同中央根据地的红军代表签署了《反日反蒋的初步协定》。 （3）《中国人民对日作战的基本纲领》 P101 1934年4月，由中国共产党提出，宋庆龄、何香凝、李杜等人签名发表，号召中国人民自己起来武装驱逐日本帝国主义。 （4）国共两党第二次合作 P103 1937年9月22日，国民党中央通讯社发表《中共中央为公布国共合作宣言》；23日，蒋介石发表讲话，实际上承认了中国共产党的合法地位。由此，以国共两党第二次合作为基础的抗日民族统一战线正式成立，形成了全民族抗战的新局面。 （5）八路军新四军 P103 1937年 8月，国共两党达成协议：红军改编为国民革命军第八路军（简称八路军。不久改称第十八集团军）。八路军由朱德任总指挥，彭德怀任副总指挥。随后，南方的红军和游击队，除琼崖红军游击队外，改编为国民革命军新编第四军（简称新四军），叶挺任军长，项英任副军长。 2、（1）《为抗日救国告全国同胞书》 P101 1935年8月1日，中共驻共产国际代表团就以中华苏维埃共和国临时中央政府和中共中央的名义发表《为抗日救国告全国同胞书》（“八一宣言”），呼吁全国各党派、各界同胞、各军队都应有“兄弟阋于墙外御其侮”的真诚觉悟，捐弃前嫌，停止内战，集中一切国力，共同抗日。最早提出建立抗日民族统一战线思想。 （2）瓦窑堡会议 P102 1935年12月，中共中央在陕北瓦窑堡召开政治局扩大会议，提出了在抗日的条件下与民族资产阶级重建统一战线的新政策，批评了党内长期存在的“左”倾冒险主义、关门主义的错误倾向。瓦窑堡会议为迎接全国抗日新高潮到来做了理论和政治上的准备。 （3）中共中央致国民党五届三中全会电 P102-103 1937年2月，中共中央致电国民党五届三中全会，提出停止内战、一致对外等五项要求；四项保证：停止武力推翻国民党政府的方针；苏维埃政府改名为中华民国特区政府，红军改名为国民革命军；特区实行彻底的民主制度；停止没收地主土地的政策。 3、（1）一二九运动及其意义 P101 起因：华北事变后，中国民族危机加深，中日民族矛盾激化。 过程和口号：1935年12月9日，北平学生在中国共产党救亡图存、全民抗战的号召和中共北平临时工作委员会的领导下举行抗日游行。喊出“反对华北自治运动”、“打倒日本帝国主义”、“停止内战，一致对外”（代表性口号）等口号。游行队伍遭到国民党军警镇压。12月16日，北平学生和市民1万多人在天桥召开市民大会，反对成立冀察政务委员会。 意义：1）打击了日本帝国主义侵略中国并吞并华北的计划；2）促进了中华民族的觉醒；3）标志着中国人民抗日救亡运动新高潮的到来。 （2）西安事变的和平解决及其意义 P102-103 事变的发生： 1936年12月12日，在中国共产党抗日主张影响下，张学良、杨虎城毅然实行“兵谏”，扣留了前来督剿红军的蒋介石，提出了改组南京政府、停止一切内战、召开救国会议等八项主张，这就是西安事变。 和平解决及意义：中国共产党审时度势，从民族利益出发，确定促成事变和平解决的基本方针，并派周恩来等组成中共代表团赴西安谈判。经过和平谈判，终于迫使蒋介石作出了停止“剿共”、联合红军抗日等六项承诺。西安事变的和平解决成为时局转换的枢纽，十年内战的局面由此结束，国内和平基本实现。 4、中国共产党关于建立抗日民族统一战线的新政策 P101-102 在全国抗日救亡运动高涨之际，中国共产党及时提出抗日民族统一战线的新政策 。 1）1935年8月1日，中共驻共产国际代表团就以中华苏维埃共和国临时中央政府和中共中央的名义发表《为抗日救国告全国同胞书》（“八一宣言”），呼吁全国各党派、各界同胞、各军队都应有“兄弟阋于墙外御其侮”的真诚觉悟，捐弃前嫌，停止内战，集中一切国力，共同抗日。最早提出建立抗日民族统一战线思想。 2）1935年12月，中共中央在陕北瓦窑堡召开政治局扩大会议，提出了在抗日的条件下与民族资产阶级重建统一战线的新政策，批评了党内长期存在的“左”倾冒险主义、关门主义的错误倾向。瓦窑堡会议为迎接全国抗日新高潮到来做了理论和政治上的准备。 三、国民党的正面战场以及大后方的抗日民主运动 1、（1）台儿庄战役 P104 1938年3月，李宗仁领导的第五战区在台儿庄战役中，歼灭日军1万余人。 （2）为国捐躯的国民党将领 P104 国民党在抗战中牺牲的将领：佟麟阁、赵登禹、谢晋元、张自忠、戴安澜等 （3）豫湘桂战役 P106 1944年4月至1945年1月，日军发动打通中国大陆交通线的作战。战役中，国民党军队损失50多万兵力，丢失20多万平方公里的国土。激起了大后方人民对蒋介石集团的严重不满，国民党政府在军事、政治、经济各个方面陷入深刻的危机。 2、（1）相持阶段到来后国民党的对内对外政策 P105 国民党在重申坚持持久抗战的同时，其对内对外政策发生重大调整和变化。 1）1939年1月，国民党五届五中全会决定成立“防共委员会”，确定了“防共、限共、溶共、反共”的方针； 2）对抗战在全局上逐渐趋向消极，保存实力；同时又限制、打击共产党及其领导的八路军、新四军，制造了反共“磨擦”事件； 3）对外蒋介石将抗战到底的含义解释为“恢复到卢沟桥事变以前的状态”，这标志着国民党由片面抗战逐步转变为消极抗战。 （2）中国战区与中国远征军 P105 1942年成立中国战区，蒋介石任最高统帅。同年2月，中国远征军入缅作战。师长戴安澜在缅北殉国。曾经救援出被日军所困的英军7000多人。 3、国民党正面战场溃退的原因 P104 国民党领导的正面战场始终是中国抗战的重要战场，在全民族抗战中具有重要地位。在战略防御阶段，制定了持久消耗战的基本战略，这些抵抗没有达到维护领土的目的，国民党正面战场溃败、中国迅速丢失大面积国土。 原因：1）中日国力和军力对比的悬殊；2）蒋介石集团实行的是片面抗战的路线，将希望单纯地寄托在政府和正规军的抵抗上；3）国民政府在战略指导方针的失误。在战略战术上，没有采取积极防御的方针。 4、中共共产党领导和开展的大后方抗日民主运动和抗日文化工作 P106-107 1）抗日民主运动：中国共产党积极团结国统区抗日民主力量，推进国统区民主改革。1938年初，周恩来担任国民政府军事委员会政治部副部长，中国共产党人参加国民参政会；中共中央长江局、南方局先后具体领导了大后方的抗日民族统一战线工作。1944年9月，中共参政员林伯渠在国民参政会上提出成立民主联合政府的主张。 2）抗日文化工作：中国共产党积极领导和开展国统区进步文化工作，推动和参与文化界抗战团体的组建和发展。文化界提出“抗战、团结、民主”为文艺创作的三大目标，抗战文化在斗争中得到新的发展；合并组建国立西南联合大学，为中华民族的独立和复兴坚持进行教学和开展科学研究工作。 3）国民党统治区的抗日民主运动和进步文化工作，是全民族抗日战争中的一条重要的战线，对于激发大后方人民的爱国民主意识、坚持国共合作团结抗战、支援抗战前线、积蓄革命力量等发挥了重要的作用。 四、中国共产党成为抗日战争中的中流砥柱 1、（1）洛川会议和《抗日救国十大纲领》P108 1937年8月22日，中共中央在陕北洛川召开政治局扩大会议。会议通过《抗日救国十大纲领》，反映了共产党全面抗战路线。具体内容：1）强调使抗战成为全面的全民族的抗战，与国民党政府包办的片面抗战相对立的。2）指出必须实行全国军事的总动员、全国人民的总动员；必须改革政治机构，给人民以充分的抗日民主权利，并适当改善工农大众的生活。 （2）敌后抗日根据地 P109 1937年，八路军发动独立自卫的敌后游击战争，先后开辟晋察冀、晋西北、晋冀豫、山东、大青山等抗日根据地；新四军创建了华中抗日根据地 （3）为国捐躯的八路军、新四军将领 P109 八路军副参谋长左权、东北抗日联军第二路军副总指挥赵尚志、新四军第四师师长彭雪枫等 （4）国民党顽固派制造的反共高潮 P111 1939年冬至1940年春，国民党顽固派发动第一次反共高潮。进攻中共中央所在地陕甘宁边区，和太行山的新军和八路军总部；1941年1月，国民党顽固派发动第二次反共高潮（“皖南事变”），针对南方的新四军；1943年春，国民党顽固派策划发动第三次反共高潮（未遂）。 （5）“三三制”政权 P113 抗日根据地的政权，是中国共产党领导下的抗日民族统一战线性质的政权。在政权机关工作人员的名额分配上实行“三三制”原则，即共产党员、非党的左派进步分子和中间派各占三分之一。 （6）精兵简政 P113 精兵简政：1941年党外人士李鼎铭提出“精兵简政”的提案，中共中央立即采纳，在各根据地实行。 （7）教条主义 P116 主观主义的主要表现形式是教条主义和经验主义，尤其是教条主义。这是中国共产党内反复出现“左”、右倾错误的思想认识根源。 （8）中共七大 P116 1945年在延安召开，正式将毛泽东思想确定为党的指导思想。 2、（1）中国共产党的全面抗战路线 P108 洛川会议通过的《抗日救国十大纲领》的主要内容，体现了中国共产党的全面抗战路线，是彻底的抗日纲领。具体内容：1）强调使抗战成为全面的全民族的抗战，与国民党政府包办的片面抗战是相对立的。2）指出必须实行全国军事的总动员、全国人民的总动员；必须改革政治机构，给人民以充分的抗日民主权利，并适当改善工农大众的生活。 （2）抗日民族统一战线中的独立自主原则 P111-112 中国共产党强调，必须在统一战线中坚持独立自主原则，既统一，又独立。 1）必须保持在思想上、政治上和组织上的独立性，放手发动群众，壮大人民力量； 2）必须坚持人民军队的绝对领导，冲破国民党的限制和束缚，努力发展人民武装和抗日根据地； 3）必须对国民党采取又团结又斗争、以斗争求团结的方针。 （3）大生产运动 P113-114 为克服二十世纪四十年代初抗日根据出现的严重的经济困难。毛泽东提出了“发展生产，保障供给”的经济工作和财政工作的总方针，号召根据地军民“自己动手，丰衣足食”，开展大生产运动。大生产运动首先在陕甘宁边区进行，八路军三五九旅将荒芜人烟的南泥湾改造成为“陕北的好江南。 3、（1）中国抗日战争的两个战场及其关系 P109-110 1）中国抗日战争形成两个战场。一个是主要由国民党军队担负的正面战场；一个是由共产党领导的人民军队为主担负的敌后战场。 2）两个战场是战略上的相互配合的关系。 （2）抗日游击战争的战略地位和作用 P110 1）八路军、新四军采取“基本是游击战，但不放松有利条件下的运动战”的作战方针。抗日游击战具有重要的战略地位和作用。 2）在战略防御阶段，敌后的游击战是辅助国民党正面战场的。阻止了日军进攻、减轻正面战场压力、促使战争转入战略相持阶段。 3）在战略相持阶段，敌后游击战争成为主要的抗日作战方式。日军逐步将主要兵力用于敌后战场，以保持和巩固其占领地。这种全面的消耗日军，便赢来了战略反攻。 4、（1）中国共产党及其领导的人民抗日力量是抗日战争的中流砥柱 P 1）中国共产党在抗日战争时期坚持全面抗战的路线 .1937年8月洛川通过《抗日救国十大纲领》，体现了中国人民的根本利益和要求，是彻底的抗日纲领； 2）从民族大义出发，积极维护统一战线。提出了独立自主原则和抗日民族统一战线的策略总方针等方针，并身体力行贯彻执行； 3）坚持持久战方法，并领导人民军队开展独立自主的敌后游击战争，牵制和消灭了日军大量的有生力量。毛泽东《论持久战》发表，科学的预测了抗日战争的发展进程。八路军新四军英勇抗战，相持阶段到来后敌后游击战争成为主要作战方式。 所以，中国共产党成为抗日战争的中流砥柱。 （2）毛泽东《论持久战》的主要内容及其意义 P108-109 1938年，毛泽东发表《论持久战》的讲演，总结抗战十个月的经验，集中全党智慧，系统阐述抗日战争的特点、前途和发展规律，阐明了持久抗战的总方针。 1）中日战争是半殖民地半封建的中国和帝国主义的日本之间在20世纪30年代进行的一个决死的战争。全部问题的根据就在这里。中日双方存在着互相矛盾的四个特点：敌强我弱，敌小我大，敌退步我进步，敌寡助我多助。 2）前途和规律：一方面，日本是强国，中国是弱国，这一对比，决定了抗日战争只能是持久战。另一方面，日本是小国，发动的是退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，在国际上得道多助，最后胜利又将是属于中国的。 进程和方针：科学地预测了抗日战争将经过战略防御、战略相持、战略反攻三个阶段。其中，战略相持阶段，是中国抗日战争取得最后胜利的最关键的阶段。坚持持久抗战方针，中国将在这个阶段中获得转弱为强的力量，乃至最后取胜。 意义：毛泽东阐明的持久战战略思想，抓住了中日战争发生的时代特点和战争性质，揭示了抗日战争的发展规律和坚持抗战、争取抗战胜利必须实行的战略方针，对全国抗战起了积极作用 （3）中国共产党关于巩固和扩大抗日民族统一战线的策略总方针 P112-113 总方针：“发展进步势力，争取中间势力，孤立顽固势力”。 1）进步势力主要是指工人、农民和城市小资产阶级。他们是统一战线的基础，抗日战争的主要依靠力量。为了发展进步势力，就要冲破国民党的限制和束缚，放手发动人民群众，扩大抗日人民武装，创立抗日民主根据地，在全国发展共产党的组织和民众的抗日运动，这是整个策略的中心环节。 2）中间势力主要是指民族资产阶级、开明绅士和地方实力派。争取中间势力需要三方面条件：一是共产党要有充足的力量；二是尊重他们的利益；三是要同顽固派作坚决的斗争，并能一步一步地取得胜利。 3）顽固势力是指大地主大资产阶级的抗日派，即以蒋介石集团为代表的国民党亲英美派。针对其两面政策（既主张团结抗日，又限共、溶共、反共并摧残进步势力）共产党须以革命的两面政策来对付他们，即贯彻又联合又斗争的政策。同顽固派作斗争时，应坚持有理、有利、有节的原则。以不破裂统一战线为底线。 （4）新民主主义理论的系统阐述及其意义 P114-115 1940年前后，毛泽东撰写了《共产党人发刊词》、《中国革命和中国共产党》、《新民主主义论》等著作，系统地阐释了中国共产党的新民主主义理论。 1）分析了近代中国半殖民地半封建的社会性质和主要矛盾，科学阐明了中国革命运动包括民主主义革命和社会主义革命两个阶段。五四运动以后已经是新民主主义革命，它的前途是社会主义。 2）阐明了中国共产党在新民主主义革命阶段的基本纲领。政治上，推翻帝国主义和封建主义的压迫，建立一个新民主主义共和国。经济上，没收官僚垄断资本归新民主主义国家所有；没收地主阶级的土地归农民所有；允许民族资本主义经济的发展和富农经济的存在。文化上，发展无产阶级领导的人民大众的反帝反封建的中华民族的新文化，即民族的科学的大众的文化。 3）总结了中国共产党成立以来的经验，提出了统一战线、武装斗争、党的建设，是中国共产党领导革命的三个基本问题，是战胜敌人的三个法宝。 意义： 1）新民主主义理论是以毛泽东为主要代表的中国共产党人把马克思主义基本原理同中国革命具体实际相结合的理论成果。 2）新民主主义理论的系统阐明，标志着毛泽东思想得到多方面展开而达到成熟。 （5）延安整风运动及其意义 P115-116 20世纪40年代前中期，中国共产党以延安为中心，在全党范围内开展了一场整风运动。 1）主要内容：反对主观主义以整顿学风、反对宗派主义以整顿党风、反对党八股以整顿文风。其中，反对主观主义是整风运动最主要的任务。主观主义的主要表现形式是教条主义和经验主义，尤其是教条主义。这是中国共产党内反复出现“左”、右倾错误的思想认识根源。 2）意义： 整风运动是一场伟大的思想解放运动，在全党范围确立起一切从实际出发、理论联系实际、实事求是的马克思主义思想路线。 在整风运动基础上，1945年中共七大将中国共产党人把马克思列宁主义基本原理同中国具体实际相结合所创造的理论成果，正式命名为毛泽东思想，并规定为党的一切工作的指针。 五、抗日战争的胜利及其意义 1、联合国制宪会议 P120 1945年4月在美国旧金山举行。包括中国解放区代表董必武在内的中国代表团出席了会议。中国成为联合国的创始国和五个常任理事国之一。 2、抗日战争的胜利 P117 1945年8月15日，天皇宣布无条件投降；9月2日，日本政府签订投降书（9月3日为中国人民抗日战争胜利纪念日）；9月9日，中国战区受降在南京举行；10月25日，中国政府在台湾举行受降仪式，台湾以及澎湖列岛的收回，是抗日战争取得完全胜利的标志。 3、中国人民抗日战争在世界反法西斯战争中的地位 P120 1）中国人民抗日战争不仅是中华民族救亡图存的民族解放战争，也是世界反法西斯战争的重要组成部分。中华民族为世界反法西斯战争的胜利作出了伟大贡献，付出了巨大的民族牺牲。 2）中国人民抗日战争是世界反法西斯战争的东方主战场。在世界反法西斯战争中，中国人民抗日战争开始最早，持续时间最长。中国战场年平均牵制日本陆军的74％以上，最高年份达90％。日军在海外作战中损失的287万人中，有150万人伤亡在中国战场。 3）国人民的持久抗战，不仅遏制了日本的“北进”计划，迟滞了日本的“南进”步伐，而且大大减轻了其他战场的压力，为同盟国军队完成太平洋战场的战略转折和实施战略反攻创造了有利条件。中国作为亚洲太平洋地区盟军对日作战的重要后方基地，还为盟国提供了大量战略物资和军事情报。中国军队出国作战，不仅打击了日军，还对盟军给予了实际支援。 4）大国身份直接参与反法西斯战争的国际协调。中国国际地位随着抗日战争的胜利得到提高。1942年1月，26个国家共同签署《联合国家宣言》，1945年4月，参加联合国制宪会议，中国成为联合国的创始国和五个常任理事国之一。 4、（1）中国人民抗日战争史近代以来中华民族反抗外来侵略第一次取得完全胜利的民族解放战争 P117-118 中国人民抗日战争，是近代以来中华民族反抗外敌入侵第一次取得完全胜利的民族解放战争。 1）中国人民抗日战争的胜利，彻底打败了日本侵略者，捍卫了中国的国家主权和领土完整，使中华民族避免了遭受殖民奴役的厄运。 2）中国人民抗日战争的胜利，促进了中华民族的觉醒，使中国人民在精神上、组织上的进步达到了前所未有的高度。中国人民通过抗日战争的实践认识到，中国共产党是领导中国各族人民争取民族独立和人民解放的坚强核心。 3）中国人民抗日战争的胜利，促进了中华民族的大团结，弘扬了中华民族的伟大精神。这就是：民族自尊品格、民族团结意识、民族英雄气概、民族自强信念、民族创造精神。 4）中国人民抗日战争的胜利，对世界人民战胜法西斯、维护世界和平的伟大事业产生巨大影响，为最终战胜世界法西斯势力作出了历史性贡献，显著提高了中国的国际地位和国际影响。 （2）中国人民抗日战争胜利的主要原因和基本经验 P118-119 主要原因 1）中国共产党在全民族抗战中发挥了中流砥柱的作用。这是中国人民抗日战争同近代以来历次反侵略战争最大的区别。中国共产党积极倡导、促成、维护抗日民族统一战线。中国共产党人，科学阐明了抗日战争的规律和进程，制定了正确的战略和策略，对抗日战争发挥了重要的指导作用。 2）中国人民巨大的民族觉醒、空前的民族团结和英勇的民族抗争，是中国人民抗日战争胜利的决定性因素。抗日战争唤起了全民族的危机意识和使命意识。中国共产党以全民抗战的纲领主张、团结御侮的先锋作用、人民战争的组织力量，最大限度地调动起全国人民的抗日积极性。国民党的爱国官兵也为反对日本的侵略作出了贡献。 3）中国人民抗日战争的胜利，同世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持也是分不开的。苏联、美国、法国、英国等向中国提供了经济和军事援助。许多国家的反法西斯战士直接参加了中国人民的抗日战争，为中国人民的解放事业贡献鲜血和生命。 基本经验 1）全国各族人民的大团结，是中国人民战胜一切艰难困苦、实现抗战胜利的力量源泉。在抗日战争中，中华民族实现了空前的大团结，形成了真正意义上的全民族抗战。没有全国各族人民的大团结，没有抗日民族统一战线，就没有抗日战争的伟大胜利。 2）以爱国主义为核心的伟大民族精神是中国人民团结奋进的精神动力。这是抗日战争得以坚持和胜利的重要的思想保证。抗日战争大大丰富和升华了以爱国主义为核心的中华民族精神。中国共产党充分发挥出民族先锋队和阶级先锋队的作用，赢得了全中国人民的拥戴。 3）中国人民热爱和平、反对侵略战争，同时又不惧怕战争。中国人民进行反侵略战争，是为了捍卫中华民族生存和发展的权利，是对世界反法西斯战争和人类进步事业的重大贡献。 第七章 为创建新中国而斗争 一、从争取和平民主到进行自卫战争 1、（1）重庆谈判 P125 1945年8月28日毛泽东、周恩来、王若飞等在重庆与国民党当局进行的谈判。10月10日，双方签署《政府与中共代表会谈纪要》（即双十协定），确认和平建国的基本方针。 （2）重庆政治协商会议 P126 1946年1月10日，在重庆开幕，参加会议的有国民党、共产党、民主同盟、青年党及社会贤达代表38人，会议通过了政府组织、国民大会、和平建国纲领、宪法草案等五项协议。 （3）校场口惨案 P126 国民党制造的破坏和平的事件。1946年2月10日国民党破坏进步团体在重庆校场口举行的“庆祝政协成功大会”，李公朴、郭沫若、马寅初及新闻记者等多人被打伤，逮捕数十人。 （4）下关惨案 P126 1946年6月23日，上海人民团体联合会请愿团向国民党当局呼吁和平，请愿团到达南京下关车站时，遭到国民党当局指使的大批暴徒的围殴，团长马叙伦和代表雷洁琼等多人受伤。 2、抗日战争胜利后的国际格局 P123 1）帝国主义受到削弱，人民民主力量明显增长。 2）逐步打破了以维持欧洲大国均势为中心的传统的国际政治格局，形成了美苏两极的政治格局。 3）这样的国际格局对抗战后中国产生重大影响。 3、必须和能够打败蒋介石 P127-128 全面内战战争爆发不久，毛泽东代表中共提出了这样的论断。 1）必须打败蒋介石，因为蒋介石发动的战争，是反对中国民族独立和中国人民解放的反革命的战争，只有用革命战争反对反革命战争，中国才能解放和中华民族的才能真正独立； 2）能够打败蒋介石，因为蒋介石军事力量的优势和美国的援助，只是暂时的现象和临时起作用的因素；而蒋介石发动的战争的反人民性质，人心的向背，则是经常起作用的因素。人民解放战争所具有的爱国的正义的革命的性质，必然要获得全国人民的拥护。这就是战胜蒋介石的政治基础。 4、抗日战争胜利后中国国内的三种建国方案和两个中国之命运的较量 P123-125 1）第一种是地主阶级与买办性的大资产阶级的建国方案。这个建国方案背离中国最广大人民群众的利益和愿望。随着新中国的诞生，国民党的反动统治也在根本上被推翻了； 2）第二种是民族资产阶级的建国方案。这个方案在中国行不通。因为：帝国主义不容许；民族资产阶级在经济上、政治上的软弱性，使得它们没有勇气和能力去领导人民进行彻底反帝反封建的斗争，从而为建立资产阶级共和国扫清障碍。民族资产阶级中的绝大多数最终接受了中国共产党的新民主主义革命纲领； 3）第三种是工人阶级、农民阶级和城市小资产阶级的建国方案。其政治代表是中国共产党。其建国方案是：在工人阶级及其政党的领导下，通过新民主主义革命，建立一个工人阶级领导的、以工农联盟为基础的、团结一切可以团结的力量的人民民主专政的人民共和国。这一方案是引导中华民族和中国人民争得民族独立和人民解放从而为实现国家富强开辟道路的科学的建国方案。 二、国民党政府处于全民的包围之中 1、（1）新民主主义三大经济纲领 P130 1947年12月，毛泽东在《目前形势和我们的任务》的报告中提出新民主主义革命的三大经济纲领：没收封建阶级的土地归农民所有，没收蒋介石、宋子文、孔祥熙、陈立夫为首的垄断资本归新民主主义的国家所有，保护民族工商业。 （2）新民主主义革命总路线 P130 1948年4月，毛泽东在《在晋绥干部会议上的讲话》中完整地提出：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命，这就是中国的新民主主义革命，这就是中国共产党在新民主主义革命阶段的总路线和总政策。 （3）《五四指示》 P130 1946年5月4日，中共中央发出《关于清算、减租及土地问题的指示》（史称《五四指示》），决定将党在抗日战争时期实行的减租减息政策改变为实现“耕者有其田”的政策。 （4）《中国土地法大纲》 P130 1947年7月至9月，中国共产党在河北省平山县召开了全国土地会议，制定《中国土地法大纲》，明确规定废除封建性及半封建性剥削的土地制度，实现耕者有其田的土地制度。 （5）土地改革的总路线 P131 1948年4月，毛泽东《在晋绥干部会议上的讲话》中系统阐明了土地改革总路线，即依靠贫农，团结中农，有步骤地、有分别地消灭封建剥削制度，发展农业生产。 （6）“五二○”惨案 P132 1947年 5月20日，南京和天津游行学生，要求“反饥饿、反内战”，遭到国民党镇压，即“五•二○”惨案。以此为标志，反对国民党统治的第二条战线的正式形成。 （7）台湾人民“二二八”起义 P133 1947年2月28日，台北市人民为反抗国民党当局的暴政、抗议反动军警屠杀市民，举行大规模示威游行，遭国民党军警镇压，之后，台湾各地各族人民夺取武器，举行起义。 （8）民主党派 P134 八个民主党派（大多成立于抗战和解放战争时期）： a. 中国国民党革命委员会（民革）：宋庆龄、李济深。 b. 中国民主同盟（民盟）：黄炎培、张澜。由原中国民主政团同盟改名而来。（由三党三派联合组成：全国各界救国联合会、中华职业教育社、乡村建设协会、中华民族解放行动委员会‘第三党’、青年党、国家社会党）。 c. 中国民主建国会（民建）：黄炎培、胡厥文等。爱国的民族工商业者以及有联系的知识分子发起。 d. 中国民主促进会（民进）：马叙伦。文化教育出版界知识分子为主，还有一部分工商界爱国人士。 e. 中国农工民主党（农工党）：邓演达、章伯钧。 f. 中国致公党（致公党）：李济深、陈其尤。 g. 九三学社：许德珩等。纪念1945年9月3日抗日战争和世界反法西斯战争的伟大胜利，由民主科学座谈会改建为九三学社。 h. 台湾民主自治同盟（台盟）：谢雪红。 2、（1）人民解放军的战略进攻 P128-129 1）标志：1947年6月底，刘伯承、邓小平率领的晋冀鲁豫野战军主力强渡黄河、千里跃进大别山，在鄂豫皖实施战略展开。陈毅、粟裕指挥的华东野战军主力为东路，挺进苏鲁豫皖地区；陈赓、谢富治指挥的晋冀鲁豫野战军一部为西路，挺进豫西。三军相互策应，机动歼敌。国民党军处于被动地位。人民解放战争战略进攻的序幕由此揭开。 2）1947年8月，西北野战军、华东野战军山东兵团、晋察冀野战军、晋冀鲁豫野战军太岳兵团等加紧发起攻击，转入反攻。晋察冀野战军攻占石家庄，开创了人民军队攻占大城市的先例。 （2）国民党统治的政治经济危机 P131-132 1）抗战胜利后，国民党把接收变成“劫收”，大发“胜利财”，丧失民心； 2）国民党为了内战，加剧对广大人民的掠夺； 3）国民党统治集团发动反人民的内战，将全国各阶层人民置于饥饿和死亡线上，激起了全国各阶层人民的反抗。 3、中国共产党与各民族党派的团结合作 P136 1）重庆国共谈判和政协会议期间，各民主党派作为“第三方面”，主要同共产党一起反对国民党反动派的内战、独裁政策，为和平民主而共同努力； 2）在国民党当局撕毁政协协议、发动全面内战时，民主党派中的大多数同共产党保持一致，拒绝参加国民党一手包办的“国民大会”、反对国民党炮制的 “宪法”； 3）民主党派的许多成员积极参加和支持中国共产党领导的爱国民主运动；（民盟李公朴、闻一多，杜斌丞等为此被国民党暗杀） 4）在人民解放战争转入战略反攻并且取得节节胜利的形势下，1948年初，各民主党派都公开宣言，站在人民革命一边，同共产党一道为推翻国民党的反动统治建立新中国而共同奋斗。 4、中国共产党领导的多党合作、政治协商格局的形成 P137 1） 1948年4月30日，中共中央在纪念五一国际劳动节的口号中提出：“各民主党派、各人民团体、各社会贤达迅速召开政治协商会议，讨论并实现召集人民代表大会，成立民主联合政府。” 2）各民主党派和社会各界热烈响应，各民主党派负责人、无党派民主人士接受中共中央邀请，陆续进入东北、华北解放区。（在哈尔滨的民主人士章伯钧等提出，政治协商会议即等于临时人民代表会议，即可产生临时中央政府。这个意见为中共中央所接受。） 3）1949年1月22日，李济深、沈钧儒等民主党派的领导人和著名的无党派民主人士55人联合发表《对时局的意见》，一致拥护中共提出的召开政治协商会议、成立联合政府的主张。这个政治声明表明，中国各民主党派和无党派民主人士自愿地接受了中国共产党的领导，决心走人民革命的道路，拥护建立人民民主的新中国。 4）在中国共产党的领导下，各民主党派和无党派民主人士同全国各界人民代表一道参加建立新中国的各项筹备工作。 三、人民共和国：中国人民的历史性选择 1、（1）战略决战 P138 辽沈战役（林彪东北野战军主打）1948.9.12-1948.11.2 淮海战役（刘伯承、邓小平、陈毅等中原、华东野战军主打）1948.11.6-1949.1,10 平津战役（东北野战军、华北野战军主打）。1948.11.29-1949.1.31 （2）国共北平谈判 P139 1949年4月1日起，国共双方代表以中共所提八项条件为基础在北平进行谈判。4月20日，国民党政府电令其和谈代表拒绝在中共提出的《国内和平协定》（最后修正案）上签字，和谈破裂。 （3）人民解放军占领南京及其向全国进军 P139 1949年4月21日，毛泽东、朱德发布《向全国进军的命令》，中国人民解放军发起渡江战役。第二、第三野战军强渡长江天险，摧毁国民党长江防线。4月23日，人民解放军占领南京，延续了22年的国民党的反动统治宣告覆灭。随后，解放军各路大军举行大进军，分别以战斗或和平方式，解决残余敌人，解放广大国土。 2、中共七届二中全会的主要内容 P140 1949年3月，七届二中全会在西柏坡召开。其主要内容是： 1）规定了全国胜利后中国共产党在政治、经济、外交方面应当采取的基本政策。 2）指出了中国由农业国转变为工业国、由新民主主义社会转变为社会主义社会的发展方向。 3）在中国共产党自身建设的问题上，提出了“两个务必”的要求。（“务必使同志们继续地保持谦虚、谨慎、不骄、不躁的作风，务必使同志们继续地保持艰苦奋斗的作风”。） 3、《论人民民主专政》与中国共产党建国主张 P140-141 1949年6月30日，毛泽东发表了《论人民民主专政》一文，系统地阐明了中国共产党关于建立人民民主专政的新中国的主张： 1）人民民主专政的基础是工人阶级、农民阶级和城市小资产阶级的联盟。 2）工人阶级和农民阶级的联盟是主要的联盟，因为这两个阶级占了中国人口的80%-90%.推翻帝国主义和国民党反动派、由新民主主义到社会主义，都主要依靠这两个阶级的联盟。 3）为建立新中国，必须利用一切于国计民生有利的城乡资本主义因素，团结民族资产阶级。但是民族资产阶级不能充当革命的领导者，也不应当在国家政权中占主要的地位。 4）毛泽东指出：总结我们的经验，集中到一点，就是工人阶级（经过共产党）领导的以工农联盟为基础的人民民主专政。 4、（1）中国人民政治协商会议及其《共同纲领》的主要内容 P141-142 在1956中国年第一部宪法颁布前，《共同纲领》具有临时宪法性质。 1）规定了关于新中国的国体和政体。《共同纲领》规定：“中华人民共和国实行工人阶级领导的、以工农联盟为基础的、团结各民主阶级和国内各民族的人民民主专政”。（国体）“中华人民共和国的国家政权属于人民。人民行使国家政权的机关为各级人民代表大会和各级人民政府”。 “各级政权机关一律实行民主集中制”。（政体及其组织原则）此项规定，是《共同纲领》最基本、最核心的内容。这项规定也从法律上正式确立了中国共产党在全国的执政地位。 2）规定了新中国的基本的民族政策。《共同纲领》规定：“中华人民共和国境内各民族一律平等”。“各少数民族聚居的地区，应实行民族区域自治。 3）规定了新中国的经济工作方针。《共同纲领》规定：“以公私兼顾、劳资两利、城乡互助、内外交流的政策，达到发展生产、繁荣经济之目的”。国家应调剂国营经济、个体经济、私人资本主义经济等，“使各种社会经济成分在国营经济领导之下，分工合作，各得其所，以促进整个社会经济的发展”。 4）规定了新中国的外交工作原则。《共同纲领》规定：“保障本国独立、自由和领土主权的完整，维护国际的持久和平和各国人民间的友好合作，反对帝国主义的侵略政策和战争政策”。 （2）中国革命胜利的主要原因和基本经验 P142-144 主要原因： 1）党的领导：首先是由于有了中国共产党的领导。中国共产党作为工人阶级的政党，不仅代表着中国工人阶级的利益，而且代表着整个中华民族和全中国人民的利益。中国共产党是用马克思主义的科学理论武装起来的，以中国化的马克思主义即毛泽东思想作为一切工作的指针。能够制定出适合中国情况的、符合中国人民利益的纲领、路线、方针和政策，为中国人民的斗争指明正确的方向。“没有共产党，就没有新中国。”这是中国人民基于自己的切身体验所确认的客观真理。 2）人民的广泛参加：工人、农民、城市小资产阶级群众是民主革命的主要力量，民族资产阶级也逐步向共产党靠拢。没有广大人民和各界人士的广泛参加和大力支持，中国革命的胜利是不可能的。 3）国际的帮助：中国革命之所以能够赢得胜利，同国际无产阶级和人民群众的支持也是分不开的。 基本经验： 1）建立广泛的统一战线。 统一战线中存在着两个联盟：一个是劳动者的联盟，这是基本的、主要的；一个是劳动者与非劳动者的联盟，这是辅助的、同时又是重要的。必须坚决依靠第一个联盟，争取建立和扩大第二个联盟。 巩固和扩大统一战线的关键，是坚持工人阶级领导权，率领同盟者向共同的敌人作坚决的斗争并取得胜利；对被领导者给以物质福利，至少不损害其利益，同时对被领导者给以政治教育；对资产阶级采取又联合、又斗争的政策。 2）坚持革命的武装斗争。中国革命只能以长期的武装斗争作为主要形式。中国的武装斗争实质上是工人阶级领导的农民战争。必须深入农村进行土地革命，走农村包围城市道路，才能逐步地争取革命的胜利。必须建立一支在共产党绝对领导下的新型人民军队。这支军队必须实行一系列具有中国特点的人民战争的战略战术。 3）加强共产党自身的建设。在农民和其他小资产阶级占人口大多数的中国，建设一个工人阶级先锋队的党，是极其艰巨的任务。毛泽东的建党学说成功地解决了这个难题。 中国共产党的建设，是密切地联系着党的政治路线进行的。首先着重党的思想建设，用工人阶级思想克服资产阶级、小资产阶级思想；培育和发扬理论与实际相结合、密切联系群众和自我批评的作风；创造了在全党通过批评与自我批评进行马克思主义思想教育的整风形式等。中国共产党在长期的斗争实践中，成为了掌握统一战线和武装斗争这两个武器以实行对敌冲锋陷阵的英勇战士，成为了全国各族人民拥戴的领导核心。 第八章 社会主义基本制度的全面确立 一、《共同纲领》的全面实施与新民主主义革命任务的彻底完成 1、（1）《中华人民共和国土地改革法》 P149 1950年6月中央人民政府颁布《中华人民共和国土地改革法》，农村掀起了轰轰烈烈的土地改革运动。 （2）“三反”运动 P153 针对不法资本家行贿党政干部情况，1951年底到1952年春，中国共产党在党政机构工作人员中开展了反贪污、反浪费、反官僚主义的“三反”运动。处决了犯有严重贪污罪行的中共天津地委前任书记刘青山、时任书记张子善，处理了一批党政干部。 （3） “五反”运动 P153 针对不法资本家的“五毒”行为，1952年1月起历时半年，中共中央决定在工商业者中开展反行贿、反偷税漏税、反盗窃国家资财、反偷工减料、反盗窃国家经济情报的“五反”运动。 2、（1）西藏和平解放 P149 1951年5月，中央人民政府同西藏地方政府达成和平解放西藏的协议；10月，人民解放军进驻拉萨。西藏和平解放，标志着祖国大陆基本解放和各族人民实现统一。 （2）没收官僚资本 P151 1949年1月，中共中央发出《关于接受官僚资本企业的指示》，规定在某个城市解放的时候，根据事先调查的结果，由该城市的军事管制委员会立即派出军代表，按照官僚资本企业原属系统，自上而下、原封不动，整套接受。官僚资本企业成为社会主义性质的国营经济。 3、（1）新中国成立初期的各项民主改革 P150-151 1）在已经没收的官僚资本企业中，建立工厂民主管理制度，工人阶级成为企业的主人。 2）按照对私营工商业（原民族资本）的生产关系、劳资关系和产销关系，进行了全面调整。 3）颁布新婚姻法，妇女解放和移风易俗。人民政府于1950年5月颁布《中华人民共和国婚姻法》。对新婚姻法的宣传和实施，引起了几千年来中国社会与家庭生活的深刻变革，推动了社会上移风易俗的改革。 4）有步骤地开展了对旧教育制度和电影、戏剧等文化事业的改革，确定了思想宣传工作的方针和任务，制定了新中国文化教育的方针。 1951年9月，在全国开展了知识分子思想改造运动。 （2）争取国家财政经济状况基本好转的条件 P152 1950年6月，七届三中全会毛泽东在《为争取国家财政经济状况的基本好转而斗争》的报告中指出，要获得根本好转，要创作三个条件： 1）土地革命的完成； 2）现有工商业的调整； 3）国家机构所需经费的大量节减。 （3）国民经济迅速的恢复及其原因 P154 经过三年的努力， 到1952年底，国民经济得到全面恢复和初步发展。其原因如下： 1）中共中央和人民政府紧紧抓住恢复和发展生产作为一切工作的中心，正确处理恢复国民经济同其他各项工作的关系； 2）从当时的国情出发，制定了“不要四面出击”等正确方针政策，妥善处理公私关系、劳资关系等各种社会关系； 3）刚刚执政的中国共产党加强自身的建设，保持和发扬党的优良传统和作用，及时有力地抵制了资产阶级的腐蚀。 4、（1）中华人民共和国的成立开辟了中国历史的新纪元 P147 中华人民共和国的成立，宣告中国人民当家做主的时代已经到来，中国历史由此开辟了一个新纪元。 1）（反帝任务完成，民族独立实现）帝国主义列强压迫中国、奴役中国人民的历史从此结束。占人类总数四分之一的中国人从此站立起来了； 2）（反封任务完成，人民解放实现）本国封建主义、官僚资本主义统治的历史从此结束，广大中国人民在历史上第一次成为国家的主人； 3）（国家统一完成，和平局面实现）军阀割据混战的历史从此结束，国家基本统一，民族团结，社会政治局面趋向稳定，从事经济文化等方面建设的时期开始到来了； 4）（社会主义方向确定）从根本上改变了中国社会的发展方向，为实现由新民主主义向社会主义的过渡，创造了前提条件； 5）（中国共产党从夺权到执政）中国共产党成为全国范围内的执政党。它可以运用国家政权凝聚和调集全国力量，解放并发展社会生产力，造福于整个中华民族。 总之，中华人民共和国的成立，标志着中国的新民主主义革命取得了基本的胜利，标志着半殖民地半封建社会的结束和新民主主义社会在全国范围内的建立。 （2）中国共产党在全国执政面临的新考验 P148 1）能不能保卫住人民胜利的成果，巩固新生的人民政权。 解放全中国的任务还没有完成。国民党从大陆撤退时遗留下数百万军队、土匪以及特务分子还有待肃清。在广大城乡，反动会道门和传统黑恶势力还危害着人民的生命财产安全。广大的新解放区还没有进行封建土地制度的改革。 2）能不能战胜严重的经济困难，迅速恢复和发展国民经济。1949年，新中国从旧中国接收过来的是一副烂摊子。许多工厂倒闭，大批工人失业，通货膨胀，物价飞涨，人民生活遇到极大的困难。 3）能不能巩固民族独立，维护国家主权和安全。新中国的诞生初期，以美国为首的西方资本主义阵营实行强硬的对华政策。 4）能不能经受住执政的考验，继续保持谦虚、谨慎、不骄、不躁的作风和艰苦奋斗的作风。 这些问题，从根本上说，是前进中的问题。中国共产党有能力带领全国人民接受考验、克服困难。 二、制定过渡时期总路线 1、（1）新民主主义社会的建立 P156 中国共产党领导人民进行新民主主义革命，是要建立以中国无产阶级为首领的中国各个革命阶级联合专政的新民主主义社会。 （2）过渡时期总路线的内容 P159 中共中央在1952年底开始酝酿并于1953年正式提出党在过渡时期的总路线，明确规定：“党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。”简称“一化三改”、“一体两翼”。 2、资本主义工业化与社会主义工业化 P158-159 进行经济建设，要把中国从一个落后的农业国变成先进的工业国，实现国家的工业化的两条道路： 1）欧美及日本所走的资本主义工业化道路，历史表明，在中国是走不通的； 2）苏联走过的社会主义工业化道路，实事表明，中国必须走社会主义的道路。 3、（1）新民主主义社会的特点与性质 P157-158 特点： 1）经济上：五种经济成分共存：社会主义性质的国营经济，农民和手工业者的个体经济，私人资本主义经济（以上是三种主要形式），半社会主义性质的合作社经济、国家资本主义经济。 2）政治文化上：无产阶级的政治领导地位和马克思主义指导地位已经确立。 3）社会的两种基本矛盾：有三种基本的阶级力量：工人阶级、农民及其他小资产阶级、资产阶级。从内外来说，中国还存在着两种基本的矛盾：国际上是新中国同帝国主义的矛盾，国内是工人阶级和资产阶级的矛盾。 性质：新民主主义社会既有社会主义因素，又有资本主义因素，总体上是社会主义因素在增长的过渡性社会。 4、过渡时期总路线反映了历史的必然 P159-160 中共中央1953年正式提出党在过渡时期的总路线。即：“要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造。”，历史表明，中国共产党提出的过渡时期总路线是完全正确的，反映了历史的必然。 1）已经建立起来的社会主义性质的国营经济是实现国家工业化的主要基础。国家的社会主义工业化，是国家独立和富强的必要条件； 2）资本主义经济力量弱小，发展困难，不可能成为中国工业起飞的基础。1950年以后，对资本主义工商业进行采取了引向社会主义的多种方式，为对资本主义工商业进行社会主义改造积累了初步的经验； 3）对个体农业进行社会主义改造，是保证工业发展、实现国家工业化的一个必要条件。只有实行农业合作化来规模性增产农产品，才能满足工业发展的各方面需要； 4）国际环境也促使中国选择社会主义。美国等西方资本主义国家严密封锁和遏制中国，只有社会主义的苏联能够援助中国； 总之，中国在20世纪50年代的最重要事件就是选择了社会主义，成功地进行了社会主义改造，实现了中国历史上最伟大、最深刻的社会变革，这是十分必要的、完全正确的。 三、开辟中国社会主义改造道路 1、（1）手工业合作化的组织形式 P163 手工业合作化的组织形式，是由手工业生产合作小组、手工业供销合作社到手工业生产合作社，步骤是从供销入手，由小到大，由低到高，逐步实行社会主义改造和生产改造。 （2）“四马分肥” P164 企业利润采取“四马分肥”的办法，即分为国家所得税、企业公积金、工人福利费、股金红利四个部分。 2、（1）对农业社会主义改造采取的过渡性经济组织形式 P161 1953年12月，中共中央通过《关于发展农业生产合作社的决议》提出对农业社会主义改造的三种过渡性组织形式。 1）互助组，具有社会主义的萌芽性质。 2）初级农业生产合作社，具有半社会主义的性质。 3）高级农业生产合作社（将土地及其他主要生产资料归集体所有，统一经营、集体劳动）具有社会主义的性质。 （2）国家资本主义的初级形式和高级形式 P163-164 1）初级形式的国家资本主义：资本主义企业在所有权和经营权不变的情况下，在企业外部与国营经济建立联系。其形式有：在工业中有收购、加工、订货、统购、包销；商业中有经销、代销、代购代销、公私联营等。新中国成立初期，着重发展的是加工订货、经销代销等初级形式的国家资本主义。 2）高级形式的国家资本主义（又称公私合营），分作两种。 个别企业的公私合营。（企业利润采取“四马分肥”的办法，即分为国家所得税、企业公积金、工人福利费、股金红利四个部分。） 全行业的公私合营。1955年后，开始实行全行业公私合营。（国家核定私营资本的价值和私股股额；在合营期间，每年发给资本家5%的股息，即定股定息。）全行业公私合营以后，原来的私人资本企业基本上已经是社会主义性质的经济，除资本家领取定息外，同国营企业已经没有原则的区别。实行公私合营以后，在生产领域和所有权领域中社会主义经济在企业中已经具有决定性作用了。 （3）第一个五年计划以及工业建设的成就 P165-166 1955年7月召开一届全国人大二次会议通过第一个五年计划（1953年-1957年）。 内容： 1）集中主要力量发展重工业，建立国家工业化和国防现代化的初步基础； 2）相应地发展交通运输业、轻工业、农业和商业； 3）相应地培养建设人才； 4）保证在发展生产的基础上逐步提高人民的物质生活和文化生活的水平； 其实施标志着中国开始了有计划的社会主义建设。一五计划的特点是集中主要力量发展重工业。 工业建设主要成就： 1）鞍山、包头、武汉三大钢铁基地建成； 2）多个第一，长春第一汽车制造厂、沈阳机床厂、北京电子管厂、沈阳飞机制造厂； 3）武汉长江大桥通车，铁路贯穿中国南北； 4）青藏、康藏、新藏公路通车，沟通西藏与内地联系。 3、完成对农业社会主义改造的意义 P162-163 这是中国历史上一次伟大的社会变革、社会进步。 1）在改造期间，农民安居乐业，生产有所发展，生活有所改善，中国农村在发展稳定的气氛中完成了从几千年的分散个体劳动向集体所有、集体经营的历史性转变； 2）农业社会主义改造的迅猛发展，极大地加快了手工业合作化的步伐。 4、（1）对农业社会主义改造的基本原则和方针 P161-162 1）在中国的条件下，可以走先合作化、后机械化的道路。在土地改革基本完成后，及时将“组织起来”作为农村工作的一件大事来抓。 2）充分利用和发挥土改后农民的两种生产积极性，（即干个体的积极性和要求合作的积极性）“趁热打铁”，不待农村发生剧烈两极分化，通过互助组、初级农业生产合作社、高级农业生产合作社这种由低到高的互助合作的组织形式，实行积极发展、稳步前进、逐步过渡的方针。 3）农业互助合作的发展，要坚持自愿和互利的原则，采取典型示范、逐步推广的方法，发展一批，巩固一批。 4）要始终把是否增产作为衡量合作社是否办好的标准。 5）要把社会改造同技术改造相结合。在实现农业合作化以后，国家应努力用先进的技术和装备发展农业经济。 （2）对资本主义工商业采取和平赎买政策的特点及意义 P164-165 经过国家资本主义来改造资本主义工商业，意味着国家对资本主义工商业采取和平赎买的政策。 特点： 1）有偿地而不是无偿地，逐步地而不是突然地改变资产阶级的所有制。 2）在改造他们的同时，给予他们以必要的工作安排。 3）不剥夺资产阶级的选举权，并且对于他们中间突出的代表人物给以恰当的政治安排。 意义：对资产阶级实行赎买，这是列宁曾经设想并打算实行的方法。中国共产党把这种设想付诸实施并取得成功，资产阶级中的绝大多数人公开表示接受这样的方案。 从根本上说，对于资本主义工商业的社会主义改造既符合于客观需要，也符合马克思主义理论，是一件有伟大历史意义的事情。 （3）新民主主义革命的胜利，社会主义基本制度的建立，为当代中国一切发展进步奠定了根本政治前提和制度基础 P147-168 1）新民主主义革命的胜利，推翻了帝、封、官资三大主义在中国的统治，建立了人民民主专政的人民共和国，广大人民群众真正当家做主，中国共产党成为全国范围的执政党，马克思主义成为指导思想。这些都为当代中国一切发展进步奠定了根本的政治前提； 2）新中国成立后，中国共产党领导人民建立和巩固了各级地方人民政权，召开了地方各级人民代表大会。在此基础上，1954年9月，召开了第一届全国人民代表大会第一次会议，通过了《中华人民共和国宪法》，确立了社会主义政治制度。这是当代中国一切发展进步的政治方面的制度基础。 3）通过对个体农业、手工业和资本主义工商业的社会主义改造，在全国范围建立了社会主义集体所有制和全民所有制，确立了社会主义经济制度。这是当代中国一切发展进步的经济方面的制度基础。 第九章**、社会主义建设在探索中曲折发展** 一、良好的开局 1、（1）社会主义制度确立后中国国内的主要矛盾 P172 1956年中共八大分析了国内的主要矛盾，是人民对于建立先进工业国的要求同落后的农业国的现实之间的矛盾，是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。实质是先进的社会主义制度同落后社会生产力之间的矛盾。 （2）《关于正确处理人民内部矛盾的问题》 P174 1957年2月，毛泽东在扩大的最高国务会议上的讲话，提出要把正确处理人民内部矛盾作为国家政治生活的主题。 （3）整风运动与反右派斗争 P175-176 整风运动：1957年4月27日，中共中央发出《关于整风运动的指示》，整风运动全面开展。（反对主观主义、宗派主义、官僚主义） 反右派斗争：1957年6月8日，中共中央发出反击右派分子进攻的指示，《人民日报》发表《这是为什么》社论，全面群众性的反右派运动开展起来了。 2、《论十大关系》及其提出的建设社会主义的基本方针 P171 1956年4月25日毛泽东中央政治局扩大会议和5月2日最高国务会议上作《论十大关系》的报告。系统阐述了经济政治十方面关系。 基本方针：一定要努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来，把我国建设成为一个强大的社会主义国家。这成为同年9月召开的中共八大的指导思想。是以毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志。 3、（1）中共八大制定的路线及其意义 P172-173 1956年9月15日至27日，中共八大在北京举行。 1）路线： 大会正确地分析了社会主义制度建立后国内的主要矛盾和主要任务，指出：我们国内的主要矛盾，已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾。党和全国人民的当前的主要任务是集中力量来解决这个矛盾，把我国尽快地从落后的农业国变为先进的工业国。 2）意义：中共八大为全面进行社会主义建设制定的路线是正确的，提出的许多新的方针和思想是富于创造精神的。大会集中全党智慧总结提出的探索中国建设社会主义道路的重要成果，对于社会主义建设事业和党的事业的发展有着长远的指导意义。 （2）毛泽东关于社会主义社会基本矛盾的分析 P174 1957年2月，毛泽东发表《关于正确处理人民内部矛盾的问题》讲话。毛泽东在文章中科学分析了社会主义社会的基本矛盾，指出：社会主义社会的基本矛盾仍然是生产力和生产关系、经济基础和上层建筑之间的矛盾。这些矛盾可以经过社会主义制度本身的自我调整和完善，不断地得到解决。这实际上为积极促进社会主义制度的自我完善和发展奠定了理论基石。 4、毛泽东关于正确区分两类社会矛盾以及正确处理人民内部矛盾的思想及其意义 P174 1957年2月，毛泽东在扩大的最高国务会议上《关于正确处理人民内部矛盾的问题》的讲话，提出要把正确处理人民内部矛盾作为国家政治生活的主题。 1）概括提出了区分和处理敌我和人民内部两类矛盾的学说，敌我之间的矛盾需要用强制的、专政的方法去解决；人民内部的矛盾只能用民主的、说服教育夫人、“团结—批评—团结”的方法去解决。 2）正确处理人民内部矛盾问题有一个重要指导思想，就是“团结全国各族人民进行一场新的战争—向自然界开战，发展我们的经济、文化，使全天人民比较顺利地走过目前的过渡时期，巩固我们的新制度，建设我们的新国家”。 3）《关于正确处理人民内部矛盾的问题》是一篇重要的马克思主义文献，运用马克思主义对立统一规律，创造性地阐述了社会主义社会矛盾学说，是对科学社会主义理论的重要发展，进一步丰富和发展了中共八大路线，对中国社会主义事业具有长远的指导意义。 二、探索中的严重曲折 1、（1）“大跃进”运动 P177 1958年发动，初衷是好的，但结果是违背经济规律，破坏了经济平衡。其主要标志和特点是：高指标、瞎指挥、浮夸风、“共产风”。 （2）人民公社化运动 P178 1958年发动，人民公社的体制是 “政社合一”，特点被概括为 “一大二公”，实际上就是搞“一平二调” （ “大”指规模大：“公”，是公有化程度高。“平”指绝对平均的分配方式，“调”指对原属个高级社的生产资料和财产无偿调拨）。结果：脱离农村生产水平，伤害社员和小集体利益。 （3）庐山会议 P180 1）1959年7月2日起，中共中央在庐山召开政治局扩大会议。会间，彭德怀致信毛泽东，认为1958年大跃进“成绩确是伟大的，但也有不少深刻的经验教训”。毛泽东错误地认为这是党内外的右倾势力对“三面红旗的否定。2）8月，在庐山召开中共八届八中全会。作出了《关于以彭德怀同志为首的反党集团的错误的决议》，随后在全党范围错误地开展了”反右倾“斗争。 （4）“二月逆流” P185 1966年2月中旬，在有部分中共中央政治局委员、国务院和中共中央军委领导人参加的碰头会上，谭震林、陈毅、叶剑英、李富春、李先念、徐向前、聂荣臻等对中央文革小组的错误做法提出强烈的批评。然而，这次抗争却被诬称为”二月逆流“，遭到压制。 （5）林彪反革命集团 P186 1971年，林彪反革命集团阴谋夺取最高权力、策动反革命武装政变（简称“九一三”事件）。是“文化大革命”推翻党的一系列基本原则的结果，客观上宣告了“文化大革命”的理论和实践的失败。 （6）“四人帮” P187 1973年8月召开的中国共产党第十次全国代表大会，继续了九大的“左”倾错误方针。江青、张春桥、姚文元、王洪文在中央政治局内结成“四人帮”。 2、（1）20世纪60年代前期的国民经济调整 P181 1）调整开始的标志 ：1960年11月，中共中央发出《关于农村人民公社当前政策的紧急指示信》，要求彻底清理“一平二调”，彻底纠正“共产风”。 1961年1月，中共八届九中全会正式决定对国民经济实行“调整、巩固、充实、提高”的方针。紧急指示信》的发布和全会的召开，标志着党和政府指导方针的重要转变。 2）调整中形成一系列工作条例：毛泽东亲自主持起草了《农村人民公社工作条例（草案）》（简称农业六十条）。其他领导人也主持制定出有关各方面的工作条例草案，总结历史经验，继续纠正“左”的错误，推动国民经济转入1962年至1965年的三年调整时期。 （2）“文化大革命”的发动 P183-184 导火线：1965年11月10日，姚文元的文章《评新编历史剧〈海瑞罢官〉》在上海《文汇报》发表。发动和开始的标志：1966年5月，中共中央召开政治局扩大会议。会议通过的《中共中央通知》（即“五一六通知”），系统地阐发了发动“文化大革命”的主要论点。会上成立“中央文化革命小组，成为文革领导机构。 再发动：1965年8月，中共八届十一中全会召开，会上印发毛泽东《炮打司令部——我的一张大字报》，对”文化大革命“进行再发动。全会通过的《关于无产阶级文化大革命的决定》（简称”十六条“），成为 ”文化大革命“的指导方针。 （3）“文化大革命”的结束 P187-188 1976年年9月9日，毛泽东逝世。江青反革命集团加紧进行夺取党和国家最高领导权的阴谋活动。10月6日晚，中共中央政治局执行党和人民的意志，毅然粉碎了江青反革命集团，结束了“文化大革命”。（在这场斗争中，华国锋、叶剑英、李先念等起了重要作用，作出了重要贡献。） 3、（1）1958年秋冬至庐山会议前期的纠“左”努力 P178-180 1）1958年11月，毛泽东在第一次郑州会议中提出，需要冷静下来，联系中中国社会主义革命和经济建设去读一些马克思主义理论著作，强调搞社会主义没有耐心是不行的； 2）同年武昌中共八届六中全会通过《关于人民公社若干问题的决议》，整顿人民公社，虽然有效的遏制了急于向全民所有制、向共产主义过渡的势头，但没有真正缓解政府同农民的紧张关系； 3）1959年第二次郑州会议，制定了《关于人民公社管理体制的若干规定（草案）》，上海会议上制定了《关于人民公社的十八个问题》，进一步巩固了武昌会议和第二次郑州会议的纠“左”成果； 4）在纠正人民公社化过程中的问题同时，政府对过高的生产指标也作了适当的调整； 总体来说，经过纠“左”努力取得初步成效，但在继续坚持总路线、大跃进、人民公社的前提下，带有很大局限性。 （2）“七千人大会”的召开及其意义 P181-182 1）1962年1、2月间，中共中央在北京召开扩大的中央工作会议。中央、大区、省市自治区、地区、县五级的党政军领导干部七千余人与会，被称为“七千人大会”。毛泽东、刘少奇等对前几年的工作展开批评和自我批评并初步总结了经验。 2）意义：这次会议对于恢复实事求是、民主精神和自我批评精神起了积极作用，在贯彻落实“八字方针”、推动形势迅速好转的过程中起了关键作用。“七千人大会”前后，中央开始对“反右倾”运动中受到错误批判的人进行甄别平反，摘掉了大多人的“右派分子”帽子。由于采取了一系列果断措施，国民经济得到比较顺利的恢复和发展。 （3）社会主义教育运动 P183 1963年至1965年，多数城乡发起了社会主义教育运动。虽然对于解决干部作风和经济管理等方面的问题起来一定作用，但把这些问题都作为阶级斗争或阶级斗争在党内的反映来处理，使不少基层干部受到不应有的打击。1965年（《农村社会主义教育运动中目前提出的一些问题》）简称“二十三条”又错误地提出运动的重点是“整党内那些走资本主义道路的当权派”。 4、（1）探索中国社会主义建设道路的曲折历程 P176-189 1）“大跃进”和“人民公社化运动”；纠正“左倾”错误的努力；“反右倾”斗争的错误开展；国民经济的调整。 2）文化大革命；全面内乱，“二月逆流”；林彪反革命集团及其粉碎；“四人帮”、“组阁”图谋的挫败； （2）“文化大革命”发生的社会历史原因 P189-190 “文化大革命”之所以发生并且持续十年之久，有着深刻的社会历史原因。 1）我们党在迅速进入社会主义新的历史阶段之后，对于如何在一个经济文化不发达的国家进行全面的社会主义建设，缺乏充分的思想准备和科学研究；对于什么是社会主义、怎样建设社会主义的问题，并没有完全搞清楚。 2）由于中国共产党在历史上积累下了丰富的阶级斗争经验，在社会主义改造基本完成之后，在观察和处理社会主义建设中遇到的新事物、新问题时，容易照搬过去的经验，把本不属于阶级斗争的问题看作是阶级斗争，仍然习惯于采取大规模群众性政治运动的方法去处理。这种脱离现实生活的主观主义的思想和做法，由于把马克思、恩格斯、列宁、斯大林著作中的某些设想和论点加以误解或教条化，反而显得有“理论根据”。这些都促成了阶级斗争扩大化错误的产生。 3）党的民主集中制和集体领导制度遭到严重破坏，致使党无法依靠制度的和集体的力量及时地发现并纠正错误。在中国共产党面临工作重心转向社会主义建设这一新任务因而需要特别谨慎的时候，毛泽东逐渐骄傲起来，逐渐脱离实际和脱离群众，主观主义和个人专断作风日益严重，日益凌驾于党中央之上，使党和国家政治生活中的集体领导原则和民主集中制不断受到削弱以至破坏。再加上由于种种历史原因，使党的权力过分集中于个人，党内个人专断和个人崇拜现象滋长起来，这样也就使党和国家难于防止和制止像“文化大革命”这样全局性错误的发生和发展。 （3）科学分析中国共产党在探索中所犯的错误 P190 在1956年到1976年，中国共产党所犯的错误，需要做具体的、历史的分析。 1）中国共产党在犯严重错误的时候，其性质和宗旨都没有改变。 在“大跃进”造成国民经济严重困难的时期，党和政府对人民群众依然具有巨大凝聚力。在“文化大革命”的特殊年代里，中国共产党保持着统一，社会主义制度的根基仍然保存，经济建设仍在进行，国家仍然保持统一，并在国际上发挥着重要左右 2）党内外广大干部群众在“文化大革命”期间对“左”倾错误的抵制和抗争，对林彪、江青两个反革命集团的斗争，从未停止过，使得“文化大革命”的破坏性作用受到一定的限制。 3）毛泽东在全局上坚持“文化大革命”的错误，但也制止和纠正过一些具体错误。保护过一些党政军领导干部和党外著名人士，使一些负责干部重新回到重要的领导岗位。领导粉碎林彪反革命集团，对“四人帮”批评和揭露，使其夺取党和国家最高领导权的图谋未能得逞。始终警觉地维护国家的安全，并开创了外交工作的新局面。在“文化大革命”中，共产党维持着统一，社会主义制度的根基仍然保存，经济建设仍在进行，国家仍然保持统一都是同毛泽东的作用分不开的。 三、建设的成就探索的成果 1、（1）“两弹一星” P192 1964年10月，中国爆炸了第一颗原子弹。 1967年6月，爆炸了第一颗氢弹。 1970年4月，第一颗人造地球卫星发射成功。 （2）中国恢复在联合国的合法席位 P193 1971年10月，在广大发展中国家的积极争取下中国恢复了在联合国合法席位 （3）“乒乓外交”与中美关系正常化 P194 20世纪60年代末，尼克松总统开始检讨美国的对华政策，毛泽东、周恩来敏锐地觉察到美方的变化，抓住时机发起了“乒乓外交”，实现“小球转动了大球”。1972年2月，美国总统尼克松访华，中美两国发表上海联合公报。同年9月，中日两国发表关于建交的联合声明，中美关系正常化。 2、毛泽东关于社会主义发展阶段的思考 P194 毛泽东关于社会主义的发展阶段，毛泽东指出社会主义这个阶段，又可能为两个阶段。 第一个阶段是不发达的社会主义； 第二个阶段是比较发达的社会主义，这一阶段可能比前一阶段需要更长的时间。 3、实现社会主义现代化的“两步走”战略 P194 以毛泽东为代表的第一代领导集体提出的“两步走”发展战略： 第一步，建成一个独立的比较完整的工业体系和国民经济体系； 第二步，全面实现农业、工业、国防和科学技术的现代化，使中国的经济走在世界前列。 4、（1）新中国社会主义建设取得的成就 P191-194 1）基本建立了独立的比较完整的工业体系和国民经济体系，从根本上解决了工业化中“从无到有”的问题，为国民经济的进一步发展打下了坚实的基础； 2）人民生活水平提高，文化、医疗、科技等事业发展，初步满足了站世界1/4人口的基本生活需求，文化、教育、文学艺术、医疗、科学技术方面等取得了一系列重要的成就； 3）国际地位提高，国际环境改善，抗美援朝的胜利，日内为国际会议和万隆会议的出席，极大的提高了新中国的国际地位。提出和平共处五项原则成为处理国与国际关系的公认的国际准则。20世纪70年代恢复了联合国的合法席位，打开了中美、中日关系正常化的大门。 （2）毛泽东等老一代革命家探索中国社会主义建设道路的理论贡献及其意义 P194-195 1）在基本的指导思想方面，论述了必须实行马克思主义与中国实际“第二次结合”的基本思想，提出了社会主义社会矛盾的学说，阐明了建设社会主义的基本方针。 2）在社会主义发展阶段问题上，提出社会主义发展阶段阶段分为不发达的社会主义和比较发达的社会主义两个阶段。 3）在社会主义现代化建设的战略目标和步骤问题上，强调社会主义现代化建设采取“两步走”的发展战略，第一步，建成一个独立的比较完整的工业体系和国民经济体系；第二步，全面实现农业、工业、国防和科学技术的现代化战略目标，使中国的经济走在世界前列。 4）在社会主义经济建设方面，毛泽东提出了一系列正确的观点。如以农、轻、重为序发展国民经济； 在优先发展重工业的条件下，坚持工业和农业并举、重工业和轻工业并举、中央工业和地方工业并举、大中小企业并举等“两条腿”走路的方针；正确解决好综合平衡的问题，处理好积累和消费、生产和生活的问题，处理好国家、集体和个人的关系，统筹兼顾，适当安排。 5）在社会主义民主政治建设方面，毛泽东提出了许多正确的观点。如造成一个又有集中又有民主，又有纪律又有自由，又有统一意志、又有个人心情舒畅、动活泼的政治局面； 要把正确处理人民内部矛盾作为国家政治生活的主题； 处理好中国共产党同各民主党派的关系，坚持长期共存、互相监督的方针，巩固和扩大爱国统一战线； 要切实保障人民当家作主的各项权利，尤其是人民参与国家和社会事务管理的权利； 社会主义法制要保护劳动人民利益，保护社会主义经济基础，保护社会生产力。） 6）在社会主义文化建设方面，毛泽东提出，要坚持马克思主义的指导地位，实行“百花齐放、百家争鸣”的方针。 7）在国防建设和军队建设方面，毛泽东提出必须加强国防、建设现代化正规化国防军和发展现代化国防技术的重要指导思想。 8）关于加强共产党自身建设，毛泽东最早觉察到帝国主义的“和平演变”战略的危险，号召共产党人提高警惕，同这种危险作斗争。十分警惕党在执政以后可能产生的种种消极现象。提出：共产党员务必继续地保持谦虚、谨慎、不骄、不躁的作风。继续地保持艰苦奋斗的作风。 意义： 以毛泽东为主要代表的中国共产党人所阐明的这些重要思想，把对社会主义社会建设和发展规律的认识大大地向前推进，为继续进行探索并在中共十一届三中全会后系统形成中国特色社会主义理论提供了重要的基础。 第十章 改革开放与现代化建设新时期 一、历史性的伟大转折和改革开放的起步 1、（1）四项基本原则 P201 1979年3月30日，邓小平在理论工作务虚会上提出：即坚持社会主义道路，坚持人民民主专政，坚持共产党的领导，坚持马克思列宁主义、毛泽东思想这四项基本原则，（“四个坚持”）。 （2）20世纪70年代末80年代初的国民经济调整 P203 1979年4月中共中央工作会议提出对国民经济实行“调整、改革、整顿、提高”的方针，开始纠正前两年经济工作中的失误，清理长期存在的“左”倾错误影响。是我国经济建设指导思想的重要转变，也是改革开放的前奏。 （3）经济特区 P204 1980年5月，中央决定在深圳、珠海、汕头、厦门设立经济特区。 （4）全国人大常委会《告台湾同胞书》 P205 1979年1月1日发表，建议两岸结束军事对峙状态。 2、（1）平反冤假错案 P200-201 从1978年底到1982年底大规模进行，290多万名干部的冤假错案得到了平反和纠正。其中包括“天安门事件”、“反击右倾翻案风”等重大错案平反；为刘少奇彻底平反并恢复名誉；改正了错划右派分子的案件等。 （2）“统分结合”的农村家庭联产承包责任制 P204-205 1978年安徽、四川最早开始。1979年9月，中共十一届四中全会通过了《关于加快农业发展若干问题的决定》、1980年5月，邓小平发表《关于农村政策的谈话》，肯定包产到户、包干到户是社会主义集体经济的生产责任制并在全国各地逐渐推广。“统分结合”的农村家庭联产承包责任制的普遍实行，促进了“政社合一”的人民公社体制的解体。1983年10月，中央作出决定，废除人民公社，建立乡（镇）政府作为基层政权，同时成立村民委员会作为村民自治组织。 3、（1）关于真理标准问题大讨论 P198-199 1）1978年5月11日，《光明日报》发表题为《实践是检验真理的唯一标准》的特邀评论员文章，在全国开始了关于真理标准问题的大讨论。这一讨论冲破了“两个凡是”的思想束缚，自始至终得到邓小平等的全力支持。 2）关于真理标准问题的大讨论，是继延安整风之后又一场马克思主义思想解放运动，成为拨乱反正和改革开放的思想先导，为党重新确立实事求是的思想路线，纠正长期以来的“左”倾错误，实现历史性的转折作了思想理论准备。 （2）中国共产党第二个历史决议及其意义 P202 1981年中共十一届六中全会通过的《关于建国以来党的若干历史问题的决议》，简称“第二个历史决议”。 1）科学地评价了毛泽东和毛泽东思想的历史地位； 2）从根本上否定文化大革命的理论和实践，对新中国成立以来的重大历史事件作出了基本结论。 3）标志着党在指导思想上拨乱反正的完成，表明中国共产党是成熟的坚强的马克思主义政党，体现以邓小平为和谐的中共中央领导集体的成熟和远见，体现出中国共产党在反省错误、纠正错误的过程中总结新经验、探索新道路的能力。 4、（1）中共十一届三中全会的历史贡献 P199-200 1978年12月18日至22日，中共十一届三中全会在北京召开。中央工作会议上邓小平《解放思想，实事求是，团结一致向前看》的讲话实际是十一届三中全会的主题报告。 1）会议冲破长期“左”的错误的严重束缚，彻底否定了“两个凡是”的错误方针，高度评价了关于真理标准问题的讨论，并且断然否定“以阶级斗争为纲”的指导思想，作出了把工作重点转移到社会主义现代化建设上来和实行改革开放的战略决策，重新确立了马克思主义的思想路线、政治路线和组织路线。 2）全会公报全面分析了当前的主要矛盾和主要任务，指明了改革开放的方向。指出：大规模的急风暴雨式的群众阶级斗争已经基本结束，今后应该按照严格区别和正确处理两类不同性质的矛盾的方针去解决，按照宪法和法律规定的程序去解决。实现四个现代化，要求大幅度地提高生产力，也就必然要求多方面地改变同生产力发展不相适应的生产关系和上层建筑，改变一切不适应的管理方式、活动方式和思想方式，因而是一场深刻的革命。 3）全会作出了一系列具有深远影响的重大决定：决定全党工作的着重点应该转移到社会主义现代化建设上来；决定在党的生活和国家政治生活中加强民主，明确党的思想路线，加强党的领导机构和成立中央纪律检查委员会；决定把立法工作摆到全国人民代表大会及其常务委员会的重要议程上来；决定保障人民民主、加强社会主义法制等问题。 会议是新中国成立以来党的历史上具有深远意义的伟大转折，中国进入了改革开放和社会主义现代化建设的历史新时期。 （2）第二个历史决议关于毛泽东和毛泽东思想历史地位的科学评价 P202 1）毛泽东同志是伟大的马克思主义者，是伟大的无产阶级革命家、战略家和理论家。他的功绩是第一位的，错误是第二位的。他为中国共产党和中国人民解放军的创立和发展，为中国各族人民解放事业的胜利，为中华人民共和国的缔造和中国社会主义事业的发展，建立了永远不可磨灭的功勋。 2）决议对毛泽东思想的科学体系和活的灵魂作了概括。指出：毛泽东思想是马克思列宁主义在中国的运用和发展，是被实践证明了的关于中国革命和建设的正确的理论原则和经验总结，是中国共产党集体智慧的结晶。实事求是、群众路线和独立自主是贯穿其中的活动灵魂。决议强调：“毛泽东思想是我们党的宝贵的精神财富，它将长期指导我们的行动。 二、改革开放和现代化建设新局面的展开 1、（1）中共十二大 P205-206 1982年9月举行。邓小平在开幕词中提出：走自己的道路，建设有中国特色的社会主义。制定了社会主义现代化建设宏伟纲领。中共十二大报告提出了把我国建设成为高度文明、高度民主的社会主义国家。 提出到20世纪末国内工农业生产总值 “翻两番”，人民的物质文化生活达到小康水平。 （2）中共十三大 P209 1987年10月举行。大会比较系统地阐述了关于社会主义初级阶段的理论；完整地概括了中国共产党在社会主义初级阶段的基本路线；制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标。 （3）一个中心，两个基本点 P209 对党的十三大提出的社会主义初级阶段的基本路线的简要概括，一个中心即以经济建设为中心，两个基本点即坚持四项基本原则，坚持改革开放。1989年6月中共十三届四中全会进一步指出：四项基本原则是立国之本；改革开放是强国之路。 2、（1）中共十二届三中全会《关于经济体制改革的决定》 P207 1984年10月中共十二届三中全会通过。 《决定》突破把计划经济同商品经济对立起来的观点，指出我国社会主义经济是在公有制基础上的有计划的商品经济。 1）所有制结构突破单一的公有制结构，形成以公有制为主体，多种经济成分开始发展的局面； 2）大部分国有企业实行了各种形式的承包经营责任制，经营自主权逐步扩大，所有权和经营权适当分离； 3）其他领域的体制改革也加快了步伐。 （2）多层次对外开放格局 P207 1）1983年4月决定海南享有某些特殊政策（1988年4月建立海南省，将海南岛辟为经济特区）； 2）1984年5月开放14个沿海港口城市； 3）1985年2月开辟沿海经济开放区（长江三角洲、珠江三角洲、闽南厦门泉州漳州三角地区）； 逐步形成了“经济特区——沿海开放城市——沿海经济开放区——内地”这样一个多层次、有重点、点面结合的对外开放格局。 （3）社会主义精神文明建设 P208 1986年9月中共十二届六中全会作出，阐述了社会主义精神文明建设的战略地位和根本任务、基本方针提出社会主义精神文明建设的根本任务，是培养有理想、有道德、有文化、有纪律的社会主义公民，提高整个中华民族的思想道德素质和科学文化素质。 （4）中共十三届六中全会《关于加强党同人民群众联系的决定》 P213-214 1990年3月中共十三届六中全会通过。 1）强调能否始终保持和发展党同人民群众的血肉联系，直接关系到党和国家的盛衰兴亡； 2）提出在党内普遍深入地进行马克思主义群众观点和群众路线的再教育，克服党内存在的各种腐败现象。 3、（1）“三步走”发展战略 P210 1）第一步，实现国民生产总值比1980年翻一番，解决人民的温饱问题，这个任务已经基本实现；第二步，到20世纪末，使国民生产总值再增长一倍，人民生活达到小康水平；第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化。 2）为实现“三步走”的战略，提出“台阶式”发展的思想，要求抓住机遇，加快发展，争取每隔几年使国民经济上一个新台阶，阐明了允许和鼓励一部分地区、一部分人通过辛勤努力先富起来，逐步达到共同富裕的政策。 （2）邓小平《党和国家领导制度的改革》 P210 1980年，在中共中央政治局扩大会议上发表。 1）政治体制改革的具体内容：解决官僚主义、权力过分集中、党政不分、事实上存在的领导职务终身制等问题，肃清封建主义残余影响和资产阶级思想影响，发展社会主义民主，调动广大人民群众的积极性。 2）政治体制改革遵循的性质和指导原则：政治体制改革是社会主义制度的自我完善，必须以四项基本原则为指导，遵循统一领导、循序渐进的原则，在中国共产党的领导下有步骤、有秩序地推进。 3）政治体制改革的底线：必须坚持从本国国情出发，总结本国的实践经验，同时借鉴人类政治文明的有益成果，绝不应照搬西方政治制度的模式，绝不能搞资产阶级自由化。 根据邓小平提出的上述基本思路，其主要内容写入了十三大报告。 （3）邓小平关于中国农业改革和发展“两个飞跃”的思想 P212-213 1990年，同江泽民谈话时提出。 1）中国社会主义农业的改革和发展会有两个飞跃，第一个飞跃是废除人民公社，实行家庭联产承包为主的责任制，第二个飞跃是发展集体经济。 2）社会主义经济以公有制为主体，农业最终要以公有制为主体。从长远的观点看，必然产生第二个飞跃，即农村经济最终还是要实现集体化和集约化。仅靠双手劳动，仅是一家一户的耕作，不向集体化集约化经济发展，农业现代化的实现是不可能的。最终还是要走这条路。 4、社会主义初级阶段理论和中国共产党的基本路线 P209 1987年10月25日至11月1日，中共十三大举行。大会系统阐述了关于社会主义初级阶段的理论，完整地概括了中国共产党的社会主义初级阶段“一个中心、两个基本点”的基本路线，制订了下一步经济、政治体制改革的基本任务和奋斗目标。 1）十三大指出，我国正处在社会主义的初级阶段。这个论断，包括两层含义。第一，我国社会已经是社会主义社会。我们必须坚持而不能离开社会主义。第二，我国的社会主义社会还处在初级阶段。 2）中国共产党在社会主义初级阶段的基本路线是，领导和团结全国各族人民，以经济建设为中心（一个中心），坚持四项基本原则，坚持改革开放（两个基本点），自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗。（被简要概括为“一个中心”，“两个基本点”的路线） 三、改革开放和现代化建设发展的新阶段 1、（1）中共十四大 P215 1992年10月举行。确立了邓小平建设有中国特色社会主义理论在全党的指导地位，概括了建设有中国特色社会主义理论的主要内容。明确提出我国经济体制改革的目标是建立社会主义市场经济体制。 此后改革开放和现代化建设事业进入从计划经济体制向社会主义市场经济体制转变的新阶段。 （2）中共十四届三中全会《关于建立社会主义市场经济体制若干问题的决定》 P216 1993年11月中共十四届三中全会通过。将十四大提出的社会主义市场经济体制改革的目标和基本原则具体化，成为20世纪90年代进行经济体制改革的行动纲领。 （3）中共十五大 P218 1997年9月举行。大会主题：高举邓小平理论伟大旗帜，把建设有中国特色社会主义事业全面推向二十一世纪。把邓小平理论确立为中国共产党的指导思想，提出了党在社会主义初级阶段基本纲领。指出：公有制为主体、多种所有制经济共同发展，是中国社会主义初级阶段的一项基本经济制度。公有制的实现形式可以而且应当多样化。依法治国，是党领导人民治理国家的基本方略。 （4）“三讲”教育 P221 1998年11月，中共中央决定在县级以上党政领导班子、领导干部中开展以讲学习、讲政治、讲正气为主要内容的党性党风教育。历时近两年。 2、20世纪90年代后期改革开放和现代化建设经受的风险考验 P219-220 1）1997年亚洲经融危机； 2）1998年长江、嫩江和松花江等流域罕见洪涝灾害； 3）1999年北约袭击中国驻南斯拉夫使馆、李登辉“两国论”、“法轮功”邪教组织策划和煽动闹事。 3、（1）改革、发展、稳定的关系 P217 1）提出抓住机遇、深化改革、扩大开放、促进发展、保持稳定的基本方针。 2）1994年5月，提出：稳定是前提，改革是动力，发展是目的，三者相互促进。 3）1994年9月，在中共十四届五中全会提出要把改革的力度、发展的速度和社会可承受的程度协调统一起，做到在政治和社会稳定中推进改革和发展，在改革和发展的推进中实现政治和社会的长期稳定。 （2）香港澳门的回归 P220 1）1984年12月和1987年4月签署了中英《关于香港问题的联合声明》和中葡《关于澳门问题的联合声明》。1997年7月1日，中国对对香港恢复行使主权，香港特别行政区正式成立。1999年12月20日，澳门也回归祖国，澳门特别行政区正式成立。 2）香港、澳门的回归，使“一国两制”从科学构想变为现实，标志着祖国统一大业又向前迈出了重要的一步。 4、（1）邓小平南方谈话的主要内容及其意义 P214-215 1992年1月18日至2月21日，邓小平先后视察武昌、深圳、珠海、上海等地，发表重要谈话。 内容： 1）强调革命是解放生产力，改革也是解放生产力。提出 “三个有利于”标准，即判断一切工作和改革开放是非得失的主要看是否有利于发展社会主义社会的生产力，是否有利于增强社会主义国家的综合国力，是否有利于提高人民的生活水平。 2）指出计划多一点还是市场多一点，不是社会主义与资本主义的本质区别。计划和市场都是经济手段。社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕。强调中国要警惕右，但主要是防止“左”。 3）强调发展才是硬道理。抓住时机，发展自己，关键是发展经济。 4）指出关键在人，坚持“两手都要抓，两手都要硬”，一手抓改革开放，一手抓打击各种犯罪活动，反对腐败。 5）强调社会主义还处在初级阶段。巩固和发展社会主义制度，还需要一个很长的历史阶段，至少需要100年。 意义：小平南方谈话，在重大历史关头，科学地总结了十一届三中全会以来党的基本实践和基本经验，明确回答了长期困扰和束缚人们思想的许多重大认识问题，对整个社会主义现代化建设事业产生了重大而深远的影响。 （2）“三个代表”重要思想的提出及其意义 P221-222 1）提出：中共十三届四中全会以来，以江泽民为主要代表的中国共产党人，高举邓小平理论伟大旗帜，准确把握时代特征，科学判断中国共产党所处的历史方位，围绕建设中国特色社会主义这个主题，逐步形成了“三个代表”重要思想这一系统的科学理论。 “三个代表”重要思想作为完整的概念，是2000年2月江泽民在广东考察工作时提出来的。同年5月，江泽民又进一步把“三个代表”作为中国共产党的立党之本、执政之基、力量之源。2001年7月1日，江泽民在庆祝中国共产党成立80周年大会上发表讲话，系统阐述“三个代表”重要思想的科学内涵和基本内容。 2）意义：“三个代表”重要思想的提出，有力地推动了改革开放和现代化建设的跨世纪发展，也为中共十六大的召开奠定了思想基础。 四、全面建设小康社会 1、（1）中共十六大 P222 2002年11月举行。大会把“三个代表”重要思想确立为中国共产党的指导思想，写入党章。提出了全面建设小康社会的奋斗目标。 （2）保持共产党员先进性教育活动 P226 2005年初至2006年上半年，在全党开展以实践“三个代表”重要思想为主要内容的教育活动。 2、（1）社会主义核心价值体系 P224 2006年10月，中共十六届六中全会通过的《中共中央关于构建社会主义和谐社会若干重大问题的决定》中所提出：马克思主义指导思想，中国特色社会主义共同理想，以爱国主义为核心的民族精神和以改革创新为核心的时代精神，社会主义荣辱观，上述五方面构成社会主义核心价值体系的基本内容。 （2）建设社会主义新农村 P225 2005年10月，中共十六届五中全会提出建设社会主义新农村的战略任务，提出生产发展、生活富裕、乡风文明、村容整洁、管理民主的要求。 （3）社会主义荣辱观 P225 2006年3月胡锦涛提出了以“八荣八耻”为主要内容的社会主义荣辱观。它体现了社会主义道德规范的本质要求，成为社会主义精神文明建设的重要指导方针。 （4）加强党的执政能力建设 P226 2004年9月，中共十六届四中全会通过《关于加强党的执政能力建设的决定》。提出加强党的执政能力建设的五项主要任务：不断提高驾驭社会主义市场经济的能力、发展社会主义民主政治的能力、建设社会主义先进文化的能力、构建社会主义和谐社会的能力、应对国际局势和处理国际事务的能力。 3、（1）全面建设小康社会 P222 228 1）要转变发展方式，在优化结构、提高效益、降低消耗、保护环境的基础上，实现人均国内生产总值到2020年比2000年翻两番。 2）使中国成为工业化基本实现、综合国力显著增强、国内市场总体规模位居世界前列的国家，成为人民富裕程度普遍提高、生活质量明显改善、生态环境良好的国家，成为人民享有更加充分民主权利、具有更高文明素质和精神追求的国家，成为各方面制度更加完善、社会更加充满活力而又安定团结的国家，成为对外更加开放、更加具有亲和力、为人类文明作出更大贡献的国家。 3）提出要在本世纪头二十年，紧紧抓住这一重要战略机遇期，集中力量，全面建设惠及十几亿人口的更高水平的小康社会，使经济更加发展、民主更加健全、科教更加进步、文化更加繁荣、社会更加和谐、人民生活更加殷实。 （2）构建社会主义和谐社会 P224-225 2006年10月，中共十六届六中全会通过《中共中央关于构建社会主义和谐社会若干重大问题的决定》。 1）指出社会和谐是中国特色社会主义的本质属性，是国家富强、民族振兴、人民幸福的重要保证。将“和谐”列入现代化建设的奋斗目标，使中国特色社会主义事业的总体布局发展为社会主义经济建设、政治建设、文化建设、社会建设四位一体。 2）我们要构建的社会主义和谐社会，是在中国特色社会主义道路上，中国共产党领导全体人民共同建设、共同享有的和谐社会。 主要特征是民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处。 （3）坚持走和平发展的道路 P225-226 2005年11月，胡锦涛在英国伦敦金融城发表演讲，系统地阐述了走和平发展道路的基本内涵。 1）中国既通过争取和平的国际环境来发展自己，又通过自己的发展来促进世界和平，永远做维护世界和平、促进共同发展的坚定力量。 2）主要依靠自身力量和改革创新来实现发展，同时坚持对外开放的基本国策，在平等互利的基础上同世界各国开展交流合作，努力实现互利共赢。 3）中国与其他社会成员一道，为实现各国和谐相处、全球经济和谐发展、不同文明和谐进步的美好前景发挥积极作用，共同致力于建设一个持久和平、共同繁荣的和谐世界。 4、（1）科学发展观的提出及其意义 P223-224 2003年10月召开的中共十六届三中全会，正式提出了坚持以人为本、全面协调可持续的科学发展观。2007年10月15日，胡锦涛在中共十七大报告中，全面论述了科学发展观的科学内涵和精神实质。 1）内容：科学发展观，第一要义是发展，核心是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾。要始终把实现好、维护好、发展好最广大人民的根本利益作为党和国家一切工作的出发点和落脚点；做到发展为了人民、发展依靠人民、发展成果由人民共享。 2）意义：科学发展观是以胡锦涛为总书记的中共中央坚持以邓小平理论和“三个代表”重要思想为指导，从新世纪新阶段党和国家事业发展全局出发提出的重大战略思想。它是马克思主义关于发展的世界观和方法论的集中体现，是同马克思列宁主义、毛泽东思想、邓小平理论和“三个代表”重要思想既一脉相承又与时俱进的科学理论，是我国经济社会发展的重要指导方针，是发展中国特色社会主义必须坚持和贯彻的重大战略思想。 （2）中共十七大的主题及其意义 P226-227 主题：高举中国特色社会主义伟大旗帜，以邓小平理论和“三个代表”重要思想为指导，深入贯彻落实科学发展观，继续解放思想，坚持改革开放，推动科学发展，促进社会和谐，为夺取全面建设小康社会新胜利而奋斗。 意义： 1)大会报告总结改革开放以来的历程和成功经验，对中国特色社会主义道路和理论体系作了科学概括，阐明科学发展观的科学内涵和精神实质，进一步提出全面建设小康社会的新要求和战略部署； 2)审议并一致通过了党章修正案，在保持党章总体稳定的原则下，把十七大报告确立的重大理论观点、重大战略思想、重大工作部署写入党章； 3)选举产生新一届党的中央委员会（十七届一中全会选举胡锦涛为中共中央总书记）为继续推进中国特色社会主义事业提供了可靠的组织保证。 （3）改革开放的历史进程及基本经验 P227 中共十七大报告站在新的历史起点上，对改革开放近30年的历程作了回顾，指出： 1）自1978年中共十一届三中全会开启了改革开放历史新时期以来，中国人民的面貌、社会主义中国的面貌、中国共产党的面貌发生了历史性变化。 2）新时期最鲜明的特点是改革开放，最显著的成就是快速发展，最突出的标志是与时俱进。 3）改革开放以来我们取得一切成绩和进步的根本原因，归结起来就是：开辟了中国特色社会主义道路，形成了中国特色社会主义理论体系。高举中国特色社会主义伟大旗帜，最根本的就是要坚持这条道路和这个理论体系。 五、改革开放和现代化建设的成就 1、基层民主自治体系 P230 以农村村民委员会、城市居民委员会和企业职工代表大会为主要内容。 2、走中国特色精兵之路 P232 1）以科学发展观作为国防和军队建设的重要指导方针，人民解放军坚持以新时期军事战略方针为统揽； 2）以推进中国特色军事变革为主线； 3）以军事斗争准备为龙头，按照建设信息化军队、打赢信息化战争的战略目标，全面推进国防和军队现代化建设，坚定不移地走中国特色精兵之路。 3、进入21世纪的全方位外交 P232 国际影响日益扩大，国际地位显著提高，在国际社会中发挥着重要作用。具体说： （1）同周边的睦邻友好关系日益加强。努力推动南南合作和南北对话，同广大发展中国家的传统友好合作关系进一步巩固。 （2）同发达国家的关系得到改善和发展。中美关系总体保持稳定和发展，中俄战略协作伙伴关系继续深化，中欧全面战略伙伴关系的内涵不断充实。 （3）中国政府坚决反对各种形式的霸权主义和强权政治，推动建立和平、稳定、公正合理的国际新秩序，大力倡导互信、互利、平等、协作的新安全观，按照和平共处五项原则和其他公认的国际关系准则处理国际事务。 4、（1）中共十一届三中全会以来取得的十大成就 P229-233 1）综合国力和国际竞争力显著提高； 2）人民生活总体达到小康水平； 3）经济体制改革和对外开放取得重大进展； 4）社会主义民主政治建设稳步推进； 5）社会主义精神文明建设成效显著； 6）民族政策和宗教政策得到全面贯彻； 7）祖国统一大业取得重大进展； 8）国防和军队建设迈出新步伐； 9）积极开展全方位外交； 10）党的建设新的伟大贯彻全面推进。 （2）改革开放近三十年的深刻历史启示 P233-234 经验： 1）（找到了一条道路）开创了中国特色社会主义道路，沿着这条道路，大幅度提高了国家的综合国力和人民生活水平，为全面建设小康社会、基本实现社会主义现代化开辟了广阔的前景。 2）（举起了一面旗帜）中国特色社会主义，是当代中国发展进步的旗帜，是全党全国各族人民团结奋斗的旗帜。 3）（坚持了一条路线）毫不动摇地坚持党的基本路线，是我们事业能够经受风险考验、顺利达到目标的最可靠的保证。 4）（得出了一句结论）实践充分证明，中共十一届三中全会以来中国共产党开辟的中国特色社会主义道路，确立的基本理论、基本路线、基本纲领、基本经验，是完全正确的。 启示： 1）（底子薄）人口多、底子薄、人均占有资源少，中国依然是世界上最大的发展中国家，必须居安思危，长期艰苦奋斗。 2）（新问题）中国的改革开放和现代化建设面临着新的考验和诸多新的问题。如城乡、区域、经济社会发展很不平衡，人口资源环境压力加大等。 这些问题，在中国共产党领导下，依靠社会主义制度，是可以在前进中解决的，也只有在前进中才能解决。 简单的结语 4、20世纪中国经历的三次历史性巨大变化 P235-236 20世纪以来，中国更经历了三次历史性的巨大变化。 1）第一次是辛亥革命，推翻统治中国几千年的君主专制制度。它开创了完全意义上的近代民族民主革命。为中国的进步打开了闸门，使反动统治秩序再也无法稳定下来。 2）第二次是中华人民共和国的成立和社会主义制度的建立。中国共产党带领人民完成民族独立和人民解放的历史任务，建立了人民当家作主的新中国，为实现中华民族的伟大复兴创造了前提。新中国成立后，中国共产党带领全国人民确立了社会主义基本制度。 3）第三次是改革开放，为实现社会主义现代化而奋斗。在新中国成立以来革命和建设成就的基础上，十一届三中全会以来，中国共产党带领全人民，成功地开创了中国特色社会主义道路，坚持以经济建设为中心、坚持四项基本原则、坚持改革开放，初步建立起社会主义市场经济体制，大幅度提高了我国的综合国力和人民生活水平，为全面建设小康社会、基本实现社会主义现代化开辟了广阔的前景。社会主义在中国显示出蓬勃的生机和活力，并赋予中华民族复兴以新的强大生机。 这三次历史性巨大变化，从根本上改变了中国人民的前途命运，决定了中国历史的发展方向。","link":"/2020/10/31/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"},{"title":"Android开发艺术探究 1-10","text":"1.onStart 和 onResume、onPause和onStop从描述上来看差不多，对我们来说有什么实质的不同？ onStart 和 onStop是从Activity是否可见这个角度来回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的，除了这种区别，没有其他区别 2.假设当前Activity为A，如果这时用户打开一个新Activity B，那么 B 的onResume()和 A 的onPaus()哪个先执行呢？ 启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护着一个ActivityStack并负责栈内的Activvity的状态，AMS通过 ActivityThread去同步Activity的状态从而完成生命周期方法的调用。在ActivityStack中的resumeTopActivityInnerLocked方法中，在新Acctivity启动之前， 栈顶的Activity需要先onPause()后，新Activity才能启动。最终在ActivityStackSupervisor中的realStartActivityLocked方法会调用scheduleLaunchActivity， 接着完成新Activity的onCreate、onStart、onResume的调用过程。因此，可以得到结论，是旧Activity先onPause，然后新Activity再启动。 3.Activity被销毁并重建后，我们去获取之前的存储字符串，接受的位置可以是onRestoreInstanceState 或者 onCreate 方法，两者区别是？ onRestoreInstanceState一旦被调用，其参数Bundle savedInstanceState 一定是有值的，我们不用额外的拍断是否为空； 但是onCreate不行，onCreate如果正常启动的话，其参数Bundle savedInstanceState为null, 所以必须要额外判断。 4.onSaveInstanceState和onRestoreInstanceState，在正常流程下会出发么？ 系统只在Activity异常种植的时候才会调用onSaveInstanceState和onRestoreInstanceState来存储和恢复数据，其他情况不会出发这个过程。 5.比如目前任务栈S1中的情况为ABC，这个时候Activity D 以singleTask模式请求启动，其所需要的任务栈为 S2，由于S2和D的实例均不存在，所以系统会先创建 任务栈S2，然后在创建D的实例并将其入栈到S2. 6.TaskAffinity任务相关性。 这个参数标识一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为应用的包名。可以为每个Activity都单独制定TaskAffinity属性， 这个属性必须不能和包名相同，否则就相当于没有制定。TaskAffinity属性主要和singleTask启动模式或者allTaskReparenting属性配对使用。当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity回运行在名字和TaskAffinity相同的任务栈中。 当TaskAffinity和allowTaskReparenting结合的时候，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allTaskReparenting属性为true的话，那么当应用B被启动后，词Activity回直接从应用A的任务栈转移到应用B的任务栈中。 7.SharedPerences是否安全？ SharedPreferences不支持两个进程同时去执行写操作，否则会导致一定几率的数据丢失，因为SharedPreferences底层是通过读/写XML文件来实现的，并发会出问题。 每个应用的SharedPreferences文件都在当前包所在的data目录下查看到，目录位于 /data/data/pacakage name/shared_prefs目录下。 SharedPreferences也属于文件的一种，但是由于系统对他的读/写有一定的缓存策略，即在内存中有一份ShareePreferences文件的缓存，因此在多进程下，系统对它的读写诗不可靠的，当面对高并发的读/写访问，有很大几率丢失文件。 8.Serializable接口的原理及serialVersionUID作用？ 想让一个对象实现序列化，只需要这个类实现Serializable接口并声明一个serialVersionUID即可。实际上，甚至连这个serialVersionUID也不是必须的。如何进行对象的序列化和反序列化也很简单，只需要采用ObjectOutputStream和ObjectInputStream，readObject()writeObject()函数。 serialVersionUID是用来辅助序列化和反序列化过程的，原则上序列化后的数据中的serialVersionUID只有和当前累的serialVersionUID相同时才能够正常的被反序列化。 serialVersionUID的详细工作机制时这样的：序列化的时候系统把当前类的serialVersionUID写入序列化文件中，当反序列化时候系统回去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本时相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变化，比如成员变量的数量、类型可能发生了改变，这个时候时无法正常反序列化的。 9.Parcelable接口原理？ Parcelable也是一个接口，只要实现这个接口，一个类的对象就可以实现序列化并通过Intent和Binder传递。 Parcel内部包装了可序列化的数据，可以在Binder中自由传输。 序列化的功能由writeToParcel方法来完成，最终时通过Parcel的一系列write方法来完成的； 反序列化功能由CREATOR来完成，其内部表明了如何创建序列化对象和数组，并通过Parcel的一系列read方法来完成反序列化过程。 10.Parcelable和Serializable的区别？ Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。 Parcelable是Android中的序列化方式，操作复杂，效率很高。 Parcelable主要用在内存序列化上，通过Parcelable将对象序列化到存储设备中或者将对象序列化后通过网络传输也都是可以的，但是 这个过程会稍显复杂，因此这两种情况建议使用Serializable。","link":"/2021/09/17/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%A9%B6/"},{"title":"Glide圆角失效问题","text":"title: Glide圆角问题thumbnail: /gallery/thumbnails/ChMlV17jFHCIasscABVv58GqDdkAAUrTgCXxekAFW__680.jpgcategories: 精品美文tags: Glide 圆角 Glide圆角问题 前两天 项目中遇到了 Glide圆角失效的问题，百度了一圈，最后找到了正解。 RequestOptions options = new RequestOptions(); options.transform(buildRoundCornerTransformation(imageView, 20)); Glide.with(imageView.getContext()).load((String)path).apply(options).into(imageView); /** * Glide 圆角问题 * @param imageView * @param cornerRadius * @return */ private static MultiTransformation buildRoundCornerTransformation(ImageView imageView, int cornerRadius) { switch (imageView.getScaleType()) { case CENTER_INSIDE: return new MultiTransformation&lt;Bitmap&gt;(new CenterInside(), new RoundedCorners(cornerRadius)); case FIT_CENTER: case FIT_START: case FIT_END: case FIT_XY: return new MultiTransformation&lt;Bitmap&gt;(new FitCenter(), new RoundedCorners(cornerRadius)); case CENTER_CROP: default: return new MultiTransformation&lt;Bitmap&gt;(new CenterCrop(), new RoundedCorners(cornerRadius)); } }","link":"/2021/09/17/Glide%E5%9C%86%E8%A7%92%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Build","slug":"Build","link":"/tags/Build/"},{"name":"CoordinatorLayout","slug":"CoordinatorLayout","link":"/tags/CoordinatorLayout/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"AAPT","slug":"AAPT","link":"/tags/AAPT/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"ApkBuilder","slug":"ApkBuilder","link":"/tags/ApkBuilder/"},{"name":"Dex工具","slug":"Dex工具","link":"/tags/Dex%E5%B7%A5%E5%85%B7/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"版本控制","slug":"版本控制","link":"/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"},{"name":"分支","slug":"分支","link":"/tags/%E5%88%86%E6%94%AF/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"Gradle插件开发","slug":"Gradle插件开发","link":"/tags/Gradle%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"zipalign工具","slug":"zipalign工具","link":"/tags/zipalign%E5%B7%A5%E5%85%B7/"},{"name":"keystore","slug":"keystore","link":"/tags/keystore/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"GC算法","slug":"GC算法","link":"/tags/GC%E7%AE%97%E6%B3%95/"},{"name":"Charles","slug":"Charles","link":"/tags/Charles/"},{"name":"MAC应用","slug":"MAC应用","link":"/tags/MAC%E5%BA%94%E7%94%A8/"},{"name":"破解","slug":"破解","link":"/tags/%E7%A0%B4%E8%A7%A3/"},{"name":"MACOS","slug":"MACOS","link":"/tags/MACOS/"},{"name":"AndroidStudio","slug":"AndroidStudio","link":"/tags/AndroidStudio/"},{"name":"网络","slug":"网络","link":"/tags/%E7%BD%91%E7%BB%9C/"},{"name":"壁纸路径","slug":"壁纸路径","link":"/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"name":"Mac系统","slug":"Mac系统","link":"/tags/Mac%E7%B3%BB%E7%BB%9F/"},{"name":"谷歌云","slug":"谷歌云","link":"/tags/%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"name":"so文件","slug":"so文件","link":"/tags/so%E6%96%87%E4%BB%B6/"},{"name":"ndk","slug":"ndk","link":"/tags/ndk/"},{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/%E7%BF%BB%E5%A2%99/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"霍比特人","slug":"霍比特人","link":"/tags/%E9%9C%8D%E6%AF%94%E7%89%B9%E4%BA%BA/"},{"name":"意外之旅","slug":"意外之旅","link":"/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"},{"name":"bt","slug":"bt","link":"/tags/bt/"},{"name":"指环王","slug":"指环王","link":"/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"},{"name":"比尔博·巴金斯","slug":"比尔博·巴金斯","link":"/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"},{"name":"甘道夫","slug":"甘道夫","link":"/tags/%E7%94%98%E9%81%93%E5%A4%AB/"},{"name":"索伦","slug":"索伦","link":"/tags/%E7%B4%A2%E4%BC%A6/"},{"name":"魔苟斯","slug":"魔苟斯","link":"/tags/%E9%AD%94%E8%8B%9F%E6%96%AF/"},{"name":"戒灵","slug":"戒灵","link":"/tags/%E6%88%92%E7%81%B5/"},{"name":"炎魔","slug":"炎魔","link":"/tags/%E7%82%8E%E9%AD%94/"},{"name":"精灵","slug":"精灵","link":"/tags/%E7%B2%BE%E7%81%B5/"},{"name":"魔戒","slug":"魔戒","link":"/tags/%E9%AD%94%E6%88%92/"},{"name":"咕噜","slug":"咕噜","link":"/tags/%E5%92%95%E5%99%9C/"},{"name":"阿拉贡","slug":"阿拉贡","link":"/tags/%E9%98%BF%E6%8B%89%E8%B4%A1/"},{"name":"魔多","slug":"魔多","link":"/tags/%E9%AD%94%E5%A4%9A/"},{"name":"史茅革","slug":"史茅革","link":"/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"},{"name":"ShadowRocket","slug":"ShadowRocket","link":"/tags/ShadowRocket/"},{"name":"小火箭","slug":"小火箭","link":"/tags/%E5%B0%8F%E7%81%AB%E7%AE%AD/"},{"name":"Appstore","slug":"Appstore","link":"/tags/Appstore/"},{"name":"vpn","slug":"vpn","link":"/tags/vpn/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"brew","slug":"brew","link":"/tags/brew/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"开车司机","slug":"开车司机","link":"/tags/%E5%BC%80%E8%BD%A6%E5%8F%B8%E6%9C%BA/"},{"name":"番号","slug":"番号","link":"/tags/%E7%95%AA%E5%8F%B7/"},{"name":"pornograhic","slug":"pornograhic","link":"/tags/pornograhic/"},{"name":"spread pornograhic content","slug":"spread-pornograhic-content","link":"/tags/spread-pornograhic-content/"},{"name":"后台服务","slug":"后台服务","link":"/tags/%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1/"},{"name":"Tomact","slug":"Tomact","link":"/tags/Tomact/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ClashX","slug":"ClashX","link":"/tags/ClashX/"},{"name":"加速器","slug":"加速器","link":"/tags/%E5%8A%A0%E9%80%9F%E5%99%A8/"},{"name":"Shadowsocks","slug":"Shadowsocks","link":"/tags/Shadowsocks/"},{"name":"V2Ray","slug":"V2Ray","link":"/tags/V2Ray/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"激活码","slug":"激活码","link":"/tags/%E6%BF%80%E6%B4%BB%E7%A0%81/"},{"name":"IntellJ","slug":"IntellJ","link":"/tags/IntellJ/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"WordPress","slug":"WordPress","link":"/tags/WordPress/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"个人博客","slug":"个人博客","link":"/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"name":"MacOs","slug":"MacOs","link":"/tags/MacOs/"},{"name":"Mac应用","slug":"Mac应用","link":"/tags/Mac%E5%BA%94%E7%94%A8/"},{"name":"快捷键","slug":"快捷键","link":"/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"},{"name":"Python3","slug":"Python3","link":"/tags/Python3/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"小游戏开发","slug":"小游戏开发","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"ThreadPool","slug":"ThreadPool","link":"/tags/ThreadPool/"},{"name":"Java基础知识","slug":"Java基础知识","link":"/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"近代史","slug":"近代史","link":"/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"},{"name":"近代历史","slug":"近代历史","link":"/tags/%E8%BF%91%E4%BB%A3%E5%8E%86%E5%8F%B2/"},{"name":"历史题","slug":"历史题","link":"/tags/%E5%8E%86%E5%8F%B2%E9%A2%98/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"电报群","slug":"电报群","link":"/tags/%E7%94%B5%E6%8A%A5%E7%BE%A4/"},{"name":"自考","slug":"自考","link":"/tags/%E8%87%AA%E8%80%83/"},{"name":"Java4747","slug":"Java4747","link":"/tags/Java4747/"},{"name":"自考历史题","slug":"自考历史题","link":"/tags/%E8%87%AA%E8%80%83%E5%8E%86%E5%8F%B2%E9%A2%98/"},{"name":"滑动冲突","slug":"滑动冲突","link":"/tags/%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"},{"name":"activity","slug":"activity","link":"/tags/activity/"}],"categories":[{"name":"Android开发","slug":"Android开发","link":"/categories/Android%E5%BC%80%E5%8F%91/"},{"name":"Android基础","slug":"Android基础","link":"/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"精品美文","slug":"精品美文","link":"/categories/%E7%B2%BE%E5%93%81%E7%BE%8E%E6%96%87/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"自考","slug":"自考","link":"/categories/%E8%87%AA%E8%80%83/"},{"name":"MAC应用","slug":"MAC应用","link":"/categories/MAC%E5%BA%94%E7%94%A8/"},{"name":"Mac应用","slug":"Mac应用","link":"/categories/Mac%E5%BA%94%E7%94%A8/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"经典电影","slug":"经典电影","link":"/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/categories/TensorFlow/"},{"name":"IOS应用","slug":"IOS应用","link":"/categories/IOS%E5%BA%94%E7%94%A8/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"软件应用","slug":"软件应用","link":"/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"},{"name":"学习资料","slug":"学习资料","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"}]}