{"pages":[{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 个人信息：90后计算机网络技术专业从事Android开发，坚信代码改变世界摄影爱好者QQ: 798774875Email: moruoyiming123@gmail.comJianShu: jianzeyicongGithub: moruoyimingYouTube: Jean RilenInstagram: jianzeyicong500px: moruoyiming 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志： –2020.09.29：增加相册、视频功能–2020.09.18：增加AdSense广告–2020.08.22：改版部分显示，优化速度–2020.06.18：icarus3.0主题适配–2019.12.16：增加不蒜子统计–2019.10.16：文章列表加上评论数显示–2019.03.13：改版评论–2017.12.16：icarus1.0主题适配–2017.08.12：搭建个人博客 本站推荐索引 技术知识点 Java教程 Python3教程 JavaScript教程 剑指Offer 免费学习资料 常用工具 图片压缩 在线转换工具 贝塞尔弧曲线 ProcessOn流程图 Youtube视频下载 免费翻墙 free-ss free-ss.site ss.pythonic.life 免费节点 软件下载 萌新网 麦氪派 福利 电影天堂 高清电影 BD电影 剧迷 高速车 持续更新~","link":"/about/index.html"},{"title":"categories","text":"(adsbygoogle = window.adsbygoogle || []).push({});","link":"/categories/index.html"},{"title":"","text":"风光 人像 动物 图片均为本人拍摄，有共同爱好的小伙伴可以约起来哦~~~ 留言 😊 😊 😊。","link":"/album/index.html"},{"title":"电影","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 -&gt;点击以下条目开始播放视频,向下滑动查看更多&lt;- (adsbygoogle = window.adsbygoogle || []).push({});","link":"/media/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"}],"posts":[{"title":"Android项目运行时丢失so文件","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码 123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 123456789101112defaultConfig { applicationId &quot;…&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' }} 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2020/09/11/Android%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E6%97%B6%E4%B8%A2%E5%A4%B1so%E6%96%87%E4%BB%B6/"},{"title":"Mac 下移动硬盘的读写软件Mounty","text":"title: Mac下移动硬盘的读写软件Mountythumbnail: /gallery/thumbnails/sculpture.jpgcategories: Mac应用tags: 壁纸路径 Mounty Mac系统 终端运行: brew cask install mounty 官网地址:https://mounty.app/","link":"/2020/09/11/Mac%20%E4%B8%8B%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E7%9A%84%E8%AF%BB%E5%86%99%E8%BD%AF%E4%BB%B6Mounty/"},{"title":"Mac系统壁纸路径","text":"在 Finder 中，菜单栏选取“前往”&gt;“前往文件夹”，弹出的框里输入/Library/Desktop Pictures/或/System/Library/Desktop Pictures/然后回车即可打开该文件夹。 系统壁纸默认路径存在两个地方，当时去了第一个路径上找未找到，后来通过命令行获取到路径发现System 下也有一个Desktop Pictures 文件夹。 终端命令：显示壁纸所在路径（路径显示在屏幕对应壁纸上）： defaults write com.apple.dock desktop-picture-show-debug-text -bool TRUE;killall Dock 终端命令：隐藏该路径： defaults delete com.apple.dock desktop-picture-show-debug-text;killall Dock","link":"/2020/09/11/Mac%20%E7%B3%BB%E7%BB%9F%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"title":"Mac下Google备份和同步问题","text":"1.下载并安装Google备份和同步 Google备份和同步（下载地址） 2.打开xx的http代理 在偏好设置中打开http代理服务器，配置默认即可 3.打开系统设置中的http代理 系统偏好设置→网络→高级→代理→网页代理(HTTP)，设置代理127.0.0.1:1087 4. 允许并登录Google账户 完全配置完成后即可食用 原文地址 https://www.fangpengjun.com/2017/09/08/%E8%A7%A3%E5%86%B3Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/","link":"/2020/09/11/Mac%E4%B8%8BGoogle%E5%A4%87%E4%BB%BD%E5%92%8C%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"},{"title":"Mac使用终端登录谷歌云","text":"1.网页SSH进入谷歌云，切换到root角色 sudo -i 2.修改SSH配置文件/etc/ssh/sshd_config vi /etc/ssh/sshd_config 修改PermitRootLogin和PasswordAuthentication为yes # Authentication: PermitRootLogin yes //默认为no，需要开启root用户访问改为yes # Change to no to disable tunnelled clear text passwords PasswordAuthentication yes //默认为no，改为yes开启密码登陆 3.给root用户设置密码 passwd root 4.重启SSH服务使修改生效 /etc/init.d/ssh restart 5.启动mac终端 ssh root@ip 输入密码即可进入SSH。","link":"/2020/09/11/Mac%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"title":"Mac下安装软件提示文件损坏解决办法","text":"1.打开应用程序-实用工具-终端；b2制以下代码（master注意是两个-）到终端中，回车（输入电脑密码）： 1sudo spctl --master-disable 3.打开应用程序-系统偏好设置-安全性和隐私-通用，消失的任何来源终于出现了（默认应该勾选了）；4.此时可以尽情使用第三方程序了如已经开启了任何来源，还无法安装当出现提示的时候，去系统偏好设置-安全和隐私那里允许下（会提示该软件的安装信息） 还提示损坏的，试试按住Control后，再次点击软件图标","link":"/2020/09/11/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"Mac安装oh-my-zsh出现TimeOut","text":"mac终端 安装 oh-my-zshsh -c “$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)” 提示错误 curl: (7) Failed to connect to raw.githubusercontent.com port 443: Operation timed out 用这个连接wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh","link":"/2020/09/11/Mac%E5%AE%89%E8%A3%85oh-my-zsh%20%E5%87%BA%E7%8E%B0TimeOut/"},{"title":"Mac文件安装应用，打开提示文件已损坏，如何解决","text":"终端运行该命令:sudo xattr -d com.apple.quarantine /Applications/ColorFinale.app","link":"/2020/09/11/Mac%E6%96%87%E4%BB%B6%E5%AE%89%E8%A3%85%E5%BA%94%E7%94%A8%EF%BC%8C%E6%89%93%E5%BC%80%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E5%B7%B2%E6%8D%9F%E5%9D%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/"},{"title":"Android 项目中so文件丢失","text":"项目运行时提示缺少so文件，需要在App项目中build.gradle增加支持的so 文件类型.在defaultConfig下增加下方代码123ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } 完整代码 1234567891011121314151617defaultConfig { applicationId &quot;...&quot; minSdkVersion versions.minSdk targetSdkVersion versions.targetSdk versionCode versions.appVerCode versionName versions.appVerName multiDexEnabled true ndk { abiFilters &quot;armeabi&quot;,'x86', 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a' } javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } 从新编译应用，并在build/outputs/apk下查看编译成功的apk 文件中的libs 已经将so文件成功编译进去。","link":"/2019/02/26/SO%E6%96%87%E4%BB%B6%E7%BC%BA%E5%A4%B1/"},{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2019/02/20/SSH%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"ShadowRocket-小火箭🚀🚀购买教程","text":"研究了几天试了几种方法想白嫖小火箭感觉难得一批，最后决定自己入手。分享一下最简单的方式；1.登录appstore修改地区为美国，关于账户的一些设置信息可以参考地址 美国 Old Harbor, AK 邮编 99643电话(430) 558-8829 2.某宝上买充值卡（记得买美区的） 购买成功，会发一个卡图 3.Appstore上进入个人中心进入Redeem Gift Card or Code进入页面点击use camera 扫一下 成功后，回到首页购买；4.操作前最好也挂下vp恩，自己定位看看是不是美国地区的。网上说有可能会充值失败，账号被锁啥的。我也不懂。如果对你有帮助记得赞下哦！我的个人博客：https://www.errorcode.xyz/","link":"/2020/10/23/ShadowRocket-%E5%B0%8F%E7%81%AB%E7%AE%AD%F0%9F%9A%80%F0%9F%9A%80%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"title":"TensorFlow Mac安装教程","text":".安装Python 3.7.5 版本百度云盘:链接:https://pan.baidu.com/s/1lC7ZPFAIB8pYor1DbIOL8Q 密码:v6tj官网:https://www.python.org/ftp/python/3.7.5/python-3.7.5-macosx10.9.pkg 查看版本号。 123python3 --versionpip3 --versionvirtualenv --version 输入which python3 查看路径 2.如果已经安装，跳过这步：如果没用过brew，需要先下载，关于brew查看这里: https://brew.sh/ 123/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; export PATH=&quot;/usr/local/bin:/usr/local/sbin:$PATH&quot; 1234/usr/bin/ruby -e &quot;PATH&quot;brew updatebrew install python # Python 3sudo pip3 install -U virtualenv # system-wide install 3.安装virtualenv虚拟环境创建一个新的虚拟环境通过选择一个Python解释器,创建./venv目录来保存它:可修改为其他目录。目录会出现在 user的子目录下。 1virtualenv --system-site-packages -p python3 ./venv 4.激活虚拟环境 1source ./venv/bin/activate # sh, bash, ksh, or zsh virtualenv活跃时,shell提示符前缀(venv)。 安装包在一个虚拟环境在不影响主机系统设置。先升级pip: 12pip install --upgrade pippip list # show packages installed within the virtual environment 5.退出虚拟环境 deactivate # don’t exit until you’re done using TensorFlow 如果提示权限不够时，需要在命令后添加 –user。 6.安装TensorFlow 1pip install --upgrade tensorflow 验证安装 1python -c &quot;import tensorflow as tf;print(tf.reduce_sum(tf.random.normal([1000, 1000])))&quot; 问题汇总 1pip install Keras-Applications ModuleNotFoundError: No module named ‘matplotlib’ 1pip install matplotlib ModuleNotFoundError: No module named ‘tensorflow_datasets’ 1pip install tensorflow_datasets ModuleNotFoundError: No module named ‘tensorflow_hub’ 1pip install tensorflow_hub seaborn 绘制矩阵图 (pairplot) 1pip install seaborn 引入类库 TensorFlow and tf.keras12import tensorflow as tffrom tensorflow import keras Helper librariesimport numpy as npimport matplotlib.pyplot as pltimport pandas as pdimport seaborn as sns","link":"/2020/09/11/TensorFlow%20Mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"title":"android之HandlerThread","text":"HandlerThread是个什么东西？查看类的定义时有这样一段话： 1Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 意思就是说：这个类的作用是创建一个包含looper的线程。那么我们在什么时候需要用到它呢?加入在应用程序当中为了实现同时完成多个任务，所以我们会在应用程序当中创建多个线程。为了让多个线程之间能够方便的通信，我们会使用Handler实现线程间的通信。这个时候我们手动实现的多线程+Handler的简化版就是我们HandlerThrea所要做的事了。 下面我们首先看一下HandlerThread的基本用法： 12345678910111213141516171819202122232425HandlerThread mHandlerThread = new HandlerThread(&quot;myHandlerThreand&quot;); mHandlerThread.start(); // 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; title = (TextView) findViewById(R.id.title); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Message msg = new Message(); msg.obj = &quot;11111&quot;; mHandler.sendMessage(msg); msg = new Message(); msg.obj = &quot;2222&quot;; mHandler.sendMessage(msg); } }); 我们首先定义了一个HandlerThread对象，是直接通过new的方式产生的，查看其构造方法： 1234public HandlerThread(String name) { super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; }可以知道HandlerThread继承于Thread，所以说HandlerThread本质上是一个线程，其构造方法主要是做一些初始化的操作。 然后我们调用了mHandlerThread.start()方法，由上我们知道了HandlerThread类其实就是一个Thread，一个线程，所以其start方法内部调用的肯定是Thread的run方法，我们查看一下其run方法的具体实现： 12345678910111213@Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } 我们发现其内部调用了Looper.prepate()方法和Loop.loop()方法，熟悉android异步消息机制的童鞋应当知道，在android体系中一个线程其实是对应着一个Looper对象、一个MessageQueue对象，以及N个Handler对象，具体可参考： android源码解析之（二）–&gt;异步消息机制 所以通过run方法，我们可以知道在我们创建的HandlerThread线程中我们创建了该线程的Looper与MessageQueue； 这里需要注意的是其在调用Looper.loop()方法之前调用了一个空的实现方法：onLooperPrepared(),我们可以实现自己的onLooperPrepared（）方法，做一些Looper的初始化操作； run方法里面当mLooper创建完成后有个notifyAll()，getLooper()中有个wait()，这是为什么呢？因为的mLooper在一个线程中执行，而我们的handler是在UI线程初始化的，也就是说，我们必须等到mLooper创建完成，才能正确的返回getLooper();wait(),notify()就是为了解决这两个线程的同步问题 然后我们调用了： 1234567// 创建的Handler将会在mHandlerThread线程中执行 final Handler mHandler = new Handler(mHandlerThread.getLooper()) { @Override public void handleMessage(Message msg) { Log.i(&quot;tag&quot;, &quot;接收到消息：&quot; + msg.obj.toString()); } }; 该Handler的构造方法中传入了HandlerThread的Looper对象，所以Handler对象就相当于含有了HandlerThread线程中Looper对象的引用。 然后我们调用handler的sendMessage方法发送消息，在Handler的handleMessge方法中就可以接收到消息了。 最后需要注意的是在我们不需要这个looper线程的时候需要手动停止掉； 1234protected void onDestroy() { super.onDestroy(); mHandlerThread.quit(); } 相对来说HandlerThread还是比较简单的，这里总结一下： HandlerThread本质上是一个Thread对象，只不过其内部帮我们创建了该线程的Looper和MessageQueue； 通过HandlerThread我们不但可以实现UI线程与子线程的通信同样也可以实现子线程与子线程之间的通信； HandlerThread在不需要使用的时候需要手动的回收掉； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E4%B9%8BHandlerThread/"},{"title":"Android 项目构建流程","text":"平时开发过程中我们通过android studio编写完成android项目之后直接点击 Run ‘app’就可以在build/outputs/apk生成可以在android设备中安装的apk文件了，那么整个android源码的构建过程是怎么样的呢？ 我们可以根据Google官方提供的流程图来具体了解构建的过程： 通常的构建过程就是如上图所示，下面是具体描述： 1.AAPT(Android Asset Packaging Tool)工具会打包应用中的资源文件，如AndroidManifest.xml、layout布局中的xml等，并将xml文件编译为二进制形式，当然assets文件夹中的文件不会被编译，图片及raw文件夹中的资源也会保持原来的形态，需要注意的是raw文件夹中的资源也会生成资源id。AAPT编译完成之后会生成R.java文件。 2.AIDL工具会将所有的aidl接口转化为java接口。 3.所有的java代码，包括R.java与aidl文件都会被Java编译器编译成.class文件。 4.Dex工具会将上述产生的.class文件及第三库及其他.class文件编译成.dex文件（dex文件是Dalvik虚拟机可以执行的格式），dex文件最终会被打包进APK文件。 5.ApkBuilder工具会将编译过的资源及未编译过的资源（如图片等）以及.dex文件打包成APK文件。 6.生成APK文件后，需要对其签名才可安装到设备，平时测试时会使用debug keystore，当正式发布应用时必须使用release版的keystore对应用进行签名。 7.如果对APK正式签名，还需要使用zipalign工具对APK进行对齐操作，这样做的好处是当应用运行时会减少内存的开销。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程","link":"/2020/09/11/android%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"一键解除iOS版Telegram对群组和频道的限制/苹果iPhone有些频道不显示问题","text":"一键解除iOS版Telegram对群组和频道的限制/苹果iPhone有些频道不显示问题Telegram，也就是我们所说的电报，是当前最流行的社交 APP，很多网站、品牌和公众人物都拥有自己的“电报群”。开放的群组和频道是 Telegram 最具特色的功能，也是很多用户（包括我）使用 Telegram 的主要目的。 Telegram 汇集了世界各地的用户。它开源且安全，轻便且没有广告，端到端加密数据，保护用户隐私……因为这些特性，用户能够在 Telegram 上获得几乎任何内容。 不过受限于苹果的政策，iOS 平台上的 Telegram 官方 APP 限制访问特定的群组或频道，例如包含色#情或盗版信息的那部分就被阻止了。如何突破限制，成为众多用户头疼的事情。往常的做法是使用第三方客户端，不过这个选择有很大的风险，因为用户不知道背后是否是窃取隐私信息的“有心人”。 具体可能会提示如下信息： This group/channel is blocked because it was used to spread pornograhic content. 该群组/频道由于传播色#情内容,已被屏蔽。 This channel can’t be displayed because it was used to spread pornographic content? This channel is blocked because it was used to spread pornograhic content. 如今这个问题已经有了“官方”的解决办法。不是说官方宣布，而是用官方客户端本身的功能来解决，再也不用借助于“旁门左道”了。 操作方法目前有两个方法来关闭敏感内容过滤，一是使用网页端，二是使用桌面客户端。从便捷性来考虑自然是网页端更好，不需要借助电脑，直接用手机浏览器就可以解决。 1、使用Telegram Web首先登录 Telegram Web 端：https://web.telegram.org/ 点击右上角的菜单，打开 Settings，将 Show Sensitive Content 的开关打开就完成了。 关掉 iOS APP 再重新打开就会发现福利已经尽显眼前了。 2、使用桌面客户端首先在下载和安装 Win 或 Mac 版 Telegram： Win版：https://desktop.telegram.org/ Mac版：https://macos.telegram.org/ 登录 Telegram 账号之后打开 Settings – Privacy and Security，把 Sensitive Content 下的 Disable filtering 打开： 好了，把 iOS 上的 Telegram APP 关掉重新打开，就会发现之前无法查看的群组和频道都已经可以访问。 根据选项下方的介绍，这个开关是全局性的，也就是说这样操作过后，该账号在所有平台上面的客户端都适用这个规则。如果想要浪子回头，把它再关掉就好了。","link":"/2020/10/21/%E4%B8%80%E9%94%AE%E8%A7%A3%E9%99%A4iOS%E7%89%88Telegram%E5%AF%B9%E7%BE%A4%E7%BB%84%E5%92%8C%E9%A2%91%E9%81%93%E7%9A%84%E9%99%90%E5%88%B6%E8%8B%B9%E6%9E%9CiPhone%E6%9C%89%E4%BA%9B%E9%A2%91%E9%81%93%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"},{"title":"序列化面试题","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243面试相关1. 反序列化后的对象，需要调用构造函数重新构造吗 反序列化调用不会调用构造函数。以存储的二进制数据进行构造2. 序列前的对象与序列化后的对象是什么关系？是(&quot;==&quot;还是equal？是浅复制还是深复制？) 序列化前和序列化后 是两个不同的对象，对象地址发生了改变。调用equal 和 == 返回true。是一个深复制。3. Android里面为什么要设计出Bundle而不是直接用Map结构 Bundle中是使用的Parcel打包数据。Parcel可以实现跨进程通讯。 &lt;!-- more --&gt; Bundle内部是由ArrayMap实现的，ArrayMap的内部实现是两个数组，一个int数组是存储对象数 据对应下标，一个对象数组 保存key和value，内部使用二分法对key进行排序，所以在添加、删 除、查找数据的时候，都会使用二分法查找，只适合于小数 据量操作，如果在数据量比较大的情况 下，那么它的性能将退化。而HashMap内部则是数组+链表结构，所以在数据量较少的时候， HashMap的Entry Array比ArrayMap占用更多的内存。因为使用Bundle的场景大多数为小数据 量，我没见过在两个Activity之 间传递10个以上数据的场景，所以相比之下，在这种情况下使用 ArrayMap保存数据，在操作速度和内存占用上都具有优势， 因此使用Bundle来传递数据，可以保 证更快的速度和更少的内存占用。 另外一个原因，则是在Android中如果使用Intent来携带数据的话， 需要数据是基本类型或者是可 序列化类型，HashMap使用Serializable进行序列化，而Bundle则是使用Parcelable进行序列化。 而在Android平台中，更推荐使用Parcelable实现序列化，虽然写法复杂，但是开销更小，所以为 了更加快速的进行数据的序列化和反序列化， 系统封装了Bundle类，方便我们进行数据的传输。4. SerialVersionID的作用是什么？ 版本控制5. Android中Intent/Bundle的通信原理及大小限制 大小限制 bundle 在zgote在创建进程的时候，分配了binder的内存大小。binder申请匿名内存有限制。 binder在内核空间创建内存映射时，大小限制在 &lt; 4M intent 1M限制 Intent 中的 Bundle 是使用 Binder 机制进行数据传送的。能使用的 Binder 的缓冲区是有大小限 制的(有些手机是 2 M)， 而一个进程默认有 16 个 Binder 线程，所以一个线程能占用的缓冲区 就更小了( 有人以前做过测试，大约一个线程可以占用 128 KB)。 所以当你看到 The Binder transaction failed because it was too large 这类 TransactionTooLargeException 异常时， 你应 该知道怎么解决了6. 为何Intent不能直接在组件间传递对象而要通过序列化机制？ startActivity（intent），activity启动流程要和AMS交互，需要跨进程通讯。只有把数据序列化后，传递。7. 序列化与持久化的关系和区别是什么？ 序列化:跨进程传输数据时，需要使用序列化。 持久化:数据的存储。 Intent在启动其他组件时，会离开当前应用程序进程，进入ActivityManagerService进程 (intent.prepareToLeaveProcess())， 这也就意味着，Intent所携带的数据要能够在不同进程间 传输。首先我们知道，Android是基于Linux系统，不同进程之间的java对象是无法传输， 所以我 们此处要对对象进行序列化，从而实现对象在 应用程序进程 和 ActivityManagerService进程 之间 传输。 而Parcel或者Serializable都可以将对象序列化，其中，Serializable使用方便，但性能不如Parcel 容器 ，后者也是Android系统专门推出的用于进程间通信等的接口","link":"/2020/09/11/%E5%BA%8F%E5%88%97%E5%8C%96%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"科学上网利器大全","text":"Algo - 在云中设置个人 IPSEC VPN。 源码 ClashX - 基于 clash 的一款支持规则过滤的科学上网工具。 源码 FreeVPN Plus - 永不过期 Mac 免费VPN。 Firefly 萤火虫 - 免费科学上网。 GoAgentX - 科学上网。(https://github.com/getlantern/lantern) GTX加速器 - 每天签到领取 500M 流量。 Lantern - 科学上网。(https://github.com/getlantern/lantern) LoCoVPN - 每天签到可获得 2 小时免费VPN加速。 SpechtLite - 支持 Shadowsocks 及规则管理的高效率代理。源码 ShadowsocksX - 一个快速的隧道代理，可以帮助你绕过防火墙。源码 ShadowsocksX-NG - 一款 ShadowsocksX 客户端软件。源码 Surge - 科学上网。 Shimo - 连接大量 VPN 的应用 Tunnelbear - 简单的私人 VPN。 Tunnelblick - OpenVPN 的免费软件。 tinc - VPN 软件. 源码 V2Ray - 原生支持 Socks、HTTP、Shadowsocks、VMess 等协议。 V2rayU - 一款 v2ray 客户端软件。源码 二师兄VPN - 提供无限流量、无限续期免费 VPN 账号。 风驰VPN - 无限流量、无限续期的免费 VPN 加速服务。","link":"/2020/10/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%88%A9%E5%99%A8%E5%A4%A7%E5%85%A8/"},{"title":"Android 基础知识总结","text":"​ Activity生命周期 img Fragment生命周期 Activity**四种启动模式** standard : 标准模式,每次启动Activity都会创建一个新的Activity实例,并且将其压入任务栈栈顶,而不管这个Activity是否已经存在。Activity的启动三回调(onCreate()-&gt;onStart()-&gt;onResume())都会执行。 singleTop : 栈顶复用模式.这种模式下,如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,所以它的启动三回调就不会执行,同时Activity的onNewIntent()方法会被回调.如果Activity已经存在但是不在栈顶,那么作用与standard**模式一样. singleTask: 栈内复用模式.创建这样的Activity的时候,系统会先确认它所需任务栈已经创建,否则先创建任务栈.然后放入Activity,如果栈中已经有一个Activity实例,那么这个Activity就会被调到栈顶,onNewIntent(),并且singleTask会清理在当前Activity上面的所有Activity.(clear top) singleInstance : 加强版的singleTask模式,这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了 Service**的生命周期与启动方法由什么区别？** startService()：开启Service，调用者退出后Service仍然存在。 bindService()：开启Service，调用者退出后Service也随即退出。 Service**生命周期：** 只是用startService()启动服务：onCreate() -&gt; onStartCommand() -&gt; onDestory 只是用bindService()绑定服务：onCreate() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 同时使用startService()启动服务与bindService()绑定服务：onCreate() -&gt; onStartCommnad() -&gt; onBind() -&gt; onUnBind() -&gt; onDestory 广播**发送和接收的原理了解吗**？ 继承BroadcastReceiver，重写onReceive()方法。 通过Binder机制向ActivityManagerService注册广播。 通过Binder机制向ActivityMangerService发送广播。 ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。 BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。、 Android Handler机制是做什么的，原理了解吗 主要涉及的角色如下所示： 1.Message:消息,分为硬件产生的消息（例如:按钮、触摸）和软件产生的消息。 2. MessageQueue：消息队列，主要用来向消息池添加消息和取走消息。 3. Looper：消息循环器，主要用来把消息分发给相应的处理者。 4. Handler：消息处理器，主要向消息队列发送各种消息以及处理各种消息。 整个消息的循环流程还是比较清晰的，具体说来： 1. Handler通过sendMessage()发送消息Message到消息队列MessageQueue。 2. Looper通过loop()循环提取触发Message,并将Message交给对应的target handler来处理。 3. target handler调用自身的handleMessage()方法来处理Message。 如何自定义android控件 自定义属性的声明和获取 分析需要的自定义属性 在res/values/attrs.xml定义声明 在layout文件中进行使用 在View的构造方法中进行获取 测量onMeasure(int widthMeasureSpec, int heightMeasureSpec) 布局onLayout(boolean changed, int left, int top, int right, int bottom) 绘制onDraw(Canvas canvas) onTouchEvent onInterceptTouchEvent(ViewGroup) 状态的恢复与保存 描述一下**View的绘**制原理？ View的绘制流程主要分为三步： onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成测量工作。 onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。 onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。 ④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。 requestLayout()**、invalidate()与postInvalidate()有什么区别？** requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定 会触发onDraw()方法。 invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会 触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。 postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。 APK的打包流程 1. 通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。 2. 通过AIDL工具处理AIDL文件，生成相应的Java文件。 3. 通过Javac工具编译项目源码，生成Class文件。 4. 通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。 5. 通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。 6. 利用KeyStore对生成的APK文件进行签名。 7. 如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件 的速度会更快。 (adsbygoogle = window.adsbygoogle || []).push({}); APK的安装流程 1. 复制APK到/data/app目录下，解压并扫描安装包。 2. 资源管理器解析APK里的资源文件。 3. 解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。 4. 然后对dex文件进行优化，并保存在dalvik-cache目录下。 5. 将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。 6. 安装完成后，发送广播。 Android Binder**机制是做什么的，为什么选用Binder，原理了解吗？** Android Binder是用来做进程通信的，Android的各个应用以及系统服务都运行在独立的进程中，它们的通信都依赖于Binder。 为什么选用Binder，在讨论这个问题之前，我们知道Android也是基于Linux内核，Linux现有的进程通信手段有以下几种： 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息**队**列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 \\6. 信号 : 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进 程等； 既然有现有的IPC方式，为什么重新设计一套Binder机制呢。主要是出于以上三个方面的考量： 高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。 稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。 安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全 是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。","link":"/2020/09/11/Android%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%20(%E9%9D%A2%E8%AF%95)/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it&apos;s upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法：requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact MeQQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2019/10/11/Android%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF%E4%BC%A0%E8%BE%93DEMO/"},{"title":"8 Zygote进程启动流程","text":"大家都知道android系统的Zygote进程是所有的android进程的父进程，包括SystemServer和各种应用进程都是通过Zygote进程fork出来的。Zygote（孵化）进程相当于是android系统的根进程，后面所有的进程都是通过这个进程fork出来的，而Zygote进程则是通过linux系统的init进程启动的，也就是说，android系统中各种进程的启动方式 init进程 –&gt; Zygote进程 –&gt; SystemServer进程 –&gt;各种应用进程 init进程：linux的根进程，android系统是基于linux系统的，因此可以算作是整个android操作系统的第一个进程； Zygote进程：android系统的根进程，主要作用：可以作用Zygote进程fork出SystemServer进程和各种应用进程； SystemService进程：主要是在这个进程中启动系统的各项服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务等等； 各种应用进程：启动自己编写的客户端应用时，一般都是重新启动一个应用进程，有自己的虚拟机与运行环境； 本文主要介绍一下Zygote进程的启动流程，关于SystenServer进程和各种应用进程的启动方式会在以后的文章中介绍。 init进程在启动Zygote进程时一般都会调用ZygoteInit类的main方法，因此我们这里看一下该方法的具体实现(基于android23源码)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static void main(String argv[]) { try { RuntimeInit.enableDdms(); // Start profiling the zygote initialization. SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = &quot;zygote&quot;; String abiList = null; for (int i = 1; i &lt; argv.length; i++) { if (&quot;start-system-server&quot;.equals(argv[i])) { startSystemServer = true; } else if (argv[i].startsWith(ABI_LIST_ARG)) { abiList = argv[i].substring(ABI_LIST_ARG.length()); } else if (argv[i].startsWith(SOCKET_NAME_ARG)) { socketName = argv[i].substring(SOCKET_NAME_ARG.length()); } else { throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); } } if (abiList == null) { throw new RuntimeException(&quot;No ABI list supplied.&quot;); } registerZygoteSocket(socketName); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); // Finish profiling the zygote initialization. SamplingProfilerIntegration.writeZygoteSnapshot(); // Do an initial gc to clean up after startup gcAndFinalize(); // Disable tracing so that forked processes do not inherit stale tracing tags from // Zygote. Trace.setTracingEnabled(false); if (startSystemServer) { startSystemServer(abiList, socketName); } Log.i(TAG, &quot;Accepting command socket connections&quot;); runSelectLoop(abiList); closeServerSocket(); } catch (MethodAndArgsCaller caller) { caller.run(); } catch (RuntimeException ex) { Log.e(TAG, &quot;Zygote died with exception&quot;, ex); closeServerSocket(); throw ex; } } 第一行主要是调用enableDdms()，设置DDMS可用，可以发现DDMS启动的时机还是比较早的，在整个Zygote进程刚刚开始要启动额时候就设置可用了。 下面的循环主要是解析main方法的参数获取是否需要启动SystemService进程，获取abi列表，获取scoket连接名称（这里需要注意的是：android系统中进程之间通讯的方式是Binder，但是有一个例外是SystemService进程与Zygote进程之间是通过Socket的方式进行通讯的） 然后调用registerZygoteSocket（String socketName）为Zygote进程注册socket： 123456789101112131415161718192021private static void registerZygoteSocket(String socketName) { if (sServerSocket == null) { int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try { String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); } catch (RuntimeException ex) { throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex); } try { FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); sServerSocket = new LocalServerSocket(fd); } catch (IOException ex) { throw new RuntimeException( &quot;Error binding to local socket '&quot; + fileDesc + &quot;'&quot;, ex); } } } 接着调用系统方法preLoad() 123456789101112static void preload() { Log.d(TAG, &quot;begin preload&quot;); preloadClasses(); preloadResources(); preloadOpenGL(); preloadSharedLibraries(); preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes. WebViewFactory.prepareWebViewInZygote(); Log.d(TAG, &quot;end preload&quot;); } 这其中：preloadClasses()用于初始化Zygote中需要的class类；preloadResources()用于初始化系统资源；preloadOpenGL()用于初始化OpenGL；preloadSharedLibraries()用于初始化系统libraries；preloadTextResources()用于初始化文字资源；prepareWebViewInZygote()用于初始化webview; 然后调用startSystemServer(abiList, socket); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException { long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); /* Hardcoded command line to start the system server */ String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007&quot;, &quot;--capabilities=&quot; + capabilities + &quot;,&quot; + capabilities, &quot;--nice-name=system_server&quot;, &quot;--runtime-args&quot;, &quot;com.android.server.SystemServer&quot;, }; ZygoteConnection.Arguments parsedArgs = null; int pid; try { parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); } catch (IllegalArgumentException ex) { throw new RuntimeException(ex); } /* For child process */ if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); } return true; } 可以看到这段逻辑的执行逻辑就是通过Zygote fork出SystemServer进程。 总结：Zygote进程mian方法主要执行逻辑： 初始化DDMS； 注册Zygote进程的socket通讯； 初始化Zygote中的各种类，资源文件，OpenGL，类库，Text资源等等； 初始化完成之后fork出SystemServer进程； fork出SystemServer进程之后，关闭socket连接； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCache","link":"/2020/09/11/Zygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"android之IntentService","text":"什么是IntentService？简单来说IntentService就是一个含有自身消息循环的Service，首先它是一个service，所以service相关具有的特性他都有，同时他还有一些自身的属性，其内部封装了一个消息队列和一个HandlerThread，在其具体的抽象方法：onHandleIntent方法是运行在其消息队列线程中，废话不多说，我们来看其简单的使用方法： 定义一个IntentService 123456789101112public class MIntentService extends IntentService{ public MIntentService() { super(&quot;&quot;); } @Override protected void onHandleIntent(Intent intent) { Log.i(&quot;tag&quot;, intent.getStringExtra(&quot;params&quot;) + &quot; &quot; + Thread.currentThread().getId()); }} 在androidManifest.xml中定义service 123&lt;service android:name=&quot;.MIntentService&quot; /&gt; 启动这个service 12345678title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(MainActivity.this, MIntentService.class); intent.putExtra(&quot;params&quot;, &quot;ceshi&quot;); startService(intent); } }); 可以发现当点击title组件的时候，service接收到了消息并打印出了传递过去的intent参数，同时显示onHandlerIntent方法执行的线程ID并非主线程，这是为什么呢？ 下面我们来看一下service的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public abstract class IntentService extends Service { private volatile Looper mServiceLooper; private volatile ServiceHandler mServiceHandler; private String mName; private boolean mRedelivery; private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } /** * Creates an IntentService. Invoked by your subclass's constructor. * * @param name Used to name the worker thread, important only for debugging. */ public IntentService(String name) { super(); mName = name; } /** * Sets intent redelivery preferences. Usually called from the constructor * with your preferred semantics. * * &lt;p&gt;If enabled is true, * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_REDELIVER_INTENT}, so if this process dies before * {@link #onHandleIntent(Intent)} returns, the process will be restarted * and the intent redelivered. If multiple Intents have been sent, only * the most recent one is guaranteed to be redelivered. * * &lt;p&gt;If enabled is false (the default), * {@link #onStartCommand(Intent, int, int)} will return * {@link Service#START_NOT_STICKY}, and if the process dies, the Intent * dies along with it. */ public void setIntentRedelivery(boolean enabled) { mRedelivery = enabled; } @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } @Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } /** * You should not override this method for your IntentService. Instead, * override {@link #onHandleIntent}, which the system calls when the IntentService * receives a start request. * @see android.app.Service#onStartCommand */ @Override public int onStartCommand(Intent intent, int flags, int startId) { onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY; } @Override public void onDestroy() { mServiceLooper.quit(); } /** * Unless you provide binding for your service, you don't need to implement this * method, because the default implementation returns null. * @see android.app.Service#onBind */ @Override public IBinder onBind(Intent intent) { return null; } /** * This method is invoked on the worker thread with a request to process. * Only one Intent is processed at a time, but the processing happens on a * worker thread that runs independently from other application logic. * So, if this code takes a long time, it will hold up other requests to * the same IntentService, but it will not hold up anything else. * When all requests have been handled, the IntentService stops itself, * so you should not call {@link #stopSelf}. * * @param intent The value passed to {@link * android.content.Context#startService(Intent)}. */ @WorkerThread protected abstract void onHandleIntent(Intent intent);} 怎么样，代码还是相当的简洁的，首先通过定义我们可以知道IntentService是一个Service，并且是一个抽象类，所以我们在继承IntentService的时候需要实现其抽象方法：onHandlerIntent。 下面看一下其onCreate方法： 12345678910111213@Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(&quot;IntentService[&quot; + mName + &quot;]&quot;); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } 我们可以发现其内部定义一个HandlerIThread（本质上是一个含有消息队列的线程）具体可参考：android源码解析之（四）–&gt;HandlerThread然后用成员变量维护其Looper和Handler，由于其Handler关联着这个HandlerThread的Looper对象，所以Handler的handMessage方法在HandlerThread线程中执行。 然后我们发现其onStartCommand方法就是调用的其onStart方法，具体看一下其onStart方法： 1234567@Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 很简单就是就是讲startId和启动时接受到的intent对象传递到消息队列中处理，那么我们具体看一下其消息队列的处理逻辑： 1234567891011private final class ServiceHandler extends Handler { public ServiceHandler(Looper looper) { super(looper); } @Override public void handleMessage(Message msg) { onHandleIntent((Intent)msg.obj); stopSelf(msg.arg1); } } 可以看到起handleMessage方法内部执行了两个逻辑一个是调用了其onHandlerIntent抽象方法，通过分析其onCreate方法handler对象的创建过程我们知道其handler对象是依附于HandlerThread线程的，所以其handeMessage方法也是在HandlerThread线程中执行的，从而证实了我们刚刚例子中的一个结论，onHandlerIntent在子线程中执行。然后调用了stopSelf方法，这里需要注意的是stopSelf方法传递了msg.arg1参数，从刚刚的onStart方法我们可以知道我们传递了startId，参考其他文章我们知道，由于service可以启动N次，可以传递N次消息，当IntentService的消息队列中含有消息时调用stopSelf(startId)并不会立即stop自己，只有当消息队列中最后一个消息被执行完成时才会真正的stop自身。 通过上面的例子与相关说明，我们可以知道： IntentService是一个service，也是一个抽象类； 继承IntentService需要实现其onHandlerIntent抽象方法； onHandlerIntent在子线程中执行； IntentService内部保存着一个HandlerThread、Looper与Handler等成员变量，维护这自身的消息队列； 每次IntentService后台任务执行完成之后都会尝试关闭自身，但是当且仅当IntentService消息队列中最后一个消息被执行完成之后才会真正的stop自身； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThread","link":"/2020/09/11/android%E4%B9%8BIntentService/"},{"title":"6 android之Log日志","text":"首先说点题外话，对于想学android framework源码的同学，其实可以在github中fork一份，具体地址：platform_frameworks_base这里面基本都是android framework层的源码了。而且最近发现了一个比较不错的github插件：OctoTree，它 是一个浏览器插件，它可以让你在Github 看代码时，左边栏会出现一个树状结构，就像我们在IDE 一样。当我们看一个项目的结构，或者想看具体的某个文件，这样就会很方便。 怎么样这样查看源代码的话是不是很方面？ 好了说一下我们今天需要介绍的Log对象，它位于android framework层utils包下，是一个final class类：查看其具体定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200public final class Log { /** * Priority constant for the println method; use Log.v. */ public static final int VERBOSE = 2; /** * Priority constant for the println method; use Log.d. */ public static final int DEBUG = 3; /** * Priority constant for the println method; use Log.i. */ public static final int INFO = 4; /** * Priority constant for the println method; use Log.w. */ public static final int WARN = 5; /** * Priority constant for the println method; use Log.e. */ public static final int ERROR = 6; /** * Priority constant for the println method. */ public static final int ASSERT = 7; private Log() { } /** * Send a {@link #VERBOSE} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int v(String tag, String msg) { return println(LOG_ID_MAIN, VERBOSE, tag, msg); } /** * Send a {@link #VERBOSE} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int v(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, VERBOSE, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #DEBUG} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int d(String tag, String msg) { return println(LOG_ID_MAIN, DEBUG, tag, msg); } /** * Send a {@link #DEBUG} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int d(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, DEBUG, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send an {@link #INFO} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int i(String tag, String msg) { return println(LOG_ID_MAIN, INFO, tag, msg); } /** * Send a {@link #INFO} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int i(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, INFO, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Send a {@link #WARN} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int w(String tag, String msg) { return println(LOG_ID_MAIN, WARN, tag, msg); } /** * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int w(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, msg + '\\n' + getStackTraceString(tr)); } /* * Send a {@link #WARN} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param tr An exception to log */ public static int w(String tag, Throwable tr) { return println(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr)); } /** * Send an {@link #ERROR} log message. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. */ public static int e(String tag, String msg) { return println(LOG_ID_MAIN, ERROR, tag, msg); } /** * Send a {@link #ERROR} log message and log the exception. * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @param tr An exception to log */ public static int e(String tag, String msg, Throwable tr) { return println(LOG_ID_MAIN, ERROR, tag, msg + '\\n' + getStackTraceString(tr)); } /** * Handy function to get a loggable stack trace from a Throwable * @param tr An exception to log */ public static String getStackTraceString(Throwable tr) { if (tr == null) { return &quot;&quot;; } // This is to reduce the amount of log spew that apps do in the non-error // condition of the network being unavailable. Throwable t = tr; while (t != null) { if (t instanceof UnknownHostException) { return &quot;&quot;; } t = t.getCause(); } StringWriter sw = new StringWriter(); PrintWriter pw = new PrintWriter(sw); tr.printStackTrace(pw); pw.flush(); return sw.toString(); } /** * Low-level logging call. * @param priority The priority/type of this log message * @param tag Used to identify the source of a log message. It usually identifies * the class or activity where the log call occurs. * @param msg The message you would like logged. * @return The number of bytes written. */ public static int println(int priority, String tag, String msg) { return println(LOG_ID_MAIN, priority, tag, msg); } /** @hide */ public static final int LOG_ID_MAIN = 0; /** @hide */ public static final int LOG_ID_RADIO = 1; /** @hide */ public static final int LOG_ID_EVENTS = 2; /** @hide */ public static final int LOG_ID_SYSTEM = 3; /** @hide */ public static final int LOG_ID_CRASH = 4; /** @hide */ @SuppressWarnings(&quot;unused&quot;) public static int println(int bufID, int priority, String tag, String msg) { return 0; }}可以看到其实final 类，所以我们不能通过继承Log类的方式实现自身的日志工具类，一般的我们可以通过定义Log成员变量的方式，封装Log工具方法； 在Log类中我们定义了六种日志级别，分别是：VERBOSE、DEBUG、INFO、WARN、ERROR、ASSERT等六种级别，但是我们平时使用的只有前五种，即VERBOSE,DEBUG,INFO,WARN,ERROR。 通过查看源代码我们发现Log类中所有的静态日志方法Log.v()，Log.d()，Log.i()，Log.w()，Log.e()等方法都是底层都是调用了println方法，然后在github的源码中查看，其实其内部调用的是println_native方法，也就是通过JNI调用底层的c++输出日志； 我们暂时只是分析到这里，至于底层的c++日志输出的具体实现不作分析，总结一下： Log.java是一个final类，所以我们不可以继承Log类来实现自己的日志框架，但是可以通过关联（保存Log成员变量）的方式实现自己的Log工具类； Log.java中定义了六种日志级别，但是我们通常只是使用其中的五种日志级别，分别对应着VERBOSE、DEBUG、INFO、WARN、ERROR，在具体的使用场景下具体分析； 有些同学对android自带的日志框架不太满意，主要是无法定位日志位置，这里可以查看我写的一篇实现自定义日志框架的文章：github项目解析（五）–&gt;android日志框架 日志可以个性化的展示相关信息： 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentService","link":"/2020/09/11/android%E4%B9%8BLog%E6%97%A5%E5%BF%97/"},{"title":"24 onSaveInstanceState执行时机","text":"我们已经分析过Activity的启动流程，从中也分析了Activity的生命周期。而其中有一个生命周期方法:onSaveInstanceState方法，今天我们主要讲解一下onSaveInstanceState方法的执行时机。可能部分同学对Activity的onSaveInstanceState方法不是特别熟悉，这里我们简单介绍一下。onSaveInstanceState方法是Activity的成员方法，主要用于在Activity销毁时保存Activity相关的对象信息，而其执行的时机不是我们主动调用的，而是Android系统的framework帮忙调用的，而其调用的时机，可以参考android系统的介绍： This method is called before an activity may be killed so that when it comes back some time in the future it can restore its state. For example, if activity B is launched in front of activity A, and at some point activity A is killed to reclaim resources, activity A will have a chance to save the current state of its user interface via this method so that when the user returns to activity A, the state of the user interface can be restored via {@link #onCreate} or {@link #onRestoreInstanceState}. 可以发现onSaveInstanceState方法会在Activity将要被kill的时候执行。O(∩_∩)O哈哈~，可能跟以前讲解的内容不是太对，我们看过不少文章都是说onSaveInstanceStatex方法会在Activity容易被销毁的时候执行。那么这里明明说的是当Activity被销毁的时候就会执行onSaveInstanceState方法，那么具体的情况是如何的呢?我们具体看一下源码吧，哈哈。 通过分析Activity的生命周期方法，我们知道onSaveInstanceState方法在onPause方法之后执行在onStop方法之前执行。这里我们首先看一下onPause方法的源码逻辑。 Activity在执行onPause方法的时候回回调ActivityThread的handlePauseActivity方法，不太熟悉的同学可以参考: android源码解析之（十四）–&gt;Activity启动流程，文章中有对Activity生命周期的详细讲解。 好吧，先具体看一下ActivityThread.handlePauseActivity的源码： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 在方法体中我们除了执行一些其他的操作，然后在handlePauseActivity方法体中调用了performPauseActivity方法，这个方法就是具体执行回调pauseActivity操作的方法，既然这样我们在看一下performPauseActivity方法的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; }可以发现在performPauseActivity方法中首先判断ActivityClientRecord是否为空，然后又调用了performPauseActivity方法的重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { callCallActivityOnSaveInstanceState(r); } ... } 可以发现，这里调用了callCallActivityOnSaveInstanceState方法，看名称可以发现这里应该回调的是Activity的onSaveInstanceState方法，但是这里执行之前有一个条件判断，首先会判断这里的Activity是否被finish？应为这时候刚刚执行onPause方法所以这里的mFinished变量为false，所以判断执行callCallActivityOnSaveInstanceState方法只要需要通过saveState变量来判断了，而这里的saveState方法是performPauseActivity方法传递过来的。。。。好吧，我们来看一下调用performPauseActivity方法时saveState变量是如何赋值的。回到我们的handlePauseActivity方法，看一下performPauseActivity方法是如何调用的： 1performPauseActivity(token, finished, r.isPreHoneycomb()); 可以发现saveState boolean变量是通过r.isPreHoneycomb方法赋值的，这里我们看一下IsPreHoneycomb方法是如何实现的： 1234567public boolean isPreHoneycomb() { if (activity != null) { return activity.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB; } return false; } 可以发现当我们的App设置的targetSdk版本号小于android versionCode 11也就是android3.0的时候返回为true，其他的时候返回为false，也就是说当我们App设置的targetVersion大于android3.0的时候才会执行callCallActivityOnSaveInstanceState方法，好吧，继续看一下callCallActivityOnSaveInstanceState方法是如何实现的： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 可以发现方法体主要调用了mInstrumentation的callActivityOnSaveInstanceState方法，既然这样，我们再来看一下callActivityOnSaveInstanceState方法： 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 这里方法体中又回调了Activity的performSaveInstanceState方法。。。 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 可以看到这里回调了Activity的onSaveInstanceState方法，这样经过一系列的方法回调之后我们就执行了onSaveInstanceState方法。 这样我们当只执行onPause方法的时候一般通过设置targetVersion控制是否执行onSaveInstanceState方法，当设置的targetVersionCode大于android3.0的时候默认不会执行onSaveInstanceState方法。 然后我们看一下当Activity执行onStop方法的时候是否会执行onSaveInstanceState方法，通过之前分析的Activity的启动流程，我们知道Actvitiy执行onStop方法会回调ActivityThread的handleStopActivity，这样我们先看一下handleStopActivity方法的实现： 12345678910111213141516171819private void handleStopActivity(IBinder token, boolean show, int configChanges) { ActivityClientRecord r = mActivities.get(token); r.activity.mConfigChangeFlags |= configChanges; StopInfo info = new StopInfo(); performStopActivityInner(r, info, show, true); if (localLOGV) Slog.v( TAG, &quot;Finishing stop of &quot; + r + &quot;: show=&quot; + show + &quot; win=&quot; + r.window); updateVisibility(r, show); info.activity = r; info.state = r.state; info.persistentState = r.persistentState; mH.post(info); mSomeActivitiesChanged = true; } 然后我们发现在方法performStopActivity方法中调用了performStopActivityInner方法，我们继续看一下performStopActivityInner方法的实现： 12345678910private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } ... } 可以发现还是通过saveState变量来控制是否调用onSaveInstanceState，而这里的saveState变量是在performStopActivityInner方法调用的时候传递的，回到我们的handleStopActivity方法中关于performStopActivityInner调用的代码： 1performStopActivityInner(r, info, show, true); 好吧，这里直接传值为true，这样我们执行Activity的stop方法一定执行onSaveInstanceState方法。 总结 onSaveInstanceState方法是Activity的生命周期方法，主要用于在Activity销毁时保存一些信息。 当Activity只执行onPause方法时（Activity a打开一个透明Activity b）这时候如果App设置的targetVersion大于android3.0则不会执行onSaveInstanceState方法。 当Activity执行onStop方法时，通过分析源码我们知道调用onSaveInstanceState的方法直接传值为true，所以都会执行onSaveInstanceState方法。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程","link":"/2020/09/11/onSaveInstanceState%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： | 搬瓦工配置 | 搬瓦工费用 | 优惠链接 || — | — | — || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $25.99/半年 | 点击进入 || SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 40 GB RAID-10RAM内存: 2048 MBCPU处理器: 1x Intel XeonTransfer流量: 2000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $27.99/季 | 点击进入 || SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 1x Intel XeonTransfer流量: 1000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $29.99 /半年 | 点击进入 || 80G KVM – PROMOSSD硬盘: 80 GB RAID-10RAM内存: 4 GBCPU处理器: 4x Intel XeonTransfer流量: 3 TB/mo连接速度: 1 GigabitMultiple locations | $19.99/月 | 点击进入 || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $49.99/年 | 点击进入 || 40G KVM – PROMOSSD硬盘: 40 GB RAID-10RAM内存: 2 GBCPU处理器: 3x Intel XeonTransfer流量: 2 TB/mo连接速度: 1 GigabitMultiple locations | $99.99/年 | 点击进入 || 160G KVM – PROMOSSD硬盘: 160 GB RAID-10RAM内存: 8 GBCPU处理器: 5x Intel XeonTransfer流量: 4 TB/mo连接速度: 1 GigabitMultiple locations | $39.99/月 | 点击进入 || 3200G KVM – PROMOSSD硬盘: 320 GB RAID-10RAM内存: 16 GBCPU处理器: 6x Intel XeonTransfer流量: 5 TB/mo连接速度: 1 GigabitMultiple locations | $79.99/月 | 点击进入 | 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：1yum install wget 执行安装ss：1wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限1chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限1chmod +x bbr.sh 启动BBR安装1./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2019/10/11/%E6%90%AC%E7%93%A6%E5%B7%A5%E5%BF%AB%E9%80%9F%E6%89%8B%E5%8A%A8%E6%90%AD%E5%BB%BASS(Shadowsocks)%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"注解相关知识","text":"注解@Retention可以用来修饰注解，是注解的注解，称为元注解。Retention注解有一个属性value，是RetentionPolicy类型的，Enum RetentionPolicy是一个枚举类型，@Retention 注解指定标记注解的存储方式：RetentionPolicy.SOURCE - 注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；RetentionPolicy.CLASS - 标记的注解在编译时由编译器保留，但Java虚拟机(JVM)会忽略。 这是默认的生命周期；RetentionPolicy.RUNTIME - 注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在，因此运行时环境可以使用它。 @Target 注解标记另一个注解，以限制可以应用注解的 Java 元素类型。目标注解指定以下元素类型之一作为其值：ElementType.ANNOTATION_TYP可以应用于注解类型。ElementType.CONSTRUCTOR 可以应用于构造函数。ElementType.FIELD 可以应用于字段或属性。ElementType.LOCAL_VARIABLE 可以应用于局部变量。ElementType.METHOD 可以应用于方法级注解。ElementType.PACKAGE 可以应用于包声明。ElementType.PARAMETER 可以应用于方法的参数。ElementType.TYPE 可以应用于类的任何元素。 package com.example.inject; import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target; 在Activity 中增加注解标注，通过注解+反射+动态代理等，来优化Activity中代码。省去 setContentView、findViewById、setOnClickListener等操作。Layout注解12345@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectLayout { @LayoutRes int value();} View注解12345@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface InjectView { @IdRes int value();} OnClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent(listenerSetter = &quot;setOnClickListener&quot;, listenerType = View.OnClickListener.class, methodName = &quot;onClick&quot;)public @interface OnClick { int[] value();} OnLongClick注解123456@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@InjectEvent( listenerSetter= &quot;setOnLongClickListener&quot;, listenerType= View.OnLongClickListener.class,methodName = &quot;onLongClick&quot;)public @interface OnLongClick { int[] value();} 元注解 标注 OnClick OnLongClick 的注解1234567@Target(ElementType.ANNOTATION_TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface InjectEvent { String listenerSetter(); Class&lt;?&gt; listenerType(); String methodName();} 注解管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package com.example.inject;import android.app.Activity;import android.view.View;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class InjectManage { public static void inJect(Activity activity) { injectLayout(activity); injectView(activity); injectEvent(activity); } /** * 依赖注入 layoutId布局 * 获取 Activity 上的注解 * * @param activity */ private static void injectLayout(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity是否为InjectLayout修饰 if (clazz.isAnnotationPresent(InjectLayout.class)) {// 3.获取InjectLayout注解 InjectLayout annotation = clazz.getAnnotation(InjectLayout.class); if (annotation != null) { try {// 4.通过反射获取 当前Activity 的 setContentView 方法 Method method = clazz.getMethod(&quot;setContentView&quot;, int.class);// 5.获取注解上的value layoutId int resourceId = annotation.value();// 6.调用setContentView method.invoke(activity, resourceId); } catch (Exception e) { e.printStackTrace(); } } } } /** * 依赖注入 获取View * * @param activity */ private static void injectView(Activity activity) { if (activity == null) { throw new NullPointerException(); }// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.判断当前Activity中所有的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) {// 3. 判断字段是否为InjectView修饰 if (field.isAnnotationPresent(InjectView.class)) { InjectView injectView = field.getAnnotation(InjectView.class); if (injectView != null) { try {// 4.反射获取findViewById方法 Method method = clazz.getMethod(&quot;findViewById&quot;, int.class);// 5.获取资源id int resourceId = injectView.value();// 6.获取View对象 View view = (View) method.invoke(activity, resourceId);// 7.设置访问权限 field.setAccessible(true);// 8.将反射获取到的view赋值到Activity上 field.set(activity, view); } catch (Exception e) { e.printStackTrace(); } } } } } /** * 依赖注入 获取 OnClick OnLongClick注解事件 * 注解 + 反射 + 动态代理 * * @param activity */ private static void injectEvent(Activity activity) { if (activity == null) { throw new NullPointerException(); } try {// 1.获取Activity的class对象 Class&lt;? extends Activity&gt; clazz = activity.getClass();// 2.获取Activity的所有成员方法 排除继承方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods) {// 3.是否是自定义注解修饰 if (method.isAnnotationPresent(OnClick.class)) {//TODO OnLongClick事件处理 OnClick onClick = method.getAnnotation(OnClick.class); int[] value = onClick.value();// 4.获取注解上的注解 元注解 InjectEvent injectEvent = onClick.annotationType().getAnnotation(InjectEvent.class); String listenerSetter = injectEvent.listenerSetter(); Class&lt;?&gt; listenerType = injectEvent.listenerType(); String methodName = injectEvent.methodName();// 5.动态代理 生成代理的listener ProxyHandler handler=new ProxyHandler(activity); Object listener = Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[]{listenerType}, handler); handler.mapMethod(methodName,method);// 6.反射获取 findViewById方法的Method对象 Method findViewByIdMethod = clazz.getMethod(&quot;findViewById&quot;, int.class); findViewByIdMethod.setAccessible(true); for (int id : value) {// 7.通过findViewById获取view View btn = (View) findViewByIdMethod.invoke(activity, id);// 8.根据listenerSetter方法名和listenerType方法参数找到method Method listenerSetMethod = btn.getClass().getMethod(listenerSetter, listenerType); listenerSetMethod.setAccessible(true); listenerSetMethod.invoke(btn, listener); } } } } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) { e.printStackTrace(); } }} ProxyHandler12345678910111213141516171819202122232425262728293031323334353637383940414243package com.example.inject;import android.app.Activity;import android.util.Log;import java.lang.ref.WeakReference;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.util.HashMap;public class ProxyHandler implements InvocationHandler { private WeakReference&lt;Activity&gt; mHandlerRef; private HashMap&lt;String, Method&gt; mMethodHashMap; public ProxyHandler(Activity activity) { mHandlerRef = new WeakReference&lt;&gt;(activity); mMethodHashMap = new HashMap&lt;&gt;(); } public void mapMethod(String name, Method method) { mMethodHashMap.put(name, method); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { try { Object handler = mHandlerRef.get(); if (null == handler) return null; String name = method.getName(); //将onClick方法的调用映射到activity 中的注解标注的方法 Method realMethod = mMethodHashMap.get(name);// Log.i(&quot;injectEvent&quot;, &quot;proxy=&quot; + proxy + &quot;,method=&quot; + method.getName() + &quot;,realMethod=&quot; + realMethod); if (null != realMethod) { return realMethod.invoke(handler, args); } } catch (Exception e) { e.printStackTrace(); } return null; }} 12345678910111213141516171819202122232425262728293031323334@InjectLayout(value = R.layout.activity_network)public class NetworkActivity extends AppCompatActivity { @InjectView(R.id.get_data) Button button; @InjectView(R.id.get_data2) Button button2; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); InjectManage.inJect(this);// setContentView();// button=findViewById(R.id.button)// button.setOnClickListener(new View.OnClickListener() {// @Override// public void onClick(View v) {// testNetWorkApi();// }// });// button.setOnLongClickListener(new View.OnLongClickListener() {// @Override// public boolean onLongClick(View v) {// return false;// }// }); } @OnClick({R.id.get_data,R.id.get_data2}) public void onClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onClick&quot;); } @OnLongClick(R.id.get_data) public void onLongClick(View view){ Log.e(&quot;Inject&quot;,&quot;依赖注入实现 onLongClick&quot;); } 期间遇到点小问题，就是动态代理这块，对这块理解不够深。首先 Activity中 使用OnClick注解修饰的方法onClick()是需要传入参数的，否则在动态代理里，动态代理回调这个方法就会出错。","link":"/2020/09/11/%E6%B3%A8%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"},{"title":"搭建 WordPress 博客教程（超详细）","text":"本文转自：Nonecy 的小黑屋*链接：http://blog.studymany.com/2018/07/29/create-wordpress-blog/* 需要 一台服务器 一个域名，直接通过ip访问好傻好傻的样子，哈哈。 linux知识 肯折腾 具体步骤第一步购买服务器，国内阿里云的云服务器挺不错的，国外的就更多了，这一步就不介绍了，不懂得的自己上网搜。接下来操作需要： 远程连接服务器Windows 用户 以Xshell为例。 下载安装Xshell，官网链接。 安装完成后新建会话（Alt+N）。依次填写图中信息。名称可以是Vultr或者其他，协议选择SSH，主机填写之前的IP Address，端口号选择22。 连接 点击左侧的用户身份验证，填写信息。方法选择Password，用户名为之前的Username（一般都是root），密码为之前的Password（这个建议直接复制粘贴过来，系统给的有点复杂） 用户身份验证 填写完之后点击确定。然后点击连接。出现其他提示的话选择接受就可以了。这时你就可以看到一个命令控制台了。这时就算连接成功了。 Mac OS 用户 打开终端或者iTerm2等。 1ssh root@45.32.195.77 然后输入密码即可。 安装nginx，mysql，php建议使用lnmp一键安装包安装，方便快捷。如果不用一键安装包，我估计得研究这一块的东西大概一周吧。下面以一键安装包为例。 获取lnmp一键安装包链接 lnpm官网链接 找到下载页面选择最新的复制其链接。 写此文时最新版本信息如下： 1234LNMP 1.4 测试版http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz (131KB)MD5：bd851e151b2ba13c3a32c435efb1a76c最后更新: 2017年2月14日14:18 GMT+8 其中的http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz就是我们需要的链接，复制到剪贴板。 安装 12345678# 下载，后边的路径直接粘贴就好。XShell上面复制快捷键是ctrl+insert，粘贴快捷键是Shift+insert，mac上面是我们熟悉的 command+c，command+vwget http://soft.vpser.net/lnmp/lnmp1.4beta.tar.gz# 解压tar -zxvf lnmp1.4beta.tar.gz# 进入lnmp目录cd lnmp1.4# 执行install.sh进行安装./install.sh lnmp 依次输入你要安装的选项前的数字并回车即可下一步。 MYSQL 选项 123456789You have 5 options for your DataBase install.1: Install MySQL 5.1.732: Install MySQL 5.5.53 (Default)3: Install MySQL 5.6.344: Install MySQL 5.7.165: Install MariaDB 5.5.536: Install MariaDB 10.0.287: Install MariaDB 10.1.190: DO NOT Install MySQL/MariaDBEnter your choice (1, 2, 3, 4, 5, 6, 7 or 0): 此处根据所需选择，如果使用的上述服务器，请选择2或者直接回车。我选择默认。 注意：安装MySql时，如果选择太高的版本安装会被拒绝，提示信息如下 Memory less than 1GB, can't install MySQL 5.6, 5.7 or MairaDB 10!。根据个人手动安装MySql5.7的经验来看，此768MB内存的服务器在运行一个nginx，mysql，php时还好，倘若再运行一个tomcat，mysql将会不定期down掉。所以此处选择一个低版本的5.5MySql即可。 1234You will install MySQL 5.5.53===========================Please setup root password of MySQL.(Default password: root)Please enter: 输入密码回车或直接回车，直接回车默认密码为root。此处做实验我选择默认，个人实际使用请修改。 1234MySQL root password: root===========================Do you want to enable or disable the InnoDB Storage Engine?Default enable,Enter your choice [Y/n]: 输入Y或者n然后回车或直接回车，直接回车默认启用InnoDB存储引擎。我选择默认。 1234567891011No input,The InnoDB Storage Engine will enable.===========================You have 6 options for your PHP install.1: Install PHP 5.2.172: Install PHP 5.3.293: Install PHP 5.4.454: Install PHP 5.5.38 (Default)5: Install PHP 5.6.306: Install PHP 7.0.157: Install PHP 7.1.1Enter your choice (1, 2, 3, 4, 5, 6 or 7): 输入选项然后回车或者直接回车，直接回车默认安装PHP5.5.38版本。我选择默认。 12345You will install PHP 7.1.1===========================You have 3 options for your Memory Allocator install.1: Don't install Memory Allocator. (Default)2: Install Jemalloc3: Install TCMalloc 输入选项然后回车或者直接回车，直接回车默认不安装内存分配器。我选择默认。 此时出现 1Press any key to install...or Press Ctrl+c to cancel 当然是摁任意键啦，一般都是回车咯。 然后出现一大堆信息。前几行如下： 12345678910111213You will install lnmp stack.nginx-1.10.3mysql-5.5.53php-5.5.38Enable InnoDB: yPrint lnmp.conf infomation...Download Mirror: http://soft.vpser.netNginx Additional Modules: PHP Additional Modules: Database Directory: /usr/local/mysql/varDefault Website Directory: /home/wwwroot/defaultCentOS release 6.8 (Final)Kernel \\r on an \\m 这一堆东西你就不用管啦。本次实验的开始时间23:04……经过了漫长漫长漫长的等待之后……大概23:35结束。所以期间你去洗个澡看个电视剧都不是问题。然后我们看到屏幕上最后输出的信息如下。 1234The service command supports only basic LSB actions (start, stop, restart, try-restart, reload, force-reload, status). For other actions, please try to use systemctl.Removed symlink /etc/systemd/system/basic.target.wants/firewalld.service.Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.Add Startup and Starting LNMP...Add nginx service at system startup...Starting nginx... doneAdd mysql service at system startup...Starting MySQL... SUCCESS! Add php-fpm service at system startup...Starting php-fpm done============================== Check install ==============================Checking ...Nginx: OKMySQL: OKPHP: OKPHP-FPM: OKClean src directory...+------------------------------------------------------------------------+| LNMP V1.4 for CentOS Linux Server, Written by Licess |+------------------------------------------------------------------------+| For more information please visit https://lnmp.org |+------------------------------------------------------------------------+| lnmp status manage: lnmp {start|stop|reload|restart|kill|status} |+------------------------------------------------------------------------+| phpMyAdmin: http://IP/phpmyadmin/ || phpinfo: http://IP/phpinfo.php || Prober: http://IP/p.php |+------------------------------------------------------------------------+| Add VirtualHost: lnmp vhost add |+------------------------------------------------------------------------+| Default directory: /home/wwwroot/default |+------------------------------------------------------------------------+| MySQL/MariaDB root password: root |+------------------------------------------------------------------------++-------------------------------------------+| Manager for LNMP, Written by Licess |+-------------------------------------------+| https://lnmp.org |+-------------------------------------------+nginx (pid 715 713) is running...php-fpm is runing! SUCCESS! MySQL running (1247)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN tcp6 0 0 :::22 :::* LISTEN Install lnmp V1.4 completed! enjoy it. 简单说明一下，此安装过程安装完成便也启动了nginx，mysql，php-fpm并加入了开机启动项。如果重启服务器，不需要再单独手动开启相关的服务了。总的来说相当方便的。 关于Linux服务，自己之前做的笔记分享给大家。Linux 服务管理 这时候你在浏览器输入http://IP 例如 http://45.32.195.77便可以访问了。看到的内容如下： 访问页面 网站根目录路径/home/wwwroot/default,如果只用来放一些静态页面，那么，现在就足够了，直接将你的html，js，css等文件丢进去即可。这不是本文重点，在此不赘述了。 退出使用ctrl+c 安装WordPress下载WordPress包 中文官方站点英文官方站点具体的根据自己的需求选择。下面以中文版为例。当前最新版本是4.7.2 为了方便，我们还是在用站点默认的路径，但是我们投机取巧一下。 1234567891011121314# 进入根目录上一级目录cd /home/wwwroot/# 将default重命名为oldmv default old# 下载WordPress包中文版wget https://cn.wordpress.org/wordpress-4.7.2-zh_CN.tar.gz# 解压WordPress包tar -zxvf wordpress-4.7.2-zh_CN.tar.gz # 查看解压后的文件夹名，此处是wordpress，估计应该都是吧，看看保险啊[root@vultr wwwroot]# lsold wordpress wordpress-4.7.2-zh_CN.tar.gz# 将wordpress重命名为defaultmv wordpress default# 再次查看检验[root@vultr wwwroot]# lsdefault old wordpress-4.7.2-zh_CN.tar.gz 给相应目录授权 12345# 目录以及目录下的文件授权[root@vultr wwwroot]# chown -R 755 /home/wwwrootchown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted# 将目录的所有者分给www组下的www用户。[root@vultr wwwroot]# chown -R www:www /home/wwwroot/chown: changing ownership of ‘/home/wwwroot/old/.user.ini’: Operation not permitted 出现的提示大概是说有一个文件无法更改用户分组和权限。不会影响你的wordpress，忽略就好。 创建一个数据库wordpress 1234567891011121314151617181920212223242526# 登录数据库mysql -u root -p# 输入密码默认的话就是root，否则就是你自己之前设置的那个# 登录进来之后，看到这样一些东西Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.5.53-log Source distributionCopyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respective owners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; # 不用理会上面的，创建我们的数据库，比如名字为wordpress。记得加分号。mysql&gt; create database wordpress;# 看一下，有没有我们创建的数据库mysql&gt; show databases;# 大概看到如下内容。意味着这一步也没问题。+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || wordpress |+--------------------+4 rows in set (0.01 sec)# 退出mysqlexit 配置WordPress 这时候在此通过浏览器访问 http://IP 例如 http://45.32.195.77，浏览器将自动跳转到http://45.32.195.77/wp-admin/setup-config.php，这就是wordpress的配置页面了，看到的内容如下： 访问页面 点击现在就开始。这时候我们看到如下页面: 数据库配置 按照之前设置的，输入如下信息。 12345数据库名：wordpress用户名：root密码：root数据库主机：localhost表前缀：wp_ 点击提交。 数据库连接完成 到这一步，基本上就意味着大功告成了，因为后边基本不会出错啦。 点击进行安装按钮。出现下图： wordpress 设置 按照自己的需求填写，比如我这里填写如下： wordpress 我的设置 点击安装WordPress按钮，然后登录设置啥的纯页面操作就不在这里过多介绍咯。 主页大概是这样的 后期问题解决有问题的反馈在此，我会进行补充。 主题只显示一个原因：php没有权限读取文件目录。 解决方案：编辑php.ini文件中的disable_functions字段，将其中的scandir去掉。 123456# 使用一键安装包安装的php的配置文件路径如下vi /usr/local/php/etc/php.ini# 查找disable_functions在当前的底行模式下输入 /disable_functions,便可以找到这样一行disable_functions = passthru,exec,system,chroot,scandir,chgrp,chown,shell_exec,proc_open,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru,stream_socket_server# 删掉其中的scandir，此处很容易搞乱，所以有必要会使用编辑模式，摁i进入编辑模式。就可以输入删除了。# 退出编辑模式，并保存退出。esc退出编辑模式，:wq保存退出。 更多的指令看我之前的一个简单的入门笔记吧。Linux VIM 文本编辑器 然后记得重启php-fpm服务 1/etc/init.d/php-fpm restart 这样再刷新，就会发现主题不只有一个啦。 更多如果你使用MarkDown，那么请安装JetPack插件，如果你需要语法高亮，请安装Crayon Syntax Highlighter。 以后可能会深入研究一下，有机会的话会专门写一篇文章介绍WordPress主题与插件的哈。","link":"/2020/09/11/%E6%90%AD%E5%BB%BA%20WordPress%20%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B%EF%BC%88%E8%B6%85%E8%AF%A6%E7%BB%86%EF%BC%89/"},{"title":"27 HOME事件流程","text":"上一篇文章中我们介绍了android系统的截屏事件，由于截屏事件是一种系统全局处理事件，所以事件的处理逻辑不是在App中执行，而是在PhoneWindowManager中执行。而本文我们现在主要讲解android系统中HOME按键的事件处理，和截屏事件类似，这里的HOME按键也是系统级别的按键事件监听，所以其处理事件的逻辑也应该和截屏事件处理流程类似，从上一篇文章的分析过冲中我们不难发现，系统级别的按键处理逻辑其实都是在PhoneWindowManager中，所以HOME按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中执行，那么我们就从dispatchUnhandleKey方法开始分析HOME按键的处理流程。 好吧我们看一下PhoneWindowManager的dispatchUnhandleKey方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } if (DEBUG_INPUT) { if (fallbackEvent == null) { Slog.d(TAG, &quot;No fallback.&quot;); } else { Slog.d(TAG, &quot;Performing fallback: &quot; + fallbackEvent); } } return fallbackEvent; } 通过查看源码，我们重点看一下dispatchUnhandledKey方法中调用的interceptFallback方法，关于HOME按键的处理逻辑也是在这个方法体中的，所以继续看一下interceptFallback方法的实现： 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析源码我们知道关于HOME按键的处理逻辑主要是在interceptKeyBeforeDispatching方法的实现的，既然这样，我们看一下interceptKeyBeforeDispatching方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) { ... // First we always handle the home key here, so applications // can never break it, although if keyguard is on, we do let // it handle it, because that gives us the correct 5 second // timeout. if (keyCode == KeyEvent.KEYCODE_HOME) { // If we have released the home key, and didn't do anything else // while it was pressed, then it is time to go home! if (!down) { cancelPreloadRecentApps(); mHomePressed = false; if (mHomeConsumed) { mHomeConsumed = false; return -1; } if (canceled) { Log.i(TAG, &quot;Ignoring HOME; event canceled.&quot;); return -1; } // If an incoming call is ringing, HOME is totally disabled. // (The user is already on the InCallUI at this point, // and his ONLY options are to answer or reject the call.) TelecomManager telecomManager = getTelecommService(); if (telecomManager != null &amp;&amp; telecomManager.isRinging()) { Log.i(TAG, &quot;Ignoring HOME; there's a ringing incoming call.&quot;); return -1; } // Delay handling home if a double-tap is possible. if (mDoubleTapOnHomeBehavior != DOUBLE_TAP_HOME_NOTHING) { mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); // just in case mHomeDoubleTapPending = true; mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout()); return -1; } handleShortPressOnHome(); return -1; } // If a system window has focus, then it doesn't make sense // right now to interact with applications. WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null; if (attrs != null) { final int type = attrs.type; if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0) { // the &quot;app&quot; is keyguard, so give it the key return 0; } final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length; for (int i=0; i&lt;typeCount; i++) { if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) { // don't do anything, but also don't pass it to the app return -1; } } } // Remember that home is pressed and handle special actions. if (repeatCount == 0) { mHomePressed = true; if (mHomeDoubleTapPending) { mHomeDoubleTapPending = false; mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable); handleDoubleTapOnHome(); } else if (mLongPressOnHomeBehavior == LONG_PRESS_HOME_RECENT_SYSTEM_UI || mDoubleTapOnHomeBehavior == DOUBLE_TAP_HOME_RECENT_SYSTEM_UI) { preloadRecentApps(); } } else if ((event.getFlags() &amp; KeyEvent.FLAG_LONG_PRESS) != 0) { if (!keyguardOn) { handleLongPressOnHome(event.getDeviceId()); } } return -1; } // Let the application handle the key. return 0; } 这里我们主要看一下对android系统HOME按键的处理逻辑，通过分析源码我们知道HOME按键进入launcher界面的主要逻辑是在handleShortPressOnHome();方法中执行的，所以我们继续看一下handleShortPressOnHome方法的实现。 1234567891011121314private void handleShortPressOnHome() { // Turn on the connected TV and switch HDMI input if we're a HDMI playback device. getHdmiControl().turnOnTv(); // If there's a dream running then use home to escape the dream // but don't actually go home. if (mDreamManagerInternal != null &amp;&amp; mDreamManagerInternal.isDreaming()) { mDreamManagerInternal.stopDream(false /*immediate*/); return; } // Go home! launchHomeFromHotKey(); } 可以看到在handleShortPressOnHome方法中调用了launchHomeFromHotKey方法，该方法的注释用于go home，所以继续看一下该方法的实现： 123void launchHomeFromHotKey() { launchHomeFromHotKey(true /* awakenFromDreams */, true /*respectKeyguard*/); } 可以看到在launchHomeFromHotKey方法中我们又调用了launchHomeFromHotkey的重构方法，这样我们看一下这个重构方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445void launchHomeFromHotKey(final boolean awakenFromDreams, final boolean respectKeyguard) { if (respectKeyguard) { if (isKeyguardShowingAndNotOccluded()) { // don't launch home if keyguard showing return; } if (!mHideLockScreen &amp;&amp; mKeyguardDelegate.isInputRestricted()) { // when in keyguard restricted mode, must first verify unlock // before launching home mKeyguardDelegate.verifyUnlock(new OnKeyguardExitResult() { @Override public void onKeyguardExitResult(boolean success) { if (success) { try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } }); return; } } // no keyguard stuff to worry about, just launch home! try { ActivityManagerNative.getDefault().stopAppSwitches(); } catch (RemoteException e) { } if (mRecentsVisible) { // Hide Recents and notify it to launch Home if (awakenFromDreams) { awakenDreams(); } sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); hideRecentApps(false, true); } else { // Otherwise, just launch Home sendCloseSystemWindows(SYSTEM_DIALOG_REASON_HOME_KEY); startDockOrHome(true /*fromHomeKey*/, awakenFromDreams); } } 可以发现在方法中我们首先调用了ActivityManagerNative.getDefault().stopAppSwitches();该方法主要用于暂停后台的打开Activity的操作，避免打扰用户的操作。比如这时候我们在后台打开一个新的App，那么这时候由于要回到home页面，所以需要先延时打开。方法执行这个方法之后然后执行了sendCloseSystemWindows方法，该方法主要实现了对当前系统App页面的关闭操作，下面我们先看一下ActivityManagerNative.getDefault().stopAppSwitches();方法的实现，这里的ActivityManagerNative.getDefault我们在前面已经多次说过了其是一个Binder对象，是应用进程Binder客户端用于与ActivityManagerService之间通讯，所以这里最终调用的是ActivityManagerService的stopAppsSwitches方法，这样我们就继续看一下ActivityManagerService的stopAppsSwitches方法的实现。 1234567891011121314151617@Override public void stopAppSwitches() { if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) { throw new SecurityException(&quot;Requires permission &quot; + android.Manifest.permission.STOP_APP_SWITCHES); } synchronized(this) { mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME; mDidAppSwitch = false; mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG); Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG); mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME); } } 可以发现这里主要是发送了一个异步消息，并且msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG，即跳转Activity，然后我们继续我们看一下mHandler的handleMessage方法当msg.what为DO_PENDING_ACTIVITY_LAUNCHES_MSG时的操作。而且我们可以发现这里的异步消息是一个延时的异步消息，延时的时间为APP_SWITCH_DELAY_TIME，我们可以看一下该变量的定义： 123// Amount of time after a call to stopAppSwitches() during which we will // prevent further untrusted switches from happening. static final long APP_SWITCH_DELAY_TIME = 5*1000; 然后我们可以看一下mHander的handleMessage方法的具体实现： 12345case DO_PENDING_ACTIVITY_LAUNCHES_MSG: { synchronized (ActivityManagerService.this) { mStackSupervisor.doPendingActivityLaunchesLocked(true); } } break; 可以发现这里直接调用了mStackSupervisor.doPendingActivityLaunchesLocked方法，好吧，继续看一下doPendingActivityLaunchesLocked方法的实现。 1234567final void doPendingActivityLaunchesLocked(boolean doResume) { while (!mPendingActivityLaunches.isEmpty()) { PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); } } 可以发现这里就是调用了startActivity的操作了，看过Activity启动流程的同学应该知道：android源码解析之（十四）–&gt;Activity启动流程 这里就是开始启动Activity了，所以当我们按下HOME按键的时候，后台的startActivity都会延时5秒钟执行… 然后回到我们的launchHomeFromHotKey方法，看一下launchHomeFromHotKey方法的实现。 123void sendCloseSystemWindows(String reason) { PhoneWindow.sendCloseSystemWindows(mContext, reason); } 可以发现这里调用了PhoneWindow的静态方法sendCloseSystemWindow,继续看一下该方法的实现逻辑。 12345678public static void sendCloseSystemWindows(Context context, String reason) { if (ActivityManagerNative.isSystemReady()) { try { ActivityManagerNative.getDefault().closeSystemDialogs(reason); } catch (RemoteException e) { } } } 看到这里，很明显了又是调用了Binder的进程间通讯，最终ActivityManagerService的closeSystemDialogs方法会被执行，所以我们继续看一下ActivityManagerService的closeSystemDialogs方法的实现。 12345678910111213141516171819202122232425262728@Override public void closeSystemDialogs(String reason) { enforceNotIsolatedCaller(&quot;closeSystemDialogs&quot;); final int pid = Binder.getCallingPid(); final int uid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); try { synchronized (this) { // Only allow this from foreground processes, so that background // applications can't abuse it to prevent system UI from being shown. if (uid &gt;= Process.FIRST_APPLICATION_UID) { ProcessRecord proc; synchronized (mPidsSelfLocked) { proc = mPidsSelfLocked.get(pid); } if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { Slog.w(TAG, &quot;Ignoring closeSystemDialogs &quot; + reason + &quot; from background process &quot; + proc); return; } } closeSystemDialogsLocked(reason); } } finally { Binder.restoreCallingIdentity(origId); } } 可以发现其实在方法体中将关闭窗口的逻辑下发到了closeSystemDialogsLocked中，所以我们继续看一下closeSystemDialogsLocked方法的实现。 123456789101112131415void closeSystemDialogsLocked(String reason) { Intent intent = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND); if (reason != null) { intent.putExtra(&quot;reason&quot;, reason); } mWindowManager.closeSystemDialogs(reason); mStackSupervisor.closeSystemDialogsLocked(); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, -1, Process.SYSTEM_UID, UserHandle.USER_ALL); } 可以发现在方法体中首先调用了mWindowManager.closeSystemDialogs方法，该方法就是关闭当前页面中存在的系统窗口，比如输入法，壁纸等： 12345678910111213141516171819@Override public void closeSystemDialogs(String reason) { synchronized(mWindowMap) { final int numDisplays = mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) { final WindowList windows = mDisplayContents.valueAt(displayNdx).getWindowList(); final int numWindows = windows.size(); for (int winNdx = 0; winNdx &lt; numWindows; ++winNdx) { final WindowState w = windows.get(winNdx); if (w.mHasSurface) { try { w.mClient.closeSystemDialogs(reason); } catch (RemoteException e) { } } } } } } 讲过这样一层操作之后，我们就关闭了当前中存在的系统窗口。然后还是回到我们的launchHomeFromHotKey方法，我们发现在方法体的最后我们调用了startDockOrHome方法，这个方法就是实际的跳转HOME页面的方法了，我们可以具体看一下该方法的实现。 12345678910111213141516171819202122232425262728void startDockOrHome(boolean fromHomeKey, boolean awakenFromDreams) { if (awakenFromDreams) { awakenDreams(); } Intent dock = createHomeDockIntent(); if (dock != null) { try { if (fromHomeKey) { dock.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } startActivityAsUser(dock, UserHandle.CURRENT); return; } catch (ActivityNotFoundException e) { } } Intent intent; if (fromHomeKey) { intent = new Intent(mHomeIntent); intent.putExtra(WindowManagerPolicy.EXTRA_FROM_HOME_KEY, fromHomeKey); } else { intent = mHomeIntent; } startActivityAsUser(intent, UserHandle.CURRENT); } 可以发现我们在方法体中调用了createHomeDockIntent，这个方法的作用就是创建到达HOME页面的Intent对象，然后我们调用了startActivityAsUser方法，这样经过一系列的调用之后就调起了home页面的Activity，所以这时候系统就返回到了HOME页面。 总结： 系统也是在PhoneWindowManager中监听HOME按键的点击并进行处理； 系统监听到HOME按键之后会首先关闭相应的系统弹窗； 通过创建Intent对象，并调用startActivity方法使系统跳转到HOME页面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程","link":"/2020/09/11/HOME%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"20 Dialog取消绘制流程","text":"上几篇文章中我们分析了Dialog的加载绘制流程，也分析了Acvityi的加载绘制流程，说白了Android系统中窗口的展示都是通过Window对象控制，通过ViewRootImpl对象执行绘制操作来完成的，那么窗口的取消绘制流程是怎么样的呢？这篇文章就以Dialog为例说明Window窗口是如何取消绘制的。 有的同学可能会问前几篇文章介绍Activity的加载绘制流程的时候为何没有讲Activity的窗口取消流程，这里说明一下。那是因为当时说明的重点是Activity的加载与绘制流程，而取消绘制流程由于混杂在Activity的生命周期管理，可能不太明显，所以这里将Window窗口的取消绘制流程放在Dialog中，其实他们的取消绘制流程都是相似的，看完Dialog的取消绘制流程之后，再看一下Activity的取消绘制流程就很简单了。 还记得我们上一篇文章关于Dialog的例子么？我们通过AlertDialog.Builder创建了一个AlertDialog，并通过Activity中的按钮点击事件来显示这个AlertDialog，而在AlertDialog中定义了一个“知道了”按钮，点击这个按钮就会触发alertDialog.cancel方法，通过执行这个方法，我们的alertDialog就不在显示了，很明显的，cancel方法执行过程中就执行了取消绘制的逻辑，这里我们先看一下我们的例子核心代码： 123456789101112131415161718title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this.getApplication()); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.cannel(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 这里的title就是我们自己的Activity中的一个TextView，通过注册这个TextView的点击事件，来显示一个AlertDialog，通过注册AlertDialog中按钮的点击事件，执行alertDialog的cancel方法。 好吧，看一下Dialog的cannel方法的具体实现： 12345678public void cancel() { if (!mCanceled &amp;&amp; mCancelMessage != null) { mCanceled = true; // Obtain a new message so this dialog can be re-used Message.obtain(mCancelMessage).sendToTarget(); } dismiss(); } 可以看到方法体中，若当前Dialog没有取消，并且设置了取消message，则调用Message.obtain(mCancel).sendToTarget()，前面已经分析过这里的sendToTarget方法会回调我们注册的异步消息处理逻辑： 123456789101112public void setOnCancelListener(final OnCancelListener listener) { if (mCancelAndDismissTaken != null) { throw new IllegalStateException( &quot;OnCancelListener is already taken by &quot; + mCancelAndDismissTaken + &quot; and can not be replaced.&quot;); } if (listener != null) { mCancelMessage = mListenersHandler.obtainMessage(CANCEL, listener); } else { mCancelMessage = null; } }可以看到如果我们在初始化AlertDialog.Builder时，设置了setOnCancelListener，那么我们就会执行mListenersHandler的异步消息处理，好吧，这里看一下mListenersHandler的定义： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 好吧，这里调用的是设置的OnCancelListener的onCancel方法，也就是说我们调用dialog.cancel方法时首先会判断dialog是否调用了setOnCancelListener若设置了，则先调用OnCancelListener的onCancel方法，然后再次执行dismiss方法，若我们没有为Dialog.Builder设置OnCancelListener那么cancel方法和dismiss方法是等效的。 这样，我们来看一下dismiss方法的实现逻辑： 1234567public void dismiss() { if (Looper.myLooper() == mHandler.getLooper()) { dismissDialog(); } else { mHandler.post(mDismissAction); } } 可以看到，这里首先判断当前线程的Looper是否是主线程的Looper（由于mHandler是在主线程中创建的，所以mHandler.getLooper返回的是主线程中创建的Looper对象），若是的话，则直接执行dismissDialog()方法，否则的话，通过mHandler发送异步消息至主线程中，简单来说就是判断当前线程是否是主线程，若是主线程则执行dismissDialog方法否则发送异步消息，我们看一下mHandler对异步消息的处理机制，由于这里的mDismissAction是一个Runnable对象，所以这里直接看一下mDismissAction的定义：12345private final Runnable mDismissAction = new Runnable() { public void run() { dismissDialog(); } };好吧，这里的异步消息最终也是调用的dismissDialog方法。。。。 所以无论我们执行的cancel方法还是dismiss方法，无论我们方法是在主线程执行还是子线程中执行，最终调用的都是dismissDialog方法，那么就看一下dismissDialog是怎么个执行逻辑。123456789101112131415161718192021222324void dismissDialog() { if (mDecor == null || !mShowing) { return; } if (mWindow.isDestroyed()) { Log.e(TAG, &quot;Tried to dismissDialog() but the Dialog's window was already destroyed!&quot;); return; } try { mWindowManager.removeViewImmediate(mDecor); } finally { if (mActionMode != null) { mActionMode.finish(); } mDecor = null; mWindow.closeAllPanels(); onStop(); mShowing = false; sendDismissMessage(); } }好吧，看样子代码还不是特别多，方法体中，首先判断当前的mDector是否为空，或者当前Dialog是否在显示，若为空或者没有在显示，则直接return掉，也就是说当前我们的dialog已经不再显示了，则我们不需要往下在执行。 然后我们调用了mWindow.isDestroyed()方法，判断Window对象是否已经被销毁，若已经被销毁，则直接return，并打印错误日志。 然后我们调用了mWindowManager.removeViewImmediate(mDector)，这里的mDector是我们Dialog窗口的根布局，看这个方法的名字应该就是Dialog去除根布局的操作了，可以看一下这个方法的具体实现。前几篇文章中我们已经分析过了这里的mWindowManager其实是WindowManagerImpl的实例，所以这里的removeViewImmediate方法应该是WindowManagerImpl中的方法，我们看一下它的具体实现： 1234@Override public void removeViewImmediate(View view) { mGlobal.removeView(view, true); } 可以发现，这里它调用了mGlobal.removeView方法，而这里的mGlobal是WindowManagerGlobal的实例，所以我们再看一下WIndowManagerGlobal中removeView的实现逻辑: 1234567891011121314151617public void removeView(View view, boolean immediate) { if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(&quot;Calling with view &quot; + view + &quot; but the ViewAncestor is attached to &quot; + curView); } } 可以发现，这里在获取了保存的mDector组件之后，又调用了removeViewLocked方法，我们在看一下这个方法的具体实现逻辑： 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 看到了么，我们获取了mDector组件的ViewRootImpl，然后调用了其的die方法，通过这个方法实现Window组件的销毁流程。 1234567891011121314151617boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, &quot;Attempting to destroy the window while drawing!\\n&quot; + &quot; window=&quot; + this + &quot;, title=&quot; + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } 可以看到在方法体中有调用了doDie方法，看名字应该就是真正执行window销毁工作的方法了，我们在看一下doDie方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839void doDie() { checkThread(); if (LOCAL_LOGV) Log.v(TAG, &quot;DIE in &quot; + this + &quot; of &quot; + mSurface); synchronized (this) { if (mRemoved) { return; } mRemoved = true; if (mAdded) { dispatchDetachedFromWindow(); } if (mAdded &amp;&amp; !mFirst) { destroyHardwareRenderer(); if (mView != null) { int viewVisibility = mView.getVisibility(); boolean viewVisibilityChanged = mViewVisibility != viewVisibility; if (mWindowAttributesChanged || viewVisibilityChanged) { // If layout params have been changed, first give them // to the window manager to make sure it has the correct // animation info. try { if ((relayoutWindow(mWindowAttributes, viewVisibility, false) &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) { mWindowSession.finishDrawing(mWindow); } } catch (RemoteException e) { } } mSurface.release(); } } mAdded = false; } WindowManagerGlobal.getInstance().doRemoveView(this); } 可以看到方法体中，首先调用了checkThread方法，介绍Activity的绘制流程的时候有过介绍，判断当前执行代码的线程，若不是主线程，则抛出异常： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 我们顺着doDie的方法往下看，又调用了dispatchDetachedFromWindow()方法，这个方法主要是销毁Window中的各中成员变量，临时变量等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void dispatchDetachedFromWindow() { if (mView != null &amp;&amp; mView.mAttachInfo != null) { mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(false); mView.dispatchDetachedFromWindow(); } mAccessibilityInteractionConnectionManager.ensureNoConnection(); mAccessibilityManager.removeAccessibilityStateChangeListener( mAccessibilityInteractionConnectionManager); mAccessibilityManager.removeHighTextContrastStateChangeListener( mHighContrastTextManager); removeSendWindowContentChangedCallback(); destroyHardwareRenderer(); setAccessibilityFocus(null, null); mView.assignParent(null); mView = null; mAttachInfo.mRootView = null; mSurface.release(); if (mInputQueueCallback != null &amp;&amp; mInputQueue != null) { mInputQueueCallback.onInputQueueDestroyed(mInputQueue); mInputQueue.dispose(); mInputQueueCallback = null; mInputQueue = null; } if (mInputEventReceiver != null) { mInputEventReceiver.dispose(); mInputEventReceiver = null; } try { mWindowSession.remove(mWindow); } catch (RemoteException e) { } // Dispose the input channel after removing the window so the Window Manager // doesn't interpret the input channel being closed as an abnormal termination. if (mInputChannel != null) { mInputChannel.dispose(); mInputChannel = null; } mDisplayManager.unregisterDisplayListener(mDisplayListener); unscheduleTraversals(); } 可以看到我们在方法中调用了mView.dispatchDetachedFromWindow方法，这个方法的作用就是将mView从Window中detach出来，我们可以看一下这个方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637383940void dispatchDetachedFromWindow() { AttachInfo info = mAttachInfo; if (info != null) { int vis = info.mWindowVisibility; if (vis != GONE) { onWindowVisibilityChanged(GONE); } } onDetachedFromWindow(); onDetachedFromWindowInternal(); InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null) { imm.onViewDetachedFromWindow(this); } ListenerInfo li = mListenerInfo; final CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners = li != null ? li.mOnAttachStateChangeListeners : null; if (listeners != null &amp;&amp; listeners.size() &gt; 0) { // NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to // perform the dispatching. The iterator is a safe guard against listeners that // could mutate the list by calling the various add/remove methods. This prevents // the array from being modified while we iterate it. for (OnAttachStateChangeListener listener : listeners) { listener.onViewDetachedFromWindow(this); } } if ((mPrivateFlags &amp; PFLAG_SCROLL_CONTAINER_ADDED) != 0) { mAttachInfo.mScrollContainers.remove(this); mPrivateFlags &amp;= ~PFLAG_SCROLL_CONTAINER_ADDED; } mAttachInfo = null; if (mOverlay != null) { mOverlay.getOverlayView().dispatchDetachedFromWindow(); } } 其中onDetachedFromWindow方法是一个空的回调方法，这里我们重点看一下onDetachedFromWindowInternal方法： 12345678910111213141516171819protected void onDetachedFromWindowInternal() { mPrivateFlags &amp;= ~PFLAG_CANCEL_NEXT_UP_EVENT; mPrivateFlags3 &amp;= ~PFLAG3_IS_LAID_OUT; removeUnsetPressCallback(); removeLongPressCallback(); removePerformClickCallback(); removeSendViewScrolledAccessibilityEventCallback(); stopNestedScroll(); // Anything that started animating right before detach should already // be in its final state when re-attached. jumpDrawablesToCurrentState(); destroyDrawingCache(); cleanupDraw(); mCurrentAnimation = null; } onDetachedFromWindowInternal方法的方法体也不是特别长，都是一些调用函数，这里看一下destropDrawingCache方法，这个方法主要是销毁View的缓存Drawing，我们来看一下具体实现： 12345678910public void destroyDrawingCache() { if (mDrawingCache != null) { mDrawingCache.recycle(); mDrawingCache = null; } if (mUnscaledDrawingCache != null) { mUnscaledDrawingCache.recycle(); mUnscaledDrawingCache = null; } } 这里的mDrawingCache其实就是一个Bitmap类型的成员变量，而这里调用的recycler和置空操作其实就是把View中执行draw方法之后缓存的bitmap清空。 这里需要说明的是，我们View组件的最终显示落实是通过draw方法实现绘制的，而我们的draw方法的参数是一个Canvas，这是一个画布的对象，通过draw方法就是操作这个对象并显示出来，而Canvas对象之所以能够实现显示的效果是因为其内部保存着一个Bitmap对象，通过操作Canvas对象实质上是操作Canvas对象内部的Bitmap对象，而View组件的显示也就是通过这里的Bitmap来实现的。 而我们上文中置空了bitmap对象就相当于把View组件的显示效果置空了，就是相当于我们取消了View的draw方法的执行效果，继续回到我们的dispatchDetachedFromWindow方法，在执行了mView.dispatchDetachedFromWindow()方法之后，又调用了mView = null;方法，这里设置mView为空，这样我们有取消了View的meature和layouot的执行效果。 这样经过一系列的操作之后我们的Dialog的取消绘制流程就结束了，现在我们来看一下Activity的取消绘制流程。还记得我们“Activity的销毁流程”么？可参考：android源码解析之（十五）–&gt;Activity销毁流程当我们调用activity的finish方法的时候回调用ActivityThread的handleDestroyActivity方法，我们来看一下这个方法的实现： 123456private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... wm.removeViewImmediate(v); ... } 可以看到这里调用了这里调用了wm.removeViewImmediate方法，这个方法不就是我们刚刚分析Dialog销毁绘制流程的起始方法么？以后的逻辑都是详细的，这样我们就实现了Activity的取消绘制流程。 总结： 窗口的取消绘制流程是相似的，包括Activity和Dialog等； 通过调用WindowManager.removeViewImmediate方法，开始执行Window窗口的取消绘制流程； Window窗口的取消绘制流程，通过清空bitma撤销draw的执行效果，通过置空View撤销meature和layout的执行效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程","link":"/2020/09/11/Dialog%E5%8F%96%E6%B6%88%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"10 Launcher启动流程","text":"Launcher程序就是我们平时看到的桌面程序，它其实也是一个android应用程序，只不过这个应用程序是系统默认第一个启动的应用程序，这里我们就简单的分析一下Launcher应用的启动流程。 不同的手机厂商定制android操作系统的时候都会更改Launcher的源代码，我们这里以android23的源码为例大致的分析一下Launcher的启动流程。 通过上一篇文章，我们知道SystemServer进程主要用于启动系统的各种服务，二者其中就包含了负责启动Launcher的服务，LauncherAppService。具体关于SystenServer的启动流程可以参见： android源码解析之（九）–&gt;SystemServer进程启动流程 在SystemServer进程的启动过程中会调用其main静态方法，开始执行整个SystemServer的启动流程，在其中通过调用三个内部方法分别启动boot service、core service和other service。在调用startOtherService方法中就会通过调用mActivityManagerService.systemReady()方法，那么我们看一下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130// We now tell the activity manager it is okay to run third party // code. It will call back into us once it has gotten to the state // where third party code can really run (but before it has actually // started launching the initial applications), for us to complete our // initialization. mActivityManagerService.systemReady(new Runnable() { @Override public void run() { Slog.i(TAG, &quot;Making services ready&quot;); mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); try { mActivityManagerService.startObservingNativeCrashes(); } catch (Throwable e) { reportWtf(&quot;observing native crashes&quot;, e); } Slog.i(TAG, &quot;WebViewFactory preparation&quot;); WebViewFactory.prepareWebViewInSystemServer(); try { startSystemUi(context); } catch (Throwable e) { reportWtf(&quot;starting System UI&quot;, e); } try { if (networkScoreF != null) networkScoreF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Score Service ready&quot;, e); } try { if (networkManagementF != null) networkManagementF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Managment Service ready&quot;, e); } try { if (networkStatsF != null) networkStatsF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Stats Service ready&quot;, e); } try { if (networkPolicyF != null) networkPolicyF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Network Policy Service ready&quot;, e); } try { if (connectivityF != null) connectivityF.systemReady(); } catch (Throwable e) { reportWtf(&quot;making Connectivity Service ready&quot;, e); } try { if (audioServiceF != null) audioServiceF.systemReady(); } catch (Throwable e) { reportWtf(&quot;Notifying AudioService running&quot;, e); } Watchdog.getInstance().start(); // It is now okay to let the various system services start their // third party code... mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); try { if (wallpaperF != null) wallpaperF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying WallpaperService running&quot;, e); } try { if (immF != null) immF.systemRunning(statusBarF); } catch (Throwable e) { reportWtf(&quot;Notifying InputMethodService running&quot;, e); } try { if (locationF != null) locationF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying Location Service running&quot;, e); } try { if (countryDetectorF != null) countryDetectorF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying CountryDetectorService running&quot;, e); } try { if (networkTimeUpdaterF != null) networkTimeUpdaterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying NetworkTimeService running&quot;, e); } try { if (commonTimeMgmtServiceF != null) { commonTimeMgmtServiceF.systemRunning(); } } catch (Throwable e) { reportWtf(&quot;Notifying CommonTimeManagementService running&quot;, e); } try { if (textServiceManagerServiceF != null) textServiceManagerServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TextServicesManagerService running&quot;, e); } try { if (atlasF != null) atlasF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying AssetAtlasService running&quot;, e); } try { // TODO(BT) Pass parameter to input manager if (inputManagerF != null) inputManagerF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying InputManagerService running&quot;, e); } try { if (telephonyRegistryF != null) telephonyRegistryF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying TelephonyRegistry running&quot;, e); } try { if (mediaRouterF != null) mediaRouterF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MediaRouterService running&quot;, e); } try { if (mmsServiceF != null) mmsServiceF.systemRunning(); } catch (Throwable e) { reportWtf(&quot;Notifying MmsService running&quot;, e); } } });可以发现这个方法传递了一个Runnable参数，里面执行了各种其他服务的systemReady方法，这里不是我们关注的重点，我们看一下在ActivityManagerService中systemReady方法的具体实现，方法体比较长，我就不在这里贴出代码了，主要的逻辑就是做一些ActivityManagerService的ready操作 1234567public void systemReady(final Runnable goingCallback) { ... // Start up initial activity. mBooting = true; startHomeActivityLocked(mCurrentUserId, &quot;systemReady&quot;); ... } 重点是在这个方法体中调用了startHomeActivityLocked方法，看其名字就是说开始执行启动homeActivity的操作，好了，既然如此，我们再看一下startHomeActivityLocked的具体实现： 12345678910111213141516171819202122232425262728boolean startHomeActivityLocked(int userId, String reason) { if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) { // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don't try to start anything. return false; } Intent intent = getHomeIntent(); ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) { intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); // Don't do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) { intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); mStackSupervisor.startHomeActivity(intent, aInfo, reason); } } return true; } 首先是调用getHomeIntent()方法，看一下getHomeIntent是如何实现构造Intent对象的： 12345678Intent getHomeIntent() { Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) { intent.addCategory(Intent.CATEGORY_HOME); } return intent; } 可以发现，启动Launcher的Intent对象中添加了Intent.CATEGORY_HOME常量，这个其实是一个launcher的标志，一般系统的启动页面Activity都会在androidmanifest.xml中配置这个标志。比如我们在github中的android launcher源码中查看其androidmanifest.xml文件：可以发现其Activity的定义intentfilter中就是定义了这样的category。不同的手机厂商可能会修改Launcher的源码，但是这个category一般是不会更改的。 继续回到我们的startHomeActivityLocked方法，我们发现经过一系列的判断逻辑之后最后调用了mStackSupervisor.startHomeActivity方法，然后我们可以查看一下该方法的具体实现逻辑： 12345678910111213141516void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) { moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); startActivityLocked(null /* caller */, intent, null /* resolvedType */, aInfo, null /* voiceSession */, null /* voiceInteractor */, null /* resultTo */, null /* resultWho */, 0 /* requestCode */, 0 /* callingPid */, 0 /* callingUid */, null /* callingPackage */, 0 /* realCallingPid */, 0 /* realCallingUid */, 0 /* startFlags */, null /* options */, false /* ignoreTargetSecurity */, false /* componentSpecified */, null /* outActivity */, null /* container */, null /* inTask */); if (inResumeTopActivity) { // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. scheduleResumeTopActivities(); } } 发现其调用的是scheduleResumeTopActivities()方法，这个方法其实是关于Activity的启动流程的逻辑了，这里我们不在详细的说明，关于Activity的启动流程我们在下面的文章中会介绍。 因为我们的Launcher启动的Intent是一个隐士的Intent，所以我们会启动在androidmanifest.xml中配置了相同catogory的activity，android M中配置的这个catogory就是LauncherActivity。 LauncherActivity继承与ListActivity，我们看一下其Layout布局文件： 12345678910111213141516171819202122&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;ListView android:id=&quot;@android:id/list&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;TextView android:id=&quot;@android:id/empty&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center&quot; android:text=&quot;@string/activity_list_empty&quot; android:visibility=&quot;gone&quot; android:textAppearance=&quot;?android:attr/textAppearanceMedium&quot; /&gt;&lt;/FrameLayout&gt; 可以看到我们现实的桌面其实就是一个ListView控件，然后看一下其onCreate方法： 12345678910111213141516171819202122232425262728@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPackageManager = getPackageManager(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS); setProgressBarIndeterminateVisibility(true); } onSetContentView(); mIconResizer = new IconResizer(); mIntent = new Intent(getTargetIntent()); mIntent.setComponent(null); mAdapter = new ActivityAdapter(mIconResizer); setListAdapter(mAdapter); getListView().setTextFilterEnabled(true); updateAlertTitle(); updateButtonText(); if (!mPackageManager.hasSystemFeature(PackageManager.FEATURE_WATCH)) { setProgressBarIndeterminateVisibility(false); } } 可以看到在LauncherActivity的onCreate方法中初始化了一个PackageManager，其主要作用就是从中查询出系统所有已经安装的应用列表，应用包名，应用图标等信息。然后将这些信息注入到Adapter中，这样就可以将系统应用图标和名称显示出来了。在系统的回调方法onListItemClick中 12345@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); } 这也就是为什么我们点击了某一个应用图标之后可以启动某一项应用的原因了，我们看一下这里的intentForPosition是如何实现的。 1234protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); } 这里又调用了adapter的intentForPosition方法： 12345678910111213public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以看到由于adapter的每一项中都保存了应用的包名可启动Activity名称，所以这里在初始化Intent的时候，直接将这些信息注入到Intent中，然后调用startActivity，就将这些应用启动了（关于startActivity是如何启动的下面的文章中我将介绍）。 总结： Launcher的启动流程 Zygote进程 –&gt; SystemServer进程 –&gt; startOtherService方法 –&gt; ActivityManagerService的systemReady方法 –&gt; startHomeActivityLocked方法 –&gt; ActivityStackSupervisor的startHomeActivity方法 –&gt; 执行Activity的启动逻辑，执行scheduleResumeTopActivities()方法。。。。 因为是隐士的启动Activity，所以启动的Activity就是在AndroidManifest.xml中配置catogery的值为： 1public static final String CATEGORY_HOME = &quot;android.intent.category.HOME&quot;; 可以发现android M中在androidManifest.xml中配置了这个catogory的activity是LauncherActivity，所以我们就可以将这个Launcher启动起来了 LauncherActivity中是以ListView来显示我们的应用图标列表的，并且为每个Item保存了应用的包名和启动Activity类名，这样点击某一项应用图标的时候就可以根据应用包名和启动Activity名称启动我们的App了。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程","link":"/2020/09/11/Launcher%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"MacOS快捷键说明","text":"您可以按下某些组合键来实现通常需要鼠标、触控板或其他输入设备才能完成的操作。 要使用键盘快捷键，请按住一个或多个修饰键，然后按快捷键的最后一个键。例如，要使用 Command-C（拷贝），请按住 Command 键并按 C 键，然后同时松开这两个键。Mac 菜单和键盘通常对某些按键使用符号，其中包括以下修饰键： Command（或 Cmd）⌘ Shift ⇧ Option（或 Alt）⌥ Control（或 Ctrl）⌃ Caps Lock ⇪ Fn 在 Windows PC 专用键盘上，请用 Alt 键代替 Option 键，用 Windows 标志键代替 Command 键。Apple 键盘上的某些按键具有特殊符号和功能，例如显示屏亮度 、键盘亮度 、调度中心等。如果您的键盘上没有这些功能，您也许可以通过创建自己的键盘快捷键来实现其中的一些功能。要将这些键用作 F1、F2、F3 或其他标准功能键，请将它们与 Fn 键组合使用。 剪切、拷贝、粘贴和其他常用快捷键 Command-X：剪切所选项并拷贝到剪贴板。 Command-C：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。 Command-V：将剪贴板的内容粘贴到当前文稿或应用中。这同样适用于“访达”中的文件。 Command-Z：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些应用中，您可以撤销和重做多个命令。 Command-A：全选各项。 Command-F：查找文稿中的项目或打开“查找”窗口。 Command-G：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。 Command-H：隐藏最前面的应用的窗口。要查看最前面的应用但隐藏所有其他应用，请按 Option-Command-H。 Command-M：将最前面的窗口最小化至“程序坞”。要最小化最前面的应用的所有窗口，请按 Option-Command-M。 Command-O：打开所选项，或打开一个对话框以选择要打开的文件。 Command-P：打印当前文稿。 Command-S：存储当前文稿。 Command-T：打开新标签页。 Command-W：关闭最前面的窗口。要关闭应用的所有窗口，请按下 Option-Command-W。 Option-Command-Esc：强制退出应用。 Command–空格键：显示或隐藏“聚焦”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您使用多个输入源以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何更改冲突的键盘快捷键。） Control-Command–空格键：显示字符检视器，您可以从中选择表情符号和其他符号。 Control-Command-F：全屏使用应用（如果应用支持）。 空格键：使用快速查看来预览所选项。 Command-Tab：在打开的应用中切换到下一个最近使用的应用。 Shift-Command-5：在 macOS Mojave 中，拍摄屏幕快照或录制屏幕。在更早的 macOS 版本中，请使用 Shift-Command-3 或 Shift-Command-4 来拍摄屏幕快照。进一步了解屏幕快照。 Shift-Command-N：在“访达”中创建一个新文件夹。 Command-逗号 (,)：打开最前面的应用的偏好设置。 睡眠、退出登录和关机快捷键在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样可以避免您无意中启用快捷键。 电源按钮：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住则会强制您的 Mac 关机。 Option–Command–电源按钮*或 Option–Command–Media Eject（Option–Command–介质推出键）：将您的 Mac 置于睡眠状态。 Control–Shift–电源按钮*或 Control–Shift–Media Eject（Control–Shift–介质推出键）：将显示器置于睡眠状态。 Control–电源按钮*或 Control–Media Eject（Control–介质推出键）：显示一个对话框，询问您是要重新启动、睡眠还是关机。 Control–Command–Power 电源按钮：*强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。 Control–Command–Media Eject（Control–Command–介质推出键）：退出所有应用，然后重新启动您的 Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Control–Option-Command–电源按钮*或 Control–Option–Command–Media Eject（Control–Option–Command–介质推出键）：退出所有应用，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。 Shift–Command–Q：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。 * 不适用于触控 ID 传感器。 访达和系统快捷键 Command-D：复制所选文件。 Command-E：推出所选磁盘或宗卷。 Command-F：在“访达”窗口中开始“聚焦”搜索。 Command-I：显示所选文件的“显示简介”窗口。 Command-R：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些应用（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在“软件更新”偏好设置中，再次检查有没有软件更新。 Shift-Command-C：打开“电脑”窗口。 Shift-Command-D：打开“桌面”文件夹。 Shift-Command-F：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。 Shift-Command-G：打开“前往文件夹”窗口。 Shift-Command-H：打开当前 macOS 用户帐户的个人文件夹。 Shift-Command-I：打开 iCloud 云盘。 Shift-Command-K：打开“网络”窗口。 Option-Command-L：打开“下载”文件夹。 Shift-Command-N：新建文件夹。 Shift-Command-O：打开“文稿”文件夹。 Shift-Command-P：在“访达”窗口中显示或隐藏预览面板。 Shift-Command-R：打开“隔空投送”窗口。 Shift-Command-T：显示或隐藏“访达”窗口中的标签页栏。 Ctrl-Shift-Command-T：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本） Shift-Command-U：打开“实用工具”文件夹。 Option-Command-D：显示或隐藏“程序坞”。 Control-Command-T：将所选项添加到边栏（OS X Mavericks 或更高版本）。 Option-Command-P：隐藏或显示“访达”窗口中的路径栏。 Option-Command-S：隐藏或显示“访达”窗口中的边栏。 Command–斜线 (/)：隐藏或显示“访达”窗口中的状态栏。 Command-J：显示“显示”选项。 Command-K：打开“连接服务器”窗口。 Command-L：为所选项制作替身。 Command-N：打开一个新的“访达”窗口。 Option-Command-N：新建智能文件夹。 Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。 Option-Command-T：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。 Option-Command-V：移动：将剪贴板中的文件从原始位置移动到当前位置。 Command-Y：使用“快速查看”预览所选文件。 Option-Command-Y：显示所选文件的快速查看幻灯片显示。 Command-1：以图标方式显示“访达”窗口中的项目。 Command-2：以列表方式显示“访达”窗口中的项目。 Command-3：以分栏方式显示“访达”窗口中的项目。 Command-4：以封面流方式显示“访达”窗口中的项目。 Command–左中括号 ([)：前往上一文件夹。 Command–右中括号 (])：前往下一个文件夹。 Command–上箭头：打开包含当前文件夹的文件夹。 Command–Control–上箭头：在新窗口中打开包含当前文件夹的文件夹。 Command–下箭头：打开所选项。 右箭头：打开所选文件夹。这个快捷键仅在列表视图中有效。 左箭头：关闭所选文件夹。这个快捷键仅在列表视图中有效。 Command-Delete：将所选项移到废纸篓。 Shift-Command-Delete：清倒废纸篓。 Option-Shift-Command-Delete：清倒废纸篓而不显示确认对话框。 Command–调高亮度：打开或关闭目标显示器模式。 Command–调低亮度：当您的 Mac 连接到多台显示器时，打开或关闭视频镜像。 Option–调高亮度：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。 Control–调高亮度或 Control–调低亮度：更改外部显示器的亮度（如果显示器支持）。 Option-Shift–调高亮度或 Option-Shift–调低亮度：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。 Option–“调度中心”：打开“调度中心”偏好设置。 Command–“调度中心”：显示桌面。 Control–下箭头：显示最前面的应用的所有窗口。 Option–调高音量：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。 Option-Shift–调高音量或 Option-Shift–调低音量：以较小的步幅调节音量。 Option–键盘调高亮度：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。 Option-Shift–键盘调高亮度或 Option-Shift–键盘调低亮度：以较小的步幅调节键盘亮度。 连按 Option 键：在单独的窗口中打开项目，然后关闭原始窗口。 连按 Command 键：在单独的标签页或窗口中打开文件夹。 按住 Command 键拖移到另一个宗卷：将拖移的项目移到另一个宗卷，而不是拷贝它。 按住 Option 键拖移：拷贝托移的项目。拖移项目时指针会随之变化。 按住 Option-Command 键拖移：为拖移的项目制作替身。拖移项目时指针会随之变化。 按住 Option 键点按开合三角：打开所选文件夹内的所有文件夹。此快捷键仅在列表视图中有效。 按住 Command 键点按窗口标题：查看包含当前文件夹的文件夹。 了解如何使用 Command 或 Shift 在“访达”中选择多个项目。 点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。 文稿快捷键这些快捷键的行为可能因您使用的应用而异。 Command-B：以粗体显示所选文本，或者打开或关闭粗体显示功能。 Command-I：以斜体显示所选文本，或者打开或关闭斜体显示功能。 Command-K：添加网页链接。 Command-U：对所选文本加下划线，或者打开或关闭加下划线功能。 Command-T：显示或隐藏“字体”窗口。 Command-D：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。 Control-Command-D：显示或隐藏所选字词的定义。 Shift-Command–冒号 (：显示“拼写和语法”窗口。 Command–分号 (;)：查找文稿中拼写错误的字词。 Option-Delete：删除插入点左边的字词。 Control-H：删除插入点左边的字符。也可以使用 Delete 键。 Control-D：删除插入点右边的字符。也可以使用 Fn-Delete。 Fn-Delete：在没有向前删除 键的键盘上向前删除。也可以使用 Control-D。 Control-K：删除插入点与行或段落末尾处之间的文本。 Fn–上箭头：Page Up：向上滚动一页。 Fn–下箭头：Page Down：向下滚动一页。 Fn–左箭头：Home：滚动到文稿开头。 Fn–右箭头：End：滚动到文稿末尾。 Command–上箭头：将插入点移至文稿开头。 Command–下箭头：将插入点移至文稿末尾。 Command–左箭头：将插入点移至当前行的行首。 Command–右箭头：将插入点移至当前行的行尾。 Option–左箭头：将插入点移至上一字词的词首。 Option–右箭头：将插入点移至下一字词的词尾。 Shift-Command–上箭头：选中插入点与文稿开头之间的文本。 Shift-Command–下箭头：选中插入点与文稿末尾之间的文本。 Shift-Command–左箭头：选中插入点与当前行行首之间的文本。 Shift-Command–右箭头：选中插入点与当前行行尾之间的文本。 Shift–上箭头：将文本选择范围扩展到上一行相同水平位置的最近字符处。 Shift–下箭头：将文本选择范围扩展到下一行相同水平位置的最近字符处。 Shift–左箭头：将文本选择范围向左扩展一个字符。 Shift–右箭头：将文本选择范围向右扩展一个字符。 Option–Shift–上箭头：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。 Option–Shift–下箭头：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。 Option–Shift–左箭头：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。 Control–A：移至行或段落的开头。 Control–E：移至行或段落的末尾。 Control–F：向前移动一个字符。 Control–B：向后移动一个字符。 Control–L：将光标或所选内容置于可见区域中央。 Control–P：上移一行。 Control–N：下移一行。 Control–O：在插入点后新插入一行。 Control–T：将插入点后面的字符与插入点前面的字符交换。 Command–左花括号 ({)：左对齐。 Command–右花括号 (})：右对齐。 Shift-Command–竖线 (|)：居中对齐。 Option-Command-F：前往搜索栏。 Option-Command-T：显示或隐藏应用中的工具栏。 Option-Command-C：拷贝样式：将所选项的格式设置拷贝到剪贴板。 Option-Command-V：粘贴样式：将拷贝的样式应用到所选项。 Option-Shift-Command-V：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。 Option-Command-I：显示或隐藏检查器窗口。 Shift-Command-P：页面设置：显示用于选择文稿设置的窗口。 Shift-Command-S：显示“存储为”对话框或复制当前文稿。 Shift-Command-减号 (-)：缩小所选项。 Shift-Command-加号 (+)：放大所选项。Command–等号 (=) 可实现相同的功能。 Shift-Command–问号 (?)：打开“帮助”菜单。 其他快捷键如需了解更多快捷键，请查看应用菜单中显示的快捷键缩写。每个应用都有自己的快捷键，在一个应用中可用的快捷键可能在另一个应用中不可用。 辅助功能快捷键 Safari 浏览器快捷键 聚焦快捷键 启动快捷键 iTunes 快捷键：从 iTunes 菜单栏中选取“帮助”&gt;“键盘快捷键”。 其他快捷键：选取苹果菜单 &gt;“系统偏好设置”，点按“键盘”，然后点按“快捷键”。","link":"/2020/09/11/MacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%AF%B4%E6%98%8E/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; } 在android 中配置 sourceSets { main { jni.srcDirs = [&apos;src/main/jni&apos;, &apos;src/main/jni/&apos;] } } externalNativeBuild { ndkBuild { path &apos;src/main/jni/Android.mk&apos; } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2019/10/11/SerialportManager/"},{"title":"21 PopupWindow加载绘制流程","text":"在前面的几篇文章中我们分析了Activity与Dialog的加载绘制流程，取消绘制流程，相信大家对Android系统的窗口绘制机制有了一个感性的认识了，这篇文章我们将继续分析一下PopupWindow加载绘制流程。 在分析PopupWindow之前，我们将首先说一下什么是PopupWindow？理解一个类最好的方式就是看一下这个类的定义，这里我们摘要了一下Android系统中PopupWindow的类的说明： A popup window that can be used to display an arbitrary view. The popup window is a floating container that appears on top of the current activity. 一个PopupWindow能够被用于展示任意的View，PopupWindow是一个悬浮的容易展示在当前Activity的上面。简单来说PopupWindow就是一个悬浮在Activity之上的窗口，可以用展示任意布局文件。 在说明PopupWindow的加载绘制机制之前，我们还是先写一个简单的例子用于说明一下PopupWindow的简单用法。 1234567891011121314151617181920212223public static View showPopupWindowMenu(Activity mContext, View anchorView, int layoutId) { LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View view = inflater.inflate(layoutId, null); popupWindow = new PopupWindow(view, DisplayUtil.dip2px(mContext, 148), WindowManager.LayoutParams.WRAP_CONTENT); popupWindow.setBackgroundDrawable(mContext.getResources().getDrawable(R.drawable.menu_bg)); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); int[] location = new int[2]; anchorView.getLocationOnScreen(location); popupWindow.setAnimationStyle(R.style.popwin_anim_style); popupWindow.showAtLocation(anchorView, Gravity.NO_GRAVITY, location[0] - popupWindow.getWidth() + anchorView.getWidth() - DisplayUtil.dip2px(mContext, 12), location[1] + anchorView.getHeight() - DisplayUtil.dip2px(mContext, 10)); popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() { @Override public void onDismiss() { popupWindow = null; } }); return view; } 可以看到我们首先通过LayoutInflater对象将布局文件解析到内存中View对象，然后创建了一个PopupWindow对象，可以看到传递了三个参数，一个是View对象，一个是PopupWindow的宽度和高度。 这里就是PopupWindow的初始化流程的开始了，好吧，我们来看一下PopupWindow的构造方法的实现： 123public PopupWindow(View contentView, int width, int height) { this(contentView, width, height, false); }可以看到这里调用了PopupWindow的重载构造方法，好吧，继续看一下这个重载构造方法的实现逻辑： 1234567891011public PopupWindow(View contentView, int width, int height, boolean focusable) { if (contentView != null) { mContext = contentView.getContext(); mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } setContentView(contentView); setWidth(width); setHeight(height); setFocusable(focusable); } 这里首先根据传入的View是否为空做了一下判断，若不为空，则初始化成员变量,Context和mWindowManager，可以发现这里的mContext对象就是传入的View组件中保留的Context对象，这里的mWindowManager是应用进程创建的时候注册的服务本地接口。然后调用了setContentView方法，这里就是为PopupWindow的contentView赋值。然后后面调用的setWidth、setHeight、setFocusable方法都是为PopupWindow的成员变量，width，height，focusable等赋值，这样PopupWindow的构造方法就执行完成了。 我们继续回到我们的例子代码中，在后续的代码中我们调用了：popupWindow.setBackgroundDrawable、popupWindow.setFocusable、PopupWindow.setOutsideTouchable、PopupWindow.setAnimationStyle等方法，初始化了PopupWindow中的相关成员变量，最后我们调用了popupWindow.showAtLocation方法用于展示PopupWindow，这里我们具体看一下showAtLocation的实现逻辑： 123public void showAtLocation(View parent, int gravity, int x, int y) { showAtLocation(parent.getWindowToken(), gravity, x, y); } 可以发现，这里调用了showAtLocation的重载函数，这样我们继续看一下这个重载函数的实现方式： 12345678910111213141516171819202122232425public void showAtLocation(IBinder token, int gravity, int x, int y) { if (isShowing() || mContentView == null) { return; } TransitionManager.endTransitions(mDecorView); unregisterForScrollChanged(); mIsShowing = true; mIsDropdown = false; final WindowManager.LayoutParams p = createPopupLayoutParams(token); preparePopup(p); // Only override the default if some gravity was specified. if (gravity != Gravity.NO_GRAVITY) { p.gravity = gravity; } p.x = x; p.y = y; invokePopup(p); } 可以看到通过调用createPopupLayoutParams方法创造了WindowManager.LayoutParams对象，然后又调用了preparePopup方法，可以看一下preparePopup方法的具体实现： 12345678910111213141516171819202122232425262728293031323334353637private void preparePopup(WindowManager.LayoutParams p) { if (mContentView == null || mContext == null || mWindowManager == null) { throw new IllegalStateException(&quot;You must specify a valid content view by &quot; + &quot;calling setContentView() before attempting to show the popup.&quot;); } // The old decor view may be transitioning out. Make sure it finishes // and cleans up before we try to create another one. if (mDecorView != null) { mDecorView.cancelTransitions(); } // When a background is available, we embed the content view within // another view that owns the background drawable. if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } mDecorView = createDecorView(mBackgroundView); // The background owner should be elevated so that it casts a shadow. mBackgroundView.setElevation(mElevation); // We may wrap that in another view, so we'll need to manually specify // the surface insets. final int surfaceInset = (int) Math.ceil(mBackgroundView.getZ() * 2); p.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset); p.hasManualSurfaceInsets = true; mPopupViewInitialLayoutDirectionInherited = (mContentView.getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT); mPopupWidth = p.width; mPopupHeight = p.height; } preparePopup方法的参数是WindowManager.LayoutParams，然后设置了PopupWindow中的几个比较重要的成员变量，首先看一下mBackgroundView的初始化过程： 123456if (mBackground != null) { mBackgroundView = createBackgroundView(mContentView); mBackgroundView.setBackground(mBackground); } else { mBackgroundView = mContentView; } 可以发现如果我们设置了mBackground变量也就是我们在初始化的时候执行了popupWindow的setBackgound方法，那么我们这里执行的就是if分之，这里看一下createBackgourndView的具体执行逻辑： 12345678910111213141516private PopupBackgroundView createBackgroundView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupBackgroundView backgroundView = new PopupBackgroundView(mContext); final PopupBackgroundView.LayoutParams listParams = new PopupBackgroundView.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, height); backgroundView.addView(contentView, listParams); return backgroundView; } 可以看到，createBackgroundView的执行逻辑就是在参数contentView的外面一层包裹一层PopupBackgroundView，而这里的PopupBackgroundView值我们自定义的FrameLayout的子类，重写了其onCreateDrawableState方法。 继续回到我们的preparePopup方法，这里我们又调用了createDecorView方法初始化mDectorView变量，我们可以看一下createDecorView的具体实现： 12345678910111213141516private PopupDecorView createDecorView(View contentView) { final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams(); final int height; if (layoutParams != null &amp;&amp; layoutParams.height == ViewGroup.LayoutParams.WRAP_CONTENT) { height = ViewGroup.LayoutParams.WRAP_CONTENT; } else { height = ViewGroup.LayoutParams.MATCH_PARENT; } final PopupDecorView decorView = new PopupDecorView(mContext); decorView.addView(contentView, ViewGroup.LayoutParams.MATCH_PARENT, height); decorView.setClipChildren(false); decorView.setClipToPadding(false); return decorView; } 可以发现这里也是给参数contentView外面包裹了一层PopupDecorView，这里的PopupDecorView也是我们自定义的FrameLayout的子类，PopupDecorView的源码比较多，这里就不都贴出来了，这里具体看一下其onTouchEvent方法的实现： 12345678910111213141516@Override public boolean onTouchEvent(MotionEvent event) { final int x = (int) event.getX(); final int y = (int) event.getY(); if ((event.getAction() == MotionEvent.ACTION_DOWN) &amp;&amp; ((x &lt; 0) || (x &gt;= getWidth()) || (y &lt; 0) || (y &gt;= getHeight()))) { dismiss(); return true; } else if (event.getAction() == MotionEvent.ACTION_OUTSIDE) { dismiss(); return true; } else { return super.onTouchEvent(event); } } 可以发现其重写了onTouchEvent时间，这样我们在点击popupWindow外面的时候就会执行pupopWindow的dismiss方法，取消PopupWindow。 好吧，继续回到我们的showAsDropDown方法，在执行完成preparePopup方法之后又调用了invokePopup方法，这里的方法应该就是具体执行PopupWindow的加载与显示逻辑了。这里我们具体看一下其实现逻辑： 12345678910111213141516private void invokePopup(WindowManager.LayoutParams p) { if (mContext != null) { p.packageName = mContext.getPackageName(); } final PopupDecorView decorView = mDecorView; decorView.setFitsSystemWindows(mLayoutInsetDecor); setLayoutDirectionFromAnchor(); mWindowManager.addView(decorView, p); if (mEnterTransition != null) { decorView.requestEnterTransition(mEnterTransition); } } 我们看到这里我们调用了mWindowManager.addView方法，看过我们前面几篇关于Dialog和Activity的加载与现实流程的同学应该知道这里的addView其实是我们布局绘制的流程，这里的mWindowManager是我们在调用PopupWIndow的构造函数的时候初始化的，其调用的是： 123if (mWindowManager == null &amp;&amp; mContentView != null) { mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE); } 而这里的mContext.getSystemService是一个接口其具体的实现是在ContextImpl中实现的，所以这里我们看一下ContextImpl的getSystemService的实现： 1234@Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 好吧，在ContextImpl中的getSystemService方法又调用了SystemServiceRegister中的静态方法getSystemService，这样我们再看看一下在SystemServiceRegister是如何实现的。 1234public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } 这里发现服务对象的获取就是通过一个SYSTEM_SERVICE_FETCHERS的map数据结构获取的，那么这个map对象的数据是何时填充的呢？通过查看源码我们发下在SystemServiceRegister中有一段静态代码主要用于注册本地服务接口，其中关于windowManagerService本地服务的代码如下： 123456registerService(Context.WINDOW_SERVICE, WindowManager.class, new CachedServiceFetcher&lt;WindowManager&gt;() { @Override public WindowManager createService(ContextImpl ctx) { return new WindowManagerImpl(ctx.getDisplay()); }}); 好吧，原来我们通过mContext.getSystemService获取的WindowManager其实际上是一个WindowManagerImpl对象，而我们调用的addView就是WindowManagerImpl的addView方法。 这样就回到了我们前几篇讲解的内容上了，通过调用WindowManagerImpl实现了布局文件的绘制流程。。。。 好了，经过上面的一系列的操作我们分析完了PopupWindow的加载绘制流程，其和Dialog，Activity的加载绘制流程类似，都是通过Window对象控制布局文件的加载与绘制流程。 总结： PopupWindow的界面加载绘制流程也是通过Window对象实现的； PopupWindow内部保存的mWindowManager对象通过ContextImpl中获取，并且取得的是WindowManagerImpl对象； PopupWindow通过为传入的View添加一层包裹的布局，并重写该布局的点击事件，实现点击PopupWindow之外的区域PopupWindow消失的效果； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程","link":"/2020/09/11/PopupWindow%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"22 Toast加载绘制流程","text":"前面我们分析了Activity、Dialog、PopupWindow的加载绘制流程，相信大家对整个Android系统中的窗口绘制流程已经有了一个比较清晰的认识了，这里最后再给大家介绍一下Toast的加载绘制流程。 其实Toast窗口和Activity、Dialog、PopupWindow有一个不太一样的地方，就是Toast窗口是属于系统级别的窗口，他和输入框等类似的，不属于某一个应用，即不属于某一个进程，所以自然而然的，一旦涉及到Toast的加载绘制流程就会涉及到进程间通讯，看过前面系列文章的同学应该知道，Android间的进程间通讯采用的是Android特有的Binder机制，所以Toast的加载绘制流程也会涉及到Binder进程间通讯。 Toast的显示流程其实内部还是通过Window的窗口机制实现加载绘制的，只不过由于是系统级别的窗口，在显示过程中涉及到了进程间通讯等机制。 下面我们来具体看一下Toast窗口的简单使用。 1Toast.makeText(context, msg, Toast.LENGTH_SHORT).show(); 上面的代码是Toast的典型使用方式，通过makeText方法创建出一个Toast对象，然后调用show方法将Toast窗口显示出来。 下面我们来看一下makeText方法的具体实现： 1234567891011121314public static Toast makeText(Context context, CharSequence text, @Duration int duration) { Toast result = new Toast(context); LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; } 方法体不是很长，在makeText方法中，我们首先通过Toast对象的构造方法，创建了一个新的Toast对象，这样我们就先来看一下Toast的构造方法做了哪些事。 12345678public Toast(Context context) { mContext = context; mTN = new TN(); mTN.mY = context.getResources().getDimensionPixelSize( com.android.internal.R.dimen.toast_y_offset); mTN.mGravity = context.getResources().getInteger( com.android.internal.R.integer.config_toastDefaultGravity); }可以看到这里初始化了Toast对象的成员变量mContext和mTN，这里的mContext是一个Context类型的成员变量，那mTN是什么东西呢？ 1private static class TN extends ITransientNotification.Stub 从类的源码定义来看，我们知道TN是一个继承自ITransientNotification.Stub的类，这里我们暂时只用知道他的继承关系就好了，知道其是一个Binder对象，可以用于进程间通讯，然后回到我们的makeText方法，在调用了Toast的构造方法创建了Toast对象之后，我们又通过context.getSystemService方法获取到LayoutInflater，然后通过调用LayoutInflater的inflate方法加载到了Toast的布局文件： 123LayoutInflater inflate = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View v = inflate.inflate(com.android.internal.R.layout.transient_notification, null); 这里我们可以看一下布局文件的具体代码： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:background=&quot;?android:attr/toastFrameBackground&quot;&gt; &lt;TextView android:id=&quot;@android:id/message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textAppearance=&quot;@style/TextAppearance.Toast&quot; android:textColor=&quot;@color/bright_foreground_dark&quot; android:shadowColor=&quot;#BB000000&quot; android:shadowRadius=&quot;2.75&quot; /&gt;&lt;/LinearLayout&gt; 可以发现Toast加载的布局文件只有一个LinearLayout布局，并且只包含一个TextView组件。。。。 然后我们通过调用： 1234567TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message); tv.setText(text); result.mNextView = v; result.mDuration = duration; return result; 初始化了布局文件，Toast的mNextView和mDuration成员变量并返回Toast类型的result对象。这样我们的Toast对象就构造完成了。 然后我们回到我们的Toast.show方法，调用完这个方法之后就准备开始显示Toast窗口了，我们来具体看一下show方法的具体实现： 12345678910111213141516public void show() { if (mNextView == null) { throw new RuntimeException(&quot;setView must have been called&quot;); } INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try { service.enqueueToast(pkg, tn, mDuration); } catch (RemoteException e) { // Empty } } 首先判断我们的mNextView是否为空，为空的话，显示逻辑就无法进行了，所以这里判断如果mNextView为空的话，就直接抛出异常，不在往下执行。。。。 然后我们执行了： 1INotificationManager service = getService(); 这里的INotificationManager是服务器端NotificationManagerService的Binder客户端，我们可以看一下getService方法的实现方式： 1234567static private INotificationManager getService() { if (sService != null) { return sService; } sService = INotificationManager.Stub.asInterface(ServiceManager.getService(&quot;notification&quot;)); return sService; } 这里获取了INotificationManager对象，然后我们调用了service.enqueueToast方法，并传递了package，TN对象，duration等参数，这里实际执行的是NotificationManagerService的内部类的INotificationManager.Stub的enqueueToast方法，而我们的NoticationManagerService是在SystemServer进程中执行的，这里的底层其实是通过Binder机制传输数据的，具体的Binder机制相关知识可自行学习。。 好吧，我们在看一下INotificationManager.Stub的enqueueToast方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Override public void enqueueToast(String pkg, ITransientNotification callback, int duration) { ... synchronized (mToastQueue) { int callingPid = Binder.getCallingPid(); long callingId = Binder.clearCallingIdentity(); try { ToastRecord record; int index = indexOfToastLocked(pkg, callback); // If it's already in the queue, we update it in place, we don't // move it to the end of the queue. if (index &gt;= 0) { record = mToastQueue.get(index); record.update(duration); } else { // Limit the number of toasts that any given package except the android // package can enqueue. Prevents DOS attacks and deals with leaks. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, &quot;Package has already posted &quot; + count + &quot; toasts. Not showing more. Package=&quot; + pkg); return; } } } } record = new ToastRecord(callingPid, pkg, callback, duration); mToastQueue.add(record); index = mToastQueue.size() - 1; keepProcessAliveLocked(callingPid); } // If it's at index 0, it's the current toast. It doesn't matter if it's // new or just been updated. Call back and tell it to show itself. // If the callback fails, this will remove it from the list, so don't // assume that it's valid after this. if (index == 0) { showNextToastLocked(); } } finally { Binder.restoreCallingIdentity(callingId); } } } 可以发现我们首先将我们的ToastRecord（Toast对象在server端的对象）保存到一个List列表mToastQueue中，然后调用了showNextToastLocked方法，这样我们在看一下showNextToastLocked方法的具体实现。 12345678910111213141516171819202122232425void showNextToastLocked() { ToastRecord record = mToastQueue.get(0); while (record != null) { if (DBG) Slog.d(TAG, &quot;Show pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); try { record.callback.show(); scheduleTimeoutLocked(record); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to show notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // remove it from the list and let the process die int index = mToastQueue.indexOf(record); if (index &gt;= 0) { mToastQueue.remove(index); } keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { record = mToastQueue.get(0); } else { record = null; } } } } 这里主要执行了record.callback.show方法，而这里的callback对象就是我们创建Toast对象的时候传递的TN对象，显然的，这了的show方法就是我们的Toast内部类TN的show方法，然后我们调用了scheduleTimeoutLocked方法，这里先看一下scheduleTimeoutLocked方法的实现。 1234567private void scheduleTimeoutLocked(ToastRecord r) { mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); } 可以发现这里发送了一个异步消息，并且这里的异步消息是在duration时间之后发送的，也就是说我们在Toast端传递的duration参数就是这里的message消息delay发送的时间，而我们发送MESSAGE_TIMEOUT异步消息之后最终会被方法handleTimeout执行。 12345678910private void handleTimeout(ToastRecord record) { if (DBG) Slog.d(TAG, &quot;Timeout pkg=&quot; + record.pkg + &quot; callback=&quot; + record.callback); synchronized (mToastQueue) { int index = indexOfToastLocked(record.pkg, record.callback); if (index &gt;= 0) { cancelToastLocked(index); } } } 好吧，方法体里面又调用了cancelToastLocked方法，然后我们看一下cancelToastLocked方法的实现： 12345678910111213141516171819void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, &quot;Object died trying to hide notification &quot; + record.callback + &quot; in package &quot; + record.pkg); // don't worry about this, we're about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() &gt; 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); } } 好吧，这里又是调用了record.callback.hide方法，显然的这里的hide方法和刚刚的show方法是相似的，都是调用的Toast内部类TN的hide方法，所以这里可以看出Toast的显示与隐藏操作都是在Toast内部类TN的show和hide方法实现的，然后我们调用了: 1mToastQueue.remove(index); 清除这个Toast对象，并继续执行showNextToastLocked方法，直到mToastQueue的大小为0。。。 这样关于Toast窗口的显示与隐藏操作都是在Toast内部类TN的show方法和hide方法中，我们先看一下TN内部类的show方法的具体实现： 12345@Override public void show() { if (localLOGV) Log.v(TAG, &quot;SHOW: &quot; + this); mHandler.post(mShow); } 好吧，这里也是发送一个异步消息，我们看一下Runnable类型的mShow的定义。 123456final Runnable mShow = new Runnable() { @Override public void run() { handleShow(); } }; 可以看到再其run方法中调用了handleShow方法，继续看handleShow方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738public void handleShow() { if (localLOGV) Log.v(TAG, &quot;HANDLE SHOW: &quot; + this + &quot; mView=&quot; + mView + &quot; mNextView=&quot; + mNextView); if (mView != mNextView) { // remove the old view if necessary handleHide(); mView = mNextView; Context context = mView.getContext().getApplicationContext(); String packageName = mView.getContext().getOpPackageName(); if (context == null) { context = mView.getContext(); } mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // We can resolve the Gravity here by using the Locale for getting // the layout direction final Configuration config = mView.getContext().getResources().getConfiguration(); final int gravity = Gravity.getAbsoluteGravity(mGravity, config.getLayoutDirection()); mParams.gravity = gravity; if ((gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) { mParams.horizontalWeight = 1.0f; } if ((gravity &amp; Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) { mParams.verticalWeight = 1.0f; } mParams.x = mX; mParams.y = mY; mParams.verticalMargin = mVerticalMargin; mParams.horizontalMargin = mHorizontalMargin; mParams.packageName = packageName; if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } if (localLOGV) Log.v(TAG, &quot;ADD! &quot; + mView + &quot; in &quot; + this); mWM.addView(mView, mParams); trySendAccessibilityEvent(); } } 好吧，在handleShow方法中经过一系列的初始化操作，初始化mWN对象，初始化mView对象，初始化了mParams对象，然后调用了mWM的addView方法，到了这里大家应该就很熟悉了（不熟悉的同学可以看一下Activity的加载绘制流程等文章 android源码解析（十八）–&gt;Activity布局绘制流程&nbsp;&nbsp; android源码解析（十七）–&gt;Activity布局加载流程）通过这个方法就实现了Toast窗口的显示逻辑。 继续看一下TN的hide方法： 12345@Override public void hide() { if (localLOGV) Log.v(TAG, &quot;HIDE: &quot; + this); mHandler.post(mHide); } 好吧，和show方法类似，也是发送了一个异步消息，这里看一下Runnable类型的mHide对象的定义： 12345678final Runnable mHide = new Runnable() { @Override public void run() { handleHide(); // Don't do this in handleHide() because it is also invoked by handleShow() mNextView = null; } }; 可以发现在其run方法中调用了handleHide方法，显然的，与show方法类似，这里的handleHide方法也是执行Toast窗口销毁的逻辑： 1234567891011121314public void handleHide() { if (localLOGV) Log.v(TAG, &quot;HANDLE HIDE: &quot; + this + &quot; mView=&quot; + mView); if (mView != null) { // note: checking parent() just to make sure the view has // been added... i have seen cases where we get here when // the view isn't yet added, so let's try not to crash. if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, &quot;REMOVE! &quot; + mView + &quot; in &quot; + this); mWM.removeView(mView); } mView = null; } } 可以发现，在方法体重调用了mWM.removeView(mView),又是熟悉的代码，通过执行这里的removeView方法，我们可以实现Toast窗口的销毁流程，至此我们就分析完了Toast窗口的显示与销毁流程。 总结： Toast是一个系统窗口，Toast在显示与销毁流程设计到进程间通讯（Binder机制实现） Toast的show方法首先会初始化一个Toast对象，然后将内部对象TN与duration传递给NotificationManagerService，并在NotificationManagerService端维护一个Toast对象列表。 NotificationManagerService接收到Toast的show请求之后，保存Toast对象并回调Toast.TN的show方法具体实现Toast窗口的显示逻辑。 Toast窗口的显示与销毁机制与Activity、Dialog、PopupWIndow都是类似的，都是通过WIndow对象实现的。 NotificationManagerService端在执行show方法执行会发送一个异步消息用于销毁Toast窗口，这个异步消息会在duration时间段之后发出，这样，在设置Toast显示的时间就会被传递到NotificationManagerService端，并在这段时间之后发送异步消息销毁Toast窗口。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程","link":"/2020/09/11/Toast%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"15 activity销毁流程","text":"继续我们的源码解析，上一篇文章我们介绍了Activity的启动流程，一个典型的场景就是Activity a 启动了一个Activity b，他们的生命周期回调方法是：onPause(a) –&gt; onCreate(b) –&gt; onStart(b) –&gt; onResume(b) –&gt; onStop(a)而我们根据源码也验证了这样的生命周期调用序列，那么Activity的销毁流程呢？它的生命周期的调用顺序又是这样的呢？ 这里我们我做一个简单的demo，让一个Activity a启动Activity b，然后在b中调用finish()方法，它们的生命周期执行顺序是： onPause(b)onRestart(a)onStart(a)onResume(a)onStop(b)onDestory(b) 好吧，根据我们测试的生命周期方法的回调过程开始对Activity销毁流程的分析，一般而言当我们需要销毁Activity的时候都会调用其自身的finish方法，所以我们的流程开始是以finish方法开始的。 一：请求销毁当前Activity MyActivity.finish()Activity.finish()ActivityManagerNative.getDefault().finishActivity()ActivityManagerService.finishActivity()ActivityStack.requestFinishActivityLocked()ActivityStack.finishActivityLocked()ActivityStack.startPausingLocked() 首先我们在自己的Activity调用了finish方法，它实际上调用的是Activity的finish方法： 123public void finish() { finish(false);}然后我们可以发现其调用了finish方法的重载方法，并且传递了一个参数值： 123456789101112131415161718192021222324private void finish(boolean finishTask) { if (mParent == null) { int resultCode; Intent resultData; synchronized (this) { resultCode = mResultCode; resultData = mResultData; } if (false) Log.v(TAG, &quot;Finishing self: token=&quot; + mToken); try { if (resultData != null) { resultData.prepareToLeaveProcess(); } if (ActivityManagerNative.getDefault() .finishActivity(mToken, resultCode, resultData, finishTask)) { mFinished = true; } } catch (RemoteException e) { // Empty } } else { mParent.finishFromChild(this); } } 好吧，这个参数值似乎并没什么用。。。这里就不在讨论了，然后调用了ActivityManagerNative.getDefault().finishActivity方法，好吧，根据上一篇文章的介绍，我们知道了ActivityManagerNative是一个Binder对象，这里调用的方法最终会被ActivityManagerService执行，所以这了的finishActivity最终被执行的是ActivityManagerService.finishActivity方法，好吧，我们来看一下ActivityManagerService的finishActivity方法的执行逻辑。。。 123456@Overridepublic final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) { ... res = tr.stack.requestFinishActivityLocked(token, resultCode,resultData, &quot;app-request&quot;, true); ...} 这里我们可以发现，经过一系列逻辑判断之后，最终调用了ActivityStack的requestFinishActivityLocked方法，这里应该就是执行finish Activity的逻辑了。 1234567891011121314final boolean requestFinishActivityLocked(IBinder token, int resultCode, Intent resultData, String reason, boolean oomAdj) { ActivityRecord r = isInStackLocked(token); if (DEBUG_RESULTS || DEBUG_STATES) Slog.v(TAG_STATES, &quot;Finishing activity token=&quot; + token + &quot; r=&quot; + &quot;, result=&quot; + resultCode + &quot;, data=&quot; + resultData + &quot;, reason=&quot; + reason); if (r == null) { return false; } finishActivityLocked(r, resultCode, resultData, reason, oomAdj); return true; } 这个方法体里面又调用了finishActivityLocked方法，那我们继续看一下finishActivityLocked方法的实现： 1234567final boolean finishActivityLocked(ActivityRecord r, int resultCode, Intent resultData, String reason, boolean oomAdj) { ... startPausingLocked(false, false, false, false); ... return false; } 好吧，在这里调用了startPausingLocked方法，看名字应该是开始要执行Activity的onPause方法请求了，然后我们看一下startPausingLocked方法的实现： 123456789101112131415161718final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 这样从应用程序调用finish方法，ActivityManagerService接收请求并执行startPausingLocked方法。 二：执行当前Activity的onPause方法 IApplicationThread.schedulePauseActivity()ActivityThread.schedulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused()ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked() 在方法startPausingLocked中我们调用了：prev.app.thread.schedulePauseActivity这里实际上调用的是IApplicationThread的schedulePauseActivity方法，IApplicationThread也是一个Binder对象，它是ActivityThread中ApplicationThread的Binder client端，所以最终会调用的是ApplicationThread的schedulePauseActivity方法，好吧我们看一下ActivityThread的schedulePauseActivity方法的具体实现： 123456public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges);} 然后调用了ActivityThread的sendMessage方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 然后又回调了sendMessage的重载方法。。 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用mH发送异步消息，然后在mH的handleMessge方法中处理异步消息并调用handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 好吧，这里回调了performPauseActivity方法，上篇文章中我们已经分析过了这段代码： performPauseActivity()Instrumentation.callActivityOnPause()Activity.performPause()Activity.onPause() 这样我们就回调了第一个生命周期方法：onPause。。。 在handlePauseActivity方法中我们调用了ActivityManagerNative.getDefault().activityPaused(token)方法，好吧又是回调ActivityManagerService的方法，这样最终会调用ActivityManagerService的activityPaused方法： 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 这样，我们继续看一下activityPausedLocked方法的实现： 12345final void activityPausedLocked(IBinder token, boolean timeout) { ... completePauseLocked(true); ...} 里面又经过一系列的逻辑判断之后，开始执行completePauseLocked方法： 1234private void completePauseLocked(boolean resumeNext) { ... mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); ... } 这样栈顶Activity的onPause操作就执行完成了，接下来就就是开始执行上一个Activity的onResume操作了。。。 三：执行上一个Activity的onResume操作这样调用了ActivityStackSupervisor.resumeTopActivitiesLocked方法。。，又开始调用这个方法，通过上一篇文章的介绍，我们知道这个方法实际上是执行Activity的初始化，我们看一下其具体的调用过程： ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopInnerLocked()IApplicationThread.scheduleResumeActivity()ActivityThread.scheduleResumeActivity()ActivityThread.sendMessage()ActivityTherad.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.H.handleResumeMessage()Activity.performResume()Activity.performRestart()Instrumentation.callActivityOnRestart()Activity.onRestart()Activity.performStart()Instrumentation.callActivityOnStart()Activity.onStart()Instrumentation.callActivityOnResume()Activity.onResume() 好吧，这个过程其实上一篇文章中已经做了介绍，这里不做过多的分析了，通过这样调用过程我们最终执行了当前栈顶Activity上一个Activity的onRestart方法，onStart方法，onResume方法等，下面我们将调用栈顶Activity的onStop方法，onDestory方法。 四：执行栈顶Activity的销毁操作 Looper.myQueue().addIdleHandler(new Idler())ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.destroyActivityLocked()IApplicationThread.scheduleDestoryActivity()ActivityThread.scheduleDestoryActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleDestoryActivity()ActivityThread.performDestoryActivity()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop()Instrumentation.callActivityOnDestory()Activity.performDestory()Acitivity.onDestory()ActivityManagerNative.getDefault().activityDestoryed()ActivityManagerService.activityDestoryed()ActivityStack.activityDestoryedLocked() 我们在ActivityThread.handleResumeActivity方法中调用了Looper.myQueue().addIdleHandler(new Idler())，下面看一下这个方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 内部有一个queueIdle的回调方法，当它被添加到MessageQueue之后就会回调该方法，我们可以发现在这个方法体中调用了ActivityManagerNative.getDefault.activityIdle方法，通过上一篇文章以及上面的讲解，我们应该知道这了最终调用的是ActivityManagerService.activityIdle方法，好吧，这里看一下activityIdle方法的具体实现： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 可以发现这里又调用了ActivityStackSupervisor.activityIdleInternalLocked方法，然后我们看一下activityIdleInternalLocked方法的具体实现： 12345final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { .... stack.destroyActivityLocked(r, true, &quot;finish-idle&quot;); .... } 可以看到这里调用ActivityStack.destroyActivityLocked方法，可以看一下其具体实现： 12345final boolean destroyActivityLocked(ActivityRecord r, boolean removeFromApp, String reason) { ... r.app.thread.scheduleDestroyActivity(r.appToken, r.finishing, r.configChangeFlags); ... } 好吧，这里又开始执行IApplicationThread.scheduleDestoryActivity方法，上文已经做了说明这里最终调用的是ActivityThread.scheduleDestroyActivity方法，好吧，看一下ActivityThread.scheduleDestryActivity方法的实现： 1234public final void scheduleDestroyActivity(IBinder token, boolean finishing, int configChanges) { sendMessage(H.DESTROY_ACTIVITY, token, finishing ? 1 : 0, configChanges);} 这里有开始执行sendMessage方法，通过一系列的调用sendMessage方法最终调用了handleDestroyActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance); if (r != null) { cleanUpPendingRemoveWindows(r); WindowManager wm = r.activity.getWindowManager(); View v = r.activity.mDecor; if (v != null) { if (r.activity.mVisibleFromServer) { mNumVisibleActivities--; } IBinder wtoken = v.getWindowToken(); if (r.activity.mWindowAdded) { if (r.onlyLocalRequest) { // Hold off on removing this until the new activity's // window is being added. r.mPendingRemoveWindow = v; r.mPendingRemoveWindowManager = wm; } else { wm.removeViewImmediate(v); } } if (wtoken != null &amp;&amp; r.mPendingRemoveWindow == null) { WindowManagerGlobal.getInstance().closeAll(wtoken, r.activity.getClass().getName(), &quot;Activity&quot;); } r.activity.mDecor = null; } if (r.mPendingRemoveWindow == null) { // If we are delaying the removal of the activity window, then // we can't clean up all windows here. Note that we can't do // so later either, which means any windows that aren't closed // by the app will leak. Well we try to warning them a lot // about leaking windows, because that is a bug, so if they are // using this recreate facility then they get to live with leaks. WindowManagerGlobal.getInstance().closeAll(token, r.activity.getClass().getName(), &quot;Activity&quot;); } // Mocked out contexts won't be participating in the normal // process lifecycle, but if we're running with a proper // ApplicationContext we need to have it tear down things // cleanly. Context c = r.activity.getBaseContext(); if (c instanceof ContextImpl) { ((ContextImpl) c).scheduleFinalCleanup( r.activity.getClass().getName(), &quot;Activity&quot;); } } if (finishing) { try { ActivityManagerNative.getDefault().activityDestroyed(token); } catch (RemoteException ex) { // If the system process has died, it's game over for everyone. } } mSomeActivitiesChanged = true; } 可以看到这里调用了performDestroyActivity方法，用来执行Avtivity的onDestroy方法： 12345678private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) { ... r.activity.performStop(); ... mInstrumentation.callActivityOnDestroy(r.activity); ... } 然后调用了Activity.performStop()方法，查看performStop方法： 12345final void performStop() { ... mInstrumentation.callActivityOnStop(this); ...} 然后调用了Instrumentation.callActivityOnStop()方法： 123public void callActivityOnStop(Activity activity) { activity.onStop(); } 好吧，终于调用了Activity的onStop方法。。。 我们继续看一下Instrumentation.callActivityOnDestroy()。。。。又是通过Instrumentation来调用Activity的onDestroy方法： 12345public void callActivityOnDestroy(Activity activity) { ... activity.performDestroy(); ...} 然后看一下Activity的performDestroy()方法的实现： 12345678910final void performDestroy() { mDestroyed = true; mWindow.destroy(); mFragments.dispatchDestroy(); onDestroy(); mFragments.doLoaderDestroy(); if (mVoiceInteractor != null) { mVoiceInteractor.detachActivity(); } } O(∩_∩)O哈哈~，终于回调了Activity的onDestroy方法。。。。 总结： Activity的销毁流程是从finish方法开始的 Activity销毁过程是：onPause –&gt; onRestart –&gt; onStart –&gt; onResume –&gt; onStop –&gt; onDestroy Activity的销毁流程是ActivityThread与ActivityManagerService相互配合销毁的 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程","link":"/2020/09/11/activity%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B/"},{"title":"Android异步任务AsyncTask","text":"android的异步任务体系中还有一个非常重要的操作类：AsyncTask，其内部主要使用的是java的线程池和Handler来实现异步任务以及与UI线程的交互。本文主要解析AsyncTask的的使用与源码。 首先我们来看一下AsyncTask的基本使用： 12345678910111213141516171819class MAsyncTask extends AsyncTask&lt;Integer, Integer, Integer&gt; { @Override protected void onPreExecute() { super.onPreExecute(); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } @Override protected void onPostExecute(Integer i) { super.onPostExecute(i); Log.i(&quot;TAG&quot;, &quot;onPostExecute...(开始执行后台任务之后)&quot;); } @Override protected Integer doInBackground(Integer... params) { Log.i(TAG, &quot;doInBackground...(开始执行后台任务)&quot;); return 0; } } 我们定义了自己的MAsyncTask并继承自AsyncTask；并重写了其中的是哪个回调方法：onPreExecute()，onPostExecute（），doInBackground();然后开始调用异步任务： 1new MAsyncTask().execute(); 好了，下面我们开始分析异步任务的执行过程，首先查看一下异步任务的构造方法： 1234567891011121314151617181920212223242526272829303132/** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() { mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; } 咋一看AsyncTask的构造方法代码量还是比较多的，但是仔细一看其实这里面只是初始化了两个成员变量：mWorker和mFuture他们分别是：WorkerRunnable和FutureTask，熟悉java的童鞋应该知道这两个类其实是java里面线程池先关的概念。其具体用法大家可以在网上查询，这里具体的细节不在表述，重点是对异步任务整体流程的把握。 总结：异步任务的构造方法主要用于初始化线程池先关的成员变量。 接下来我们看一下execute方法： 1234@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { return executeOnExecutor(sDefaultExecutor, params); } 这里发现该方法中添加一个@MainThread的注解，通过该注解，可以知道我们在执行AsyncTask的execute方法时，只能在主线程中执行，这里可以实验一下： 12345678new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); new MAsyncTask().execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); 然后执行，但是并没有什么区别，程序还是可以正常执行，我的手机的Android系统是Android5.0，具体原因尚未找到，欢迎有知道答案的童鞋可以相互沟通哈。但是这里需要主要的一个问题是：onPreExecute方法是与开始执行的execute方法是在同一个线程中的，所以如果在子线程中执行execute方法，一定要确保onPreExecute方法不执行刷新UI的方法，否则： 123456@Override protected void onPreExecute() { super.onPreExecute(); title.setText(&quot;########&quot;); Log.i(TAG, &quot;onPreExecute...(开始执行后台任务之前)&quot;); } 12345678910111213141516171819Process: com.example.aaron.helloworld, PID: 659 android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6981) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:1034) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.view.View.requestLayout(View.java:17704) at android.widget.RelativeLayout.requestLayout(RelativeLayout.java:380) at android.view.View.requestLayout(View.java:17704) at android.widget.TextView.checkForRelayout(TextView.java:7109) at android.widget.TextView.setText(TextView.java:4082) at android.widget.TextView.setText(TextView.java:3940) at android.widget.TextView.setText(TextView.java:3915) at com.example.aaron.helloworld.MainActivity$MAsyncTask.onPreExecute(MainActivity.java:53) at android.os.AsyncTask.executeOnExecutor(AsyncTask.java:587) at android.os.AsyncTask.execute(AsyncTask.java:535) at com.example.aaron.helloworld.MainActivity$1$1.run(MainActivity.java:40) at java.lang.Thread.run(Thread.java:818) 若在子线程中执行execute方法，那么这时候如果在onPreExecute方法中刷新UI，会报错，即子线程中不能更新UI。 继续看刚才的execute方法，我们可以发现其内部调用了executeOnExecutor方法： 123456789101112131415161718192021222324@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) { if (mStatus != Status.PENDING) { switch (mStatus) { case RUNNING: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task is already running.&quot;); case FINISHED: throw new IllegalStateException(&quot;Cannot execute task:&quot; + &quot; the task has already been executed &quot; + &quot;(a task can be executed only once)&quot;); } } mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; } 可以看到其具体的内部实现方法里：首先判断当前异步任务的状态，其内部保存异步任务状态的成员变量mStatus的默认值为Status.PENDING,所以第一次执行的时候并不抛出这两个异常，那么什么时候回进入这个if判断并抛出异常呢，通过查看源代码可以知道，当我们执行了execute方法之后，如果再次执行就会进入这里的if条件判断并抛出异常，这里可以尝试一下： 123456789101112131415161718192021final MAsyncTask mAsyncTask = new MAsyncTask(); title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { /*MLog.e(&quot;you have clicked the title textview!!!&quot;); Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivityForResult(intent, 101);*/ new Thread(new Runnable() { @Override public void run() { Log.i(&quot;tag&quot;, Thread.currentThread().getId() + &quot;&quot;); mAsyncTask .execute(); } }).start(); Log.i(&quot;tag&quot;, &quot;mainThread:&quot; + Thread.currentThread().getId() + &quot;&quot;); } }); 这里我们可以看到我们定义了一个AsyncTask的对象，并且每次执行点击事件的回调方法都会执行execute方法，当我们点击第一次的时候程序正常执行，但是当我们执行第二次的时候，程序就崩溃了。若这时候第一次执行的异步任务尚未执行完成则会抛出异常： 1Cannot execute task:the task is already running. 若第一次执行的异步任务已经执行完成，则会抛出异常： 1Cannot execute task:the task has already been executed (a task can be executed only once) 继续往下看，在executeOnExecutor中若没有进入异常分之，则将当前异步任务的状态更改为Running，然后回调onPreExecute()方法，这里可以查看一下onPreExecute方法其实是一个空方法，主要就是为了用于我们的回调实现，同时这里也说明了onPreExecute（）方法是与execute方法的执行在同一线程中。 然后将execute方法的参数赋值给mWorker对象那个，最后执行exec.execute(mFuture)方法，并返回自身。 这里我们重点看一下exec.execute(mFuture)的具体实现，这里的exec其实是AsyncTask定义的一个默认的Executor对象： 1private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; 那么，SERIAL_EXECUTOR又是什么东西呢？ 1public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); 继续查看SerialExecutor的具体实现： 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor { final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 可以发现其继承Executor类其内部保存着一个Runnable列表，即任务列表，在刚刚的execute方法中执行的exec.execute(mFuture)方法就是执行的这里的execute方法。这里具体看一下execute方法的实现：1）首先调用的是mTasks的offer方法，即将异步任务保存至任务列表的队尾2）判断mActive对象是不是等于null，第一次运行是null，然后调用scheduleNext()方法3）在scheduleNext()这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。4）在这之后如果再有新的任务被执行时就等待上一个任务执行完毕后才会得到执行，所以说同一时刻只会有一个线程正在执行。5）这里的THREAD_POOL_EXECUTOR其实是一个线程池对象。 然后我们看一下执行过程中mWorker的执行逻辑： 1234567891011mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked Result result = doInBackground(mParams); Binder.flushPendingCommands(); return postResult(result); } }; 可以看到在执行线程池的任务时，我们回调了doInBackground方法，这也就是我们重写AsyncTask时重写doInBackground方法是后台线程的原因。 然后在任务执行完毕之后会回调我们的done方法： 123456789101112131415mFuture = new FutureTask&lt;Result&gt;(mWorker) { @Override protected void done() { try { postResultIfNotInvoked(get()); } catch (InterruptedException e) { android.util.Log.w(LOG_TAG, e); } catch (ExecutionException e) { throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;, e.getCause()); } catch (CancellationException e) { postResultIfNotInvoked(null); } } }; 这里我们具体看一下postResultIfNotInvoked方法： 123456private void postResultIfNotInvoked(Result result) { final boolean wasTaskInvoked = mTaskInvoked.get(); if (!wasTaskInvoked) { postResult(result); } } 其内部还是调用了postResult方法： 1234567private Result postResult(Result result) { @SuppressWarnings(&quot;unchecked&quot;) Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result; } 这里可以看到起调用了内部的Handler对象的sendToTarget方法，发送异步消息，具体handler相关的内容可以参考： android源码解析之（二）–&gt;异步消息机制 追踪代码，可以查看AsyncTask内部定义了一个Handler对象： 1234567891011121314151617181920private static class InternalHandler extends Handler { public InternalHandler() { super(Looper.getMainLooper()); } @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;}) @Override public void handleMessage(Message msg) { AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 可以看到起内部的handleMessage方法，有两个处理逻辑，分别是：更新进入条和执行完成，这里的更新进度的方法就是我们重写AsyncTask方法时重写的更新进度的方法，这里的异步任务完成的消息会调用finish方法： 12345678private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 这里AsyncTask首先会判断当前任务是否被取消，若被取消的话则直接执行取消的方法，否则执行onPostExecute方法，也就是我们重写AsyncTask时需要重写的异步任务完成时回调的方法。 其实整个异步任务的大概流程就是这样子的，其中涉及的知识点比较多，这里总结一下： 异步任务内部使用线程池执行后台任务，使用Handler传递消息； onPreExecute方法主要用于在异步任务执行之前做一些操作，它所在线程与异步任务的execute方法所在的线程一致，这里若需要更新UI等操作，则execute方法不能再子线程中执行。 通过刚刚的源码分析可以知道异步任务一般是顺序执行的，即一个任务执行完成之后才会执行下一个任务。 doInBackground这个方法所在的进程为任务所执行的进程，在这里可以进行一些后台操作。 异步任务执行完成之后会通过一系列的调用操作，最终回调我们的onPostExecute方法 异步任务对象不能执行多次，即不能创建一个对象执行多次execute方法。（通过execute方法的源码可以得知） 所有源码基于android23，中间有什么疏漏欢迎指正。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTask","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1AsyncTask/"},{"title":"7 android之LruCache","text":"android开发过程中经常会用到缓存，现在主流的app中图片等资源的缓存策略一般是分两级，一个是内存级别的缓存，一个是磁盘级别的缓存。 作为android系统的维护者google也开源了其缓存方案，LruCache和DiskLruCache。从android3.1开始LruCache已经作为android源码的一部分维护在android系统中，为了兼容以前的版本android的support-v4包也提供了LruCache的维护，如果App需要兼容到android3.1之前的版本就需要使用support-v4包中的LruCache，如果不需要兼容到android3.1则直接使用android源码中的LruCache即可，这里需要注意的是DiskLruCache并不是android源码的一部分。 在LruCache的源码中，关于LruCache有这样的一段介绍： 1A cache that holds strong references to a limited number of values. Each time a value is accessed, it is moved to the head of a queue. When a value is added to a full cache, the value at the end of that queue is evicted and may become eligible for garbage collection. cache对象通过一个强引用来访问内容。每次当一个item被访问到的时候，这个item就会被移动到一个队列的队首。当一个item被添加到已经满了的队列时，这个队列的队尾的item就会被移除。 其实这个实现的过程就是LruCache的缓存策略，即Lru–&gt;(Least recent used)最少最近使用算法。 下面我们具体看一下LruCache的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319public class LruCache&lt;K, V&gt; { private final LinkedHashMap&lt;K, V&gt; map; /** Size of this cache in units. Not necessarily the number of elements. */ private int size; private int maxSize; private int putCount; private int createCount; private int evictionCount; private int hitCount; private int missCount; /** * @param maxSize for caches that do not override {@link #sizeOf}, this is * the maximum number of entries in the cache. For all other caches, * this is the maximum sum of the sizes of the entries in this cache. */ public LruCache(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); } /** * Sets the size of the cache. * * @param maxSize The new maximum size. */ public void resize(int maxSize) { if (maxSize &lt;= 0) { throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); } synchronized (this) { this.maxSize = maxSize; } trimToSize(maxSize); } /** * Returns the value for {@code key} if it exists in the cache or can be * created by {@code #create}. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } /** * Caches {@code value} for {@code key}. The value is moved to the head of * the queue. * * @return the previous value mapped by {@code key}. */ public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } /** * Remove the eldest entries until the total of remaining entries is at or * below the requested size. * * @param maxSize the maximum size of the cache before returning. May be -1 * to evict even 0-sized elements. */ public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } /** * Removes the entry for {@code key} if it exists. * * @return the previous value mapped by {@code key}. */ public final V remove(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V previous; synchronized (this) { previous = map.remove(key); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, null); } return previous; } /** * Called for entries that have been evicted or removed. This method is * invoked when a value is evicted to make space, removed by a call to * {@link #remove}, or replaced by a call to {@link #put}. The default * implementation does nothing. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * @param evicted true if the entry is being removed to make space, false * if the removal was caused by a {@link #put} or {@link #remove}. * @param newValue the new value for {@code key}, if it exists. If non-null, * this removal was caused by a {@link #put}. Otherwise it was caused by * an eviction or a {@link #remove}. */ protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {} /** * Called after a cache miss to compute a value for the corresponding key. * Returns the computed value or null if no value can be computed. The * default implementation returns null. * * &lt;p&gt;The method is called without synchronization: other threads may * access the cache while this method is executing. * * &lt;p&gt;If a value for {@code key} exists in the cache when this method * returns, the created value will be released with {@link #entryRemoved} * and discarded. This can occur when multiple threads request the same key * at the same time (causing multiple values to be created), or when one * thread calls {@link #put} while another is creating a value for the same * key. */ protected V create(K key) { return null; } private int safeSizeOf(K key, V value) { int result = sizeOf(key, value); if (result &lt; 0) { throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value); } return result; } /** * Returns the size of the entry for {@code key} and {@code value} in * user-defined units. The default implementation returns 1 so that size * is the number of entries and max size is the maximum number of entries. * * &lt;p&gt;An entry's size must not change while it is in the cache. */ protected int sizeOf(K key, V value) { return 1; } /** * Clear the cache, calling {@link #entryRemoved} on each removed entry. */ public final void evictAll() { trimToSize(-1); // -1 will evict 0-sized elements } /** * For caches that do not override {@link #sizeOf}, this returns the number * of entries in the cache. For all other caches, this returns the sum of * the sizes of the entries in this cache. */ public synchronized final int size() { return size; } /** * For caches that do not override {@link #sizeOf}, this returns the maximum * number of entries in the cache. For all other caches, this returns the * maximum sum of the sizes of the entries in this cache. */ public synchronized final int maxSize() { return maxSize; } /** * Returns the number of times {@link #get} returned a value that was * already present in the cache. */ public synchronized final int hitCount() { return hitCount; } /** * Returns the number of times {@link #get} returned null or required a new * value to be created. */ public synchronized final int missCount() { return missCount; } /** * Returns the number of times {@link #create(Object)} returned a value. */ public synchronized final int createCount() { return createCount; } /** * Returns the number of times {@link #put} was called. */ public synchronized final int putCount() { return putCount; } /** * Returns the number of values that have been evicted. */ public synchronized final int evictionCount() { return evictionCount; } /** * Returns a copy of the current contents of the cache, ordered from least * recently accessed to most recently accessed. */ public synchronized final Map&lt;K, V&gt; snapshot() { return new LinkedHashMap&lt;K, V&gt;(map); } @Override public synchronized final String toString() { int accesses = hitCount + missCount; int hitPercent = accesses != 0 ? (100 * hitCount / accesses) : 0; return String.format(&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;, maxSize, hitCount, missCount, hitPercent); }}可以看到LruCache初始化的时候需要使用泛型，一般的我们这样初始化LruCache对象： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 这里我们假设通过String作为key保存bitmap对象，同时需要传递一个int型的maxSize数值，主要用于设置LruCache链表的最大值。 查看其构造方法： 12345678910// 获取应用程序最大可用内存 int maxMemory = (int) Runtime.getRuntime().maxMemory(); int cacheSize = maxMemory / 8; // 设置图片缓存大小为程序最大可用内存的1/8 mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) { @Override protected int sizeOf(String key, Bitmap bitmap) { return bitmap.getByteCount(); } }; 可以看到其主要的是初始化了maxSize和map链表对象。 然后查看put方法： 12345678910111213141516171819202122public final V put(K key, V value) { if (key == null || value == null) { throw new NullPointerException(&quot;key == null || value == null&quot;); } V previous; synchronized (this) { putCount++; size += safeSizeOf(key, value); previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } } if (previous != null) { entryRemoved(false, key, previous, value); } trimToSize(maxSize); return previous; } 需要传递两个参数：K和V，首先做了一下参数的判断，然后定义一个保存前一个Value值得临时变量，让putCount（put执行的次数）自增，让map的size大小自增。需要注意的是这里的 1previous = map.put(key, value); 我们看一下这里的map.put（）的具体实现： 1234567891011121314151617181920212223242526@Override public V put(K key, V value) { if (key == null) { return putValueForNullKey(value); } int hash = Collections.secondaryHash(key); HashMapEntry&lt;K, V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); for (HashMapEntry&lt;K, V&gt; e = tab[index]; e != null; e = e.next) { if (e.hash == hash &amp;&amp; key.equals(e.key)) { preModify(e); V oldValue = e.value; e.value = value; return oldValue; } } // No entry for (non-null) key is present; create one modCount++; if (size++ &gt; threshold) { tab = doubleCapacity(); index = hash &amp; (tab.length - 1); } addNewEntry(key, value, hash, index); return null; } 将Key与Value的值压入Map中，这里判断了一下如果map中已经存在该key，value键值对，则不再压入map，并将Value值返回，否则将该键值对压入Map中，并返回null； 返回继续put方法： 1234previous = map.put(key, value); if (previous != null) { size -= safeSizeOf(key, previous); } 可以看到这里我们判断map.put方法的返回值是否为空，如果不为空的话，则说明我们刚刚并没有将我么你的键值对压入Map中，所以这里的size需要自减； 然后下面： 123if (previous != null) { entryRemoved(false, key, previous, value); } 这里判断previous是否为空，如果不为空的话，调用了一个空的实现方法entryRemoved()，也就是说我们可以实现自己的LruCache并在添加缓存的时候若存在该缓存可以重写这个方法； 下面调用了trimToSize(maxSize)方法： 1234567891011121314151617181920212223242526272829public void trimToSize(int maxSize) { while (true) { K key; V value; synchronized (this) { if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) { throw new IllegalStateException(getClass().getName() + &quot;.sizeOf() is reporting inconsistent results!&quot;); } if (size &lt;= maxSize) { break; } Map.Entry&lt;K, V&gt; toEvict = map.eldest(); if (toEvict == null) { break; } key = toEvict.getKey(); value = toEvict.getValue(); map.remove(key); size -= safeSizeOf(key, value); evictionCount++; } entryRemoved(true, key, value, null); } } 该方法主要是判断该Map的大小是否已经达到阙值，若达到，则将Map队尾的元素（最不常使用的元素）remove掉。 总结：LruCache put方法，将键值对压入Map数据结构中，若这是Map的大小已经大于LruCache中定义的最大值，则将Map中最早压入的元素remove掉； 查看get方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public final V get(K key) { if (key == null) { throw new NullPointerException(&quot;key == null&quot;); } V mapValue; synchronized (this) { mapValue = map.get(key); if (mapValue != null) { hitCount++; return mapValue; } missCount++; } /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ V createdValue = create(key); if (createdValue == null) { return null; } synchronized (this) { createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) { // There was a conflict so undo that last put map.put(key, mapValue); } else { size += safeSizeOf(key, createdValue); } } if (mapValue != null) { entryRemoved(false, key, createdValue, mapValue); return mapValue; } else { trimToSize(maxSize); return createdValue; } } 可以看到参数值为Key，简单的理解就是通过key值从map中取出Value值。具体来说，判断map中是否含有key值value值，若存在，则hitCount（击中元素数量）自增，并返回Value值，若没有击中，则执行create(key)方法，这里看到create方法是一个空的实现方法，返回值为null，所以我们可以重写该方法，在调用get（key）的时候若没有找到value值，则自动创建一个value值并压入map中。 总结： LruCache，内部使用Map保存内存级别的缓存 LruCache使用泛型可以设配各种类型 LruCache使用了Lru算法保存数据（最短最少使用least recent use） LruCache只用使用put和get方法压入数据和取出数据 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Log","link":"/2020/09/11/android%E4%B9%8BLruCache/"},{"title":"25 onLowMemory执行流程","text":"上篇文章中我们分析了Activity的onSaveInstanceState方法执行时机，知道了Activity在一般情况下，若只是执行onPause方法则不会执行onSaveInstanceState方法，而一旦执行了onStop方法就会执行onSaveInstanceState方法，具体的信息，可以参见onSaveInstanceState方法执行时机：android源码解析（二十四）–&gt;onSaveInstanceState执行时机 这篇文章中同样的我们分析一下Actvity（当然不只是Activity，同样包含Servier，ContentProvider，Application等）的另一个内部方法：onLowMemory。该方法主要用于当前系统可用内存比较低的时候回调使用。 这里简单介绍一下Android系统的内存分配机制。Android系统中一个个的App都是一个个不同的应用进程，拥有各自的JVM与运行时，每个App的进程可使用的内存大小都是固定的，当系统中App打开数量过多时，就会使Android系统的可用内存降低，对于当前正在使用的App而言，可能还需要继续申请系统内存，而我们的剩余系统内存已经不足以被当前App所申请了，这时候系统会自动的清理那些后台进程，进而释放出可用内存用于前台进程的使用，当然这里系统清理后台进程的算法不是我们讨论的重点。这里我们只是大概的分析Android系统回调Activity的onLowMemory方法的流程。 通过前面关于Activity的启动流程分析我们知道ActivityManagerService是整个Android系统的管理中枢，负责Activity，Servier等四大组件的启动与销毁等工作，同样的对于应用进程的管理工作也是在ActivityMaangerServier中完成的，我们知道android系统中有两个比较重要的进程Zygote进程和SystemServer进程，其中Zygote进程是整个Android系统的根进程，其他所有的进程都是通过Zygote进程fork出来的。而SystemServer进程则用于运行各种服务，为其他的应用进程提供各种功能接口等，在前面我们分析过SystemServer进程的启动流程（参考： android源码解析之（九）–&gt;SystemServer进程启动流程）其中在SystemServer的startBootService方法中我们调用了： 12// Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); 方法，看其注释说明，说的是为System进程初始化Application实例，这里我们可以看一下该方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(&quot;meminfo&quot;, new MemBinder(this)); ServiceManager.addService(&quot;gfxinfo&quot;, new GraphicsBinder(this)); ServiceManager.addService(&quot;dbinfo&quot;, new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(&quot;cpuinfo&quot;, new CpuBinder(this)); } ServiceManager.addService(&quot;permission&quot;, new PermissionController(this)); ServiceManager.addService(&quot;processinfo&quot;, new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) { ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) { mPidsSelfLocked.put(app.pid, app); } updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } } catch (PackageManager.NameNotFoundException e) { throw new RuntimeException( &quot;Unable to find android system package&quot;, e); } } 这里简单介绍一下ServierManager是一个管理服务的服务，而其addServier方法就是注册各种服务（服务注册到JNI层，具体的关于是如何注册到JNI层的这里暂不做过多的解释）。可以发现在方法体中我们注册了名称为：memInfo的服务MemBinder，MemBinder是一个Binder类型的服务，主要用于检测系统内存情况，这里可以看一下其具体的实现逻辑： 12345678910111213141516171819static class MemBinder extends Binder { ActivityManagerService mActivityManagerService; MemBinder(ActivityManagerService activityManagerService) { mActivityManagerService = activityManagerService; } @Override protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) { if (mActivityManagerService.checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) { pw.println(&quot;Permission Denial: can't dump meminfo from from pid=&quot; + Binder.getCallingPid() + &quot;, uid=&quot; + Binder.getCallingUid() + &quot; without permission &quot; + android.Manifest.permission.DUMP); return; } mActivityManagerService.dumpApplicationMemoryUsage(fd, pw, &quot; &quot;, args, false, null); } }查看源码，我们可以发现MemBinder类继承于Binder类也就是说其实一个Binder类型的服务，并且有一个成员方法dump，该方法主要用于执行shell命令，当系统可用内存比较低的时候就会执行了该方法，然后回调到ActivityManagerService中的killAllBackground方法，下面我们重点看一下killAllBackground方法的具体实现： 123456789@Override public void killAllBackgroundProcesses() { ... doLowMemReportIfNeededLocked(null); ... } finally { Binder.restoreCallingIdentity(callingId); } } 可以看到这个方法体中会执行doLowMemReportIfNeededLocked方法，该方法是做什么的呢?我们继续看一下doLowMemReportIfNeededLoced方法的实现： 12345final void doLowMemReportIfNeededLocked(ProcessRecord dyingProc) { ... scheduleAppGcsLocked(); ... } 好吧，在这个方法中我们又调用了scheduleAppGcsLocked方法，这样我们就继续看一下scheduleAppGcsLocked方法的实现逻辑： 12345678910111213141516171819/** * Schedule the execution of all pending app GCs. */ final void scheduleAppGcsLocked() { mHandler.removeMessages(GC_BACKGROUND_PROCESSES_MSG); if (mProcessesToGc.size() &gt; 0) { // Schedule a GC for the time to the next process. ProcessRecord proc = mProcessesToGc.get(0); Message msg = mHandler.obtainMessage(GC_BACKGROUND_PROCESSES_MSG); long when = proc.lastRequestedGc + GC_MIN_INTERVAL; long now = SystemClock.uptimeMillis(); if (when &lt; (now+GC_TIMEOUT)) { when = now + GC_TIMEOUT; } mHandler.sendMessageAtTime(msg, when); } } 可以发现这里执行的逻辑就是通过mHandler发送一个msg.what为GC_BACKGROUND_PROCESSES_MSG的异步消息，这样消息体最终会被mHandler的handleMessage方法所执行，继续看一下mHandler的handleMessage方法的执行逻辑： 12345case GC_BACKGROUND_PROCESSES_MSG: { synchronized (ActivityManagerService.this) { performAppGcsIfAppropriateLocked(); } } break; 在mHandler的handleMessage方法中，首先会判断msg的what是否为GC_BACKGROUND_PROCESSES_MSG，然后会执行performAppGcsIfAppropriateLocked方法，这样我们继续看一下performAppGcsIfAppropriateLocked方法的实现： 1234567891011/** * If all looks good, perform GCs on all processes waiting for them. */ final void performAppGcsIfAppropriateLocked() { if (canGcNowLocked()) { performAppGcsLocked(); return; } // Still not idle, wait some more. scheduleAppGcsLocked(); } 可以发现这里首先判断是否能够执行gc操作，若不能继续执行上面的scheduleAppGcsLocked方法，然后继续执行发送异步消息的逻辑，直到变量canGcNowLocked为true，并执行performAppGcsLocked方法，然后return掉，这样我们继续跟踪代码，看一下performAppGcsLocked方法的执行逻辑： 1234567891011121314151617181920212223242526272829303132/** * Perform GCs on all processes that are waiting for it, but only * if things are idle. */ final void performAppGcsLocked() { final int N = mProcessesToGc.size(); if (N &lt;= 0) { return; } if (canGcNowLocked()) { while (mProcessesToGc.size() &gt; 0) { ProcessRecord proc = mProcessesToGc.remove(0); if (proc.curRawAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || proc.reportLowMemory) { if ((proc.lastRequestedGc+GC_MIN_INTERVAL) &lt;= SystemClock.uptimeMillis()) { // To avoid spamming the system, we will GC processes one // at a time, waiting a few seconds between each. performAppGcLocked(proc); scheduleAppGcsLocked(); return; } else { // It hasn't been long enough since we last GCed this // process... put it in the list to wait for its time. addProcessToGcListLocked(proc); break; } } } scheduleAppGcsLocked(); } } 可以发现该方法经过一系列的逻辑判断之后会执行performAppGcLocked方法，我们继续看一下该方法的实现： 123456789101112131415161718/** * Ask a given process to GC right now. */ final void performAppGcLocked(ProcessRecord app) { try { app.lastRequestedGc = SystemClock.uptimeMillis(); if (app.thread != null) { if (app.reportLowMemory) { app.reportLowMemory = false; app.thread.scheduleLowMemory(); } else { app.thread.processInBackground(); } } } catch (Exception e) { // whatever. } } 可以发现最终执行的是app.thread.scheduleLowMemory方法，而这里的app.thread是ActivityThread.ApplicationThread对象，所以这里最终是通过Binder进程间通讯，执行的是ActivityThread.ApplicationThread的scheduleLowMemory方法，好吧让我们看一下ActivityThread.ApplicationThread的scheduleLowMemory方法的实现逻辑… 1234@Override public void scheduleLowMemory() { sendMessage(H.LOW_MEMORY, null); } 在ActivityThread中的scheduleLowMemory方法中并没有执行额外逻辑，而是直接调用了sendMessage方法，继续跟踪方法的执行： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现在sendMessage方法中最终通过一个Handler类型的mH成员变量发送一个异步消息，这样异步消息最终会被mH的handleMessage方法执行。。。。，经过查看源代码我们知道在mH的handleMessage方法中最终调用的是handleLowMemory方法： 12345678910111213141516171819202122final void handleLowMemory() { ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(true, null); final int N = callbacks.size(); for (int i=0; i&lt;N; i++) { callbacks.get(i).onLowMemory(); } // Ask SQLite to free up as much memory as it can, mostly from its page caches. if (Process.myUid() != Process.SYSTEM_UID) { int sqliteReleased = SQLiteDatabase.releaseMemory(); EventLog.writeEvent(SQLITE_MEM_RELEASED_EVENT_LOG_TAG, sqliteReleased); } // Ask graphics to free up as much as possible (font/image caches) Canvas.freeCaches(); // Ask text layout engine to free also as much as possible Canvas.freeTextLayoutCaches(); BinderInternal.forceGc(&quot;mem&quot;); } 可以发现这里通过遍历ComponentCallbacks2并执行了其onLowMemory方法，那么这里的ComponentCallBacks2是什么呢？这里我们查看一下collectComponentCallbacks方法的实现逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950ArrayList&lt;ComponentCallbacks2&gt; collectComponentCallbacks( boolean allActivities, Configuration newConfig) { ArrayList&lt;ComponentCallbacks2&gt; callbacks = new ArrayList&lt;ComponentCallbacks2&gt;(); synchronized (mResourcesManager) { final int NAPP = mAllApplications.size(); for (int i=0; i&lt;NAPP; i++) { callbacks.add(mAllApplications.get(i)); } final int NACT = mActivities.size(); for (int i=0; i&lt;NACT; i++) { ActivityClientRecord ar = mActivities.valueAt(i); Activity a = ar.activity; if (a != null) { Configuration thisConfig = applyConfigCompatMainThread( mCurDefaultDisplayDpi, newConfig, ar.packageInfo.getCompatibilityInfo()); if (!ar.activity.mFinished &amp;&amp; (allActivities || !ar.paused)) { // If the activity is currently resumed, its configuration // needs to change right now. callbacks.add(a); } else if (thisConfig != null) { // Otherwise, we will tell it about the change // the next time it is resumed or shown. Note that // the activity manager may, before then, decide the // activity needs to be destroyed to handle its new // configuration. if (DEBUG_CONFIGURATION) { Slog.v(TAG, &quot;Setting activity &quot; + ar.activityInfo.name + &quot; newConfig=&quot; + thisConfig); } ar.newConfig = thisConfig; } } } final int NSVC = mServices.size(); for (int i=0; i&lt;NSVC; i++) { callbacks.add(mServices.valueAt(i)); } } synchronized (mProviderMap) { final int NPRV = mLocalProviders.size(); for (int i=0; i&lt;NPRV; i++) { callbacks.add(mLocalProviders.valueAt(i).mLocalProvider); } } return callbacks; } 可以发现该方法最终返回类型为ArrayList类型的callBacks而我们的callBacks中保存的是我们应用进程中的Activity，Service，Provider已经Application等。咦？Activity，Service，Provider，Application都是ComponentCallBacks2类型的么？我们看一看一下具体的定义： Actvity的类定义： 12345public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2, Window.Callback, KeyEvent.Callback, OnCreateContextMenuListener, ComponentCallbacks2, Window.OnWindowDismissedCallback Service的类定义： 1public abstract class Service extends ContextWrapper implements ComponentCallbacks2 ContentProvider的类定义： 1public abstract class ContentProvider implements ComponentCallbacks2 Application的类定义： 1public class Application extends ContextWrapper implements ComponentCallbacks2 可以发现其都是继承与ComponentCalbacks2，所以其都可以被当做是ComponentCallbacks2类型的变量。而同样是四大组件的BroadcastReceiver，我们可以下其类定义： 1public abstract class BroadcastReceiver 可以看到其并未继承与ComponentCallbacks2，所以并未执行，所以通过这样的分析，我们知道了，最终应用程序中的Activity，Servier，ContentProvider，Application的onLowMemory方法会被执行。而由于我们是在系统内存紧张的时候会执行killAllBackground方法进而通过层层条用执行Activity、Service、ContentProvider、Application的onLowMemory方法，所以我们可以在这些组件的onLowMemory方法中执行了一些清理资源的操作，释放一些内存，尽量保证自身的应用进程不被杀死。 总结： 系统在JNI层会时时检测内存变量，当内存过低时会通过kiilbackground的方法清理后台进程。 经过层层的调用过程最终会执行Activity、Service、ContentProvider、Application的onLowMemory方法。 可以在组件的onLowMemory方法中执行一些清理资源的操作，释放内存防止进程被杀死。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机","link":"/2020/09/11/onLowMemory%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"各种学习资料，包括一些百度云视频链接还有pdf资料 --搬运工","text":"人生不如意事常八九 共勉 【0】Springboot微服务开发天气预报系统视频教程 https://pan.baidu.com/s/1joz7flyztCq8oklBlsz8dQ 提取密码：cpz7 【1】JAVA300集大型视频教程2018版发布 https://pan.baidu.com/s/1Bqy4mWSD1idd6JmIzS9ZLg 提取密码：llg2 【2】Vue2.5开发去旅游网站App从零基础入门到实战项目 https://pan.baidu.com/s/1DYCoIw_b893KXGkkYt_92Q 提取密码：bgoy 【3】opencv+tensorflow入门人工智能图像处理视频教程+源码下载 https://pan.baidu.com/s/10WefZkTQST094L5UQA7myg 提取密码：7b9w 【4】最新BAT面试真题讲解，想去大厂的别错过 https://pan.baidu.com/s/1ejf2Eh8ZA-T1bWbuT6gw0A 提取密码：mist 【5】Python3异步IO并发编程高级进阶视频教程下载 https://pan.baidu.com/s/1jiRwD5MNPmAKF98nXYzmKg 提取密码：hct4 【6】最新大数据数据分析与挖掘高级工程师第三期视频教程 https://pan.baidu.com/s/1g8xGPag9GiMA4_MEKbxePw 提取密码：z2v3 【7】姜承尧MYSQL,DBA视频课程(44天全)视频教程下载 https://pan.baidu.com/s/19NUjkkvdDZXhw1QG4yX21Q 提取密码：funf 【8】Python+AnsiblePlaybook+Django自动化运维项目实践课程 https://pan.baidu.com/s/1CfOHuaYi_TdPoAUzP9AW1w 提取密码：o3rc 【9】springcloud微服务实践-分布式与原理剖析链路追踪容器 https://pan.baidu.com/s/1g8QoqOnQwjI7N3zDSccr-w 提取密码：ygf5 【10】2018年最新Java高并发知识体系与高并发编程架构课程视频教程下载 https://pan.baidu.com/s/1E1NhSevRqwdnguiKSsOp5A 提取密码：mkh2 【11】2018年最新价值300Python人工智能TensorFlow框架应用实践视频课程下载 https://pan.baidu.com/s/1qYJjFz9aG6M5grMg311uRQ 提取密码：5hzp 【12】谭州学院价值1680元python视频教程12306网站案例vip特训班教程 https://pan.baidu.com/s/1yEQq5W1eSc3NA4XmyNmuJw 提取密码：cipi 【13】下载 https://pan.baidu.com/s/1D6hYdyi4ti2zpnKHVWWbEg 提取密码：glov 【14】Netty实战高性能分布式RPC视频教程下载 https://pan.baidu.com/s/1sDHh_g624MO08MTFIrwEDw 提取密码：mwa6 【15】2018年最新尚学堂Vue2全套学习视频教程下载 https://pan.baidu.com/s/147NvAV-Qse90xvTYDvHBcg 提取密码：wpfg 【16】最新2018疯狂SpringCloud微服务架构实战视频教程 https://pan.baidu.com/s/1jgC0lagtMG7tArATrAAHXg 提取密码：10kf 【17】kotlin高级教程从零开始开发完整安卓商城app https://pan.baidu.com/s/13F_C1aKuJ0ek5Kv-HWdygw 提取密码：krq2 【18】2018年最新疯狂Activiti6视频教程疯狂工作流讲义Activiti6.x视频教程 https://pan.baidu.com/s/1SriGV7tZAeSvYcYb6l_hdQ 提取密码：bzcu 【19】基于MyCat的MySQL高可用读写分离集群实战课程下载 https://pan.baidu.com/s/1DVCf57_O1iMDJkbOGxdnpw 提取密码：6a08 【20】2018年最新Webpack3由浅入深及搭载vue,react,angular框架多维度讲解 https://pan.baidu.com/s/1BYq5qb9fFMSyODlORBQCcw 提取密码：6wf3 【21】2018年最新Spark机器学习课程：智能客户系统项目实战视频教程 https://pan.baidu.com/s/12SrMtvLBlVJGOlOt5NQFjw 提取密码：uu9v 【22】最新离线数据分析平台实战驴妈妈项目实战培训视频教程 https://pan.baidu.com/s/129jhYGDLFzsM7BW5HYdg7Q 提取密码：vhjs 【23】2018年最新尚硅谷java9新特性视频教程下载 https://pan.baidu.com/s/1xC-xPm54rFMLAHYwis1Thg 提取密码：f0v6 【24】最新北风网人工智能+机器学习+深度学习+推荐系统实战第3期视频教程 https://pan.baidu.com/s/1E98ZYCtJ7Mom_tWZT6AM_g 提取密码：3abb 【25】[全栈开发]Vue+DjangoRESTframework打造生鲜电商项目视频教程 https://pan.baidu.com/s/1vFAkTEdydgL-GjdcpeEHGg 提取密码：k00f 【26】2018年最新node.js+ES+Koa2手把手教你开发一个短视频网站视频教程 https://pan.baidu.com/s/1jmxxQ88J_qWsovXkMNeDpQ 提取密码：46yh 【27】基于Java的微信平台开发教程视频下载 https://pan.baidu.com/s/1hMq-J7KFMuDezGSdzX35OA 提取密码：oycw 【28】最新精选蚂蚁-MySQL语句性能优化视频教程下载 https://pan.baidu.com/s/1miVf8Ze 提取密码：w5yt 【29】深度学习实战项目-利用RNN与LSTM网络原理进行唐诗生成视频课程 https://pan.baidu.com/s/1i6jyFtz 提取密码：vrzx 【30】2018年最新微信小游戏开发ES6+小游戏api开发视频教程下载 https://pan.baidu.com/s/1i7mwJCp 提取密码：ndl7 【31】最新甲骨论-Linux大数据及数据库存储视频教程下载 https://pan.baidu.com/s/1smi2oNj 提取密码：ypgn 【32】泰牛2017php基础班大牛班完整视频教程下载 https://pan.baidu.com/s/1ggKGo9d 提取密码：2tqk 【33】2018年最新Java微服务原理课程与改造房产销售平台视频教程 https://pan.baidu.com/s/1jKf8MMi 提取密码：i8ej 【34】使用dubbo、spring-boot等技术实现互联网后台服务项目架构视频教程 https://pan.baidu.com/s/1gg1JiBD 提取密码：1jtk 【35】最新区块链开发入门到精通视频教程下载 https://pan.baidu.com/s/1kW7FTwr 提取密码：hvep 【36】2018年最新价值1699元的深入大数据架构师之路，问鼎40万年薪视频教程下载 https://pan.baidu.com/s/1c3d1RbU 提取密码：22kw 【37】2018年最新java大数据基于storm开发实时流处理器视频教程 https://pan.baidu.com/s/1cOCHPk 提取密码：igw9 【38】2017年最新JAVA-ACE-架构师系列视频课程-RocketMQhttps://pan.baidu.com/s/1ghb9UAf 提取密码：sstz 【39】2017年深度学习项目实战视频课程-Seq2Seq序列生模型视频教程 https://pan.baidu.com/s/1dGEDwSp 提取密码：96eh 【40】2017年最新web前端工程师小白零基础入门到大神全套教程下载 https://pan.baidu.com/s/1dFQ8wgT 提取密码：7g4e 【41】2017年最新python高级模块matplotlib数据可视化分析视频教程 https://pan.baidu.com/s/1kWyRVmB 提取密码：qjaj 【42】价值1680元安卓特训班实战开发百思不得姐app项目教程下载 https://pan.baidu.com/s/1c3adHsc 提取密码：sxvg 【43】2018年最新价值799元Elasticsearch顶尖高手系列：高手进阶篇视频教程 https://pan.baidu.com/s/1mkkSBrU 提取密码：zmjn 【44】2017年最新深度学习框架Caffe使用案例视频课程下载 https://pan.baidu.com/s/1dGFsBnz 提取密码：q4dg 【45】炼数成精大数据的矩阵计算基础课程下载 https://pan.baidu.com/s/1mkaJbpY 提取密码：pnnc 【46】2018年最新redis从入门到精通与分布式架构视频教程下载 https://pan.baidu.com/s/1gggc7Fd 提取密码：img8 【47】2018年最新动力节点Java夜校视频教程下载 https://pan.baidu.com/s/1i6v7013 提取密码：dbnt 【48】全网最新基于ElasticSearch的找房网实战开发企业级房屋搜索网视频教程下载 https://pan.baidu.com/s/1bqUVrsF 提取密码：idjy 【49】Java高性能高并发秒杀系统实战视频教程下载 https://pan.baidu.com/s/1bqVBoqb 提取密码：ztqe 【50】2017最新最系统的PHP面试视频教程下载高薪无忧 https://pan.baidu.com/s/1o81Mu8q 提取密码：da2f 【51】2017年最新炼数成金机器读心术之神经网络与深度学习视频教程下载 https://pan.baidu.com/s/1mhJkQzI 提取密码：pvc6 【52】李兴华系列之Java8、Oracle、JavaScript、HTML5、Spring、Struts、Hibernate系列视频教程下载 https://pan.baidu.com/s/1o7O6ytc 提取密码：icgf 【53】2017年最新Python+scripy实现搜索引擎爬虫课程视频教程下载 https://pan.baidu.com/s/1mhLSFVy 提取密码：n333 【54】最新某某学院大数据工程师视频教程下载 https://pan.baidu.com/s/1o7Cvjwm 提取密码：ximb 【55】2017年Javaweb开发工程师成长之路全套视频教程附配套资料下载 https://pan.baidu.com/s/1qXJcyVa 提取密码：31di 【56】php高性能yii2框架开发高性能高可用负载均衡集群架构商城视频教程下载 https://pan.baidu.com/s/1jIKk70i 提取密码：b9bt 【57】2017最新兄弟连laravel入门到精通+博客实战开发教程下载 https://pan.baidu.com/s/1bZJAW2 提取密码：6p4c 【58】2017年最系统的PHP教程高薪就业视频教程下载 https://pan.baidu.com/s/1o7DG2pW 提取密码：rrds 【59】2017最新大数据10个小时快速入门hadoop3集群实战视频教程 https://pan.baidu.com/s/1hsgtagG 提取密码：dwin 【60】2017年最新Webpack+React全栈工程架构项目实战精讲视频教程下载 https://pan.baidu.com/s/1hsq2s64 提取密码：gprc 【61】2017年最新Uber车辆监控系统设计实战训练营高清视频教程全套附讲义代码 https://pan.baidu.com/s/1nv9Vm5b 提取密码：5bs8 【62】2017年最新DS206人脸识别与分析系统实战训练营硅谷讲师授课高清视频教程全套附讲义代码4周 https://pan.baidu.com/s/1c2LcBsc 提取密码：nv1h 【63】2017年最新React开发Native开发安卓与ios平台的GitHubApp视频教程 https://pan.baidu.com/s/1jI6DiXg 提取密码：7cyk 【64】2017年最新Google面试官亲授java校招面试视频讲解教程下载 https://pan.baidu.com/s/1nuDIkQ1 提取密码：hhnu 【65】Android传感器、无线传输与媒体硬件功能开发视频教程下载 https://pan.baidu.com/s/1bpoA4EV 提取密码：cvh9 【66】最新Kaggle神器之XGBoost从入门到精通高清精品视频教程附代码教程下载 https://pan.baidu.com/s/1nvj6fDR 提取密码：x493 【67】Oracle商业智能BI产品OBIEE11G深入浅出全套视频教程下载 https://pan.baidu.com/s/1o81KXPg 提取密码：f3sg 【68】2017年最新小象学院分布式爬虫第二期视频教程 https://pan.baidu.com/s/1geX7fKB 提取密码：2ac9 【69】mongodb从入门到精通高清视频教程下载 https://pan.baidu.com/s/1cpsdjC 提取密码：3ng4 【70】最新大数据快速数据挖掘平台RapidMiner数据分析视频教程下载 https://pan.baidu.com/s/1bpFE111 提取密码：3z6u 【71】最新Python自然语言分析视频课程下载 https://pan.baidu.com/s/1ge40FbP 提取密码：wa5r 【72】最新尚学堂redis视频教程下载 https://pan.baidu.com/s/1c35hRg 提取密码：gy5j 【73】最新oracle11gDBA开发和应用数据库视频教程下载 https://pan.baidu.com/s/1o7YE5Bk 提取密码：eu68 【74】2017vue2nodemongoKoa2Nuxt/VueSSR全栈开发小程序商城视频教程 https://pan.baidu.com/s/1jIw3lR4 提取密码：bmia 【75】最新python数据分析升级版视频教程下载 https://pan.baidu.com/s/1i5L7LdV 提取密码：bfk7 【76】Python数据分析(机器学习)经典案例视频教程 https://pan.baidu.com/s/1nuUCPlf 提取密码：3ytg 【77】DB2数据库性能优化视频教程下载 https://pan.baidu.com/s/1qYysRDE 提取密码：i1rx 【78】2017年node.js零基础入门到企业级全栈案例开发教程下载 https://pan.baidu.com/s/1eRBopRs 提取密码：ne2a 【79】Hadoop大数据视频教程：真实电商数据仓库全流程开发详解(共46讲)视频教程下载 https://pan.baidu.com/s/1bpMzOyr 提取密码：m3yt 【80】最新老男孩python全栈工程师第2期全套完整版视频教程下载 https://pan.baidu.com/s/1cIycbk 提取密码：cgfm 【81】价值2400元的python全栈开发系列FlaskPythonWeb网站编程视频教程 https://pan.baidu.com/s/1qXATJju 提取密码：huc3 【82】最新python从入门到精通到开发爬虫实例视频教程 https://pan.baidu.com/s/1mirFpeK 提取密码：9gmt 【83】极客学院VIP教程postgresql教程全集视频教程下载 https://pan.baidu.com/s/1i4DjPdF 提取密码：qgga 【84】最新angular4.x框架与redux开发大型企业级管理项目视频教程下载 https://pan.baidu.com/s/1nvEDQNB 提取密码：mqvu 【85】2017年数据分析与机器学习实战到经典案例全套高清视频教程（基于Python3.5anaconda4.2）15G https://pan.baidu.com/s/1nvqXoPN 提取密码：irdj 【86】2017年最新大数据实时分析Storm入门到精通学习路线视频教程 https://pan.baidu.com/s/1pL7OfvP 提取密码：2ze2 【87】使用php高可用webapp后端开发视频教程下载 https://pan.baidu.com/s/1qXTQ5FQ 提取密码：pybc 【88】2017年最新java算法详解与算法开发小游戏视频教程下载 https://pan.baidu.com/s/1dF0GWNn 提取密码：t6tk 【89】2017年9月最新pythonflask开发小视频网站视频教程 https://pan.baidu.com/s/1nuHfvZF 提取密码：pygf 【90】2017年5月炼数成金《MySQLDBA从小白到大神实战》视频教程 https://pan.baidu.com/s/1jHFP8sm 提取密码：qnmj 【91】Vue从入门到精通视频教程 https://pan.baidu.com/s/1pKCX6Wj 提取密码：h6hd 【92】北风网从C++起步到MFC实战VC++软件工程师高端培训(服务器端开发方向)332课全 https://pan.baidu.com/s/1c1SSWKg 提取密码：iw7p 【93】2017最新python3从零基础入门到精讲超清视频教程 https://pan.baidu.com/s/1c2Nd468 提取密码：h46d 【94】2017年最新使用MUI开发跨平台混合APP全套完整视频教程 https://pan.baidu.com/s/1dFxYZ0d 提取密码：9ury 【95】最新人脸识别深度学习项目实战视频教程 https://pan.baidu.com/s/1o8onm2m 提取密码：7aqr 【96】2017年最新Python网络爬虫实战案例视频教程下载共5章34课 https://pan.baidu.com/s/1micMg8w 提取密码：23gt 【97】基于Hadoop，Spark大数据技术的推荐系统算法实战教程 https://pan.baidu.com/s/1dFnP9K1 提取密码：djyk 【98】 https://pan.baidu.com/s/1gf0CGuB 提取密码：4tei 【99】2017年最新云知梦php全栈开发全套视频教程 https://pan.baidu.com/s/1qYPwSsW 提取密码：iv93 【100】Python编程高级进阶视频教程 https://pan.baidu.com/s/1bpnnEph 提取密码：y9sp 【101】2017年5月最新课程小象学院深度学习第四期视频教程 https://pan.baidu.com/s/1o7IzeXk 提取密码：kptc 【102】最新自动聊天机器人项目班实战视频课程下载 https://pan.baidu.com/s/1kU9bNev 提取密码：6p5z 【103】深度学习入门视频课程上篇+下篇下载 https://pan.baidu.com/s/1slG7qxv 提取密码：u2c4 【104】七月在线机器学习算法班9月在线班视频教程 https://pan.baidu.com/s/1nuLiXCl 提取密码：vdkz 【105】最新小象学院机器学习升级版III视频教程下载 https://pan.baidu.com/s/1gfeXSgb 提取密码：dt7t 【106】最新优达学城udacity无人驾驶工程师视频教程 https://pan.baidu.com/s/1c1UUEXi 提取密码：mjbs 【107】2017年深度学习项目实战之对抗生成网络视频课程 https://pan.baidu.com/s/1hs8chxU 提取密码：76mw 【108】2017年深度学习之Tensorflow项目实战视频课程-文本分类 https://pan.baidu.com/s/1c1Kf1wG 提取密码：dt52 【109】2017年kaggle案例实战班视频教程 https://pan.baidu.com/s/1boYu4FX 提取密码：4bhc 【110】深度学习实战决胜AI-强化学习实战系列视频课程 https://pan.baidu.com/s/1eRHZ1yq 提取密码：ifu2 【111】2017年最新从理论到实践机器学习视频教程 https://pan.baidu.com/s/1jHPsHSU 提取密码：xx9x 【112】2017最新基于springsecurity与spingmvc分布式权限管理系统 https://pan.baidu.com/s/1c13keOw 提取密码：xea9 【113】Java高并发程序设计实战视频教程 https://pan.baidu.com/s/1c1CDsnI 提取密码：xsic 【114】Sqoop、Flume、Oozie、Hue大数据工具视频教程 https://pan.baidu.com/s/1bo47OGR 提取密码：hxw7 【115】深入JVM内核—原理、诊断与优化视频教程 https://pan.baidu.com/s/1jIL46PK 提取密码：78yd 【116】Hadoop,Hbase,Hive源码解析与开发实战 https://pan.baidu.com/s/1hsznJsK 提取密码：dpmq 【117】传智播客黑马P2P金融项目网络借贷平台开发实战教程 https://pan.baidu.com/s/1pLieuzL 提取密码：gbxy 【118】2017年7月最新微服务架构的分布式事务解决视频教程 https://pan.baidu.com/s/1bo47p2R 提取密码：94hx 【119】亿级流量电商系统大型高并发与高可用缓存架构实战 https://pan.baidu.com/s/1pLmhZir 提取密码：6aj9 【120】2017Spark2.0大型项目实战：移动电商app交互式数据分析平台 https://pan.baidu.com/s/1o8EAk2Y 提取密码：gcsq 【121】NO89中移动大型分布式redis,solr,Linux,nginx,springmvc,mybatis电商项目 https://pan.baidu.com/s/1qY7K2SW 提取密码：cjj4 【122】SpringBoot从前端到后台打造企业级博客全栈实战视频 https://pan.baidu.com/s/1pKLc2BT 提取密码：8tjw 【123】（2017年）最新深度学习与机器学习 https://pan.baidu.com/s/1c76kgA 提取密码：5qyv 【124】SpringMvc+Spring+Mybatis整合视频教程 http://pan.baidu.com/s/1gfP90Pl 提取密码：kveg 【125】Struts2+Spring3+Hibernate4+Maven+EasyUI整合入门视频教程 http://pan.baidu.com/s/1bpztkOR 提取密码：krbn 【126】elk日志分析视频ELKStack视频教程以及Solr教程 http://pan.baidu.com/s/1qYwQOSc 提取密码：qr9u 【127】徐老师hadoophbasezookeepersparkkafka大数据视频教程 http://pan.baidu.com/s/1miLtQqO 提取密码：97tj 【128】2017年最新项目实战SpringBoot视频教程微服务整合Mybatis http://pan.baidu.com/s/1boMH2Cv 提取密码：gvt5 【129】传智播客最新大数据第3期实战培训完整版视频教程 http://pan.baidu.com/s/1miLZwwg 提取密码：56hs 【130】[大数据]极客学院大数据工程师全套视频代码课件 http://pan.baidu.com/s/1c160ug4 提取密码：6d28 【131】2017新版MySQL加强视频教程46课附课件源码 http://pan.baidu.com/s/1eSouP6U 提取密码：nh8i 【132】Python爬虫项目班从零开始实现爬虫系统 http://pan.baidu.com/s/1i5QiuzV 提取密码：2vpd 【133】Mongodb/Redis/HBaseNoSql视频教程2017数据库自学教程 http://pan.baidu.com/s/1kVytRIB 提取密码：mtnb 【134】Mahout零基础入门到精通实战视频教程（全套）下载 http://pan.baidu.com/s/1kUPNJaJ 提取密码：pvka 【135】2017年最新整理深度学习神经网络算法全套视频教程 http://pan.baidu.com/s/1pLsfdIb 提取密码：vy41 【136】阿里开源分布式框架dubbo&amp;mycat视频教程 https://pan.baidu.com/s/1geZwIYZ 提取密码：h7iw 【137】极客学院python开发工程师视频教程下载 https://pan.baidu.com/s/1miDOboc 提取密码：gwaa 【138】2017最新python教程老男孩Python14期视频教程下载 https://pan.baidu.com/s/1kVbWgzP 提取密码：9hk7 【139】达内2017Web前端全套最新价值2万元视频教程 http://pan.baidu.com/s/1jIA3oma 提取密码：rfqk 【140】达内Java全套最新价值2万元视频教程 https://pan.baidu.com/s/1sl545sx 提取密码：sa8i 【141】SparkMLlib机器学习算法与源码解析 https://pan.baidu.com/s/1pLptvMN 提取密码：ncek 【142】大数据开发之hadoop工程师成长之路零基础到精通下载 https://pan.baidu.com/s/1i4LciTf 提取密码：8z4m 【143】Kafka原理剖析及实战演练视频教程下载 https://pan.baidu.com/s/1mhAgeBA 提取密码：26ny","link":"/2020/09/28/%E5%90%84%E7%A7%8D%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%B8%80%E4%BA%9B%E7%99%BE%E5%BA%A6%E4%BA%91%E8%A7%86%E9%A2%91%E9%93%BE%E6%8E%A5%E8%BF%98%E6%9C%89pdf%E8%B5%84%E6%96%99%20--%E6%90%AC%E8%BF%90%E5%B7%A5/"},{"title":"29 应用程序返回按键执行流程","text":"从这篇文章中我们开始分析android系统的事件分发流程，其实网上已经有了很多关于android系统的事件分发流程的文章，奈何看了很多但是印象还不是很深，所以这里总结一番。android系统的事件分发流程分为很多部分： Native层 –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层 –&gt; ViewGroup层 –&gt; View层 所以android系统的事件分发流程是从Native层开始的，然后分发到ViewRootImpl中，然后分发到DecorView层，然后分发到ViewGroup层，最后分发到View层中。下面我们将从Native层开始分析事件的分发流程。 在Native层android系统的事件流程： Android系统是从从底层驱动中获取各种原始的用户消息，包括按键、触摸屏、鼠标、滚迹球等用户事件消息。 在获取用户消息之后，android系统会对最原始的消息进行预处理，包括两个方面：一方面，将消息转化成系统可以处理的消息事件；另一方面，处理一些特殊的事件，比如HOME、MENU、POWER键等处理（前面的几篇文章中我们已经分析了系统按键处理逻辑的执行流程）。 将处理后的消息事件分发到各个应用进程，这个需要使用IPC机制，Android系统使用管道来进行消息的传递。 Android系统使用InputManager类来管理消息，而具体的功能则是通过InputReaderThread和InputDispatcherThread两个线程来实现。其中InputReaderThread线程负责消息的读取，而InputDispatcherThread则负责消息的预处理和分发到各个应用进程中。 Acitivty系统在SystemServer进程中启动WindowManagerService服务，然后在WindowManagerService服务中启动InputManagerService服务。 可以看到在Native层，主要创建了两个两个线程，其中一个用于读取消息，另一个用于分发消息，消息经过分发最终会上传至App中。 在ViewRootImpl层android系统的事件流程 在Native层的事件分发线程中，经过事件的分发流程，最终会调用InputEventSender的dispatchInputEventFinished方法，可以看一下具体代码的实现： 123private void dispatchInputEventFinished(int seq, boolean handled) { onInputEventFinished(seq, handled); }在dispatchInputEventFinished方法中我们最终调用的是onInputEventFinished方法，然后我们查看onInputEventFinished方法的实现，发现其是一个空方法。。。，好吧，经过分析我们发现，Native层最终调用的并不是InputEventSender，而是调用InputEventSender的子类ImeInputEventSender，即ImeInputEventSender的onInputEventFinished方法，该类定义在源文件InputMethodManager中： 12345678910private final class ImeInputEventSender extends InputEventSender { public ImeInputEventSender(InputChannel inputChannel, Looper looper) { super(inputChannel, looper); } @Override public void onInputEventFinished(int seq, boolean handled) { finishedInputEvent(seq, handled, false); } } 可以看到在其onInputEventFinished方法中又调用了finishedInputEvent方法，这样我们在继续看一下finishedInputEvent方法的实现。 12345678910111213141516171819202122void finishedInputEvent(int seq, boolean handled, boolean timeout) { final PendingEvent p; synchronized (mH) { int index = mPendingEvents.indexOfKey(seq); if (index &lt; 0) { return; // spurious, event already finished or timed out } p = mPendingEvents.valueAt(index); mPendingEvents.removeAt(index); Trace.traceCounter(Trace.TRACE_TAG_INPUT, PENDING_EVENT_COUNTER, mPendingEvents.size()); if (timeout) { Log.w(TAG, &quot;Timeout waiting for IME to handle input event after &quot; + INPUT_METHOD_NOT_RESPONDING_TIMEOUT + &quot; ms: &quot; + p.mInputMethodId); } else { mH.removeMessages(MSG_TIMEOUT_INPUT_EVENT, p); } } invokeFinishedInputEventCallback(p, handled); } 在方法finishedInputEvent中，经过一系列的处理之后最终调用的是invokeFinishedInputEventCallback方法，所以我们继续看一下invokeFinishedInputEventCallback方法的实现。 1234567891011121314void invokeFinishedInputEventCallback(PendingEvent p, boolean handled) { p.mHandled = handled; if (p.mHandler.getLooper().isCurrentThread()) { // Already running on the callback handler thread so we can send the // callback immediately. p.run(); } else { // Post the event to the callback handler thread. // In this case, the callback will be responsible for recycling the event. Message msg = Message.obtain(p.mHandler, p); msg.setAsynchronous(true); msg.sendToTarget(); } } 可以发现这里我们首先判断PendingEvent的mHandler所在的线程是否是当前线程，若是的话则直接调用p.run方法，若不是的话则发送一个异步消息，而异步消息最终也是执行的p.run方法，所以我们继续看一下PendingEvent的run方法。 12345678@Override public void run() { mCallback.onFinishedInputEvent(mToken, mHandled); synchronized (mH) { recyclePendingEventLocked(this); } } 可以发现在run方法中我们调用了mCallback的onFinishedInputEvent方法，需要说明的是这里的mCallback就是我们ViewRootImpl中的ImeInputStage类对象，而这里的ViewRootImpl对象就是我们的系统当前界面，前面我们分析Activity的加载绘制流程的时候知道Activity中保存了一个Window对象用于表示窗口信息，而Window对象内部就是通过ViewRootImpl对象实现窗口的加载绘制，所以这里的mCallback对象就是我们当前的App获取焦点的窗口的ViewRootImpl中的ImeInputStage对象，然后我们看一下该对象的onFinishedInputEvent方法的实现。 12345678910111213final class ImeInputStage extends AsyncInputStage implements InputMethodManager.FinishedInputEventCallback { ... @Override public void onFinishedInputEvent(Object token, boolean handled) { QueuedInputEvent q = (QueuedInputEvent)token; if (handled) { finish(q, true); return; } forward(q); } } 这样经过一系列的调用之后我们消息的处理逻辑上传至了ViewRootImpl中，而在ViewRootImpl中经过一些列的调用之后我们ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法： 12345678910111213141516171819202122at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:4152)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4114)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3807)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:3864)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3689)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3662)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3715)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3681)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:3840)at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4006)at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2272)at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:1893)at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:1884)at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2249)at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141) 这是通过异常信息打印的堆栈信息，从中我们可以看到在ViewRootImpl中我们经过一系列的调用之后最终执行的是：ViewRootImpl$ViewPostImeInputStage.processKeyEvent方法，这样我们继续看一下processKeyEvent方法。 12345678private int processKeyEvent(QueuedInputEvent q) { ... // Deliver the key to the view hierarchy. if (mView.dispatchKeyEvent(event)) { return FINISH_HANDLED; } ...} 可以看到这里调用了mView的dispatchKeyEvent方法，而我们分析过Activity窗口加载绘制流程，从中我们知道ViewRootImpl中的mView对象就是我们PhoneWindow中的mDecorView对象（DecorView），所以经过层层调用我们最终执行到了DecorView层。 在DecorView层android系统的事件流程 从上面我们知道在ViewRootImpl中我们最终调用了mView.dispatchKeyEvent方法，即执行的是PhoneWindow%DecorView.dispatchKeyEvent方法。 12345678910111213141516171819202122232425262728293031323334353637@Override public boolean dispatchKeyEvent(KeyEvent event) { final int keyCode = event.getKeyCode(); final int action = event.getAction(); final boolean isDown = action == KeyEvent.ACTION_DOWN; if (isDown &amp;&amp; (event.getRepeatCount() == 0)) { // First handle chording of panel key: if a panel key is held // but not released, try to execute a shortcut in it. if ((mPanelChordingKey &gt; 0) &amp;&amp; (mPanelChordingKey != keyCode)) { boolean handled = dispatchKeyShortcutEvent(event); if (handled) { return true; } } // If a panel is open, perform a shortcut on it without the // chorded panel key if ((mPreparedPanel != null) &amp;&amp; mPreparedPanel.isOpen) { if (performPanelShortcut(mPreparedPanel, keyCode, event, 0)) { return true; } } } if (!isDestroyed()) { final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) { return true; } } return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event); } 从中我们可以看到如果当前的PhoneWindow不是destroy庄则，则执行cb.dispatchKeyEvent方法，而这里的callback对象就是我们的Activity对象，所以这里最终会执行到Activity的dispatchKeyEvent方法。。。 在Activity层android系统的事件流程 所以我们这里继续看一下Actiivty中的dispatchKeyEvent方法： 12345678910111213141516171819public boolean dispatchKeyEvent(KeyEvent event) { onUserInteraction(); // Let action bars open menus in response to the menu key prioritized over // the window handling it if (event.getKeyCode() == KeyEvent.KEYCODE_MENU &amp;&amp; mActionBar != null &amp;&amp; mActionBar.onMenuKeyEvent(event)) { return true; } Window win = getWindow(); if (win.superDispatchKeyEvent(event)) { return true; } View decor = mDecor; if (decor == null) decor = win.getDecorView(); return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this); } 从中我们可以看到我们首先调用了Activity的window对象的superDispatchKeyEvent方法，而这个方法就是将处理方法下发带Activity中的View，而这里我们分析的是返回按键，显然的View层是无法处理这里的返回按键的，所以win.superDispatchKeyEvent方法返回的是false，所以最终我们执行的是event.dispatch方法。这样我们继续看一下event.dispatch方法的实现。 123456789101112131415public final boolean dispatch(Callback receiver, DispatcherState state, Object target) { switch (mAction) { ... case ACTION_UP: if (DEBUG) Log.v(TAG, &quot;Key up to &quot; + target + &quot; in &quot; + state + &quot;: &quot; + this); if (state != null) { state.handleUpEvent(this); } return receiver.onKeyUp(mKeyCode, this); ... } return false; } 这里我们暂时分析一下ACTION_UP事件，可以发现这里最终调用的是receiver.onKeyUp方法，而这里的receiver就是我们的Actiivty，所以这里又回到了Activity并且执行其onKeyUp方法。 1234567891011public boolean onKeyUp(int keyCode, KeyEvent event) { if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) { onBackPressed(); return true; } } return false; } 看onKeyUp方法，我们可以发现当我们按的是返回按键时，其回调了onBackPressed方法，所以我们继续看一下onBackPressed方法。 123456789public void onBackPressed() { if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) { return; } if (!mFragments.getFragmentManager().popBackStackImmediate()) { finishAfterTransition(); } } 可以看到，在onBackPressed方法中，我们最终调用的是finishAfterTransition方法，所以继续看一下这个方法的实现逻辑。 12345public void finishAfterTransition() { if (!mActivityTransitionState.startExitBackTransition(this)) { finish(); } } O(∩_∩)O哈哈~，原来finish方法是在这里调用的，这样我们按下返回按键并抬起之后，经过层层的调用之后最终调用了我们的finish方法，而这个方法就是finish掉Activity的方法，也就解释了我们在App中默认按下返回按键之后Acitivty会被销毁了。 总结： 本文中由于是分析的返回按键的处理流程，所以事件的分发流程没有做说明，下面的文章中会着重介绍Android的事件分发流程； 事件分发流程从Native –&gt; ViewRootImpl层 –&gt; DecorView层 –&gt; Activity层都是类似的，无论是按键分发流程还是触摸事件分发流程 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E%E6%8C%89%E9%94%AE%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"},{"title":"11 应用进程启动流程","text":"转载请标明出处：一片枫叶的专栏 在android guide中有这样的一段关于android应用程序进程的描述： 1By default, every application runs in its own Linux process. Android starts the process when any of the application's components need to be executed, then shuts down the process when it's no longer needed or when the system must recover memory for other applications. 每一个android应用默认都是在他自己的linux进程中运行。android操作系统会在这个android应用中的组件需要被执行的时候启动这个应用进程，并且会在这个应用进程没有任何组件执行或者是系统需要为其他应用申请更多内存的时候杀死这个应用进程。所以当我们需要启动这个应用的四大组件之一的时候如果这个应用的进程还没有启动，那么就会先启动这个应用程序进程。 本节主要是通过分析Activity的启动过程介绍应用程序进程的启动流程。 在上一篇文章中我们简要的介绍了Launcher的启动流程，在SystemServer进程执行完成，各种系统服务启动完成之后，会调用ActivityManagerService中的systemReady()方法，在systemReady（）方法中会执行Launcher启动的相关逻辑了，具体可以参考： android源码解析之（十）–&gt;Launcher启动流程 Launcher应用程序在启动过程中会通过PackageManagerService服务请求查询系统所有的已安装应用的包名，图标和应用名称等信息，然后填充到Launcher中的Adapter中，这样点击某一项应用图标的时候就可以根据该图标的包名和启动Activity的类名初始化Intent对象，然后调用startActivity(Intent)启动相关的应用程序了。 其实android中应用进程可以通过许多方式启动，比如启动一个Activity，启动一个Service，启动一个ContentProvider或者是一个BroadcastReceiver，也就是说我们可以通过启动四大组件的方式启动应用进程，在应用进程没有启动的时候，如果我们通过启动这些组件，这时候系统会判断当前这些组件所需要的应用进程是否已经启动，若没有的话，则会启动应用进程。 这里我们通过Launcher简单分析一下应用进程的启动流程。通过上一篇Launcher启动流程，我们知道每一个launcher中的图标对应着一个应用报名和启动activity类名，查看LauncherActivity中的图标点击事件: 1234protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }在通过应用包名和启动activity类名构造完成Intent之后，我们调用了startActivity方法来启动这个activity，很明显的，当前这个应用并没有启动，也就是说我们调用的startActivity方法不单单为我们启动了这个activity也同时在启动activity之前启动了这个应用进程，好了，那我们这里就以这个方法为入口分析一下应用进程的启动流程。 跟踪代码到Activity，发现其调用了startActivity的重载方法： 1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); } 继续跟进： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 很明显的我们此时传递的options为空： 123public void startActivityForResult(Intent intent, int requestCode) { startActivityForResult(intent, requestCode, null); } 好吧，最后调用的还是这个重载方法： 123456789101112131415161718192021222324252627public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现这里调用了mInstrumentation.execStartActivity方法，这里先简单介绍一下Instrumentation对象，他是Android系统中应用程序端操作Activity的具体操作类，这里的操作段是相对于ActivityManagerService服务端来说的。也就是说当我们在执行对Activity的具体操作时，比如回调生命周期的各个方法都是借助于Instrumentation类来实现的。 好了，下面我们继续看一下Instrumentation的execStartActivity方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 这里主要关注这个代码： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这断代码实际上是进程间通讯，我们可以发现ActivityManagerNative继承于Binder接口，所以ActivityManagerNative就是一个Binder对象，然后上面一节我们介绍SystemServer进程的时候对ActivityManagerService有过了解，发现其继承于ActivityManagerNative，好吧，了解过Binder机制的童鞋就知道了，ActivityManagerService就是这个Binder机制的服务器端而ActivityManagerNative就是这个Binder机制的客户端，所以我们这里调用的startActivity实际上是讲参数传递给ActivityManagerService并执行ActivityManagerService的startActivity方法。 既然这样，我们看一下ActivityManagerService的startActivity方法： 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 调用了startActivityAsUser方法，然后我们继续看一下startActivityAsUser方法： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 继续查看startActivityMayWait方法： 1234567891011121314151617181920final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } } 这个方法的逻辑比较多，我们重点关注的是其调用了startActivityLocked方法，也就是说在初始化其他逻辑之后，这个方法会调用startActivityLocked方法： 12err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); 代码量也是比较大的，在方法体中调用了startActivityUncheckedLocked方法，然后我们继续跟进startActivityUncheckedLocked方法： 1targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); 然后我们查看startActivityLocked方法的实现： 123if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } 可以发现其调用了resumeTopActivitiesLocked方法： 1stack.resumeTopActivityLocked(null); 继续跟进： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后我们看一下resumeTopActivityLocked方法的实现： 1result = resumeTopActivityInnerLocked(prev, options); 继续查看resumeTopActivityInnerLocked方法的实现： 1mStackSupervisor.startSpecificActivityLocked(next, true, true); 可以发现在方法体中执行了相关逻辑判断与初始化操作之后调用了startSpecificActivityLocked方法： 12mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); 可以发现在方法体中调用了startProcessLocked方法，从名字可以看出来这个方法就是启动进程的。 123456789final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, boolean keepIfLarge) { return startProcessLocked(processName, info, knownToBeDead, intentFlags, hostingType, hostingName, allowWhileBooting, isolated, 0 /* isolatedUid */, keepIfLarge, null /* ABI override */, null /* entryPoint */, null /* entryPointArgs */, null /* crashHandler */); } 查看startProcessLocked方法的实现： 1234checkTime(startTime, &quot;startProcess: stepping in to startProcess&quot;); startProcessLocked( app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs); checkTime(startTime, &quot;startProcess: done starting proc!&quot;); 查看startProcessLocked方法的具体实现； 123456checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); 查看关键代码，这里调用了Process.start方法： 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 这里的processClass就是要启动的进程的名称，这里传递的就是ActivityThread： 1&quot;android.app.ActivityThread&quot; 具体的Process启动进程的Native层代码这里不做过多的分析，这个方法就是启动了AcitivtyThread进程并执行了ActivityThread的main方法，所以我们经常说的进程的启动方法就是ActivityThread的main方法就是这里体现的。 总结： android应用进程会在需要启动其组件的时候启动，当没有任何组件运行或者是系统内存较低的时候应用进程会被杀死。 在启动应用四大组件的时候若发现当前应用的进程没有启动，则会首先启动应用程序的进程。 我们可以为应用程序配置多个进程，每个进程都有自己的JVM和运行环境，各个进程之间的通讯需要通过Binder机制。 Launcher启动的过程也是先启动Launcher进程再启动其Activity组件。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"热修复技术原理总结","text":"#1.什么是热修复 传统更新流程：版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;重新发版-&gt;用户安装 弊端:重新发版本代价高 :用户下载安装成本高 :bug修复不及时，体验差 解决方案 Hybrid方案:业务逻辑以H5方式加载 插件化方案:Atlas或者DroidPlugin方案 热修复方案:采用热修复技术，将更新补丁上传到云端，APP从云端下拉补丁直接应用生效 热修复更新流程:版本上线-&gt;用户安装-&gt;发现bug-&gt;紧急修复-&gt;打出补丁,推送给用户-&gt;自动拉取补丁修复 优势 1.无需重新发版，实时高效热修复 2.用户无感知修复，无需下载新应用,代价小 3.修复成功率高，把损失降到最低 ##2.热修复框架 腾讯QQ控件的超技补丁技术，微信的Tinker，饿了么的Amigo，美团的Robust 非侵入式Android热修复方案SophixSophix不支持四大组件的修复,如果要修复四大组件，必须在AndroidManifest里预先插入代理组件，并且声明所有权限。对app运行流程的侵入性太强。未作处理。 ##3.Android热修复的三大领域:代码修复,资源修复,So修复。 ###3.1代码修复 ###代码修复方案:一种是阿里系的底层替换方案，一种是腾讯系的类加载方案优劣: 底层替换方案限制多，但时效性好，加载快，立即见效。类加载方案时效性差，需要重新冷启动才能见效，但修复范围广，限制少。 ###底层替换方案 底层替换方案是在已经加载了的类中直接替换掉原有方法，是在原来类的基础上进行修改。因而无法实现对原有类进行方法和字段的增减，因为这样将破坏原有类结构。一旦补丁类中出现了方法的增加或减少，就会导致这个类以及整个Dex的方法数的变化。方法数的变化伴随着方法索引的变化，这样在访问方法时就无法正常的索引到正确的方法了。如果字段发生了增加和减少，和方法变化的情况一样，所有字段的索引都会发生变化。更严重的问题是，如果在程序运行中间某各类突然增加了一个字段，那么对于原先已经产生的这个类的实例，他们还是原来的结构，这是无法改变的。而新方法使用到这些老的实例对象时，访问新增字段就会产生不可预期的结果。传统的底层替换方式，不论是Dexposed、Andfix或者其他安全界的Hook方案，都是直接依赖修改虚拟机方法实体的具体字段，例如，改Dalvik方法的jni函数指针、修改类或者方法的访问权限。Android开源，各大厂商对代码进行改造，Andfix里的ArtMethod的结构是根据Android源码中的结构写死的。如果ArtMethod做修改，这种替换机制就会出问题。 Sophix是一种无视底层具体结构的替换方式，解决了兼容性问题。忽略了底层ArtMethod结构的差异，对于Android版本不需要区分，代码量大大减少。只要ArtMethod数组是以线性结构排列，就不会出现问题。 ###类加载方案类加载方案的原理是在app重新启动后让Classloader去加载新的类。因为app运行时，所有需要发生变更的类已经被加载过了，在Android上是无法对一个类进行卸载。如果不重新启动，原来的类还在虚拟机上，就无法加载新类。只有重新启动，在业务逻辑执行前，抢先加载补丁中的新类，当访问这个类时就会Resolve为新类，达到热修复目的。 ###底层替换原理 Andfix即时生效，其原理是，在已经加载的类中直接在native层替换掉原有方法，实在原有类基础上进行修改。其核心在于replaceMethod函数，这是一个native方法。 其参数是在Java层通过反射机制得到的Method对象所对应的jobject。src对应的事需要被替换的原有方法。dest对应的就是新方法，新方法存在于补丁包中的新类中，也就是补丁方法。 Android的java运行环境，在4.4以下用的事dalvik虚拟机，而在4.4以上用的是art虚拟机。 我们以art为例，对于不同Android版本的art，底层Java对象的数据结构是不同的，因而会进一步区分不同的替换函数，这里我们以Android6.0为例，对应的就是replace_6_0. 每一个Java方法在art中都对应着一个ArtMethod，ArtMethod记录了这个Java方法的所有信息，包括所属类、访问权限、代码执行地址等。 通过env-&gt;FromReflectedMethod，可以由Method对象得到这个方法对应的ArtMethod的真正起始地址。然后可以把它强转成ArtMethod指针，从而对其所有成员进行修改。这样全部替换完之后就完成了热修复逻辑，以后调用这个方法时就会直接走到新方法的实现中了。 为什么这样替换完就可以实现热修复了呢？需要从虚拟机调用方法的原理说起。 在Art虚拟机中ArtMethod结构中，包含两个重8_point_from_quick_compiled_code_了，他们是方法的执行入口。Java代码在Android中会被编译成DexCode。你也不 Art中可以采用解析模式或者AOT机器码模式执行。 解析模式，就是去除Dex Code，逐条解析执行，如果方法的调用者以解析模式运行，在调用方法时，就会取得这个方法的entry_point_from_interpreter_,然后他交转过去执行。AOT的方式，就会先预编译好Dex Code 对应的机器码，然后执行期直接执行机器码，不需要一条条解析执行Dex Code。如果方法的调用者是以AOT机器码方式执行的，在调用这个方法是，就是跳转到entry_point_from_quick_compiled_code执行。因此，当把一个旧方法的所有成员字段都换成新方法后，执行时所有数据就可以保持和新方法的一至。这样在所有执行到旧方法的地方，回取得新方法的执行入口、所属class、方法索引号及所属dex信息，然后想调用旧方法一样的执行到新方法的逻辑。 Native替换方案，比如Andfix和其他安全界的Hook方案，都是写死ArtMethod结构体，这样会带来兼容性问题。Native层替换思路，其实就是替换ArtMethod的所有成员 Sophix采取的是将ArtMethod的作为整体进行替换。 访问权限的问题 方法调用时的权限检查、同包名下的权限问题、反射调用非静态方法问题。 即时生效在什么情况下不适用？ 引起原有类中发生结构变化的修改 修复了的非静态方法会被反射调用 内部类编译 内部类会在编译器会被编译为跟外部类一样的顶级类。 冷启动类加载原理当类结构发生变化时，如新增减少类的method/field再热部署模式下会受到限制，但是冷部署能够达到修复目的。 ##冷启动实现方案 ##插桩实现的前因后果 如果仅仅把补丁类打入补丁包中而不做任何处理的话， 在运行时类加载的时候会异常退出。加载一个dex文件到本地内存时，如果不存在odex文件，首先会执行dexopt，dexopt 的入口在davilk/opt/OptMain.cpp的main方法，最后调用到verifyAndOptimizeClass执行真正的verify/optimize操作。 Apk第一次安装的时候，会对原dex执行dexopt,此时假如apk只存在一个dex，所以dvmVerifyClass(clazz)结果为true,所以apk中所有的类都会被打上CLASS_ISPREVERIFIED标识，接下来执行dvmOptimizeClass，类接着被打上CLASS_ISOPTIMIZED标识。 现在加入A类是补丁类，所以补丁A类在单独的dex中，类B中的某个方法引用到补丁类A，所以执行到该方法会尝试解析类A。 类B由于被打上了CLASS_ISPREVERIFIED标志，接下来referrer是类B，resClassCheck是补丁类A，他们属于不同的dex。所以会提示dvmThrowlllegalAccessError。为了解决这个问题，一个单独无关帮助类放到一个单独的dex中，原dex中所有类的构造函数都引用这个类，一般的实现方法都是侵入dex打包流程，利用.class字节码修改技术，在所有.class文件的构造函数中引用这个帮助类，插桩由此而来。Art下冷启动实现 Dalvik下和Art下对DexFile.loadDex尝试把一个dex文件解析加载到native内存发生了什么？实际都是调用了DexFile.openDexFileNative这个native方法。Dalvik尝试加载一个压缩文件的时候只会去把classes.dex加载到内存中，如果此时内存文件中有多个dex，那么除了classes.dex之外的其他dex被直接忽略掉Art虚拟机方法调用链DexFile-&gt;openDexFileNative-&gt;OpenDexFilesFromat-&gt;LoadDexFilesArt下默认支持加载压缩文件中包含多个dex，首先肯定优先加载primary dex其实就是classes.dex，后续会加载其他的dex。所以补丁类只需要放到classes.dex即可，后续出现在其他dex中的“补丁类“是不会被重复加载的。 Art最终冷启动解决方案 把补丁dex命名为classes.dex。原apk中的dex一次命名为classes(2,3,4…).dex就好了，然后一起打包为一个压缩文件。然后DexFile.LoadDex得到DexFile对象，最后把该DexFile对象整个替换旧的dexElements数据就可以了。 Sophix 和 tinker 方案 补丁dex必须命名为classes.dex loadDex得到的DexFile完整替换掉dexElements数组而不是插入 DexFile.loadDex尝试把一个dex文件解析并加载到native内存，在加载到native内存之前，如果dex不存在对应的odex，那么Dalvik下回执行dexopt，Art下回执行dexoat，最后得到的都是一个优化后的odex，实际上最后虚拟机执行的事这个odex而不是dex。dex足够大那么dexopt/dexoat实际上是很好似的，Dalvik下实际影响比较下，因为loadDex仅仅是补丁包，Art下影响非常大，因为loadDex是补丁dex和apk中原dex合并成一个完整补丁压缩包，所以dexoat非常耗时。如果优化后的odex文件没生成或者没生成一个完整的odex文件，那么loadDex便不能在应用启动的时候进行的，因为会阻塞loadDex线程，一般是主线程。所以解决这个问题，Sophix把loadDex当做一个事务来看，如果中途被打断，那么就删除odex文件，重启的时候如果发现存在odex文件，loadDex完之后，反射注入/替换dexElements数组，实现patch。如果不存在odex文件，那么重启另一子进程loadDex，重启之后在生效。 具体实施方案对Dalvik和Art下 Dalvik下采用自行研发的全量Dex方案 Art下本质上虚拟机已经支持多dex的加载，我们只需把补丁dex作为主dex(classes.dex)加载而已 冷启动方案限制？当新增一个publlic/protected/default方法，会出现方法调用错乱。 Google的dexmerge方案 把补丁dex和原dex合并一个完整的dex。 Dalvik下完整DEX方案的新探索 冷启动类加载修复 对于Android下的冷启动类加载修复，最早的实现方案是QQ空间提出的dex插入方案。主要思想是，把插入新dex插入到ClassLoader索引路径的最前面，这样在load一个class时，优先找到补丁中的。这类插入dex 的方案，会遇到一个主要的问题，就是如何解决Dalvik虚拟机下类的pre-verify问题。 如果一个类 中直接引用到的所有非系统类都和该类在同一个dex里的话，那么这个类就会被打上CLASS_ISPREVERIFIED,具体判定代码可见虚拟机中的verifyAndOptimizeClass函数。 腾讯的三大热修复方案是如何解决这个问题的： QQ控件的处理方式，是在每个类中插入一个来自其他dex的hack.class,由此让所有类里面都无法满足pre-verified条件。 Tinker的方式，是合成全量的dex文件，这样所有class的都在全量dex中解决，从而消除class重复而带来的冲突。 Qfix的方式，是取得虚拟机中的某些底层函数，提前resolve所有补丁类，以此绕过Pre-verify检查。Sophix的方式，补丁中已包含变动的类，主要在原先基线包中dex里边，去掉补丁中已有的class。这样，补丁+去除了补丁类的基线包=app中所有类。参考Android原生multi-dex的实现，是把一个apk所用到的所有类拆分到classes.dex、classes2.dex、classes.dex…之中，而每个dex都只包含了部分的类的定义，但单个dex也是可以加载的，因为只要把所有dex都load进去，本dex中不存在的类就可以在运行期间在其他dex中找到。 #资源热修复技术 ##3.2资源修复InstantRun资源热修复原理： 构造一个新的AssetManager，并通过反射调用addAssetPath，把这个完整的新资源包加入到AssetManger中，这样就得到一个含有所有新资源的AssetManager。 找到所有之前引用到愿你有Assetmanager的地方，通过反射，把引用处替换成新的AssetManager。Sophix 资源热修复原理:构造一个package id 为0x66的资源包，其中包含改变了的资源项，然后直接在原有的AssetManager中addAssetPath这个包就可以了。由于补丁包的package id 为0x66,不与目前已经加载的0x7f冲突，因此直接加入到已有的AssetMananger中就可以直接使用。替换方式更加优雅，直接在原有的AssetManageer对象上进行析构和重构，原先AssetManager对象的引用没有发生改变，不用像InstantRun进行繁琐修改。 ###资源替换方案优势 不修改AssetManager的引用处，替换更快更安全。 不必下发完整包，补丁包中只包含有变动的资源 不要在运行时合成完整包。不占用运行时计算和内存资源。 一个Android进程只包含一个ResTable,ResTable的成员变量mPackageGroups就是所有解析过的资源包的集合。任何 一个资源包中都含有resources.arsc,他记录了所有资源的id分配情况以及资源中的所有字符串。这些信息是以二进制方式存储的。底层的AssetManager做的事就是解析这个文件，然后把相关信息存储到mPackageGroups里面。 资源信息主要是指每隔资源的名称以及他对应的编号。每隔资源，都有唯一编号。 编号是一个32位数字，用十六进制来标识就是0xPPTTEEEE。PP为package id，TT为type id，EEEE为entry id。 运行时资源的解析 默认由Android SDK编出来的apk，是由aapt工具进行打包的，其资源包的package id 是 0x7f。系统的资源包，也就是framework-res.jar，package id 为0x01。在走到app 的第一行代码之前，系统就已经帮我们构造好一个已经添加了安装包资源的AssetManager了。 因此，这个AssetManager里就已经包含了系统资源包以及app的安装包，就是package id 为0x01的framework-res.jar中的资源和package id为0x7f的app安装包资源。 如果此时直接在addAssetPath其实补丁包里的资源是不生效的。因为在getResTable已经执行很多次了。不会发生真正的解析。 ###Sophix资源解决方案 构造一个package id 为0x66的资源包，包含了改变的资源项，然后直接在原有AssetManager中addAssetPath这个包。不与已经加载的0x7f冲突。 而资源的改变包含增加、减少、修改这三种情况，分别是如何处理的呢？ 对于新增资源，直接加入补丁包，然后新代码里直接引用就可以了 对于减少资源，我们只要不使用他就行了，因此不用考虑这种情况，他也不影响补丁包 对于修改资源，比如替换了一张图片之类的情况。我们把它视为新增资源，在打补丁的时候，代码在引用处也会做响应修改，也就是直接把原来使用就资源id的地方变成新id。#3.3 So库修复So库修复本质上是对native方法的修复和替换。Sophix采用的是类似类修复反射注入方式。把补丁so库的路径插入到nativeLibraryDirectories数组的最前面，达到加载so库时时补丁so库，而不是原来so库的目录，从而达到修复的目的。采用这种方案，完全由Sophix在启动期间反射注入patch中的so库。其他方案是手动替换系统的System.load来实现替换目的。Java Api提供一下两个接口加载一个so库 System.loadLibrary(String libName);传进去的参数 so库名称，表示的so库文件，位于apk压缩文件中的libs目录，最后复制到apk安装目录下。 System.load(String pathName)传进去的参数 so库在磁盘中的完整路径。加载一个自定义外部so库文件。两种方式加载一个so库，实际上最后都调用nativeLoad这个native方法去加载so库，这个方法的参数fileName so库在磁盘中的完整路径名。 JNI编程中，动态注册的natvie方法必须实现JNI_ONLoad方法，同时实现一个JNINativeMethod[]数组 ，静态注册的native方法必须是Java+类完整路径+方法名的格式。 ##3.1. SO库冷部署重启生效实现方案 SO库修复方案 接口调用替换方案，需要强制侵入用户接口调用 反射注入方案，重启生效 总结： 动态注册的native方法映射通过加载so库过程中调用JNI_OnLoad方法调用完成 静态注册的native方法映射是在该native方法第一次执行的时候才完成映射，当然前提是该so库已经load过。 ##3.2 SO库热部署实时生效分析 ###3.2.1动态注册native方法实时生效动态注册的native方法调用一次JNI_OnLoad方法都会重新完成一次映射，所以我们是否只要先加载原来的so库，然后在加载补丁so库，就完成Java层native方法到native层patch后的新方法映射，这样就完成动态注册native方法的patch实时修复。 实测发现art下这样是可以实时生效，但Dalvik下做不到试试生效。原因Dalvik第二次load补丁so库，执行的仍然是原来的so库的JNI_OnLoad方法，而不是补丁so库的JNI_OnLoad方法。Dalvik虚拟机下dlopen方法实现，底层方法会校验so库是否已经加载过，方法的判断依据是判断name,如果加载过直接返回该so库的句柄。如果so库从未加载过，则load_library执行加载。所以Dalvik下面加载修复后的补丁so拿到的还是原so库文件的句柄，所以执行的仍然是原so库的JNI_OnLoad方法，Art下不存在问题，因Art下该方法以name作为key去查找不是bname,所以art下重新load一遍补丁so库，拿到的是补丁so库的句柄，然后执行补丁so库的JNI_OnLoad。解决Dalvik下该问题，可对补丁so库进行改名。 ###3.2.2静态注册native方法实时生效静态注册native方法的映射实在native方法第一次执行的时候完成映射，如果native方法在加载补丁so库之前已经执行过，是否这个静态注册native方法一定得不到修复？幸运的是，系统JNI API提供了解注册的接口 UnregisterNatives（JNIEnv* env,jclass jclazz）函数回吧jclazz所在类的所有native方法都重新指向为dvmResolveNativeMethod，所以调用unregisterNatives之后不管是静态注册还是动态注册的native方法之前是否执行过在加载补丁so 的时候都会重新去做映射。所以我们只需要以下调用。 ##3.3 SO库冷部署重启生效实现方案 ###3.3.1.接口调用替换方案Sdk提供接口替换System默认加载so库接口 SOPatchManager。loadLibrary接口加载so库的时候有限尝试去加载sdk指定目录下的补丁so，加载策略如下： 如果存在则加载补丁so库而不会去加载安装apk安装目录下的so库。 如果不存在补丁so，那么调用System.loadLibrary去加载安装apk目录下的so库。 方案优缺点：优点：不需要对不同sdk版本进行兼容，因为所有的SDK版本都有System.loadLibrary这个接口。缺点：调用方需要替换掉System默认加载so库接口为sdk提供的接口，如果是已经编译混淆好的三方库的so库需要patch，那么是很难做到接口的替换。 ###3.3.2反射注入方案System.loadLibrary(“native-lib”)，加载so库的原理，其实native-lib这个 so库最终传给native方法执行的参数是so库在磁盘中的完整路径，比如/data/app-lib/com.taobao.jni-2/libnative-lib.so,so库会在DexPathList.nativeLibraryDirectories/nativeLibraryPathElements变量所表示的目录下去遍历搜索。 可以发现会遍历nativeLibraryDirectories数组，如果找到了IoUtils.canOpenReadOnly(path)返回true，那么就直接返回该path，IoUtils。canOpenReadOnly(path)返回true的前提肯定是需要path标识的so文件存在的。我们可以采取类似类修复反射注入方式，只要把我们的补丁so库的路径插入到nativeLibraryDirectories数组的最前面就能够达到加载so库的时候是补丁so库而不是原来so库的目录，从而达到修复的目的。 Sdk23以上findLibrary 实现已经发生变化，只需把补丁so库的完整路径违参数构建一个Element对象，然后再插入nativeLibraryPathElements数组的最前面就好了。 优点：可以修复三方库的so库。同事接入方不需要想方案1一样强制侵入用户接口调用。缺点：需要不断的对sdk进行适配，如上sdk23为分界线，findLibrary接口实现已发生变化。不管是补丁包还是apk中一个so库存在多种cpu架构的so文件，比如armeabi，arm64-v8a,x86等。加载可定是加载其中一个so库文件的，如何选择机型对应的so库文件将是重点所在。 虚拟机究竟如何选择哪个abis目录作为参数构建PathClassLoader对象，原理如图 实际上补丁so也存在类似的问题，我们的补丁so库文件放到补丁包的libs目录下，libs目录和.dex文件res资源文件一起打包成一个压缩文件作为最后的补丁包，libs目录可能也包含多种abis目录。所以我们需要选择手机最合适的primaryCpuAbi，然后从libs目录下选择这个primaryCpuAbi子目录插入到nativeLibraryDirectories/nativeLibraryPathElements数组。所以怎么选择primaryCpuAbi是关键，具体实现如图： 1.sdk&gt;=21时，直接反射拿到ApplicationInfo对象的primaryCpuAbi即可2.sdk&lt;21时，有雨此时不支持64位，所以直接吧Build.CPU_ABI,Build.CPU_ABI2作为primaryCpuAbi即可。","link":"/2019/10/11/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"},{"title":"23 Android异常处理流程 Android 项目构建流程","text":"前面的几篇文章都是讲解的android中的窗口显示机制，包括Activity窗口加载绘制流程，Dialog窗口加载绘制流程，PopupWindow窗口加载绘制流程，Toast窗口加载绘制流程等等。整个Android的界面显示的原理都是类似的，都是通过Window对象控制View组件，实现加载与绘制流程。 这篇文章休息一下，不在讲解Android的窗口绘制机制，穿插的讲解一下Android系统的异常处理流程。O(∩_∩)O哈哈~ 开发过android项目的童鞋对android系统中错误弹窗，force close应该不陌生了，当我们的App异常崩溃时，就会弹出一个force close的弹窗，告诉我们App崩溃，以及一下简易的错误信息： 那么这里的force close弹窗是如何弹出的呢？ 还有我们在开发App的过程中，经常会自定义Application，自定义UncaughtExceptionHandler实现App的全局异常处理，那么这里的UncaughtExceptionHandler是如何实现对异常的全局处理的呢？（可参考： 在Android中自定义捕获Application全局异常） 带着这两个问题，我们开始今天的异常流程分析。 在android应用进程的启动流程中我们在经过一系列的操作之后会调用RuntimeInit.zygoteInit方法（可参考：Android应用程序进程启动过程的源代码分析） 而我们也是从这里开始分析我们的Android系统异常处理流程，好了，让我们先来看一下zygoteInit方法的具体实现： 1234567891011public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller { if (DEBUG) Slog.d(TAG, &quot;RuntimeInit: Starting application from zygote&quot;); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;RuntimeInit&quot;); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader); } 可以看到在方法体中我们调用了commonInit方法，这个方法是用于初始化操作的，继续看一下commonInit方法的实现： 12345private static final void commonInit() { ... Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); ... }可以看到在这里我们调用了Thread.setDefaultUncaughtExceptionHandler方法，这样当我们的进程出现异常的时候，异常信息就会被我们新创建的UncaughtHandler所捕获。 看过我们前面写过的关于Android全局异常处理文章的童鞋应该知道，我们实现对Android异常全局处理的操作也是通过设置Thread.setDefaultUncaughtExceptionHandler来实现的，具体可参考： 在Android中自定义捕获Application全局异常所以Android系统默认的异常信息都会被这里的UncaughtHandler所捕获并被其uncaughtException方法回调，所以若我们不重写Thread.setDefaultUncaughtExceptionHandler方法，那么这里的UncaughtHandler就是我们默认的异常处理操作 这样我们看一下UncaughtHandler的具体实现： 123456789101112131415161718192021222324252627282930313233343536private static class UncaughtHandler implements Thread.UncaughtExceptionHandler { public void uncaughtException(Thread t, Throwable e) { try { // Don't re-enter -- avoid infinite loops if crash-reporting crashes. if (mCrashing) return; mCrashing = true; if (mApplicationObject == null) { Clog_e(TAG, &quot;*** FATAL EXCEPTION IN SYSTEM PROCESS: &quot; + t.getName(), e); } else { StringBuilder message = new StringBuilder(); message.append(&quot;FATAL EXCEPTION: &quot;).append(t.getName()).append(&quot;\\n&quot;); final String processName = ActivityThread.currentProcessName(); if (processName != null) { message.append(&quot;Process: &quot;).append(processName).append(&quot;, &quot;); } message.append(&quot;PID: &quot;).append(Process.myPid()); Clog_e(TAG, message.toString(), e); } // Bring up crash dialog, wait for it to be dismissed ActivityManagerNative.getDefault().handleApplicationCrash( mApplicationObject, new ApplicationErrorReport.CrashInfo(e)); } catch (Throwable t2) { try { Clog_e(TAG, &quot;Error reporting crash&quot;, t2); } catch (Throwable t3) { // Even Clog_e() fails! Oh well. } } finally { // Try everything to make sure this process goes away. Process.killProcess(Process.myPid()); System.exit(10); } } } 这里uncaughtException方法最终会被执行异常信息的处理，我们看一下在这里我们调用了ActivityManagerNative.getDefault().handleApplicationCrash方法，看过我们前面Activity启动流程的童鞋应该知道这里的ActivityManagerNative其实是ActivityManagerService的Binder客户端，而这里的handleApplicationCrash方法最终会调用的是ActivityManagerService的handleApplicationCrash方法。最后在finally分之中，我们调用了Process.killProcess(Process.myPid)和System.exit(10)，这样我们的应用进程就会退出了。 然后我们在这里先简单的分析一下Binder的数据传输过程，看一下handleApplicationCrash方法具体做了哪些事，首先看一下ActivityManagerNative的getDefault方法是如何实现的？ 123static public IActivityManager getDefault() { return gDefault.get(); } 可以发现，其是一个静态方法，并执行了gDefault.get方法，我们在看一下gDefault.get方法的实现逻辑： 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现这里返回一个IActivityManager类型的am对象，而这个am对象是通过调用asInterface方法创建的，我们再来看一下这个asInterface方法的实现逻辑。 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 可以发现该方法最终返回的是一个ActivityManagerProxy对象，所以ActivityManagerNative.getDefault()方法最终返回的是一个ActivityManagerProxy对象，我们再来看一下ActivityManagerProxy的handleApplicationCrash方法。 12345678910111213public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(app); crashInfo.writeToParcel(data, 0); mRemote.transact(HANDLE_APPLICATION_CRASH_TRANSACTION, data, reply, 0); reply.readException(); reply.recycle(); data.recycle(); } 这里就是具体的Binder传输数据的逻辑了，这里ActivityManagerNative最为Binder的clent端，而我们的ActivityManagerService同样是继承与ActivityManagerNative，最为Binder的server端，通过传输最终ActivityManagerService的handleApplicationCrash方法会被执行。 1234567public void handleApplicationCrash(IBinder app, ApplicationErrorReport.CrashInfo crashInfo) { ProcessRecord r = findAppProcess(app, &quot;Crash&quot;); final String processName = app == null ? &quot;system_server&quot; : (r == null ? &quot;unknown&quot; : r.processName); handleApplicationCrashInner(&quot;crash&quot;, r, processName, crashInfo); } 可以看到在ActivityManagerService的handleApplicationCrash方法中我们调用了handleApplicationCreashInner方法，这样我们继续看一下handleApplicationCrashInner方法的实现。 1234567891011121314void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) { EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber); addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo); crashApplication(r, crashInfo); } 可以发现在handleApplicationCrashInner方法中主要调用了两个方法addErrorToDropBox和crashApplication，我们首先看一下addErrorToDropBox方法的实现逻辑。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File logFile, final ApplicationErrorReport.CrashInfo crashInfo) { // NOTE -- this must never acquire the ActivityManagerService lock, // otherwise the watchdog may be prevented from resetting the system. final String dropboxTag = processClass(process) + &quot;_&quot; + eventType; final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE); // Exit early if the dropbox isn't configured to accept this report type. if (dbox == null || !dbox.isTagEnabled(dropboxTag)) return; final StringBuilder sb = new StringBuilder(1024); appendDropBoxProcessHeaders(process, processName, sb); if (activity != null) { sb.append(&quot;Activity: &quot;).append(activity.shortComponentName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent.app != null &amp;&amp; parent.app.pid != process.pid) { sb.append(&quot;Parent-Process: &quot;).append(parent.app.processName).append(&quot;\\n&quot;); } if (parent != null &amp;&amp; parent != activity) { sb.append(&quot;Parent-Activity: &quot;).append(parent.shortComponentName).append(&quot;\\n&quot;); } if (subject != null) { sb.append(&quot;Subject: &quot;).append(subject).append(&quot;\\n&quot;); } sb.append(&quot;Build: &quot;).append(Build.FINGERPRINT).append(&quot;\\n&quot;); if (Debug.isDebuggerConnected()) { sb.append(&quot;Debugger: Connected\\n&quot;); } sb.append(&quot;\\n&quot;); // Do the rest in a worker thread to avoid blocking the caller on I/O // (After this point, we shouldn't access AMS internal data structures.) Thread worker = new Thread(&quot;Error dump: &quot; + dropboxTag) { @Override public void run() { if (report != null) { sb.append(report); } if (logFile != null) { try { sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE, &quot;\\n\\n[[TRUNCATED]]&quot;)); } catch (IOException e) { Slog.e(TAG, &quot;Error reading &quot; + logFile, e); } } if (crashInfo != null &amp;&amp; crashInfo.stackTrace != null) { sb.append(crashInfo.stackTrace); } String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag; int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0); if (lines &gt; 0) { sb.append(&quot;\\n&quot;); // Merge several logcat streams, and take the last N lines InputStreamReader input = null; try { java.lang.Process logcat = new ProcessBuilder(&quot;/system/bin/logcat&quot;, &quot;-v&quot;, &quot;time&quot;, &quot;-b&quot;, &quot;events&quot;, &quot;-b&quot;, &quot;system&quot;, &quot;-b&quot;, &quot;main&quot;, &quot;-b&quot;, &quot;crash&quot;, &quot;-t&quot;, String.valueOf(lines)).redirectErrorStream(true).start(); try { logcat.getOutputStream().close(); } catch (IOException e) {} try { logcat.getErrorStream().close(); } catch (IOException e) {} input = new InputStreamReader(logcat.getInputStream()); int num; char[] buf = new char[8192]; while ((num = input.read(buf)) &gt; 0) sb.append(buf, 0, num); } catch (IOException e) { Slog.e(TAG, &quot;Error running logcat&quot;, e); } finally { if (input != null) try { input.close(); } catch (IOException e) {} } } dbox.addText(dropboxTag, sb.toString()); } }; if (process == null) { // If process is null, we are being called from some internal code // and may be about to die -- run this synchronously. worker.run(); } else { worker.start(); } } 可以看到方法体很长，但是逻辑比较简单，在方法体最后通过判断应用进程是否为空（是否被销毁）来执行worker.run方法或者是worker.start方法，这里的worker是一个Thread对象，而在我们的worker对象的run方法中主要的执行逻辑就是将崩溃信息写入系统log中，所以addErrorToDropBox方法的主要执行逻辑就是讲App的崩溃信息写入系统log中。。。。 继续回到我们的handleApplicationCrashInner方法中，看一下crashApplication方法是如何实现的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private void crashApplication(ProcessRecord r, ApplicationErrorReport.CrashInfo crashInfo) { long timeMillis = System.currentTimeMillis(); String shortMsg = crashInfo.exceptionClassName; String longMsg = crashInfo.exceptionMessage; String stackTrace = crashInfo.stackTrace; if (shortMsg != null &amp;&amp; longMsg != null) { longMsg = shortMsg + &quot;: &quot; + longMsg; } else if (shortMsg != null) { longMsg = shortMsg; } AppErrorResult result = new AppErrorResult(); synchronized (this) { if (mController != null) { try { String name = r != null ? r.processName : null; int pid = r != null ? r.pid : Binder.getCallingPid(); int uid = r != null ? r.info.uid : Binder.getCallingUid(); if (!mController.appCrashed(name, pid, shortMsg, longMsg, timeMillis, crashInfo.stackTrace)) { if (&quot;1&quot;.equals(SystemProperties.get(SYSTEM_DEBUGGABLE, &quot;0&quot;)) &amp;&amp; &quot;Native crash&quot;.equals(crashInfo.exceptionClassName)) { Slog.w(TAG, &quot;Skip killing native crashed app &quot; + name + &quot;(&quot; + pid + &quot;) during testing&quot;); } else { Slog.w(TAG, &quot;Force-killing crashed app &quot; + name + &quot; at watcher's request&quot;); if (r != null) { r.kill(&quot;crash&quot;, true); } else { // Huh. Process.killProcess(pid); killProcessGroup(uid, pid); } } return; } } catch (RemoteException e) { mController = null; Watchdog.getInstance().setActivityController(null); } } final long origId = Binder.clearCallingIdentity(); // If this process is running instrumentation, finish it. if (r != null &amp;&amp; r.instrumentationClass != null) { Slog.w(TAG, &quot;Error in app &quot; + r.processName + &quot; running instrumentation &quot; + r.instrumentationClass + &quot;:&quot;); if (shortMsg != null) Slog.w(TAG, &quot; &quot; + shortMsg); if (longMsg != null) Slog.w(TAG, &quot; &quot; + longMsg); Bundle info = new Bundle(); info.putString(&quot;shortMsg&quot;, shortMsg); info.putString(&quot;longMsg&quot;, longMsg); finishInstrumentationLocked(r, Activity.RESULT_CANCELED, info); Binder.restoreCallingIdentity(origId); return; } // Log crash in battery stats. if (r != null) { mBatteryStatsService.noteProcessCrash(r.processName, r.uid); } // If we can't identify the process or it's already exceeded its crash quota, // quit right away without showing a crash dialog. if (r == null || !makeAppCrashingLocked(r, shortMsg, longMsg, stackTrace)) { Binder.restoreCallingIdentity(origId); return; } Message msg = Message.obtain(); msg.what = SHOW_ERROR_MSG; HashMap data = new HashMap(); data.put(&quot;result&quot;, result); data.put(&quot;app&quot;, r); msg.obj = data; mUiHandler.sendMessage(msg); Binder.restoreCallingIdentity(origId); } int res = result.get(); Intent appErrorIntent = null; synchronized (this) { if (r != null &amp;&amp; !r.isolated) { // XXX Can't keep track of crash time for isolated processes, // since they don't have a persistent identity. mProcessCrashTimes.put(r.info.processName, r.uid, SystemClock.uptimeMillis()); } if (res == AppErrorDialog.FORCE_QUIT_AND_REPORT) { appErrorIntent = createAppErrorIntentLocked(r, timeMillis, crashInfo); } } if (appErrorIntent != null) { try { mContext.startActivityAsUser(appErrorIntent, new UserHandle(r.userId)); } catch (ActivityNotFoundException e) { Slog.w(TAG, &quot;bug report receiver dissappeared&quot;, e); } } } 可以发现在方法体中我们调用了mUiHandler.sendMessage(msg)，其中mUiHandler是一个在主线程中创建的Handler对象，而这里的msg是一个what值为SHOW_ERROR_MSG的消息，这句话的本质就是向Ui线程中发送一个异步消息。我们来看一下mUiHander的处理逻辑。 在mUiHandler的handeMessage方法中，根据what值得不同，执行了如下逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243case SHOW_ERROR_MSG: { HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) msg.obj; boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0; synchronized (ActivityManagerService.this) { ProcessRecord proc = (ProcessRecord)data.get(&quot;app&quot;); AppErrorResult res = (AppErrorResult) data.get(&quot;result&quot;); if (proc != null &amp;&amp; proc.crashDialog != null) { Slog.e(TAG, &quot;App already has crash dialog: &quot; + proc); if (res != null) { res.set(0); } return; } boolean isBackground = (UserHandle.getAppId(proc.uid) &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; proc.pid != MY_PID); for (int userId : mCurrentProfileIds) { isBackground &amp;= (proc.userId != userId); } if (isBackground &amp;&amp; !showBackground) { Slog.w(TAG, &quot;Skipping crash dialog of &quot; + proc + &quot;: background&quot;); if (res != null) { res.set(0); } return; } if (mShowDialogs &amp;&amp; !mSleeping &amp;&amp; !mShuttingDown) { Dialog d = new AppErrorDialog(mContext, ActivityManagerService.this, res, proc); d.show(); proc.crashDialog = d; } else { // The device is asleep, so just pretend that the user // saw a crash dialog and hit &quot;force quit&quot;. if (res != null) { res.set(0); } } } ensureBootCompleted(); } 可以看到在方法体中我们创建了一个AppErrorDialog对象，并执行了show方法，这样该Dialog就会被显示出来。而这里的Dialog的显示内容就是：App already has crash dialog: …. O(∩_∩)O哈哈~，原来我们App崩溃的时候弹出昂的异常提示框就是在这里弹出来的。这里对AppErrorDialog不做过多的介绍，在其的构造方法中，调用了如下的代码： 1234// After the timeout, pretend the user clicked the quit button mHandler.sendMessageDelayed( mHandler.obtainMessage(FORCE_QUIT), DISMISS_TIMEOUT); 这里的常量DISMISS_TIME = 5 60 1000，也就是五分钟，相当于这里发送了一个延时异步消息五分钟之后取消崩溃弹窗的显示。所以我们的App若果崩溃之后不主动取消弹窗，崩溃弹窗也会默认在五分钟之后取消。 好吧，文章开头我们所提到的两个问题我们已经解决掉一个了，force close弹窗是如何弹出来的，相信大家已经有所了解了，其实第二个问题也已经说明了，我们知道系统默认的App异常处理流程就是从Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler());开始的，并创建了自己的UncaughtHandler对象，那么我们接管系统默认的异常处理逻辑其实也就是从Thread.setDefaultUncaughtExceptionHandler开始的，并重写其uncaughtException方法，那么App异常信息就会被我们自定义的UncaughtHandler所捕获，捕获之后奔溃信息的记录与上报就可以做定制了。。。 这样我们就大概分析完成了Android系统的异常处理流程。O(∩_∩)O哈哈~ 总结： App应用进程启动时会经过一系列的调用，执行Thread.setDefaultUncaughtExceptionHandler方法，创建默认的UncaughtHandler异常处理对象。 默认的UncaughtHandler异常处理对象，在其回调方法uncaughtException方法中会执行弹窗异常弹窗的操作，这也就是我们原生的force close弹窗，并且弹窗如果不主动取消的话，会在五分钟内默认取消。 自定义App的全局异常处理逻辑，需要接管UncaughtHandler，也就是创建自身的UncaughtHandler对象，并调用Thread.setDefaultUncaughtExceptionHandler方法，接管默认的异常处理逻辑。 force close弹窗，弹窗的时候App应用可能已经退出，该弹窗的弹窗是SystemServer进程中的ActivityManagerService服务控制的。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程","link":"/2020/09/11/Android%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"},{"title":"19 Dialog加载绘制流程","text":"前面两篇文章，我们分析了Activity的布局文件加载、绘制流程，算是对整个Android系统中界面的显示流程有了一个大概的了解，其实Android系统中所有的显示控件（注意这里是控件，而不是组件）的加载绘制流程都是类似的，包括：Dialog的加载绘制流程，PopupWindow的加载绘制流程，Toast的显示原理等，上一篇文章中，我说在介绍了Activity界面的加载绘制流程之后，就会分析一下剩余几个控件的显示控制流程，这里我打算先分析一下Dialog的加载绘制流程。 可能有的同学问这里为什么没有Fragment？其实严格意义上来说Fragment并不是一个显示控件，而只是一个显示组件。为什么这么说呢？其实像我们的Activity，Dialog，PopupWindow以及Toast类的内部都管理维护着一个Window对象，这个Window对象不但是一个View组件的集合管理对象，它也实现了组件的加载与绘制流程，而我们的Fragment组件如果看过源码的话，严格意义上来说，只是一个View组件的集合并通过控制变量实现了其特定的生命周期，但是其由于并没有维护Window类型的成员变量，所以其不具备组件的加载与绘制功能，因此其不能单独的被绘制出来，这也是我把它称之为组件而不是控件的原因。（在分析完这几个控件的加载绘制流程之后，有时间的话，也会分析一下Fragment的相关源码） 好吧，开始我们今天关于Dialog的讲解，相信大家在平时的开发过程中经常会使用到Dialog弹窗，使用Dialog可以在Activity弹出弹窗，确认消息等。为了更好的分析Dialog的源码，我们这里暂时写一个简单的demo，看一下Dialog的使用实例。 12345678910111213141516171819title.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setIcon(R.mipmap.ic_launcher); builder.setMessage(&quot;this is the content view!!!&quot;); builder.setTitle(&quot;this is the title view!!!&quot;); builder.setView(R.layout.activity_second); builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); alertDialog = builder.create(); alertDialog.show(); } }); 我们在Activity中获取一个textView组件，并监听TextView的点击事件，并在点击事件中，初始化一个AlertDialog弹窗，并执行AlertDialog的show方法展示弹窗，在弹窗中定义一个按钮，并监听弹窗按钮的点击事件，若用户点击了弹窗的按钮，则执行AlertDialog的dismiss方法，取消展示AlertDialog。好吧，我们来看一下这个弹窗弹出的展示结果：可以看到我们定义的icon，title，message和button都已经显示出来了，这时候我们点击弹窗按钮知道了，这时候弹窗就会消失了。 一般我们使用Dialog的大概流程都是这样的，可能定制Dialog的时候有一些定制化的操作，但是基本操作流程还是这样的。 那么我们先来看一下AlertDialog.Builder的构造方法，这里的Builder是AlertDialog的内部类，用于封装AlertDialog的构造过程，看一下Builder的构造方法： 123public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); }好吧，这里调用的是Builder的重载构造方法： 1234public Builder(Context context, int themeResId) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); } 那么这里的P是AlertDialog.Builder中的一个AlertController.AlertParams类型的成员变量，可见在这里执行了P的初始化操作。 12345public AlertParams(Context context) { mContext = context; mCancelable = true; mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); } 可以看到这里主要执行了AlertController.AlertParams的初始化操作，初始化了一些成员变量。这样执行了一系列操作之后我们的代码： 1AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); 就已经执行完成了，然后我们调用了builder.setIcon方法，这里看一下setIcon方法的具体实现： 1234public Builder setIcon(@DrawableRes int iconId) { P.mIconId = iconId; return this; } 可以看到AlertDialog的Builder的setIcon方法，这里执行的就是给类型为AlertController.AlertParams的P的mIconId赋值为传递的iconId，并且这个方法返回的类型就是Builder。 然后我们调用了builder.setMessage方法，可以看一下builder.setMessage方法的具体实现： 1234public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } 好吧，这里跟setIcon方法的实现逻辑类似，都是给成员变量的mMessage赋值为我们传递的Message值，且和setIcon方法类似的，这个方法返回值也是Builder。 再看一下builder.setTitle方法： 1234public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } 可以发现builder的setIcon、setMessage、setTitle等方法都是给Builder的成员变量P的icon，message，title赋值。 然后我们看一下builder.setView方法： 123456public Builder setView(int layoutResId) { P.mView = null; P.mViewLayoutResId = layoutResId; P.mViewSpacingSpecified = false; return this; } 可以发现这里的setView和setIcon，setMessage，setTitle等方法都是类似的，都是将我们传递的数据值赋值给Builder的成员变量P。 然后我们调用了builder.setPositiveButton方法： 123456builder.setPositiveButton(&quot;知道了&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { alertDialog.dismiss(); } }); 好吧，这里我们看一下builder的setPositiveButton的源码： 12345public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } 好吧，可以发现跟上面几个方法还是类似的，都是为Builder的成员变量P的相应成员变量赋值。。。 上面的几行代码我们都是调用的builder.setXXX等方法，主要就是为Builder的成员变量P的相应成员变量值赋值。并且setXX方法返回值都是Builder类型的，因此我们可以通过消息琏的方式连续执行： 1builder.setIcon().setMessage().setTitle().setView().setPositiveButton()... 这样代码显得比较简洁，set方法的执行顺序是没有固定模式的，这里多说一下，这种编程方式很优秀，平时我们在设计构造类工具类的时候也可以参考这种模式，构造类有不同的功能或者特性，并且都不是必须的，我们可以通过set方法设置不同的特性值并返回构造类本身。 然后我们调用了builder.create方法，并且这个方法返回了AlertDialog。 123456789101112131415public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } 可以看到这里首先构造了一个AlertDialog，我们可以看一下这个构造方法的具体实现： 1234567AlertDialog(Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { super(context, createContextThemeWrapper ? resolveDialogTheme(context, themeResId) : 0, createContextThemeWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); } 可以看到这里首先调用了super的构造方法，而我们的AlertDialog继承于Dialog，所以这里执行的就是Dialog的构造方法，好吧，继续看一下Dialog的构造方法： 1234567891011121314151617181920212223Dialog(@NonNull Context context, @StyleRes int themeResId, boolean createContextThemeWrapper) { if (createContextThemeWrapper) { if (themeResId == 0) { final TypedValue outValue = new TypedValue(); context.getTheme().resolveAttribute(R.attr.dialogTheme, outValue, true); themeResId = outValue.resourceId; } mContext = new ContextThemeWrapper(context, themeResId); } else { mContext = context; } mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); final Window w = new PhoneWindow(mContext); mWindow = w; w.setCallback(this); w.setOnWindowDismissedCallback(this); w.setWindowManager(mWindowManager, null, null); w.setGravity(Gravity.CENTER); mListenersHandler = new ListenersHandler(this); } 可以发现在Dialog的构造方法中直接直接构造了一个PhoneWindow，并赋值给Dialog的成员变量mWindow，从这里可以看出其实Dialog和Activity的显示逻辑都是类似的，都是通过对应的Window变量来实现窗口的加载与显示的。然后我们执行了一些Window对象的初始化操作，比如设置回调函数为本身，然后调用了Window类的setWindowManager方法，并传入了WindowManager，可以发现这里的WindowManager对象是通过方法： 1mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE); 获取的，而我们的context传入的是Activity对象，所以这里的WindowManager对象其实和Activity获取的WindowManager对象是一致的。然后我们看一下window类的setWindowManager方法： 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 可以看到跟Activity的Window对象的windowManager的获取方式是相同的，都是通过new的方式创建一个新的WindowManagerImpl对象。好吧，继续回到我们的AlertDialog的构造方法中，在构造方法中，我们除了调用Dialog的构造方法之外还执行了： 1mAlert = new AlertController(getContext(), this, getWindow()); 相当于初始化了AlertDiaog的成员变量mAlert。 继续回到我们的AlertDialog.Builder.create方法，在创建了一个AlertDialog之后，又执行了P.apply(dialog.mAlert)；我们知道这里的P是一个AlertController.AlertParams的变量，而dialog.mAlert是我们刚刚创建的AlertDialog中的一个AlertController类型的变量，我们来看一下apply方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051ublic void apply(AlertController dialog) { if (mCustomTitleView != null) { dialog.setCustomTitle(mCustomTitleView); } else { if (mTitle != null) { dialog.setTitle(mTitle); } if (mIcon != null) { dialog.setIcon(mIcon); } if (mIconId != 0) { dialog.setIcon(mIconId); } if (mIconAttrId != 0) { dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); } } if (mMessage != null) { dialog.setMessage(mMessage); } if (mPositiveButtonText != null) { dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); } if (mNegativeButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); } if (mNeutralButtonText != null) { dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); } if (mForceInverseBackground) { dialog.setInverseBackgroundForced(true); } // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) { createListView(dialog); } if (mView != null) { if (mViewSpacingSpecified) { dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); } else { dialog.setView(mView); } } else if (mViewLayoutResId != 0) { dialog.setView(mViewLayoutResId); } } 看到了么？就是我们在初始化AlertDialog.Builder的时候设置的icon、title、message赋值给了AlertController.AlertParams，这里就是将我们初始化时候设置的属性值赋值给我们创建的Dialog对象的mAlert成员变量。。。。 继续我们的AlertDialog.Builder.create方法，在执行了AlertController.AlertParams.apply方法之后又调用了： 1dialog.setCancelable(P.mCancelable); 可以发现这个也是AertController.AlertParams的一个成员变量，我们在初始化AlertDialog.Builder的时候也可以通过设置builder.setCancelable赋值，由于该属性为成员变量，所以默认值为false，而我们并没有通过builder.setCancelable修改这个属性值，所以这里设置的dialog的cancelable的值为false。然后我们的create方法有设置了dialog的cancelListener和dismissListener并返回了我们创建的Dialog对象。这样我们就获取到了我们的Dialog对象，然后我们调用了dialog的show方法用于显示dialog，好吧，这里我们看一下show方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public void show() { if (mShowing) { if (mDecor != null) { if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR); } mDecor.setVisibility(View.VISIBLE); } return; } mCanceled = false; if (!mCreated) { dispatchOnCreate(null); } onStart(); mDecor = mWindow.getDecorView(); if (mActionBar == null &amp;&amp; mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) { final ApplicationInfo info = mContext.getApplicationInfo(); mWindow.setDefaultIcon(info.icon); mWindow.setDefaultLogo(info.logo); mActionBar = new WindowDecorActionBar(this); } WindowManager.LayoutParams l = mWindow.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) { WindowManager.LayoutParams nl = new WindowManager.LayoutParams(); nl.copyFrom(l); nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION; l = nl; } try { mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); } finally { } } 方法体的内容比较多，我们慢慢看，由于一开始mShowing变量用于表示当前dialog是否正在显示，由于我们刚刚开始调用执行show方法，所以这里的mShowing变量的值为false，所以if分支的内容不会被执行，继续往下看： 123if (!mCreated) { dispatchOnCreate(null); } mCreated这个控制变量控制dispatchOnCreate方法只被执行一次，由于我们是第一次执行，所以这里会执行dispatchOnCreate方法，好吧，我们看一下dispatchOnCreate方法的执行逻辑： 123456void dispatchOnCreate(Bundle savedInstanceState) { if (!mCreated) { onCreate(savedInstanceState); mCreated = true; } } 好吧，可以看到代码的执行逻辑很简单就是回调了Dialog的onCreate方法，那么onCreate方法内部又执行了那些逻辑呢？由于我们创建的是AlertDialog对象，该对象继承于Dialog，所以我们这时候需要看一下AlertDialog的onCreate方法的执行逻辑： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent(); } 可以看到这里面除了调用super.onCreate方法之外就是调用了mAlert.installContent方法，而这里的super.onCreate方法就是调用的Dialog的onCreate方法，Dialog的onCreate方法只是一个空的实现逻辑，所以我们具体来看一下mAlert.installContent的实现逻辑。 12345678public void installContent() { /* We use a custom title so never request a window title */ mWindow.requestFeature(Window.FEATURE_NO_TITLE); int contentView = selectContentView(); mWindow.setContentView(contentView); setupView(); setupDecor(); } 可以看到这里实现Window窗口的页面设置布局初始化等操作，这里设置了mWindow对象为NO_TITLE，然后通过调用selectContentView设置Window对象的布局文件。 12345678910private int selectContentView() { if (mButtonPanelSideLayout == 0) { return mAlertDialogLayout; } if (mButtonPanelLayoutHint == AlertDialog.LAYOUT_HINT_SIDE) { return mButtonPanelSideLayout; } // TODO: use layout hint side for long messages/lists return mAlertDialogLayout; } 可以看到这里通过执行selectContentView方法返回布局文件的id值，这里的默认值是mAlertDialogLayout。看过Activity布局加载流程（android源码解析（十七）–&gt;Activity布局加载流程）的童鞋应该知道，从这个方法开始我们就把指定布局文件的内容加载到内存中的Window对象中。我们这里看一下具体的布局文件。 12mAlertDialogLayout = a.getResourceId( R.styleable.AlertDialog_layout, R.layout.alert_dialog); 也就是R.layout.alert_dialog的布局文件，有兴趣的同学可以看一下该布局文件的源码，O(∩_∩)O哈哈~ 继续回到我们的installContent方法，在执行了mWindow.setContentView方法之后，又调用了setupView方法和setupDector方法，这两个方法的主要作用就是初始化布局文件中的组件和Window对象中的mDector成员变量，这里就不在详细的说明。 然后回到我们的show方法，在执行了dispatchOnCreate方法之后我们又调用了onStart方法，这个方法主要用于设置ActionBar，这里不做过多的说明，然后初始化WindowManager.LayoutParams对象，并最终调用我们的mWindowManager.addView()方法。 O(∩_∩)O哈哈~，到了这一步大家如果看了上一篇Acitivty布局绘制流程的话，就应该知道顺着这个方法整个Dialog的界面就会被绘制出来了。 最后我们调用了sendShowMessage方法，可以看一下这个方法的实现： 123456private void sendShowMessage() { if (mShowMessage != null) { // Obtain a new message so this dialog can be re-used Message.obtain(mShowMessage).sendToTarget(); } } 这里会发送一个Dialog已经显示的异步消息，该消息最终会在ListenersHandler中的handleMessage方法中被执行： 12345678910111213141516171819202122private static final class ListenersHandler extends Handler { private WeakReference&lt;DialogInterface&gt; mDialog; public ListenersHandler(Dialog dialog) { mDialog = new WeakReference&lt;DialogInterface&gt;(dialog); } @Override public void handleMessage(Message msg) { switch (msg.what) { case DISMISS: ((OnDismissListener) msg.obj).onDismiss(mDialog.get()); break; case CANCEL: ((OnCancelListener) msg.obj).onCancel(mDialog.get()); break; case SHOW: ((OnShowListener) msg.obj).onShow(mDialog.get()); break; } } } 由于我们的msg.what = SHOW,所以会执行OnShowListener.onShow方法，那么这个OnShowListener是何时赋值的呢？还记得我们构造AlertDialog.Builder么？ 123456alertDialog.setOnShowListener(new DialogInterface.OnShowListener() { @Override public void onShow(DialogInterface dialog) { } }); 这样就为我们的AlertDialog.Builder设置了OnShowListener，可以看一下setOnShowListener方法的具体实现： 1234567public void setOnShowListener(OnShowListener listener) { if (listener != null) { mShowMessage = mListenersHandler.obtainMessage(SHOW, listener); } else { mShowMessage = null; } } 这样就为我们的Dialog中的mListenersHandler构造了Message对象，并且当我们在Dialog中发送showMessage的时候被mListenersHandler所接收。。。。 注：这里说一下我们平时开发中若创建的Dialog使用的Context对象不是Activity，就会报出： 12345678910111213141516Process: com.example.aaron.helloworld, PID: 11948 android.view.WindowManager$BadTokenException: Unable to add window -- token null is not for an applicationat android.view.ViewRootImpl.setView(ViewRootImpl.java:690)at android.view.WindowManagerGlobal.addView(WindowManagerGlobal.java:282)at android.view.WindowManagerImpl.addView(WindowManagerImpl.java:69)at android.app.Dialog.show(Dialog.java:298)at com.example.aaron.helloworld.MainActivity$1.onClick(MainActivity.java:59)at android.view.View.performClick(View.java:4811)at android.view.View$PerformClick.run(View.java:20136)at android.os.Handler.handleCallback(Handler.java:815)at android.os.Handler.dispatchMessage(Handler.java:104)at android.os.Looper.loop(Looper.java:194)at android.app.ActivityThread.main(ActivityThread.java:5552)at java.lang.reflect.Method.invoke(Native Method)at java.lang.reflect.Method.invoke(Method.java:372)at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964)at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 的异常，这是由于WindowManager.addView方法最终会调用ViewRootImpl.setView方法，而这时候会有mToken的检查，若我们传入的Context对象不是Activity，这时候的mToken为空，就会出现上述问题。。。 总结： Dialog和Activity的显示逻辑是相似的都是内部管理这一个Window对象，用WIndow对象实现界面的加载与显示逻辑； Dialog中的Window对象与Activity中的Window对象是相似的，都对应着一个WindowManager对象； Dialog相关的几个类：Dialog，AlertDialog，AlertDialog.Builder，AlertController，AlertController.AlertParams，其中Dialog是窗口的父类，主要实现Window对象的初始化和一些共有逻辑，而AlertDialog是具体的Dialog的操作实现类，AlertDialog.Builder类是AlertDialog的内部类，主要用于构造AlertDialog，AlertController是AlertDialog的控制类，AlertController.AlertParams类是控制参数类； 构造显示Dialog的一般流程，构造AlertDialog.Builder，然后设置各种属性，最后调用AlertDialog.Builder.create方法获取AlertDialog对象，并且create方法中会执行，构造AlertDialog，设置dialog各种属性的操作。最后我们调用Dialog.show方法展示窗口，初始化Dialog的布局文件，Window对象等，然后执行mWindowManager.addView方法，开始执行绘制View的操作，并最终将Dialog显示出来； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程","link":"/2020/09/11/Dialog%E5%8A%A0%E8%BD%BD%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"9 SystemServer进程启动流程","text":"转载请标明出处：一片枫叶的专栏 上面一文中我们讲过android系统中比较重要的几个进程：init进程，Zygote进程，SystemServer进程已经各种应用进程，其中Zygote进程是整个android系统的根进程，包含SystemServer进程已经各种应用进程在内的进程都是通过Zygote进程fork出来的，具体可参见： android源码解析之（八）–&gt;Zygote进程启动流程那么SystemServer进程是做什么用的呢？ 其实SystemServer进程主要的作用是在这个进程中启动各种系统服务，比如ActivityManagerService，PackageManagerService，WindowManagerService服务，以及各种系统性的服务其实都是在SystemServer进程中启动的，而当我们的应用需要使用各种系统服务的时候其实也是通过与SystemServer进程通讯获取各种服务对象的句柄的。 由上一篇文章我们知道SystemServer进程其实也是有Zygote进程fork出来的，并且执行其main方法，那么这里我们以android23的源码为例，看一下SystemServer的main方法的执行逻辑： 123456/** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } 这里比较简单，只是new出一个SystemServer对象并执行其run方法，查看SystemServer类的定义我们知道其实final类型的，所以我们一般不能重写或者继承。 然后我们查看run方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110private void run() { // If a device's clock is before 1970 (before 0), a lot of // APIs crash dealing with negative numbers, notably // java.io.File#setLastModified, so instead we fake it and // hope that time from cell towers or NTP fixes it shortly. if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } // If the system has &quot;persist.sys.language&quot; and friends set, replace them with // &quot;persist.sys.locale&quot;. Note that the default locale at this point is calculated // using the &quot;-Duser.locale&quot; command line flag. That flag is usually populated by // AndroidRuntime using the same set of system properties, but only the system_server // and system apps are allowed to set them. // // NOTE: Most changes made here will need an equivalent change to // core/jni/AndroidRuntime.cpp if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } // Here we go! Slog.i(TAG, &quot;Entered the Android system server!&quot;); EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_SYSTEM_RUN, SystemClock.uptimeMillis()); // In case the runtime switched since last boot (such as when // the old runtime was removed in an OTA), set the system // property so that it is in sync. We can't do this in // libnativehelper's JniInvocation::Init code where we already // had to fallback to a different runtime because it is // running as root and we need to be the system user to set // the property. http://b/11463182 SystemProperties.set(&quot;persist.sys.dalvik.vm.lib.2&quot;, VMRuntime.getRuntime().vmLibrary()); // Enable the sampling profiler. if (SamplingProfilerIntegration.isEnabled()) { SamplingProfilerIntegration.start(); mProfilerSnapshotTimer = new Timer(); mProfilerSnapshotTimer.schedule(new TimerTask() { @Override public void run() { SamplingProfilerIntegration.writeSnapshot(&quot;system_server&quot;, null); } }, SNAPSHOT_INTERVAL, SNAPSHOT_INTERVAL); } // Mmmmmm... more memory! VMRuntime.getRuntime().clearGrowthLimit(); // The system server has to run all of the time, so it needs to be // as efficient as possible with its memory usage. VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // Some devices rely on runtime fingerprint generation, so make sure // we've defined it before booting further. Build.ensureFingerprintProperty(); // Within the system server, it is an error to access Environment paths without // explicitly specifying a user. Environment.setUserRequired(true); // Ensure binder calls into the system always run at foreground priority. BinderInternal.disableBackgroundScheduling(true); // Prepare the main looper thread (this thread). android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); Looper.prepareMainLooper(); // Initialize native services. System.loadLibrary(&quot;android_servers&quot;); // Check whether we failed to shut down last time we tried. // This call may not return. performPendingShutdown(); // Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } // For debug builds, log event loop stalls to dropbox for analysis. if (StrictMode.conditionallyEnableDebugLogging()) { Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); } // Loop forever. Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 好吧，代码比较多，慢慢看。。。 1234if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } 首先判断系统当前时间，若当前时间小于1970年1月1日，则一些初始化操作可能会处所，所以当系统的当前时间小于1970年1月1日的时候，设置系统当前时间为该时间点。 然后代码： 12345678if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } 主要是设置系统的语言环境等；下面的主要是设置虚拟机运行内存，加载运行库，设置SystemServer的异步消息，具体的异步消息机制可参见： android源码解析之（二）–&gt;异步消息机制 然后下面的代码是： 1234567891011121314151617// Initialize the system context. createSystemContext(); // Create the system service manager. mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); // Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 首先调用createSystemContext()方法： 12345private void createSystemContext() { ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar); } 可以看到在SystemServer进程中也存在着Context对象，并且是通过ActivityThread.systemMain方法创建context的，这一部分的逻辑以后会通过介绍Activity的启动流程来介绍，这里就不在扩展，只知道在SystemServer进程中也需要创建Context对象。 然后通过SystemServiceManager的构造方法创建了一个新的SystemServiceManager对象，我们知道SystemServer进程主要是用来构建系统各种service服务的，而SystemServiceManager就是这些服务的管理对象。 然后调用： 1LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); 是将SystemServiceManager对象保存SystemServer进程中的一个数据结构中。 最后开始执行： 12345678910// Start services. try { startBootstrapServices(); startCoreServices(); startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } 里面主要涉及了是三个方法：startBootstrapServices() 主要用于启动系统Boot级服务startCoreServices() 主要用于启动系统核心的服务startOtherServices() 主要用于启动一些非紧要或者是非需要及时启动的服务 下面我们重点介绍这三个启动服务的方法，包括启动那些系统服务已经如何启动系统服务等。 首先看一下startBootstrapServices方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void startBootstrapServices() { // Wait for installd to finish starting up so that it has a chance to // create critical directories such as /data/user with the appropriate // permissions. We need this to complete before we initialize other services. Installer installer = mSystemServiceManager.startService(Installer.class); // Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); // Power manager needs to be started early because other services need it. // Native daemons may be watching for it to be registered so it must be ready // to handle incoming binder calls immediately (including being able to verify // the permissions for those calls). mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // Now that the power manager has been started, let the activity manager // initialize power management features. mActivityManagerService.initPowerManagement(); // Manages LEDs and display backlight so we need it to bring up the display. mSystemServiceManager.startService(LightsService.class); // Display manager is needed to provide display metrics before package manager // starts up. mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); // We need the default display before we can initialize the package manager. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); // Only run &quot;core&quot; apps if we're encrypting the device. String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; } // Start the package manager. Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Slog.i(TAG, &quot;User Service&quot;); ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); // Initialize attribute cache used to cache resources from packages. AttributeCache.init(mSystemContext); // Set up the Application instance for the system process and get started. mActivityManagerService.setSystemProcess(); // The sensor service needs access to package manager service, app ops // service, and permissions service, therefore we start it after them. startSensorService(); } 首先执行： 1Installer installer = mSystemServiceManager.startService(Installer.class); mSystemServiceManager是系统服务管理对象，在main方法中已经创建完成，这里我们看一下其startService方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { final String name = serviceClass.getName(); Slog.i(TAG, &quot;Starting &quot; + name); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); } final T service; try { Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service could not be instantiated&quot;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service must have a public constructor with a Context argument&quot;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(&quot;Failed to create service &quot; + name + &quot;: service constructor threw an exception&quot;, ex); } // Register it. mServices.add(service); // Start it. try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(&quot;Failed to start service &quot; + name + &quot;: onStart threw an exception&quot;, ex); } return service; } 可以看到我们通过反射器构造方法创建出服务类，然后添加到SystemServiceManager的服务列表数据中，最后调用了service.onStart()方法，因为我们传递的是Installer.class，我们这里我们查看一下Installer的onStart方法： 12345@Override public void onStart() { Slog.i(TAG, &quot;Waiting for installd to be ready.&quot;); mInstaller.waitForConnection(); } 很简单就是执行了mInstaller的waitForConnection方法，这里简单介绍一下Installer类，该类是系统安装apk时的一个服务类，继承SystemService（系统服务的一个抽象接口），我们需要在启动完成Installer服务之后才能启动其他的系统服务。然后查看waitForConnection（）方法： 123456789public void waitForConnection() { for (;;) { if (execute(&quot;ping&quot;) &gt;= 0) { return; } Slog.w(TAG, &quot;installd not ready&quot;); SystemClock.sleep(1000); } } 通过追踪代码可以发现，其在不断的通过ping命令连接Zygote进程（SystemServer和Zygote进程通过socket方式通讯，其他进程通过Binder方式通讯）； 总结：在开始执行启动服务之前总是会先尝试通过socket方式连接Zygote进程，在成功连接之后才会开始启动其他服务。 继续来看startBootstrapServices方法： 12345// Activity manager runs the show. mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); 这段代码主要是用于启动ActivityManagerService服务，并为其设置SysServiceManager和Installer。ActivityManagerService是系统中一个非常重要的服务，Activity，service，Broadcast，contentProvider都需要通过其余系统交互。 首先看一下Lifecycle类的定义： 1234567891011121314151617public static final class Lifecycle extends SystemService { private final ActivityManagerService mService; public Lifecycle(Context context) { super(context); mService = new ActivityManagerService(context); } @Override public void onStart() { mService.start(); } public ActivityManagerService getService() { return mService; } } 可以看到其实ActivityManagerService的一个静态内部类，在其构造方法中会创建一个ActivityManagerService，通过刚刚对Installer服务的分析我们知道，SystemServiceManager的startService方法会调用服务的onStart()方法，而在Lifecycle类的定义中我们看到其onStart（）方法直接调用了mService.start()方法，mService是Lifecycle类中对ActivityManagerService的引用，所以我们可以看一下ActivityManagerService的start方法的实现： 123456789private void start() { Process.removeAllProcessGroups(); mProcessCpuThread.start(); mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(&quot;AppOps&quot;, &quot;AppOpsService published&quot;); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); } 由于ActivityManagerService的创建过程比较复杂这里不做过多的分析了，主要是在其构造方法中初始化了一些变量。 然后是启动PowerManagerService服务： 1mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); 启动方式跟上面的ActivityManagerService服务相似都会调用其构造方法和onStart方法，PowerManagerService主要用于计算系统中和Power相关的计算，然后决策系统应该如何反应。同时协调Power如何与系统其它模块的交互，比如没有用户活动时，屏幕变暗等等。 然后是启动LightsService服务 1mSystemServiceManager.startService(LightsService.class); 主要是手机中关于闪光灯，LED等相关的服务；也是会调用LightsService的构造方法和onStart方法； 然后是启动DisplayManagerService服务 1mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); 主要是手机显示方面的服务； 然后是启动PackageManagerService，该服务也是android系统中一个比较重要的服务，包括多apk文件的安装，解析，删除，卸载等等操作。 12345Slog.i(TAG, &quot;Package Manager&quot;); mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); 可以看到PackageManagerService服务的启动方式与其他服务的启动方式有一些区别，直接调用了PackageManagerService的静态main方法，这里我们看一下其main方法的具体实现： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; } 可以看到也是直接使用new的方式创建了一个PackageManagerService对象，并在其构造方法中初始化相关变量，最后调用了ServiceManager.addService方法，主要是通过Binder机制与JNI层交互，这里不再扩展。 然后启动UserManagerService和SensorService，至此startBootstrapServices方法执行完成。 然后查看startCoreServices方法： 1234567891011121314private void startCoreServices() { // Tracks the battery level. Requires LightService. mSystemServiceManager.startService(BatteryService.class); // Tracks application usage stats. mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); // Update after UsageStatsService is available, needed before performBootDexOpt. mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); // Tracks whether the updatable WebView is in a ready state and watches for update installs. mSystemServiceManager.startService(WebViewUpdateService.class); } 可以看到这里启动了BatteryService（电池相关服务），UsageStatsService，WebViewUpdateService服务等。 最后看一下startOtherServices方法，主要用于启动系统中其他的服务，代码很多，这里就不贴代码了，启动的流程和ActivityManagerService的流程类似，会调用服务的构造方法与onStart方法初始化变量。 总结： SystemServer进程是android中一个很重要的进程由Zygote进程启动； SystemServer进程主要用于启动系统中的服务； SystemServer进程启动服务的启动函数为main函数； SystemServer在执行过程中首先会初始化一些系统变量，加载类库，创建Context对象，创建SystemServiceManager对象等之后才开始启动系统服务； SystemServer进程将系统服务分为三类：boot服务，core服务和other服务，并逐步启动 SertemServer进程在尝试启动服务之前会首先尝试与Zygote建立socket通讯，只有通讯成功之后才会开始尝试启动服务； 创建的系统服务过程中主要通过SystemServiceManager对象来管理，通过调用服务对象的构造方法和onStart方法初始化服务的相关变量； 服务对象都有自己的异步消息对象，并运行在单独的线程中； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程","link":"/2020/09/11/SystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"Handler异步休息机制","text":"知乎上看了一篇非常不错的博文：有没有必要阅读ANDROID源码痛定思过，为了更好的深入android体系，决定学习android framework层源码，就从最简单的android异步消息机制开始吧。 （一）Handler的常规使用方式 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity { public static final String TAG = MainActivity.class.getSimpleName(); private TextView texttitle = null; /** * 在主线程中定义Handler，并实现对应的handleMessage方法 */ public static Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;接收到handler消息...&quot;); } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); texttitle = (TextView) findViewById(R.id.texttitle); texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { // 在子线程中发送异步消息 mHandler.sendEmptyMessage(101); } }.start(); } }); }} 可以看出，一般handler的使用方式都是在主线程中定义Handler，然后在子线程中调用mHandler.sendEmptyMessage();方法，然么这里有一个疑问了，我们可以在子线程中定义Handler么？ （二）如何在子线程中定义Handler？ 我们在子线程中定义Handler，看看结果: 123456789101112131415161718texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 点击按钮并运行这段代码： 可以看出来在子线程中定义Handler对象出错了，难道Handler对象的定义或者是初始化只能在主线程中？其实不是这样的，错误信息中提示的已经很明显了，在初始化Handler对象之前需要调用Looper.prepare()方法，那么好了，我们添加这句代码再次执行一次： 12345678910111213141516171819texttitle.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread() { @Override public void run() { Looper.prepare(); Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } } }; } }.start(); } }); 再次点击按钮执行该段代码之后，程序已经不会报错了，那么这说明初始化Handler对象的时候我们是需要调用Looper.prepare()的，那么主线程中为什么可以直接初始化Handler呢？ 其实不是这样的，在App初始化的时候会执行ActivityThread的main方法： 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 可以看到原来Looper.prepare()方法在这里调用了，所以在其他地方我们就可以直接初始化Handler了。 并且我们可以看到还调用了：Looper.loop()方法，通过参考阅读其他文章我们可以知道一个Handler的标准写法其实是这样的： 12345678910Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); （三）查看Handler源码1）查看Looper.prepare()方法 12345678910111213141516171819// sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();/** Initialize the current thread as a looper. * This gives you a chance to create handlers that then reference * this looper, before actually starting the loop. Be sure to call * {@link #loop()} after calling this method, and end it by calling * {@link #quit()}. */ public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } sThreadLocal.set(new Looper(quitAllowed)); } 可以看到Looper中有一个ThreadLocal成员变量，熟悉JDK的同学应该知道，当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。具体参考：彻底理解ThreadLocal由此可以看出在每个线程中Looper.prepare()能且只能调用一次，这里我们可以尝试一下调用两次的情况。 1234567891011121314/** * 这里Looper.prepare()方法调用了两次*/Looper.prepare();Looper.prepare();Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 101) { Log.i(TAG, &quot;在子线程中定义Handler，并接收到消息。。。&quot;); } }};Looper.loop(); 再次运行程序，点击按钮，执行该段代码：可以看到程序出错，并提示prepare中的Excetion信息。 我们继续看Looper对象的构造方法，可以看到在其构造方法中初始化了一个MessageQueue对象： 1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 综上小结（1）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。 2）查看Handler对象的构造方法 12345678910111213141516171819public Handler(Callback callback, boolean async) { if (FIND_POTENTIAL_LEAKS) { final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) { Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; + klass.getCanonicalName()); } } mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } 可以看出在Handler的构造方法中，主要初始化了一下变量，并判断Handler对象的初始化不应再内部类，静态类，匿名类中，并且保存了当前线程中的Looper对象。综上小结（2）：Looper.prepare()方法初始话了一个Looper对象并关联在一个MessageQueue对象，并且一个线程中只有一个Looper对象，只有一个MessageQueue对象。而Handler的构造方法则在Handler内部维护了当前线程的Looper对象 3）查看handler.sendMessage(msg)方法一般的，我们发送异步消息的时候会这样调用： 1mHandler.sendMessage(new Message()); 通过不断的跟进源代码，其最后会调用： 1234567private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); } 原来msg.target就是Handler对象本身；而这里的queue对象就是我们的Handler内部维护的Looper对象关联的MessageQueue对象。查看messagequeue对象的enqueueMessage方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr); } } return true; } 可以看到这里MessageQueue并没有使用列表将所有的Message保存起来，而是使用Message.next保存下一个Message，从而按照时间将所有的Message排序； 4）查看Looper.Loop()方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */ public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); } } 可以看到方法的内容还是比较多的。可以看到Looper.loop()方法里起了一个死循环，不断的判断MessageQueue中的消息是否为空，如果为空则直接return掉，然后执行queue.next()方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105Message next() { // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) { return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) { // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null &amp;&amp; !msg.isAsynchronous()); } if (msg != null) { if (now &lt; msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount &lt;= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } 可以看到其大概的实现逻辑就是Message的出栈操作，里面可能对线程，并发控制做了一些限制等。获取到栈顶的Message对象之后开始执行：1msg.target.dispatchMessage(msg); 那么msg.target是什么呢？通过追踪可以知道就是我们定义的Handler对象，然后我们查看一下Handler类的dispatchMessage方法： 123456789101112131415/** * Handle system messages here. */ public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 可以看到，如果我们设置了callback（Runnable对象）的话，则会直接调用handleCallback方法： 123private static void handleCallback(Message message) { message.callback.run(); } 即，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。比如我们经常写的runOnUiThread方法： 123456runOnUiThread(new Runnable() { @Override public void run() { } }); 看其内部实现： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 而如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。由于Handler对象是在主线程中创建的，所以handler的handlerMessage方法的执行也会在主线程中。 综上可以知道：1）主线程中定义Handler，直接执行： 123456Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); }}; 而如果想要在子线程中定义Handler，则标准的写法为： 1234567891011// 初始化该线程Looper，MessageQueue，执行且只能执行一次 Looper.prepare(); // 初始化Handler对象，内部关联Looper对象 Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); } }; // 启动消息队列出栈死循环 Looper.loop(); 2）一个线程中只存在一个Looper对象，只存在一个MessageQueue对象，可以存在N个Handler对象，Handler对象内部关联了本线程中唯一的Looper对象，Looper对象内部关联着唯一的一个MessageQueue对象。 3）MessageQueue消息队列不是通过列表保存消息（Message）列表的，而是通过Message对象的next属性关联下一个Message从而实现列表的功能，同时所有的消息都是按时间排序的。 4）android中两个子线程相互交互同样可以通过Handler的异步消息机制实现，可以在线程a中定义Handler对象，而在线程b中获取handler的引用并调用sendMessage方法。 5）activity内部默认存在一个handler的成员变量，android中一些其他的异步消息机制的实现方法：Handler的post方法： 123456mHandler.post(new Runnable() { @Override public void run() { } }); 查看其内部实现： 1234public final boolean post(Runnable r) { return sendMessageDelayed(getPostMessage(r), 0); } 可以发现其内部调用就是sendMessage系列方法。。。 view的post方法： 123456789public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true; } 可以发现其调用的就是activity中默认保存的handler对象的post方法。 activity的runOnUiThread方法： 1234567public final void runOnUiThread(Runnable action) { if (Thread.currentThread() != mUiThread) { mHandler.post(action); } else { action.run(); } } 判断当前线程是否是UI线程，如果不是，则调用handler的post方法，否则直接执行run方法。 参考文章：Android异步消息处理机制完全解析，带你从源码的角度彻底理解 Android异步消息处理机制详解及源码分析 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制","link":"/2020/09/11/android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"title":"16 应用进程Context创建流程","text":"今天讲讲应用进程Context的创建流程，相信大家平时在开发过程中经常会遇到对Context对象的使用，Application是Context，Activity是Context，Service也是Context，所以有一个经典的问题是一个App中一共有多少个Context？ 这个问题的答案是Application + N个Activity + N个Service。 还有就是我们平时在使用Context过程中许多时候由于使用不当，可能会造成内存泄露的情况等等，这个也是需要我们注意的。这里有篇不错的文章： Android Context 是什么？ 好吧，什么叫应用进程Context呢？这是指的是Application所代表的Context的创建流程，还记得我们前几篇写的应用进程创建流程么？ android源码解析之（十一）–&gt;应用进程启动流程最后我们得出结论，应用进程的起始方法是ActivityThread.main方法，好吧， 由于还未讲解Service相关知识，这里暂时讲解一下Activity与Application中Context对象的创建过程。 首先我们就从ActivityThread.main方法开始看一下Application的创建流程。。。 123456public static void main(String[] args) { ... ActivityThread thread = new ActivityThread(); thread.attach(false); ... }这里我们发现在方法体中我们创建了一个ActivityThread对象并执行了attach方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ViewRootImpl.addFirstDrawHandler(new Runnable() { @Override public void run() { ensureJitEnabled(); } }); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { mgr.releaseSomeActivities(mAppThread); } catch (RemoteException e) { } } } }); } else { ... } } 这里看一下重点实现，我们可以发现在方法体中调用了ActivityManagerNative.getDefault().attachApplication(mAppThread)看过我的前几篇文章的童鞋应该知道这里就是一个Binder进程间通讯，其实上执行的是ActivityManagerService.attachApplication方法，具体的可以参考前几篇文章的介绍，好吧，既然这样我们看一下ActivityManagerService.attachApplication方法的具体实现。 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 然后这里面又调用了attachApplicationLocked方法： 12345678private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat,getCommonServicesLocked(app.isolated),mCoreSettingsObserver.getCoreSettingsLocked()); ... 可以看到这里面又调用了IApplication.bindApplication，从方法名称中我们可以看出这里应该是绑定Application的方法，跟上面的ActivityManangerNative类似的，前面几篇文章中我们已经做过介绍，IApplicationThread是ActivityThread中ApplicationThread binder对象的客户端，所以这里最终调用的是ApplicationThread的bindApplication方法，既然这样，我们来看一下ApplicationThread的bindApplication的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableOpenGlTrace, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) { if (services != null) { // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); } setCoreSettings(coreSettings); /* * Two possible indications that this package could be * sharing its runtime with other packages: * * 1.) the sharedUserId attribute is set in the manifest, * indicating a request to share a VM with other * packages with the same sharedUserId. * * 2.) the application element of the manifest has an * attribute specifying a non-default process name, * indicating the desire to run in another packages VM. * * If sharing is enabled we do not have a unique application * in a process and therefore cannot rely on the package * name inside the runtime. */ IPackageManager pm = getPackageManager(); android.content.pm.PackageInfo pi = null; try { pi = pm.getPackageInfo(appInfo.packageName, 0, UserHandle.myUserId()); } catch (RemoteException e) { } if (pi != null) { boolean sharedUserIdSet = (pi.sharedUserId != null); boolean processNameNotDefault = (pi.applicationInfo != null &amp;&amp; !appInfo.packageName.equals(pi.applicationInfo.processName)); boolean sharable = (sharedUserIdSet || processNameNotDefault); // Tell the VMRuntime about the application, unless it is shared // inside a process. if (!sharable) { VMRuntime.registerAppInfo(appInfo.packageName, appInfo.dataDir, appInfo.processName); } } AppBindData data = new AppBindData(); data.processName = processName; data.appInfo = appInfo; data.providers = providers; data.instrumentationName = instrumentationName; data.instrumentationArgs = instrumentationArgs; data.instrumentationWatcher = instrumentationWatcher; data.instrumentationUiAutomationConnection = instrumentationUiConnection; data.debugMode = debugMode; data.enableOpenGlTrace = enableOpenGlTrace; data.restrictedBackupMode = isRestrictedBackupMode; data.persistent = persistent; data.config = config; data.compatInfo = compatInfo; data.initProfilerInfo = profilerInfo; sendMessage(H.BIND_APPLICATION, data); } 好吧，最后调用了ActivityThread.sendMessage()… 123private void sendMessage(int what, Object obj) { sendMessage(what, obj, 0, 0, false); } 然后我们看一下其sendMessage的重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 可以发现这里调用了mH的sendMessage方法，最后通过Handler的异步消息机制被mH的handleMessage方法处理，然后根据Message.what选择处理分支，最终调用了ActivityThread的handleBindApplication方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990private void handleBindApplication(AppBindData data) { ... // 创建Instrumentation if (data.instrumentationName != null) { InstrumentationInfo ii = null; try { ii = appContext.getPackageManager(). getInstrumentationInfo(data.instrumentationName, 0); } catch (PackageManager.NameNotFoundException e) { } if (ii == null) { throw new RuntimeException( &quot;Unable to find instrumentation info for: &quot; + data.instrumentationName); } mInstrumentationPackageName = ii.packageName; mInstrumentationAppDir = ii.sourceDir; mInstrumentationSplitAppDirs = ii.splitSourceDirs; mInstrumentationLibDir = ii.nativeLibraryDir; mInstrumentedAppDir = data.info.getAppDir(); mInstrumentedSplitAppDirs = data.info.getSplitAppDirs(); mInstrumentedLibDir = data.info.getLibDir(); ApplicationInfo instrApp = new ApplicationInfo(); instrApp.packageName = ii.packageName; instrApp.sourceDir = ii.sourceDir; instrApp.publicSourceDir = ii.publicSourceDir; instrApp.splitSourceDirs = ii.splitSourceDirs; instrApp.splitPublicSourceDirs = ii.splitPublicSourceDirs; instrApp.dataDir = ii.dataDir; instrApp.nativeLibraryDir = ii.nativeLibraryDir; LoadedApk pi = getPackageInfo(instrApp, data.compatInfo, appContext.getClassLoader(), false, true, false); ContextImpl instrContext = ContextImpl.createAppContext(this, pi); try { java.lang.ClassLoader cl = instrContext.getClassLoader(); mInstrumentation = (Instrumentation) cl.loadClass(data.instrumentationName.getClassName()).newInstance(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate instrumentation &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } mInstrumentation.init(this, instrContext, appContext, new ComponentName(ii.packageName, ii.name), data.instrumentationWatcher, data.instrumentationUiAutomationConnection); if (mProfiler.profileFile != null &amp;&amp; !ii.handleProfiling &amp;&amp; mProfiler.profileFd == null) { mProfiler.handlingProfiling = true; File file = new File(mProfiler.profileFile); file.getParentFile().mkdirs(); Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024); } } else { mInstrumentation = new Instrumentation(); } ... / If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ... try { mInstrumentation.onCreate(data.instrumentationArgs); } catch (Exception e) { throw new RuntimeException( &quot;Exception thrown in onCreate() of &quot; + data.instrumentationName + &quot;: &quot; + e.toString(), e); } try { mInstrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } finally { StrictMode.setThreadPolicy(savedPolicy); } } 这个方法的方法体比较长，我们挑重点的看，可以看到方法体中系统通过反射机制创建了Instrumentation对象，并执行了init方法，执行了Insrtumentation对象的初始化。然后我们调用了LockedApk.makeApplication方法创建了Application对象，我们来看一下其具体的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) { if (mApplication != null) { return mApplication; } Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) { appClass = &quot;android.app.Application&quot;; } try { java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals(&quot;android&quot;)) { initializeJavaContextClassLoader(); } ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); } catch (Exception e) { if (!mActivityThread.mInstrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to instantiate application &quot; + appClass + &quot;: &quot; + e.toString(), e); } } mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) { try { instrumentation.callApplicationOnCreate(app); } catch (Exception e) { if (!instrumentation.onException(app, e)) { throw new RuntimeException( &quot;Unable to create application &quot; + app.getClass().getName() + &quot;: &quot; + e.toString(), e); } } } // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) { final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) { continue; } rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); } return app; } 可以发现这里也是以反射的机制创建了Application对象，并创建了一个ContextImpl对象，并将Application与ContextImpl建立关联。。。 继续回到我们的ActivityThread的handleBindApplication方法，在创建了Application对象之后我们调用了Instrumentation的onCreate方法，然后调用了Instrumentation的callApplicationOnCreate方法，我们来看一下其具体实现： 123public void callApplicationOnCreate(Application app) { app.onCreate(); } 咋样？原来Application的onCreate生命周期方法是在这里回调滴啊。 这样我们整个Application的创建执行流程就讲解完了。 总结： 应用进程启动 –&gt; 创建Instrumentation –&gt; 创建Application对象 –&gt; 创建Application相关的ContextImpl对象； ActivityThread.main方法–&gt; ActivityManagerService.bindApplication方法 –&gt; ActivityThread.handleBindApplication –&gt; 创建Instrumentation，创建Application； 每个应用进程对应一个Instrumentation，对应一个Application； Instrumentation与Application都是通过java反射机制创建； Application创建过程中会同时创建一个ContextImpl对象，并建立关联； 接下来我们来看一下Acitivty中的Context创建流程，大家都知道我们Activity的具体创建过程是在ActivityThread的performLaunchActivity,可参见： android源码解析之（十四）–&gt;Activity启动流程，这里我们看一下其具体的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } try { Application app = r.packageInfo.makeApplication(false, mInstrumentation); ... if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } ... return activity; } 这里简要说明一下，Activity也是系统通过反射机制创建的，然后我们通过LockedApk.makeApplication创建一个Application，通过查看源码我们知道若这时候LockedApk中的mApplication不为空则直接返回当前的mApplication又因为当我们创建应用进程的时候Application已经被创建，所以当创建Activity的时候这时候Application肯定不为空，所以这时候返回的就是应用进程创建的时候创建的Application，这也从侧面说明了一个应用进程对应着一个Application。然后我们通过createBaseContextForActivity创建了一个ContextImpl对象。 123456789101112131415161718192021222324252627282930private Context createBaseContextForActivity(ActivityClientRecord r, final Activity activity) { int displayId = Display.DEFAULT_DISPLAY; try { displayId = ActivityManagerNative.getDefault().getActivityDisplayId(r.token); } catch (RemoteException e) { } ContextImpl appContext = ContextImpl.createActivityContext( this, r.packageInfo, displayId, r.overrideConfig); appContext.setOuterContext(activity); Context baseContext = appContext; final DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(); // For debugging purposes, if the activity's package name contains the value of // the &quot;debug.use-second-display&quot; system property as a substring, then show // its content on a secondary display if there is one. String pkgName = SystemProperties.get(&quot;debug.second-display.pkg&quot;); if (pkgName != null &amp;&amp; !pkgName.isEmpty() &amp;&amp; r.packageInfo.mPackageName.contains(pkgName)) { for (int id : dm.getDisplayIds()) { if (id != Display.DEFAULT_DISPLAY) { Display display = dm.getCompatibleDisplay(id, appContext.getDisplayAdjustments(id)); baseContext = appContext.createDisplayContext(display); break; } } } return baseContext; } 可以发现这里创建了一个ContextImpl对象，并通过ContextImpl的setOuterContext方法，让该ContextImpl持有了Activity的引用，继续往下看，我们调用了activity.attach方法，查看一下该方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 除了一下初始化操作之外，还调用了attachBaseContext方法，让Activity持有了ContextImpl的引用，这样就相当于Activity与ContextImpl对象相互持有了对方的引用，并且Activity是继承与Context。 总结： Activity中创建ContextImpl对象的具体实现在ActivityThread的performLauncherAcitivty方法中； Activity的创建伴随着ContextImpl的创建，二者相互持有对方的引用； 创建Activity –&gt; 创建Activity相关ContextImpl对象； 创建应用进程 –&gt; 创建Application –&gt; 创建Application相关ContextImpl对象； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程","link":"/2020/09/11/%E5%BA%94%E7%94%A8%E8%BF%9B%E7%A8%8BContext%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B/"},{"title":"26 截屏事件流程","text":"今天这篇文章我们主要讲一下Android系统中的截屏事件处理流程。用过android系统手机的同学应该都知道，一般的android手机按下音量减少键和电源按键就会触发截屏事件（国内定制机做个修改的这里就不做考虑了）。那么这里的截屏事件是如何触发的呢？触发之后android系统是如何实现截屏操作的呢？带着这两个问题，开始我们的源码阅读流程。 我们知道这里的截屏事件是通过我们的按键操作触发的，所以这里就需要我们从android系统的按键触发模块开始看起，由于我们在不同的App页面，操作音量减少键和电源键都会触发系统的截屏处理，所以这里的按键触发逻辑应该是Android系统的全局按键处理逻辑。 在android系统中，由于我们的每一个Android界面都是一个Activity，而界面的显示都是通过Window对象实现的，每个Window对象实际上都是PhoneWindow的实例，而每个PhoneWindow对象都一个PhoneWindowManager对象，当我们在Activity界面执行按键操作的时候，在将按键的处理操作分发到App之前，首先会回调PhoneWindowManager中的dispatchUnhandledKey方法，该方法主要用于执行当前App处理按键之前的操作，我们具体看一下该方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** {@inheritDoc} */ @Override public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { ... final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 这里我们关注一下方法体中调用的：interceptFallback方法，通过调用该方法将处理按键的操作下发到该方法中，我们继续看一下该方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }然后我们看到在interceptFallback方法中我们调用了interceptKeyBeforeQueueing方法，通过阅读我们我们知道该方法主要实现了对截屏按键的处理流程，这样我们继续看一下interceptKeyBeforeWueueing方法的处理： 123456789101112131415161718192021222324252627282930313233343536@Override public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { if (!mSystemBooted) { // If we have not yet booted, don't let key events do anything. return 0; } ... // Handle special keys. switch (keyCode) { case KeyEvent.KEYCODE_VOLUME_DOWN: case KeyEvent.KEYCODE_VOLUME_UP: case KeyEvent.KEYCODE_VOLUME_MUTE: { if (mUseTvRouting) { // On TVs volume keys never go to the foreground app result &amp;= ~ACTION_PASS_TO_USER; } if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) { if (down) { if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } } else { mScreenshotChordVolumeDownKeyTriggered = false; cancelPendingScreenshotChordAction(); } } ... return result; } 可以发现这里首先判断当前系统是否已经boot完毕，若尚未启动完毕，则所有的按键操作都将失效，若启动完成，则执行后续的操作，这里我们只是关注音量减少按键和电源按键组合的处理事件。另外这里多说一句想安卓系统的HOME按键事件，MENU按键事件，进程列表按键事件等等都是在这里实现的，后续中我们会陆续介绍这方面的内容。 回到我们的interceptKeyBeforeQueueing方法，当我用按下音量减少按键的时候回进入到：case KeyEvent.KEYCODE_VOLUME_MUTE分支并执行相应的逻辑，然后同时判断用户是否按下了电源键，若同时按下了电源键，则执行： 12345678if (interactive &amp;&amp; !mScreenshotChordVolumeDownKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordVolumeDownKeyTriggered = true; mScreenshotChordVolumeDownKeyTime = event.getDownTime(); mScreenshotChordVolumeDownKeyConsumed = false; cancelPendingPowerKeyAction(); interceptScreenshotChord(); } 可以发现这里的interceptScreenshotChrod方法就是系统准备开始执行截屏操作的开始，我们继续看一下interceptcreenshotChord方法的实现。 123456789101112131415private void interceptScreenshotChord() { if (mScreenshotChordEnabled &amp;&amp; mScreenshotChordVolumeDownKeyTriggered &amp;&amp; mScreenshotChordPowerKeyTriggered &amp;&amp; !mScreenshotChordVolumeUpKeyTriggered) { final long now = SystemClock.uptimeMillis(); if (now &lt;= mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS &amp;&amp; now &lt;= mScreenshotChordPowerKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS) { mScreenshotChordVolumeDownKeyConsumed = true; cancelPendingPowerKeyAction(); mHandler.postDelayed(mScreenshotRunnable, getScreenshotChordLongPressDelay()); } } } 在方法体中我们最终会执行发送一个延迟的异步消息，请求执行截屏的操作而这里的延时时间，若当前输入框是打开状态，则延时时间为输入框关闭时间加上系统配置的按键超时时间，若当前输入框没有打开则直接是系统配置的按键超时处理时间，可看一下getScreenshotChordLongPressDelay方法的具体实现。 12345678private long getScreenshotChordLongPressDelay() { if (mKeyguardDelegate.isShowing()) { // Double the time it takes to take a screenshot from the keyguard return (long) (KEYGUARD_SCREENSHOT_CHORD_DELAY_MULTIPLIER * ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } return ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout(); } 回到我们的interceptScreenshotChord方法，发送了异步消息之后系统最终会被我们发送的Runnable对象的run方法执行，这里关于异步消息的逻辑可参考：android源码解析之（二）–&gt;异步消息机制 这样我们看一下Runnable类型的mScreenshotRunnable的run方法的实现: 123456private final Runnable mScreenshotRunnable = new Runnable() { @Override public void run() { takeScreenshot(); } }; 好吧，方法体中并未执行其他操作，直接就是调用了takeScreenshot方法，这样我们继续看一下takeScreenshot方法的实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void takeScreenshot() { synchronized (mScreenshotLock) { if (mScreenshotConnection != null) { return; } ComponentName cn = new ComponentName(&quot;com.android.systemui&quot;, &quot;com.android.systemui.screenshot.TakeScreenshotService&quot;); Intent intent = new Intent(); intent.setComponent(cn); ServiceConnection conn = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { synchronized (mScreenshotLock) { if (mScreenshotConnection != this) { return; } Messenger messenger = new Messenger(service); Message msg = Message.obtain(null, 1); final ServiceConnection myConn = this; Handler h = new Handler(mHandler.getLooper()) { @Override public void handleMessage(Message msg) { synchronized (mScreenshotLock) { if (mScreenshotConnection == myConn) { mContext.unbindService(mScreenshotConnection); mScreenshotConnection = null; mHandler.removeCallbacks(mScreenshotTimeout); } } } }; msg.replyTo = new Messenger(h); msg.arg1 = msg.arg2 = 0; if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; try { messenger.send(msg); } catch (RemoteException e) { } } } @Override public void onServiceDisconnected(ComponentName name) {} }; if (mContext.bindServiceAsUser( intent, conn, Context.BIND_AUTO_CREATE, UserHandle.CURRENT)) { mScreenshotConnection = conn; mHandler.postDelayed(mScreenshotTimeout, 10000); } } } 可以发现这里通过反射机制创建了一个TakeScreenshotService对象然后调用了bindServiceAsUser，这样就创建了TakeScreenshotService服务并在服务创建之后发送了一个异步消息。好了，我们看一下TakeScreenshotService的实现逻辑。 1234567891011121314151617181920212223242526272829303132public class TakeScreenshotService extends Service { private static final String TAG = &quot;TakeScreenshotService&quot;; private static GlobalScreenshot mScreenshot; private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { case 1: final Messenger callback = msg.replyTo; if (mScreenshot == null) { mScreenshot = new GlobalScreenshot(TakeScreenshotService.this); } mScreenshot.takeScreenshot(new Runnable() { @Override public void run() { Message reply = Message.obtain(null, 1); try { callback.send(reply); } catch (RemoteException e) { } } }, msg.arg1 &gt; 0, msg.arg2 &gt; 0); } } }; @Override public IBinder onBind(Intent intent) { return new Messenger(mHandler).getBinder(); }} 可以发现在在TakeScreenshotService类的定义中有一个Handler成员变量，而我们在启动TakeScreentshowService的时候回发送一个异步消息，这样就会执行mHandler的handleMessage方法，然后在handleMessage方法中我们创建了一个GlobalScreenshow对象，然后执行了takeScreenshot方法，好吧，继续看一下takeScreentshot方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Takes a screenshot of the current display and shows an animation. */ void takeScreenshot(Runnable finisher, boolean statusBarVisible, boolean navBarVisible) { // We need to orient the screenshot correctly (and the Surface api seems to take screenshots // only in the natural orientation of the device :!) mDisplay.getRealMetrics(mDisplayMetrics); float[] dims = {mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels}; float degrees = getDegreesForRotation(mDisplay.getRotation()); boolean requiresRotation = (degrees &gt; 0); if (requiresRotation) { // Get the dimensions of the device in its native orientation mDisplayMatrix.reset(); mDisplayMatrix.preRotate(-degrees); mDisplayMatrix.mapPoints(dims); dims[0] = Math.abs(dims[0]); dims[1] = Math.abs(dims[1]); } // Take the screenshot mScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } // Optimizations mScreenBitmap.setHasAlpha(false); mScreenBitmap.prepareToDraw(); // Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); } 可以看到这里后两个参数：statusBarVisible，navBarVisible是否可见，而这两个参数在我们PhoneWindowManager.takeScreenshot方法传递的： 1234if (mStatusBar != null &amp;&amp; mStatusBar.isVisibleLw()) msg.arg1 = 1; if (mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()) msg.arg2 = 1; 可见若果mStatusBar可见，则传递的statusBarVisible为true，若mNavigationBar可见，则传递的navBarVisible为true。然后我们在截屏的时候判断nStatusBar是否可见，mNavigationBar是否可见，若可见的时候则截屏同样将其截屏出来。继续回到我们的takeScreenshot方法，然后调用了： 12// Take the screenshotmScreenBitmap = SurfaceControl.screenshot((int) dims[0], (int) dims[1]); 方法，看注释，这里就是执行截屏事件的具体操作了，然后我看一下SurfaceControl.screenshot方法的具体实现，另外这里需要注意的是，截屏之后返回的是一个Bitmap对象，其实熟悉android绘制机制的童鞋应该知道android中所有显示能够显示的东西，在内存中表现都是Bitmap对象。 1234567public static Bitmap screenshot(int width, int height) { // TODO: should take the display as a parameter IBinder displayToken = SurfaceControl.getBuiltInDisplay( SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN); return nativeScreenshot(displayToken, new Rect(), width, height, 0, 0, true, false, Surface.ROTATION_0); } 好吧，这里调用的是nativeScreenshot方法，它是一个native方法，具体的实现在JNI层，这里就不做过多的介绍了。继续回到我们的takeScreenshot方法，在调用了截屏方法screentshot之后，判断是否截屏成功： 12345if (mScreenBitmap == null) { notifyScreenshotError(mContext, mNotificationManager); finisher.run(); return; } 若截屏之后，截屏的bitmap对象为空，这里判断截屏失败，调用了notifyScreenshotError方法，发送截屏失败的notification通知。 123456789101112131415161718192021static void notifyScreenshotError(Context context, NotificationManager nManager) { Resources r = context.getResources(); // Clear all existing notification, compose the new notification and show it Notification.Builder b = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_failed_title)) .setContentTitle(r.getString(R.string.screenshot_failed_title)) .setContentText(r.getString(R.string.screenshot_failed_text)) .setSmallIcon(R.drawable.stat_notify_image_error) .setWhen(System.currentTimeMillis()) .setVisibility(Notification.VISIBILITY_PUBLIC) // ok to show outside lockscreen .setCategory(Notification.CATEGORY_ERROR) .setAutoCancel(true) .setColor(context.getColor( com.android.internal.R.color.system_notification_accent_color)); Notification n = new Notification.BigTextStyle(b) .bigText(r.getString(R.string.screenshot_failed_text)) .build(); nManager.notify(R.id.notification_screenshot, n); } 然后继续看takeScreenshot方法，判断截屏的图像是否需要旋转，若需要的话，则旋转图像： 1234567891011121314if (requiresRotation) { // Rotate the screenshot to the current orientation Bitmap ss = Bitmap.createBitmap(mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, Bitmap.Config.ARGB_8888); Canvas c = new Canvas(ss); c.translate(ss.getWidth() / 2, ss.getHeight() / 2); c.rotate(degrees); c.translate(-dims[0] / 2, -dims[1] / 2); c.drawBitmap(mScreenBitmap, 0, 0, null); c.setBitmap(null); // Recycle the previous bitmap mScreenBitmap.recycle(); mScreenBitmap = ss; } 在takeScreenshot方法的最后若截屏成功，我们调用了： 123// Start the post-screenshot animation startAnimation(finisher, mDisplayMetrics.widthPixels, mDisplayMetrics.heightPixels, statusBarVisible, navBarVisible); 开始截屏的动画，好吧，看一下动画效果的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Starts the animation after taking the screenshot */ private void startAnimation(final Runnable finisher, int w, int h, boolean statusBarVisible, boolean navBarVisible) { // Add the view for the animation mScreenshotView.setImageBitmap(mScreenBitmap); mScreenshotLayout.requestFocus(); // Setup the animation with the screenshot just taken if (mScreenshotAnimation != null) { mScreenshotAnimation.end(); mScreenshotAnimation.removeAllListeners(); } mWindowManager.addView(mScreenshotLayout, mWindowLayoutParams); ValueAnimator screenshotDropInAnim = createScreenshotDropInAnimation(); ValueAnimator screenshotFadeOutAnim = createScreenshotDropOutAnimation(w, h, statusBarVisible, navBarVisible); mScreenshotAnimation = new AnimatorSet(); mScreenshotAnimation.playSequentially(screenshotDropInAnim, screenshotFadeOutAnim); mScreenshotAnimation.addListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { // Save the screenshot once we have a bit of time now saveScreenshotInWorkerThread(finisher); mWindowManager.removeView(mScreenshotLayout); // Clear any references to the bitmap mScreenBitmap = null; mScreenshotView.setImageBitmap(null); } }); mScreenshotLayout.post(new Runnable() { @Override public void run() { // Play the shutter sound to notify that we've taken a screenshot mCameraSound.play(MediaActionSound.SHUTTER_CLICK); mScreenshotView.setLayerType(View.LAYER_TYPE_HARDWARE, null); mScreenshotView.buildLayer(); mScreenshotAnimation.start(); } }); } 好吧，经过着一些列的操作之后我们实现了截屏之后的动画效果了，这里暂时不分析动画效果，我们看一下动画效果之后做了哪些？还记不记的一般情况下我们截屏之后都会收到一个截屏的notification通知？这里应该也是在其AnimatorListenerAdapter的onAnimationEnd方法中实现的，也就是动画执行完成之后，我们看一下其saveScreenshotInWorkerThread方法的实现： 1234567891011121314151617/** * Creates a new worker thread and saves the screenshot to the media store. */ private void saveScreenshotInWorkerThread(Runnable finisher) { SaveImageInBackgroundData data = new SaveImageInBackgroundData(); data.context = mContext; data.image = mScreenBitmap; data.iconSize = mNotificationIconSize; data.finisher = finisher; data.previewWidth = mPreviewWidth; data.previewheight = mPreviewHeight; if (mSaveInBgTask != null) { mSaveInBgTask.cancel(false); } mSaveInBgTask = new SaveImageInBackgroundTask(mContext, data, mNotificationManager, R.id.notification_screenshot).execute(data); } 好吧，这里主要逻辑就是构造了一个SaveImageInBackgroundTask对象，看样子发送截屏成功的通知应该是在这里实现的，我们看一下SaveImageInBackgroundTask构造方法的实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SaveImageInBackgroundTask(Context context, SaveImageInBackgroundData data, NotificationManager nManager, int nId) { ... // Show the intermediate notification mTickerAddSpace = !mTickerAddSpace; mNotificationId = nId; mNotificationManager = nManager; final long now = System.currentTimeMillis(); mNotificationBuilder = new Notification.Builder(context) .setTicker(r.getString(R.string.screenshot_saving_ticker) + (mTickerAddSpace ? &quot; &quot; : &quot;&quot;)) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setWhen(now) .setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color)); mNotificationStyle = new Notification.BigPictureStyle() .bigPicture(picture.createAshmemBitmap()); mNotificationBuilder.setStyle(mNotificationStyle); // For &quot;public&quot; situations we want to show all the same info but // omit the actual screenshot image. mPublicNotificationBuilder = new Notification.Builder(context) .setContentTitle(r.getString(R.string.screenshot_saving_title)) .setContentText(r.getString(R.string.screenshot_saving_text)) .setSmallIcon(R.drawable.stat_notify_image) .setCategory(Notification.CATEGORY_PROGRESS) .setWhen(now) .setColor(r.getColor( com.android.internal.R.color.system_notification_accent_color)); mNotificationBuilder.setPublicVersion(mPublicNotificationBuilder.build()); Notification n = mNotificationBuilder.build(); n.flags |= Notification.FLAG_NO_CLEAR; mNotificationManager.notify(nId, n); // On the tablet, the large icon makes the notification appear as if it is clickable (and // on small devices, the large icon is not shown) so defer showing the large icon until // we compose the final post-save notification below. mNotificationBuilder.setLargeIcon(icon.createAshmemBitmap()); // But we still don't set it for the expanded view, allowing the smallIcon to show here. mNotificationStyle.bigLargeIcon((Bitmap) null); } 可以发现在构造方法的后面狗仔了一个NotificationBuilder对象，然后发送了一个截屏成功的Notification，这样我们在截屏动画之后就收到了Notification的通知了。 总结： 在PhoneWindowManager的dispatchUnhandledKey方法中处理App无法处理的按键事件，当然也包括音量减少键和电源按键的组合按键 通过一系列的调用启动TakeScreenshotService服务，并通过其执行截屏的操作。 具体的截屏代码是在native层实现的。 截屏操作时候，若截屏失败则直接发送截屏失败的notification通知。 截屏之后，若截屏成功，则先执行截屏的动画，并在动画效果执行完毕之后，发送截屏成功的notification的通知。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程","link":"/2020/09/11/%E6%88%AA%E5%B1%8F%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"17 Activity布局加载流程","text":"好吧，终于要开始讲讲Activity的布局加载流程了，大家都知道在Android体系中Activity扮演了一个界面展示的角色，这也是它与android中另外一个很重要的组件Service最大的不同，但是这个展示的界面的功能是Activity直接控制的么？界面的布局文件是如何加载到内存并被Activity管理的？android中的View是一个怎样的概念？加载到内存中的布局文件是如何绘制出来的？ 要想回答这些问题，我们就需要对android的界面加载与绘制流程有所了解，这里我们先来学习一下Activity的布局加载的流程。而至于Acitivty的布局绘制流程我们在下一篇中在做介绍。 其实Activity对界面布局的管理是都是通过Window对象来实现的，Window对象，顾名思义就是一个窗口对象，而Activity从用户角度就是一个个的窗口实例，因此不难想象每个Activity中都对应着一个Window对象，而这个Window对象就是负责加载显示界面的。至于window对象是如何展示不同的界面的，那是通过定义不同的View组件实现不同的界面展示。 废话不多说了，不知道大家是否还记得我们讲过的Activity的启动流程么？不熟悉的童鞋可以参考： android源码解析之（十四）–&gt;Activity启动流程 ，在文章中我们介绍到当ActivityManagerService接收到启动Activity的请求之后会通过IApplicationThread进程间通讯告知ApplicationThread并执行handleLauncherActivity方法，这里我们可以下其具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) { mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); } // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, &quot;Handling launch of &quot; + r); // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) { // The activity manager actually wants this one to start out // paused, because it needs to be visible but isn't in the // foreground. We accomplish this by going through the // normal startup (because activities expect to go through // onResume() the first time they run, before their window // is displayed), and then pausing it. However, in this case // we do -not- need to do the full pause cycle (of freezing // and such) because the activity manager assumes it can just // retain the current state it has. try { r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); // We need to keep around the original state, in case // we need to be created again. But we only do this // for pre-Honeycomb apps, which always save their state // when pausing, so we can not have them save their state // when restarting from a paused state. For HC and later, // we want to (and can) let the state be saved as the normal // part of stopping the activity. if (r.isPreHoneycomb()) { r.state = oldState; } if (!r.activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPause()&quot;); } } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to pause activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.paused = true; } } else { // If there was an error, for any reason, tell the activity // manager to stop us. try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { // Ignore } } }可以发现这里的handleLauncherActivity方法内部调用了performLaunchActivity方法，这个方法也是具体启动Activity的方法，我们来看一下它的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, &quot;Performing launch of &quot; + r); if (localLOGV) Slog.v( TAG, r + &quot;: app=&quot; + app + &quot;, appName=&quot; + app.getPackageName() + &quot;, pkg=&quot; + r.packageInfo.getPackageName() + &quot;, comp=&quot; + r.intent.getComponent().toShortString() + &quot;, dir=&quot; + r.packageInfo.getAppDir()); if (activity != null) { Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Launching activity &quot; + r.activityInfo.name + &quot; with config &quot; + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ... return activity; } 从代码中可以看到这里是通过反射的机制创建的Activity，并调用了Activity的attach方法，那么这里的attach方法是做什么的呢？我们继续来看一下attach方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); mMainThread = aThread; mInstrumentation = instr; mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; if (voiceInteractor != null) { if (lastNonConfigurationInstances != null) { mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor; } else { mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this, Looper.myLooper()); } } mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config; } 可以看到在attach方法这里初始化了一些Activity的成员变量，主要是mWindow对象，并且mWindow的成员实例是PhoneWindow实例，这样也从侧面说明了一个Activity对应着一个Window对象。除了window对象还初始化了一些Activity的其他成员变量，这里不再做讨论，继续回到我们的performLaunchActivity方法，在调用了Activity的attach方法之后又调用了： 1mInstrumentation.callActivityOnCreate(activity, r.state); 这里的mInstrumentation是类Instrumentation，每个应用进程对应着一个Instrumentation和一个ActivityThread，Instrumentation就是具体操作Activity回调其生命周期方法的，我们这里看一下它的callActivityOnCreate方法的实现： 12345public void callActivityOnCreate(Activity activity, Bundle icicle) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 这里代码比较简洁，preOerformCreate方法和postPerformCreate方法我们这里暂时不管，主要的执行逻辑是调用了activity.performCreate方法，我们来看一下Activity的performCreate方法的实现： 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } 原来onCreate的生命周期方法是在这里回调的，其实这里的逻辑在前面几篇文章中有讲述，也可以参考前面的文章。 至此我们就回调到了我们Activity的onCreate方法，大家平时在重写onCreate方法的时候，怎么加载布局文件的呢？这里看一下我们的onCreate方法的典型写法： 12345@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } 无论我们怎么变化，我们的onCreate方法一般都是会调用这两句话的吧？那么这里的两段代码分辨是什么含义呢？我们首先看一下super.onCreate方法的实现逻辑，由于我们的Activity类继承与Activity，所以这里的super.onCreate方法，就是调用的Activity.onCreate方法，好吧，既然这样我们来看一下Activity的onCreate方法： 123456789101112131415161718192021222324protected void onCreate(@Nullable Bundle savedInstanceState) { if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onCreate &quot; + this + &quot;: &quot; + savedInstanceState); if (mLastNonConfigurationInstances != null) { mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); } if (mActivityInfo.parentActivityName != null) { if (mActionBar == null) { mEnableDefaultActionBarUp = true; } else { mActionBar.setDefaultDisplayHomeAsUpEnabled(true); } } if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } mFragments.dispatchCreate(); getApplication().dispatchActivityCreated(this, savedInstanceState); if (mVoiceInteractor != null) { mVoiceInteractor.attachActivity(this); } mCalled = true; } 可以发现，Activity的onCreate方法主要是做了一些Acitivty的初始化操作，那么如果我们不在自己的Activity调用super.onCreate方法呢？好吧，尝试之后，AndroidStudio在打开的Acitivty的onCreate方法中如果不调用super.onCreate方法的话，会报错。。。有木有搞错。。。 1FATAL EXCEPTION: main Process: com.example.aaron.helloworld, PID: 18001 android.util.SuperNotCalledException: Activity {com.example.aaron.helloworld/com.example.aaron.helloworld.SecondActivity} did not call through to super.onCreate() at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2422) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2528) at android.app.ActivityThread.access$800(ActivityThread.java:169) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1421) at android.os.Handler.dispatchMessage(Handler.java:111) at android.os.Looper.loop(Looper.java:194) at android.app.ActivityThread.main(ActivityThread.java:5552) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:964) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:759) 可以看到如果不调用super.onCreate方法的话，会在Activity的performLaunchActivity中报错，我们知道这里的performLaunchActivity方法就是我们启动Activity的时候回回调的方法，我们找找方法体实现中throws的Exception。。。 1234567891011activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } 在Activity的performLaunchActivity方法中，我们在调用了Activity的onCreate方法之后会执行一个判断逻辑，若Activity的mCalled为false，则会抛出我们刚刚捕获的异常，那么这个mCalled成员变量是在什么时候被赋值的呢？好吧，就是在Activity的onCreate方法赋值的，所以我们在实现自己的Activity的时候只有调用了super.onCreate方法才不会抛出这个异常，反过来说，我们实现自己的Actiivty，那么一定要在onCreate方法中调用super.onCreate方法。 然后我们在看一下onCreate中的setContentView方法，这里的参数就是一个Layout布局文件，可以发现这里的setContentView方法就是Acitivty中的setContentView，好吧我们来看一下Activity中setContentView的实现： 1234public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } 这里的getWindow方法就是获取Acitivty的mWindow成员变量，从刚刚我们在Activity.attach方法我们知道这里的mWindow的实例是PhoneWindow，所以这里调用的其实是PhoneWindow的setConentView方法，然后我们看一下PhoneWindow的setContentView是如何实现的。 123456789101112131415161718192021222324@Override public void setContentView(int layoutResID) { // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) { installDecor(); } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) { mContentParent.removeAllViews(); } if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); } else { mLayoutInflater.inflate(layoutResID, mContentParent); } mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) { cb.onContentChanged(); } } 这里的mContentParent对象是一个View对象，由于第一次mContentParent为空，所以执行installerDector方法，这里我们看一下installerDector方法的具体实现： 1234567891011private void installDecor() { if (mDecor == null) { mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) { mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); } } ... } 这里的mDector是一个DectorView对象，而DectorView继承与FrameLayout，所以这里的mDector其实就是一个FrameLayout对象，并通过调用generateDector()方法初始化，我们继续看一下generateDector方法的具体实现： 123protected DecorView generateDecor() { return new DecorView(getContext(), -1); } 好吧，就是通过new的方式创建了一个DectorView对象，然后我们继续看installDector方法： 12if (mContentParent == null) { mContentParent = generateLayout(mDecor); 这里初始化了mContentParent对象，这是一个View对象，我们调用了generateLayout方法，好吧，来看一下generateLayout方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122protected ViewGroup generateLayout(DecorView decor) { ... // Inflate the window decor. int layoutResource; int features = getLocalFeatures(); // System.out.println(&quot;Features: 0x&quot; + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { layoutResource = R.layout.screen_swipe_dismiss; } else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) { if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_title_icons; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); // System.out.println(&quot;Title Icons!&quot;); } else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) { // Special case for a window with only a progress bar (and title). // XXX Need to have a no-title version of embedded windows. layoutResource = R.layout.screen_progress; // System.out.println(&quot;Progress!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) { // Special case for a window with a custom title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; } else { layoutResource = R.layout.screen_custom_title; } // XXX Remove this once action bar supports these features. removeFeature(FEATURE_ACTION_BAR); } else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) { // If no other features and not embedded, only need a title. // If the window is floating, we need a dialog layout if (mIsFloating) { TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) { layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); } else { layoutResource = R.layout.screen_title; } // System.out.println(&quot;Title!&quot;); } else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) { layoutResource = R.layout.screen_simple_overlay_action_mode; } else { // Embedded, so no decoration is needed. layoutResource = R.layout.screen_simple; // System.out.println(&quot;Simple!&quot;); } mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) { throw new RuntimeException(&quot;Window couldn't find content container view&quot;); } if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) { ProgressBar progress = getCircularProgressBar(false); if (progress != null) { progress.setIndeterminate(true); } } if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) { registerSwipeCallbacks(); } // Remaining setup -- of background and title -- that only applies // to top-level windows. if (getContainer() == null) { final Drawable background; if (mBackgroundResource != 0) { background = getContext().getDrawable(mBackgroundResource); } else { background = mBackgroundDrawable; } mDecor.setWindowBackground(background); final Drawable frame; if (mFrameResource != 0) { frame = getContext().getDrawable(mFrameResource); } else { frame = null; } mDecor.setWindowFrame(frame); mDecor.setElevation(mElevation); mDecor.setClipToOutline(mClipToOutline); if (mTitle != null) { setTitle(mTitle); } if (mTitleColor == 0) { mTitleColor = mTextColor; } setTitleColor(mTitleColor); } mDecor.finishChanging(); return contentParent; } 可以发现这里就是通过调用LayoutInflater.inflate方法来加载布局文件到内存中，关于LayoutInflater.inflater是如何加载布局文件的，并且，通过对代码的分析，我们发现PhoneWindow中的几个成员变量：mDector，mContentRoot，mContentParent的关系mDector –&gt; mContentRoot –&gt; mContentParent（包含）并且我们来看一下典型的布局文件： 12345678910111213141516171819&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot; /&gt; &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot; /&gt;&lt;/LinearLayout&gt; 这里就是整个Activity加载的跟布局文件：screen_simple.xml，其中ViewStub对应着Activity中的titleBar而这里的FrameLayout里面主要用于填充内容。 然后我们具体看一下LayoutInflater.inflater方法： 123public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) { return inflate(resource, root, root != null); } 这里调用了inflate的重载方法。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) { synchronized (mConstructorArgs) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try { // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) { // Empty } if (type != XmlPullParser.START_TAG) { throw new InflateException(parser.getPositionDescription() + &quot;: No start tag found!&quot;); } final String name = parser.getName(); if (DEBUG) { System.out.println(&quot;**************************&quot;); System.out.println(&quot;Creating root view: &quot; + name); System.out.println(&quot;**************************&quot;); } if (TAG_MERGE.equals(name)) { if (root == null || !attachToRoot) { throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot; + &quot;ViewGroup root and attachToRoot=true&quot;); } rInflate(parser, root, inflaterContext, attrs, false); } else { // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) { if (DEBUG) { System.out.println(&quot;Creating params from root: &quot; + root); } // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) { // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); } } if (DEBUG) { System.out.println(&quot;-----&gt; start inflating children&quot;); } // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) { System.out.println(&quot;-----&gt; done inflating children&quot;); } // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) { root.addView(temp, params); } // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) { result = temp; } } } catch (XmlPullParserException e) { InflateException ex = new InflateException(e.getMessage()); ex.initCause(e); throw ex; } catch (Exception e) { InflateException ex = new InflateException( parser.getPositionDescription() + &quot;: &quot; + e.getMessage()); ex.initCause(e); throw ex; } finally { // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; } Trace.traceEnd(Trace.TRACE_TAG_VIEW); return result; } } 通过分析源码，不难发现，主要是通过循环解析xml文件并将信息解析到内存View对象，布局文件中定义的一个个组件都被顺序的解析到了内存中并被父子View的形式组织起来，这样通过给定的一个root View就可以将整个布局文件中定义的组件全部解析。分析完解析布局文件，回到我们的setContentVIew方法，在调用了installDector方法之后，又调用了： 1mLayoutInflater.inflate(layoutResID, mContentParent); 这个方法的含义就是将我们传递的客户端的layoutId对应的布局文件作为mContentParent的子View加载到内存中，这样我们的layoutId作为mContentParent的子View，而mContentParent又是mContentRoot的子View，mContentRoot又是mDector的子View，通过LayoutInflater的inflate方法逐步加载到了内存中，而我们的Activity又持有自身的PhoneWindow的引用，这就相当于我们的Activity持有了我们定义的布局文件的引用，因而Activity的布局文件被加载到了内存中。 总结： Activity的展示界面的特性是通过Window对象来控制的； 每个Activity对象都对应这个一个Window对象，并且Window对象的初始化在启动Activity的时候完成，在执行Activity的onCreate方法之前； 每个Window对象内部都存在一个FrameLayout类型的mDector对象，它是Acitivty界面的root view； Activity中的window对象的实例是PhoneWindow对象，PhoneWindow对象中的几个成员变量mDector，mContentRoot，mContentParent都是View组件，它们的关系是：mDector –&gt; mContentRoot –&gt; mContentParent –&gt; 自定义layoutView LayoutInflater.inflate主要用于将布局文件加载到内存View组件中，也可以设定加载到某一个父组件中； 典型的Activity的onCreate方法中需要调用super.onCreate方法和setContentView方法，若不调用super.onCreate方法，执行启动该Activity的逻辑会报错，若不执行setContentView的方法，该Activity只会显示一个空页面。 好了，关于Activity的布局加载流程我们暂时介绍这么多，下一篇文章，我们将介绍一下Activity的布局显示流程。 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"},{"title":"28 电源开关机按键事件流程","text":"前面我们讲解了系统截屏按键处理流程，HOME按键处理流程，今天再来讲解一下电源开关机按键事件流程，当然这也是系统按键处理流程方面的最后一篇博客了。 和截屏按键、HOME按键的处理流程类似，电源按键由于也是系统级别的按键，所以对其的事件处理逻辑是和截屏按键、HOME按键类似，不在某一个App中，而是在PhoneWindowManager的dispatchUnhandledKey方法中。所以和前面两篇类似，这里我们也是从PhoneWindowManager的dispatchUnhandledKey方法开始我们今天电源开关机按键的事件流程分析。 下面首先看一下dispatchUnhandledKey方法的实现逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) { ... KeyEvent fallbackEvent = null; if ((event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { final KeyCharacterMap kcm = event.getKeyCharacterMap(); final int keyCode = event.getKeyCode(); final int metaState = event.getMetaState(); final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0; // Check for fallback actions specified by the key character map. final FallbackAction fallbackAction; if (initialDown) { fallbackAction = kcm.getFallbackAction(keyCode, metaState); } else { fallbackAction = mFallbackActions.get(keyCode); } if (fallbackAction != null) { if (DEBUG_INPUT) { Slog.d(TAG, &quot;Fallback: keyCode=&quot; + fallbackAction.keyCode + &quot; metaState=&quot; + Integer.toHexString(fallbackAction.metaState)); } final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK; fallbackEvent = KeyEvent.obtain( event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null); if (!interceptFallback(win, fallbackEvent, policyFlags)) { fallbackEvent.recycle(); fallbackEvent = null; } if (initialDown) { mFallbackActions.put(keyCode, fallbackAction); } else if (event.getAction() == KeyEvent.ACTION_UP) { mFallbackActions.remove(keyCode); fallbackAction.recycle(); } } } ... return fallbackEvent; } 通过前面两篇文章的分析（ android源码解析（二十六）–&gt;截屏事件流程&nbsp;&nbsp;android源码解析（二十七）–&gt;HOME事件流程）我们知道关于系统按键的处理逻辑被下放到了interceptFallback方法中，所以我们继续看一下interceptFallback方法的实现逻辑。 1234567891011private boolean interceptFallback(WindowState win, KeyEvent fallbackEvent, int policyFlags) { int actions = interceptKeyBeforeQueueing(fallbackEvent, policyFlags); if ((actions &amp; ACTION_PASS_TO_USER) != 0) { long delayMillis = interceptKeyBeforeDispatching( win, fallbackEvent, policyFlags); if (delayMillis == 0) { return true; } } return false; }通过分析interceptFallback方法的源码，我们知道关于电源按键的处理逻辑在interceptKeyBeforeQueueing方法中，所以我们需要继续看一下interceptKeyBeforeQueueing方法中关于电源按键的处理逻辑。 12345678910111213141516public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) { ... case KeyEvent.KEYCODE_POWER: { result &amp;= ~ACTION_PASS_TO_USER; isWakeKey = false; // wake-up will be handled separately if (down) { interceptPowerKeyDown(event, interactive); } else { interceptPowerKeyUp(event, interactive, canceled); } break; } ... return result; } 这里我们重点看一下电源按键的处理事件，可以发现当电源按键按下的时候我们调用了interceptPowerKeyDown方法，可以看出，这个方法就是处理电源事件的了，既然如此，我们继续看一下interceptPowerKeyDown方法的执行逻辑。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162private void interceptPowerKeyDown(KeyEvent event, boolean interactive) { ... // Latch power key state to detect screenshot chord. if (interactive &amp;&amp; !mScreenshotChordPowerKeyTriggered &amp;&amp; (event.getFlags() &amp; KeyEvent.FLAG_FALLBACK) == 0) { mScreenshotChordPowerKeyTriggered = true; mScreenshotChordPowerKeyTime = event.getDownTime(); interceptScreenshotChord(); } // Stop ringing or end call if configured to do so when power is pressed. TelecomManager telecomManager = getTelecommService(); boolean hungUp = false; if (telecomManager != null) { if (telecomManager.isRinging()) { // Pressing Power while there's a ringing incoming // call should silence the ringer. telecomManager.silenceRinger(); } else if ((mIncallPowerBehavior &amp; Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 &amp;&amp; telecomManager.isInCall() &amp;&amp; interactive) { // Otherwise, if &quot;Power button ends call&quot; is enabled, // the Power button will hang up any current active call. hungUp = telecomManager.endCall(); } } // If the power key has still not yet been handled, then detect short // press, long press, or multi press and decide what to do. mPowerKeyHandled = hungUp || mScreenshotChordVolumeDownKeyTriggered || mScreenshotChordVolumeUpKeyTriggered; if (!mPowerKeyHandled) { if (interactive) { // When interactive, we're already awake. // Wait for a long press or for the button to be released to decide what to do. if (hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); } } else { wakeUpFromPowerKey(event.getDownTime()); if (mSupportLongPressPowerWhenNonInteractive &amp;&amp; hasLongPressOnPowerBehavior()) { Message msg = mHandler.obtainMessage(MSG_POWER_LONG_PRESS); msg.setAsynchronous(true); mHandler.sendMessageDelayed(msg, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout()); mBeganFromNonInteractive = true; } else { final int maxCount = getMaxMultiPressPowerCount(); if (maxCount &lt;= 1) { mPowerKeyHandled = true; } else { mBeganFromNonInteractive = true; } } } } } 这里我们重点看一下if(interactive)分支，在这里我们发送一个一个异步消息，并且msg的what为MSG_POWER_LONG_PRESS，即长按电源事件的异步消息，所以我们看一下mHandler的handleMessage方法对该what消息的处理逻辑。 123case MSG_POWER_LONG_PRESS: powerLongPress(); break; 我们可以发现在mHandler的handleMessage方法中当msg的what为MSG_POWER_LONG_PRESS时我们调用了powerLongPress方法，这个方法应该就是处理电源按键长按的逻辑，下面我们来看一下powerLongPress方法的实现。 123456789101112131415161718192021private void powerLongPress() { final int behavior = getResolvedLongPressOnPowerBehavior(); switch (behavior) { case LONG_PRESS_POWER_NOTHING: break; case LONG_PRESS_POWER_GLOBAL_ACTIONS: mPowerKeyHandled = true; if (!performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false)) { performAuditoryFeedbackForAccessibilityIfNeed(); } showGlobalActionsInternal(); break; case LONG_PRESS_POWER_SHUT_OFF: case LONG_PRESS_POWER_SHUT_OFF_NO_CONFIRM: mPowerKeyHandled = true; performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false); sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); mWindowManagerFuncs.shutdown(behavior == LONG_PRESS_POWER_SHUT_OFF); break; } } 可以发现这里有四个switch分之，其中第一个什么都不做直接break掉，第二个case则需要弹出选择操作界面，比如：飞行模式，开关机，静音模式，重新启动等，这里可以参看一下小米手机的关机界面： 然后第三第四个case分之则是直接调用关机方法，这里我们先看第二个case，看看系统是如何显示出关机操作界面的。那我们看一下showGlobalActionsInternal方法的实现逻辑。 12345678910111213void showGlobalActionsInternal() { sendCloseSystemWindows(SYSTEM_DIALOG_REASON_GLOBAL_ACTIONS); if (mGlobalActions == null) { mGlobalActions = new GlobalActions(mContext, mWindowManagerFuncs); } final boolean keyguardShowing = isKeyguardShowingAndNotOccluded(); mGlobalActions.showDialog(keyguardShowing, isDeviceProvisioned()); if (keyguardShowing) { // since it took two seconds of long press to bring this up, // poke the wake lock so they have some time to see the dialog. mPowerManager.userActivity(SystemClock.uptimeMillis(), false); } } 可以发现我们首先调用了sendCloseSystemWindows方法，前面我们分析HOME按键流程的时候（android源码解析（二十七）–&gt;HOME事件流程）知道该方法用于关机系统弹窗，比如输入法，壁纸等。然后我们创建了一个GlobalActions对象，并调用了其showDialog方法，通过分析源码，我们发现该方法就是用于显示长按电源按键弹出操作界面的，我们首先看一下GlobalActions的构造方法： 12345678910111213141516171819202122232425262728293031public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { mContext = context; mWindowManagerFuncs = windowManagerFuncs; mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); mDreamManager = IDreamManager.Stub.asInterface( ServiceManager.getService(DreamService.DREAM_SERVICE)); // receive broadcasts IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS); filter.addAction(Intent.ACTION_SCREEN_OFF); filter.addAction(TelephonyIntents.ACTION_EMERGENCY_CALLBACK_MODE_CHANGED); context.registerReceiver(mBroadcastReceiver, filter); ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE); mHasTelephony = cm.isNetworkSupported(ConnectivityManager.TYPE_MOBILE); // get notified of phone state changes TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_SERVICE_STATE); mContext.getContentResolver().registerContentObserver( Settings.Global.getUriFor(Settings.Global.AIRPLANE_MODE_ON), true, mAirplaneModeObserver); Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE); mHasVibrator = vibrator != null &amp;&amp; vibrator.hasVibrator(); mShowSilentToggle = SHOW_SILENT_TOGGLE &amp;&amp; !mContext.getResources().getBoolean( com.android.internal.R.bool.config_useFixedVolume); } 可以看到在GlobalActions对象的构造方法中我们主要用于初始化其成员变量，由于我们的电源长按操作界面是一个全局页面，所以这里自定义了一个Window对象，下面我们看一下GlobalActions的showDialog方法。 123456789101112public void showDialog(boolean keyguardShowing, boolean isDeviceProvisioned) { mKeyguardShowing = keyguardShowing; mDeviceProvisioned = isDeviceProvisioned; if (mDialog != null) { mDialog.dismiss(); mDialog = null; // Show delayed, so that the dismiss of the previous dialog completes mHandler.sendEmptyMessage(MESSAGE_SHOW); } else { handleShow(); } } 可以看到在showDialog方法中我们首先判断mDialog是否为空，若为空则发送msg的what为MESSAGE_SHOW的异步消息，否则调用handleShow方法，而这里的mDialog是一个类型为GlobalActionsDialog的变量，由于我们的mDialog为空，所以下面我们看一下handleShow方法。 1234567891011121314151617private void handleShow() { awakenIfNecessary(); mDialog = createDialog(); prepareDialog(); // If we only have 1 item and it's a simple press action, just do this action. if (mAdapter.getCount() == 1 &amp;&amp; mAdapter.getItem(0) instanceof SinglePressAction &amp;&amp; !(mAdapter.getItem(0) instanceof LongPressAction)) { ((SinglePressAction) mAdapter.getItem(0)).onPress(); } else { WindowManager.LayoutParams attrs = mDialog.getWindow().getAttributes(); attrs.setTitle(&quot;GlobalActions&quot;); mDialog.getWindow().setAttributes(attrs); mDialog.show(); mDialog.getWindow().getDecorView().setSystemUiVisibility(View.STATUS_BAR_DISABLE_EXPAND); } 在方法体中我们调用了createDialog方法，创建了GlobalActionsDialog类型的mDialog，这里我们看一下createDialog的实现方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118private GlobalActionsDialog createDialog() { ... mAirplaneModeOn = new ToggleAction( R.drawable.ic_lock_airplane_mode, R.drawable.ic_lock_airplane_mode_off, R.string.global_actions_toggle_airplane_mode, R.string.global_actions_airplane_mode_on_status, R.string.global_actions_airplane_mode_off_status) { void onToggle(boolean on) { if (mHasTelephony &amp;&amp; Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE))) { mIsWaitingForEcmExit = true; // Launch ECM exit dialog Intent ecmDialogIntent = new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null); ecmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mContext.startActivity(ecmDialogIntent); } else { changeAirplaneModeSystemSetting(on); } } @Override protected void changeStateFromPress(boolean buttonOn) { if (!mHasTelephony) return; // In ECM mode airplane state cannot be changed if (!(Boolean.parseBoolean( SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE)))) { mState = buttonOn ? State.TurningOn : State.TurningOff; mAirplaneState = mState; } } public boolean showDuringKeyguard() { return true; } public boolean showBeforeProvisioning() { return false; } }; onAirplaneModeChanged(); mItems = new ArrayList&lt;Action&gt;(); String[] defaultActions = mContext.getResources().getStringArray( com.android.internal.R.array.config_globalActionsList); ArraySet&lt;String&gt; addedKeys = new ArraySet&lt;String&gt;(); for (int i = 0; i &lt; defaultActions.length; i++) { String actionKey = defaultActions[i]; if (addedKeys.contains(actionKey)) { // If we already have added this, don't add it again. continue; } if (GLOBAL_ACTION_KEY_POWER.equals(actionKey)) { mItems.add(new PowerAction()); } else if (GLOBAL_ACTION_KEY_AIRPLANE.equals(actionKey)) { mItems.add(mAirplaneModeOn); } else if (GLOBAL_ACTION_KEY_BUGREPORT.equals(actionKey)) { if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.BUGREPORT_IN_POWER_MENU, 0) != 0 &amp;&amp; isCurrentUserOwner()) { mItems.add(getBugReportAction()); } } else if (GLOBAL_ACTION_KEY_SILENT.equals(actionKey)) { if (mShowSilentToggle) { mItems.add(mSilentModeAction); } } else if (GLOBAL_ACTION_KEY_USERS.equals(actionKey)) { if (SystemProperties.getBoolean(&quot;fw.power_user_switcher&quot;, false)) { addUsersToMenu(mItems); } } else if (GLOBAL_ACTION_KEY_SETTINGS.equals(actionKey)) { mItems.add(getSettingsAction()); } else if (GLOBAL_ACTION_KEY_LOCKDOWN.equals(actionKey)) { mItems.add(getLockdownAction()); } else if (GLOBAL_ACTION_KEY_VOICEASSIST.equals(actionKey)) { mItems.add(getVoiceAssistAction()); } else if (GLOBAL_ACTION_KEY_ASSIST.equals(actionKey)) { mItems.add(getAssistAction()); } else { Log.e(TAG, &quot;Invalid global action key &quot; + actionKey); } // Add here so we don't add more than one. addedKeys.add(actionKey); } mAdapter = new MyAdapter(); AlertParams params = new AlertParams(mContext); params.mAdapter = mAdapter; params.mOnClickListener = this; params.mForceInverseBackground = true; GlobalActionsDialog dialog = new GlobalActionsDialog(mContext, params); dialog.setCanceledOnTouchOutside(false); // Handled by the custom class. dialog.getListView().setItemsCanFocus(true); dialog.getListView().setLongClickable(true); dialog.getListView().setOnItemLongClickListener( new AdapterView.OnItemLongClickListener() { @Override public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { final Action action = mAdapter.getItem(position); if (action instanceof LongPressAction) { return ((LongPressAction) action).onLongPress(); } return false; } }); dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); dialog.setOnDismissListener(this); return dialog; } 方法体的内容比较长，我们看重点的内容，首先我们通过调用mContext.getResources().getStringArray(com.android.internal.R.array.config_globalActionsList)获得操作列表，这里可能包含：飞行模式、开关机、静音模式、重启等等，然后我们轮训操作列表，并添加相应的Action最后我们将这个操作列表保存到Dialog的adapter中并返回该dialog，然后我们回到我们刚刚的handleShow方法，在得到返回的dialog之后我们调用了dialog的show方法，这样我们就显示出了电源长按操作界面，比如小米的界面： 好吧，继续我们的分析，当我们长按电源按键弹出操作弹窗之后，这时候点击关机是怎么样的流程呢？我们发现在createDialog方法中关机操作adapter的item，我们添加了： 1mItems.add(new PowerAction()); 这样不难发现我们对关机按钮的操作封装在了PowerAction中，所以我们继续看一下PowerAction的实现。 1234567891011121314151617181920212223242526272829303132private final class PowerAction extends SinglePressAction implements LongPressAction { private PowerAction() { super(com.android.internal.R.drawable.ic_lock_power_off, R.string.global_action_power_off); } @Override public boolean onLongPress() { UserManager um = (UserManager) mContext.getSystemService(Context.USER_SERVICE); if (!um.hasUserRestriction(UserManager.DISALLOW_SAFE_BOOT)) { mWindowManagerFuncs.rebootSafeMode(true); return true; } return false; } @Override public boolean showDuringKeyguard() { return true; } @Override public boolean showBeforeProvisioning() { return true; } @Override public void onPress() { // shutdown by making sure radio and power are handled accordingly. mWindowManagerFuncs.shutdown(false /* confirm */); } } 可以发现在PowerAction类的成员函数onPress方法中我们调用了mWindowManagerFuncs.showdown方法，而这个方法也就是开始执行我们的关机操作了，那么这里的mWindowManagerFuncs又是什么呢？它是在什么时候赋值的呢？通过分析我们发现这里的mWindowManagerFuncs成员变量是在GlobalActions的构造方法中赋值的。 12345public GlobalActions(Context context, WindowManagerFuncs windowManagerFuncs) { ... mWindowManagerFuncs = windowManagerFuncs; ...} 好吧，回到我们的PhoneWindowManager，早构造GlobalActions时，直接传递的是PhoneWindowManager的成员变量mWindowManagerFuncs，那么PhoneWindowManager的mWindowManagerFuncs成员变量又是何时被赋值的呢?通过分析源码我们能够看到PhoneWindowManager的mWindowManagerFuncs变量是在PhoneWindowManager的init方法中初始化的，好吧，再次查找PhoneWindowManager的init方法是何时被调用的。 经过查找终于在WindowManagerService中我们找到了PhoneWindowManager的init方法的调用。 12345678910private void initPolicy() { UiThread.getHandler().runWithScissors(new Runnable() { @Override public void run() { WindowManagerPolicyThread.set(Thread.currentThread(), Looper.myLooper()); mPolicy.init(mContext, WindowManagerService.this, WindowManagerService.this); } }, 0); } 这里的mPolicy就是一个PhoneWindowManager的实力，可以发现这里的init方法中mWindowManagerFuncs传递的就是一个WindowManagerService的实例，O(∩_∩)O哈哈~，让我们好找。 然么在PowerAction的onPress方法中调用的mWindowManagerFuncs.shutdown(false / confirm /);方法，实际上调用的就是WindowManagerService的shutdown方法，这样我们继续看一下WindowManagerService的shutdown方法的实现。 1234@Override public void shutdown(boolean confirm) { ShutdownThread.shutdown(mContext, confirm); } 好吧，这里很简单就是直接调用了ShutdownThread的shutdown方法，看样子这里就是执行关机操作的封装了，继续看一下ShutdownThread的shutdown方法。 12345public static void shutdown(final Context context, boolean confirm) { mReboot = false; mRebootSafeMode = false; shutdownInner(context, confirm); } 可以看到在ShutdownThread的shutdown方法中代码很简单，具体的操作下发到了shutdownInner方法中，那么我们继续看一下shutdownInner方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void shutdownInner(final Context context, boolean confirm) { // ensure that only one thread is trying to power down. // any additional calls are just returned synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Request to shutdown already running, returning.&quot;); return; } } final int longPressBehavior = context.getResources().getInteger( com.android.internal.R.integer.config_longPressOnPowerBehavior); final int resourceId = mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_confirm : (longPressBehavior == 2 ? com.android.internal.R.string.shutdown_confirm_question : com.android.internal.R.string.shutdown_confirm); Log.d(TAG, &quot;Notifying thread to start shutdown longPressBehavior=&quot; + longPressBehavior); if (confirm) { final CloseDialogReceiver closer = new CloseDialogReceiver(context); if (sConfirmDialog != null) { sConfirmDialog.dismiss(); } sConfirmDialog = new AlertDialog.Builder(context) .setTitle(mRebootSafeMode ? com.android.internal.R.string.reboot_safemode_title : com.android.internal.R.string.power_off) .setMessage(resourceId) .setPositiveButton(com.android.internal.R.string.yes, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { beginShutdownSequence(context); } }) .setNegativeButton(com.android.internal.R.string.no, null) .create(); closer.dialog = sConfirmDialog; sConfirmDialog.setOnDismissListener(closer); sConfirmDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); sConfirmDialog.show(); } else { beginShutdownSequence(context); } } 可以看到方法体中，首先判断若用户点击了关机按键是否弹出确认框，若弹出则弹出关机确认框，若不需要确认，则直接调用beginShutdownSequence方法，执行关机操作。而在关机确认框中我们的确认按钮也是执行了beginShutdownSequence方法，所以我们继续看一下关机方法beginShutdownSequence。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private static void beginShutdownSequence(Context context) { synchronized (sIsStartedGuard) { if (sIsStarted) { Log.d(TAG, &quot;Shutdown sequence already running, returning.&quot;); return; } sIsStarted = true; } ... if (PowerManager.REBOOT_RECOVERY.equals(mRebootReason)) { mRebootUpdate = new File(UNCRYPT_PACKAGE_FILE).exists(); if (mRebootUpdate) { pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_update_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_update_prepare)); pd.setMax(100); pd.setProgressNumberFormat(null); pd.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL); pd.setProgress(0); pd.setIndeterminate(false); } else { // Factory reset path. Set the dialog message accordingly. pd.setTitle(context.getText(com.android.internal.R.string.reboot_to_reset_title)); pd.setMessage(context.getText( com.android.internal.R.string.reboot_to_reset_message)); pd.setIndeterminate(true); } } else { pd.setTitle(context.getText(com.android.internal.R.string.power_off)); pd.setMessage(context.getText(com.android.internal.R.string.shutdown_progress)); pd.setIndeterminate(true); } pd.setCancelable(false); pd.getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG); pd.show(); sInstance.mProgressDialog = pd; sInstance.mContext = context; sInstance.mPowerManager = (PowerManager)context.getSystemService(Context.POWER_SERVICE); // make sure we never fall asleep again sInstance.mCpuWakeLock = null; try { sInstance.mCpuWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.PARTIAL_WAKE_LOCK, TAG + &quot;-cpu&quot;); sInstance.mCpuWakeLock.setReferenceCounted(false); sInstance.mCpuWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mCpuWakeLock = null; } // also make sure the screen stays on for better user experience sInstance.mScreenWakeLock = null; if (sInstance.mPowerManager.isScreenOn()) { try { sInstance.mScreenWakeLock = sInstance.mPowerManager.newWakeLock( PowerManager.FULL_WAKE_LOCK, TAG + &quot;-screen&quot;); sInstance.mScreenWakeLock.setReferenceCounted(false); sInstance.mScreenWakeLock.acquire(); } catch (SecurityException e) { Log.w(TAG, &quot;No permission to acquire wake lock&quot;, e); sInstance.mScreenWakeLock = null; } } // start the thread that initiates shutdown sInstance.mHandler = new Handler() { }; sInstance.start(); } 在方法beginShutdownSequence中我们首先初始化了一个Process的dialog，该dialog用于显示关机界面，然后我们调用了sInstance.start方法，再往下的方法中就是真正的shutdown方法的实现，同时也是native方法，我们这里就不做过得解读了。。。 总结： 电源按键是系统按键，所以对电源按键的处理逻辑也是在PhoneWindowManager的dispatchUnhandledKey方法中； 在PhoneWindowManager的dispatchUnhandleKey方法处理Power按键之后会首先显示系统操作弹窗，一般包括但不限于：飞行模式，静音模式，重新启动，关机等； 当用户点击关机按钮是调用的是WindowManagerService.shutdown方法，而内部调用的是ShutdownThread.shutdown方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程","link":"/2020/09/11/%E7%94%B5%E6%BA%90%E5%BC%80%E5%85%B3%E6%9C%BA%E6%8C%89%E9%94%AE%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B/"},{"title":"12 系统启动并解析Manifest的流程","text":"最近有同学问我关于Manifest何时被系统解析的问题，正好也分析到这一块了，索性这一章就讲解一下android系统何时解析Manifest吧，这里的Manifest指的是android安装文件apk中的androidManifest.xml文件是何时被解析的。大家应该都知道，Android系统启动之后，我们就可以在一个应用中打开另一个从未打开过的应用，或者是在一个应用中发送广播，如果另外一个应用设置了这个广播的接收器，那么这个应用进程就会被启动并接收该广播并作出相应的处理，这样的例子很多，我们可以猜测到Android系统在启动的时候就会抓取到了系统中所有安装的应用信息（应该是解析apk文件的Manifest信息），即在Android系统的启动过程中就已经解析了系统中安装应用的androidManifest.xml文件并保存起来了，那么这个过程具体是如何的呢? 其实android系统启动过程中解析Manifest的流程是通过PackageManagerService服务来实现的。这里我们重点分析一下PackageManagerService服务是如何解析Manifest的。 首先看一下在SystemServer进程启动过程中是如何启动PackageManagerService服务的： 123456789private void startBootstrapServices() { ... mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); ... } 在SystemServer进程启动过程中会调用SystemServer类的startBootstrapServices方法（主要用于启动ActivityManagerService服务和PackageManagerService服务），然后会在这个方法中会调用PackageManagerService.main静态方法，这个方法主要是用来初始化PackageManagerService服务并执行相关逻辑的。下面我来看一下main方法的具体逻辑： 1234567public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); ServiceManager.addService(&quot;package&quot;, m); return m; }可以发现main方法的实现逻辑主要是创建了一个PackageManagerService对象，并将这个对象添加到ServierManager中为其他组件提供服务。好吧，看来PackageManagerService的初始化操作主要是在PackageManagerService的构造方法中了，下面我们来看一下其构造方法的实现逻辑： 1234567File dataDir = Environment.getDataDirectory(); mAppDataDir = new File(dataDir, &quot;data&quot;); mAppInstallDir = new File(dataDir, &quot;app&quot;); mAppLib32InstallDir = new File(dataDir, &quot;app-lib&quot;); mAsecInternalPath = new File(dataDir, &quot;app-asec&quot;).getPath(); mUserAppDataDir = new File(dataDir, &quot;user&quot;); mDrmAppPrivateInstallDir = new File(dataDir, &quot;app-private&quot;); PackageManagerService的构造方法代码量比较大，这里就不贴出所有的代码了，我们主要和解析Manifest相关的主要代码，在构造方法中有这样几段代码。可以发现在构造方法中，解析了系统中几个apk的安装目录，这几个目录就是系统中安装apk的目录，android系统会默认解析这几个目录下apk文件，也就是说如果我们android手机在其他的目录下存在apk文件系统是不会默认解析的，反过来说，如果我们把我们的apk文件移动到这几个目录下，那么重新启动操作系统，该apk文件就会被系统解析并执行相关的逻辑操作，具体做什么操作呢？我们看下面的实现。 123456789101112131415161718192021222324252627282930313233343536/ overlay packages if they reside in VENDOR_OVERLAY_DIR. File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR); scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0); // Find base frameworks (resource packages without code). scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags | SCAN_NO_DEX, 0); // Collected privileged system packages. final File privilegedAppDir = new File(Environment.getRootDirectory(), &quot;priv-app&quot;); scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0); // Collect ordinary system packages. final File systemAppDir = new File(Environment.getRootDirectory(), &quot;app&quot;); scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all vendor packages. File vendorAppDir = new File(&quot;/vendor/app&quot;); try { vendorAppDir = vendorAppDir.getCanonicalFile(); } catch (IOException e) { // failed to look up canonical path, continue with original one } scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); // Collect all OEM packages. final File oemAppDir = new File(Environment.getOemDirectory(), &quot;app&quot;); scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0); 在我们刚刚的PackageManagerService.mani方法中，解析完刚刚的几个系统目录之后系统会调用scanDirLI方法，那么这个方法主要是做什么用的呢？看它的名字应该是遍历这个系统目录。好吧，这个方法主要就是用于解析上面几个目录下的apk文件的。不信？我们看一下scanDirLI方法的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) { final File[] files = dir.listFiles(); if (ArrayUtils.isEmpty(files)) { Log.d(TAG, &quot;No files in app dir &quot; + dir); return; } if (DEBUG_PACKAGE_SCANNING) { Log.d(TAG, &quot;Scanning app dir &quot; + dir + &quot; scanFlags=&quot; + scanFlags + &quot; flags=0x&quot; + Integer.toHexString(parseFlags)); } for (File file : files) { final boolean isPackage = (isApkFile(file) || file.isDirectory()) &amp;&amp; !PackageInstallerService.isStageName(file.getName()); if (!isPackage) { // Ignore entries which are not packages continue; } try { scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK, scanFlags, currentTime, null); } catch (PackageManagerException e) { Slog.w(TAG, &quot;Failed to parse &quot; + file + &quot;: &quot; + e.getMessage()); // Delete invalid userdata apps if ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == 0 &amp;&amp; e.error == PackageManager.INSTALL_FAILED_INVALID_APK) { logCriticalInfo(Log.WARN, &quot;Deleting invalid package at &quot; + file); if (file.isDirectory()) { mInstaller.rmPackageDir(file.getAbsolutePath()); } else { file.delete(); } } } } } 可以放下其首先会遍历该目录下的所有文件，并判断是否是apk文件，如果是apk文件则调用scanPackageLI方法，scanPackageLI方法的名字很明显，就是用于解析这个apk文件的。 继续看一下scanPakcageLI方法的实现： 123456789101112131415161718192021private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { if (DEBUG_INSTALL) Slog.d(TAG, &quot;Parsing: &quot; + scanFile); parseFlags |= mDefParseFlags; PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setOnlyCoreApps(mOnlyCore); pp.setDisplayMetrics(mMetrics); if ((scanFlags &amp; SCAN_TRUSTED_OVERLAY) != 0) { parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY; } final PackageParser.Package pkg; try { pkg = pp.parsePackage(scanFile, parseFlags); } catch (PackageParserException e) { throw PackageManagerException.from(e); } ...} 好吧，这个方法也比较复杂，这里只是列出重点相关的代码，我们可以发现在这个方法中创建了一个PackagerParser对象，并调用了parsePackage方法，这个方法其实就是解析Manifest的主要方法，我们可以看一下其具体的实现： 1234567public Package parsePackage(File packageFile, int flags) throws PackageParserException { if (packageFile.isDirectory()) { return parseClusterPackage(packageFile, flags); } else { return parseMonolithicPackage(packageFile, flags); } } 可以发现，若我们解析的File对象是一个文件夹则执行调用parseClusterPackage方法，否则调用执行parseMonolithicPackage方法，很明显的因为我们这里解析的是apk文件（在上一方法中我们循环遍历得到了apk文件，这里的File对象就代表了一个个的apk文件信息），所以这里会执行parseMonolithicPackage方法，然后我们来看一下parseMonolithicPackage方法： 123456789101112131415161718public Package parseMonolithicPackage(File apkFile, int flags) throws PackageParserException { if (mOnlyCoreApps) { final PackageLite lite = parseMonolithicPackageLite(apkFile, flags); if (!lite.coreApp) { throw new PackageParserException(INSTALL_PARSE_FAILED_MANIFEST_MALFORMED, &quot;Not a coreApp: &quot; + apkFile); } } final AssetManager assets = new AssetManager(); try { final Package pkg = parseBaseApk(apkFile, assets, flags); pkg.codePath = apkFile.getAbsolutePath(); return pkg; } finally { IoUtils.closeQuietly(assets); } } 可以看出，这里又调用了parseBaseApk方法： 12345private Package parseBaseApk(File apkFile, AssetManager assets, int flags) ... final Package pkg = parseBaseApk(res, parser, flags, outError); ... } 可以看出，这个parseBaseApk方法调用了其重载的parseBaseApk方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;application&quot;)) { if (foundApp) { if (RIGID_PARSER) { outError[0] = &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;&lt;manifest&gt; has more than one &lt;application&gt;&quot;); XmlUtils.skipCurrentTag(parser); continue; } } foundApp = true; if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) { return null; } } else if (tagName.equals(&quot;overlay&quot;)) { pkg.mTrustedOverlay = trustedOverlay; sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestResourceOverlay); pkg.mOverlayTarget = sa.getString( com.android.internal.R.styleable.AndroidManifestResourceOverlay_targetPackage); pkg.mOverlayPriority = sa.getInt( com.android.internal.R.styleable.AndroidManifestResourceOverlay_priority, -1); sa.recycle(); if (pkg.mOverlayTarget == null) { outError[0] = &quot;&lt;overlay&gt; does not specify a target package&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } if (pkg.mOverlayPriority &lt; 0 || pkg.mOverlayPriority &gt; 9999) { outError[0] = &quot;&lt;overlay&gt; priority must be between 0 and 9999&quot;; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;key-sets&quot;)) { if (!parseKeySets(pkg, res, parser, attrs, outError)) { return null; } } else if (tagName.equals(&quot;permission-group&quot;)) { if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission&quot;)) { if (parsePermission(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;permission-tree&quot;)) { if (parsePermissionTree(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;uses-permission&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-permission-sdk-m&quot;) || tagName.equals(&quot;uses-permission-sdk-23&quot;)) { if (!parseUsesPermission(pkg, res, parser, attrs)) { return null; } } else if (tagName.equals(&quot;uses-configuration&quot;)) { ConfigurationInfo cPref = new ConfigurationInfo(); sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesConfiguration); cPref.reqTouchScreen = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqTouchScreen, Configuration.TOUCHSCREEN_UNDEFINED); cPref.reqKeyboardType = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqKeyboardType, Configuration.KEYBOARD_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqHardKeyboard, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_HARD_KEYBOARD; } cPref.reqNavigation = sa.getInt( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqNavigation, Configuration.NAVIGATION_UNDEFINED); if (sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesConfiguration_reqFiveWayNav, false)) { cPref.reqInputFeatures |= ConfigurationInfo.INPUT_FEATURE_FIVE_WAY_NAV; } sa.recycle(); pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-feature&quot;)) { FeatureInfo fi = parseUsesFeature(res, attrs); pkg.reqFeatures = ArrayUtils.add(pkg.reqFeatures, fi); if (fi.name == null) { ConfigurationInfo cPref = new ConfigurationInfo(); cPref.reqGlEsVersion = fi.reqGlEsVersion; pkg.configPreferences = ArrayUtils.add(pkg.configPreferences, cPref); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;feature-group&quot;)) { FeatureGroupInfo group = new FeatureGroupInfo(); ArrayList&lt;FeatureInfo&gt; features = null; final int innerDepth = parser.getDepth(); while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } final String innerTagName = parser.getName(); if (innerTagName.equals(&quot;uses-feature&quot;)) { FeatureInfo featureInfo = parseUsesFeature(res, attrs); // FeatureGroups are stricter and mandate that // any &lt;uses-feature&gt; declared are mandatory. featureInfo.flags |= FeatureInfo.FLAG_REQUIRED; features = ArrayUtils.add(features, featureInfo); } else { Slog.w(TAG, &quot;Unknown element under &lt;feature-group&gt;: &quot; + innerTagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); } XmlUtils.skipCurrentTag(parser); } if (features != null) { group.features = new FeatureInfo[features.size()]; group.features = features.toArray(group.features); } pkg.featureGroups = ArrayUtils.add(pkg.featureGroups, group); } else if (tagName.equals(&quot;uses-sdk&quot;)) { if (SDK_VERSION &gt; 0) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesSdk); int minVers = 0; String minCode = null; int targetVers = 0; String targetCode = null; TypedValue val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_minSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = minVers = val.data; } } val = sa.peekValue( com.android.internal.R.styleable.AndroidManifestUsesSdk_targetSdkVersion); if (val != null) { if (val.type == TypedValue.TYPE_STRING &amp;&amp; val.string != null) { targetCode = minCode = val.string.toString(); } else { // If it's not a string, it's an integer. targetVers = val.data; } } sa.recycle(); if (minCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (minCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + minCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } } else if (minVers &gt; SDK_VERSION) { outError[0] = &quot;Requires newer sdk version #&quot; + minVers + &quot; (current version is #&quot; + SDK_VERSION + &quot;)&quot;; mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } if (targetCode != null) { boolean allowedCodename = false; for (String codename : SDK_CODENAMES) { if (targetCode.equals(codename)) { allowedCodename = true; break; } } if (!allowedCodename) { if (SDK_CODENAMES.length &gt; 0) { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; (current platform is any of &quot; + Arrays.toString(SDK_CODENAMES) + &quot;)&quot;; } else { outError[0] = &quot;Requires development platform &quot; + targetCode + &quot; but this is a release platform.&quot;; } mParseError = PackageManager.INSTALL_FAILED_OLDER_SDK; return null; } // If the code matches, it definitely targets this SDK. pkg.applicationInfo.targetSdkVersion = android.os.Build.VERSION_CODES.CUR_DEVELOPMENT; } else { pkg.applicationInfo.targetSdkVersion = targetVers; } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;supports-screens&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestSupportsScreens); pkg.applicationInfo.requiresSmallestWidthDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_requiresSmallestWidthDp, 0); pkg.applicationInfo.compatibleWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_compatibleWidthLimitDp, 0); pkg.applicationInfo.largestWidthLimitDp = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largestWidthLimitDp, 0); // This is a trick to get a boolean and still able to detect // if a value was actually set. supportsSmallScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_smallScreens, supportsSmallScreens); supportsNormalScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_normalScreens, supportsNormalScreens); supportsLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_largeScreens, supportsLargeScreens); supportsXLargeScreens = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_xlargeScreens, supportsXLargeScreens); resizeable = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_resizeable, resizeable); anyDensity = sa.getInteger( com.android.internal.R.styleable.AndroidManifestSupportsScreens_anyDensity, anyDensity); sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;protected-broadcast&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestProtectedBroadcast); // Note: don't allow this value to be a reference to a resource // that may change. String name = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestProtectedBroadcast_name); sa.recycle(); if (name != null &amp;&amp; (flags&amp;PARSE_IS_SYSTEM) != 0) { if (pkg.protectedBroadcasts == null) { pkg.protectedBroadcasts = new ArrayList&lt;String&gt;(); } if (!pkg.protectedBroadcasts.contains(name)) { pkg.protectedBroadcasts.add(name.intern()); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;instrumentation&quot;)) { if (parseInstrumentation(pkg, res, parser, attrs, outError) == null) { return null; } } else if (tagName.equals(&quot;original-package&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String orig =sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); if (!pkg.packageName.equals(orig)) { if (pkg.mOriginalPackages == null) { pkg.mOriginalPackages = new ArrayList&lt;String&gt;(); pkg.mRealPackage = pkg.packageName; } pkg.mOriginalPackages.add(orig); } sa.recycle(); XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;adopt-permissions&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestOriginalPackage); String name = sa.getNonConfigurationString( com.android.internal.R.styleable.AndroidManifestOriginalPackage_name, 0); sa.recycle(); if (name != null) { if (pkg.mAdoptPermissions == null) { pkg.mAdoptPermissions = new ArrayList&lt;String&gt;(); } pkg.mAdoptPermissions.add(name); } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-gl-texture&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;compatible-screens&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;supports-input&quot;)) { XmlUtils.skipCurrentTag(parser); continue; } else if (tagName.equals(&quot;eat-comment&quot;)) { // Just skip this tag XmlUtils.skipCurrentTag(parser); continue; } else if (RIGID_PARSER) { outError[0] = &quot;Bad element under &lt;manifest&gt;: &quot; + parser.getName(); mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return null; } else { Slog.w(TAG, &quot;Unknown element under &lt;manifest&gt;: &quot; + parser.getName() + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } } 在这个parseBaseApk方法中有一个while循环，该循环主要就是用于解析AndroidManifest.xml文件中的节点信息。在开始解析application节点的时候，同时调用了parseBaseApplication方法，该方法解析了application节点下的activity，service，broadcast，contentprovier等组件的定义信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) { if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) { continue; } String tagName = parser.getName(); if (tagName.equals(&quot;activity&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false, owner.baseHardwareAccelerated); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (tagName.equals(&quot;receiver&quot;)) { Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.receivers.add(a); } else if (tagName.equals(&quot;service&quot;)) { Service s = parseService(owner, res, parser, attrs, flags, outError); if (s == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.services.add(s); } else if (tagName.equals(&quot;provider&quot;)) { Provider p = parseProvider(owner, res, parser, attrs, flags, outError); if (p == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.providers.add(p); } else if (tagName.equals(&quot;activity-alias&quot;)) { Activity a = parseActivityAlias(owner, res, parser, attrs, flags, outError); if (a == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } owner.activities.add(a); } else if (parser.getName().equals(&quot;meta-data&quot;)) { // note: application meta-data is stored off to the side, so it can // remain null in the primary copy (we like to avoid extra copies because // it can be large) if ((owner.mAppMetaData = parseMetaData(res, parser, attrs, owner.mAppMetaData, outError)) == null) { mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } else if (tagName.equals(&quot;library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestLibrary_name); sa.recycle(); if (lname != null) { lname = lname.intern(); if (!ArrayUtils.contains(owner.libraryNames, lname)) { owner.libraryNames = ArrayUtils.add(owner.libraryNames, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-library&quot;)) { sa = res.obtainAttributes(attrs, com.android.internal.R.styleable.AndroidManifestUsesLibrary); // Note: don't allow this value to be a reference to a resource // that may change. String lname = sa.getNonResourceString( com.android.internal.R.styleable.AndroidManifestUsesLibrary_name); boolean req = sa.getBoolean( com.android.internal.R.styleable.AndroidManifestUsesLibrary_required, true); sa.recycle(); if (lname != null) { lname = lname.intern(); if (req) { owner.usesLibraries = ArrayUtils.add(owner.usesLibraries, lname); } else { owner.usesOptionalLibraries = ArrayUtils.add( owner.usesOptionalLibraries, lname); } } XmlUtils.skipCurrentTag(parser); } else if (tagName.equals(&quot;uses-package&quot;)) { // Dependencies for app installers; we don't currently try to // enforce this. XmlUtils.skipCurrentTag(parser); } else { if (!RIGID_PARSER) { Slog.w(TAG, &quot;Unknown element under &lt;application&gt;: &quot; + tagName + &quot; at &quot; + mArchiveSourcePath + &quot; &quot; + parser.getPositionDescription()); XmlUtils.skipCurrentTag(parser); continue; } else { outError[0] = &quot;Bad element under &lt;application&gt;: &quot; + tagName; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; } } } 这样，经过这里循环遍历，整个androidManifest的节点信息就被解析并保存在了Package对象中。可以看到我们平时在Manifest中定义的各种节点，其实都是在这里有所体现。当androidManifest.xml文件被解析完成之后会调用我们刚刚介绍的scanPackageLI的重载方法，将解析完成的Package对象信息保存的Setting对象中，这个对象用于保存app的安装信息，具体实现是在方法： 12private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException 当解析完成manifest文件之后会调用其重载方法： 123// Note that we invoke the following method only if we are about to unpack an application PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user); 这样，解析的manifest文件信息就会被保存到Settings中，并持久化，然后执行安装apk的操作，我们可以看一下该重载方法的具体实现： 1234567891011121314private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { boolean success = false; try { final PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags, currentTime, user); success = true; return res; } finally { if (!success &amp;&amp; (scanFlags &amp; SCAN_DELETE_DATA_ON_FAILURES) != 0) { removeDataDirsLI(pkg.volumeUuid, pkg.packageName); } } } 可以发现其内部调用了scanPackageDirtyLI方法，这个方法就是实际实现持久化manifest信息并安装APK操作的： 12345678private PackageParser.Package scanPackageDirtyLI(PackageParser.Package pkg, int parseFlags, int scanFlags, long currentTime, UserHandle user) throws PackageManagerException { ... // And now re-install the app. ret = createDataDirsLI(pkg.volumeUuid, pkgName, pkg.applicationInfo.uid, pkg.applicationInfo.seinfo); ...} 可以发现其内部调用了createDataDirLI，该方法主要实现安装apk的操作。 1234567891011121314151617private int createDataDirsLI(String volumeUuid, String packageName, int uid, String seinfo) { int[] users = sUserManager.getUserIds(); int res = mInstaller.install(volumeUuid, packageName, uid, uid, seinfo); if (res &lt; 0) { return res; } for (int user : users) { if (user != 0) { res = mInstaller.createUserData(volumeUuid, packageName, UserHandle.getUid(user, uid), user, seinfo); if (res &lt; 0) { return res; } } } return res; } 查看该方法的实现：1234567891011121314public int install(String uuid, String name, int uid, int gid, String seinfo) { StringBuilder builder = new StringBuilder(&quot;install&quot;); builder.append(' '); builder.append(escapeNull(uuid)); builder.append(' '); builder.append(name); builder.append(' '); builder.append(uid); builder.append(' '); builder.append(gid); builder.append(' '); builder.append(seinfo != null ? seinfo : &quot;!&quot;); return mInstaller.execute(builder.toString()); }怎么样？很熟悉吧，这里的Installer其实调用的就是我们平时运行android项目很熟悉的install命令，原来android系统安装apk文件底层都是调用的adb命令。 总结： android系统启动之后会解析固定目录下的apk文件，并执行解析，持久化apk信息，重新安装等操作； 解析Manifest流程：Zygote进程 –&gt; SystemServer进程 –&gt; PackgeManagerService服务 –&gt; scanDirLI方法 –&gt; scanPackageLI方法 –&gt; PackageParser.parserPackage方法； 解析完成Manifest之后会将apk的Manifest信息保存在Settings对象中并持久化，然后执行重新安装的操作； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程","link":"/2020/09/11/%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E5%B9%B6%E8%A7%A3%E6%9E%90Manifest%E7%9A%84%E6%B5%81%E7%A8%8B/"},{"title":"30 触摸事件分发流程","text":"前面一篇文章中我们分析了App返回按键的分发流程，从Native层到ViewRootImpl层到DocorView层到Activity层，以及在Activity中的dispatchKeyEvent方法中分发事件，最终调用了Activity的finish方法，即销毁Activity，所以一般情况下假如我们不重写Activity的onBackPress方法或者是onKeyDown方法，当我们按下并抬起返回按键的时候默认都是销毁当前Activity。而本文中我们主要介绍触摸事件的分发流程，从Native层到Activity层触摸事件的分发了流程和按键的分发事件都是类似的，这里我们可以根据异常堆栈信息看一下。 123456789101112131415161718192021at com.example.aaron.helloworld.MainActivity.dispatchTouchEvent(MainActivity.java:103)at com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:2359)at android.view.View.dispatchPointerEvent(View.java:8698)at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:4530)at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4388)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4053)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4110)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:3977)at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:3943)at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:3951)at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:3924)at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:6345)at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:6301)at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:6254)at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:6507)at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:185) 这样经过一系列的方法调用之后最终调用了Activity的dispatchTouchEvent方法，而我们也是从Activiyt的dispatchTouchEvent方法开始对触摸事件的分发进行分析。 在具体查看Activity的dispatchTouchEvent方法之前我们先简单介绍一下触摸事件，触摸事件是由一个触摸按下事件、N个触摸滑动事件和一个触摸抬起事件组成的，通常的一个触摸事件中只能存在一个触摸按下和一个触摸抬起事件，但是触摸滑动事件可以有零个或者多个。好了，知道这个概念以后，下面我们就具体看一下Activity中的dispatchTouchEvent的实现逻辑。 123456789public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onUserInteraction(); } if (getWindow().superDispatchTouchEvent(ev)) { return true; } return onTouchEvent(ev); } 在看一下dispatchTouchEvent方法之前我们首先需要解释一下MotionEvent的概念。MotionEvent是一个触摸动作的封装，里面包含了触摸动作的类型，以及操作等属性，我们具体的可以看一下MotionEvent的说明： Object used to report movement (mouse, pen, finger, trackball) events. Motion events may hold either absolute or relative movements and other data, depending on the type of device. 然后在dispatchTouchEvent方法中，会首先判断MotionEvent的动作类型，也就是我们的触目动作的类型，判断其是否是“按下”操作，若是的湖泽，则执行onUserInteraction方法，这个方法又是实现了什么逻辑呢？ 12public void onUserInteraction() { }可以发现其在Activity中只是一个简单的空实现方法，同样的我们可以看一下该方法的介绍： Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and {@link #onUserLeaveHint} are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. 理解上就是用户在触屏点击，按home，back，menu键都会触发此方法。 回到Activity的dispatchTouchEvent方法中，我们调用了getWindow().suerDispatchTouchEvent()方法，我们分析过Activity的加载绘制流程，而这里的getWindow()就是返回Activity中的mWindow对象，而我们知道Activity中的mWindow对象就是一个PhoneWindow的实例。并且这里的window.superDispatchTouchEvent若返回值为ture，则直接返回true，否则的话会执行Activity的onTouchEvent方法，继续我们看一下PhoneWindow的superDispatchTouchEvent方法。 1234@Override public boolean superDispatchTouchEvent(MotionEvent event) { return mDecor.superDispatchTouchEvent(event); } 可以看到在PhoneWindow中的superDispatchTouchEvent方法中调用的是mDecor.superDispatchTouchEvent方法，而这里的mDecor是我们Activity显示的ViewTree的根View，并且mDecor是一个FrameLayout的子类，所以这里我们看一下mDecor的superDispatchTouchEvent方法。 1234567private final class DecorView extends FrameLayout implements RootViewSurfaceTaker { ... public boolean superDispatchTouchEvent(MotionEvent event) { return super.dispatchTouchEvent(event); } ...} 在DecorView的superDispatchTouchEvent方法中我们调用了super.dispatchTouchEvent方法，而我们的DecorView继承于FrameLayout，但是经过查看之后我们知道FrameLayout中并没有实现dispatchTouchEvent方法，而由于我们的FrameLayout继承于ViewGroup，所以这里的dispatchTouchEvent方法应该就是ViewGroup的dispatchTouchEvent方法。 好了，这里先暂时说一下Acitivty中的事件分发流程 ViewRootImpl层的事件分发会首先调用Activity的dispatchTouchEvent方法； Activity的dispatchTouchEvent方法中会通过Window.superDispatchTouchEvent方法将事件传递给DecorView即ViewGroup。 若window的superDispatchTouchEvent方法返回true，则事件分发完成，Activity的dispatchTouchEvent直接返回为true，否则的话调用Activity的onTouchEvent方法，并且Acitivty的dispatchTouchEvent返回值与Activity的onTouchEvent返回值一致。 下面我们在继续看一下ViewGroup的dispatchTouchEvent方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214public boolean dispatchTouchEvent(MotionEvent ev) { if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } // If the event targets the accessibility focused view and this is it, start // normal event dispatch. Maybe a descendant is what will handle the click. if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) { ev.setTargetAccessibilityFocus(false); } boolean handled = false; if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); } // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already // a view that is handling the gesture, do normal event dispatch. if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; if (!canceled &amp;&amp; !intercepted) { // If the event is targeting accessiiblity focus we give it to the // view that has accessibility focus and if it does not handle it // we clear the flag and dispatch the event to all children as usual. // We are looking up the accessibility focused host to avoid keeping // state since these events are very rare. View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they // have become out of sync. removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null &amp;&amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event. // Scan children from front to back. final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList(); final boolean customOrder = preorderedList == null &amp;&amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) { final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds. // Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn't handle the event, so clear // the flag and do a normal dispatch to all children. ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) { // Did not find a child to receive the event. // Assign the pointer to the least recently added target. newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed. if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } return handled; } 前面我们知道触摸事件是由一个触摸按下事件，一个触摸抬起事件和N个触摸滑动事件组成的，而这里的触摸按下事件就是这里的ACTION_DOWN，同时友谊ACTION_DOWN是一系列事件的开端，所以我们在ACTION_DOWN时进行一些初始化操作，从上面源码中注释也可以看出来，清除以往的Touch状态然后开始新的手势。并在在cancelAndClearTouchTargets(ev)方法中将mFirstTouchTarget设置为了null，接着在resetTouchState()方法中重置Touch状态标识。 然后标记ViewGroup是否拦截Touch事件的传递，if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null)这一条判断语句说明当事件为ACTION_DOWN或者mFirstTouchTarget不为null(即已经找到能够接收touch事件的目标组件)时if成立，否则if不成立，然后将intercepted设置为true，也即拦截事件。这里说明一下ViewGroup中的onInterceptTouchEvent方法是ViewGroup中特有的方法用于表示是否拦截触摸事件，返回为true的话则表示拦截事件，事件不在向子View中分发，若范围为false的话，则表示不拦截事件，继续分发事件。 123public boolean onInterceptTouchEvent(MotionEvent ev) { return false; } 一般的我们可以在自定义的ViewGroup中重写该方法，用于拦截事件的分发。而当我们在父ViewGroup重写该方法返回为true执行事件拦截的逻辑的时候，可以在子View中通过调用requestDisallowInterceptTouchEvent方法，重新设置父ViewGroup的onInterceptTouchEvent方法为false，不拦截对事件的分发逻辑。 123456789101112131415161718public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We're already in this state, assume our ancestors are too return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } } 比如常见的向我们的ViewPager中由于需要处理左右滑动事件从而在其onInterceptTouchEvent方法中重写了返回值，返回为true，拦截对事件的处理逻辑，但是若这时候ViewPager中嵌套了ListView，则listView也需要处理触摸事件的逻辑，但是ViewPager中已经重写了onInterceptTouchEvent方法，这时候怎么办呢？幸运的是ListView也在内部的实现中调用了requestDisallowInterceptTouchEvent方法，保证自身获得对触摸事件的处理。 然后在代码中我们判断childrenCount个数是否不为0，继续我们获取子View的list集合preorderedList；最后通过一个for循环倒序遍历所有的子view，这是因为preorderedList中的顺序是按照addView或者XML布局文件中的顺序来的，后addView添加的子View，会因为Android的UI后刷新机制显示在上层；假如点击的地方有两个子View都包含的点击的坐标，那么后被添加到布局中的那个子view会先响应事件；也就是说后被添加的子view会浮在上层，点击的时候最上层的那个组件先去响应事件。 然后代码通过调用getTouchTarget去查找当前子View是否在mFirstTouchTarget.next这条target链中的某一个targe中，如果在则返回这个target，否则返回null。在这段代码的if判断通过说明找到了接收Touch事件的子View，即newTouchTarget，那么，既然已经找到了，所以执行break跳出for循环。如果没有break则继续向下执行，这里你可以看见一段if判断的代码if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign))，那么这个方法又是执行什么逻辑的呢？ 在该方法中为一个递归调用，会递归调用dispatchTouchEvent()方法。在dispatchTouchEvent()中如果子View为ViewGroup并且Touch没有被拦截那么递归调用dispatchTouchEvent()，如果子View为View那么就会调用其onTouchEvent()。dispatchTransformedTouchEvent方法如果返回true则表示子View消费掉该事件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don't need to perform any transformations // or filtering. The important part is the action, not the contents. final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver. final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits &amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we // might produce a motion event with no pointers in it, then drop the event. if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don't need to perform any fancy // irreversible transformations, then we can reuse the motion event for this // dispatch as long as we are careful to revert any changes we make. // Otherwise we need to make a copy. final MotionEvent transformedEvent; if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch. if (child == null) { handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); if (! child.hasIdentityMatrix()) { transformedEvent.transform(child.getInverseMatrix()); } handled = child.dispatchTouchEvent(transformedEvent); } // Done. transformedEvent.recycle(); return handled; }然后在在ViewGroup的dispatchTransformedTouchEvent方法中，调用了该ViewGroup的child View的dispatchTouchEvent方法，若其子View也是ViewGroup，则重复执行ViewGroup的dispatchTouchEvent方法，若其子View是View，则执行View的dispatchTouchEvent方法。 但这里大概分析了一下ViewGroup的事件分发流程 首先在android的事件分发流程中，通过调用Activity的dispatchTouchEvent，事件会首先被派发是先传递到最顶级的DecorView也就是ViewGroup，再由ViewGroup递归传递到View的。 在ViewGroup中可以通过设置onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。 下面我们继续看一下View的dispatchTouchEvent方法。12345678910111213141516171819public boolean dispatchTouchEvent(MotionEvent event) { ... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; }View的dispatchTouchEvent方法的内容比较长，我们重点看一下View对触摸事件的处理逻辑，首先调用了onFilterTouchEventForSecurity(event)方法判断当前的View是否被遮盖，若没有的话，则判断View的mListenerInfo城边变量是否为空，而这里的mListenerInfo又是什么呢？通过分析源码我们知道这里的mListenerInfo是通过setOnClickListener方法设置的。 123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l; } 可以当前View一旦执行了setOnClickListener方法改View的mListenerInfo就不为空，若后有判断了该View是否可点击，最后是判断View的onTouchListener的onTouch方法的返回值。 所以当我们为当前View设置了OnTouchListener并且返回值为true的话，则直接执行其onTouch方法，若onTouch方法返回为true的话，则直接返回不在执行后续的View的onTouchEvent方法，否则继续执行View的onTouchEvent方法，而我们继续看一下View的onTouchEvent方法的实现逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); if ((viewFlags &amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) { setPressed(false); } // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0); } break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) { // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) { // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); } } break; } return true; } return false; } 在ACTION为MotionEvent.ACTION_UP时，我们经过层层调用最终执行了performClick，方法而这个方法中我们回调了View的OnClickListener的onClick方法。。。 1234567891011121314public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; } 所以View组件分发触摸事件的时候： View控件会首先执行dispatchTouchEvent方法。 View控件在dispatchTouchEvent方法中先执行onTouch方法，后执行onClick方法。 View的onTouch返回false或者mOnTouchListener为null（控件没有设置setOnTouchListener方法）或者控件不是enable的情况下会调运onTouchEvent，dispatchTouchEvent返回值与onTouchEvent返回一样。 View控件不是enable的，那么即使设置了onTouch方法也不会执行，只能通过重写控件的onTouchEvent方法处理，dispatchTouchEvent返回值与onTouchEvent返回一样。 如果控件（View）是enable且onTouch返回true情况下，dispatchTouchEvent直接返回true，不会调用onTouchEvent方法。 参考：http://blog.csdn.net/xiaanming/article/details/21696315http://blog.csdn.net/guolin_blog/article/details/9097463http://blog.csdn.net/guolin_blog/article/details/9153747 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程android源码解析（十八）–&gt;Activity布局绘制流程android源码解析（十九）–&gt;Dialog加载绘制流程android源码解析（二十）–&gt;Dialog取消绘制流程android源码解析（二十一）–&gt;PopupWindow加载绘制流程android源码解析（二十二）–&gt;Toast加载绘制流程android源码解析（二十三）–&gt;Android异常处理流程android源码解析（二十四）–&gt;onSaveInstanceState执行时机android源码解析（二十五）–&gt;onLowMemory执行流程android源码解析（二十六）–&gt;截屏事件流程android源码解析（二十七）–&gt;HOME事件流程android源码解析（二十八）–&gt;电源开关机按键事件流程android源码解析（二十九）–&gt;应用程序返回按键执行流程","link":"/2020/09/11/%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B5%81%E7%A8%8B/"},{"title":"13 apk安装流程","text":"上一篇文章中给大家分析了一下android系统启动之后调用PackageManagerService服务并解析系统特定目录，解析apk文件并安装的过程，这个安装过期实际上是没有图形界面的，底层调用的是我们平时比较熟悉的adb命令，那么我们平时安装apk文件的时候大部分是都过图形界面安装的，那么这种方式安装apk具体的流程是怎样的呢？ 下面我们就来具体看一下apk的具体安装过程，相信大家都知道如果我们想在代码里执行apk的安装，那么一般都是这样： 1234Intent intent = new Intent(Intent.ACTION_VIEW);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.setDataAndType(Uri.parse(&quot;file://&quot; + path),&quot;application/vnd.android.package-archive&quot;);context.startActivity(intent); 这样，我们就会打开安装apk文件的程序并执行安装逻辑了，那么这段代码具体是打开那个activity呢？好吧，从这个问题开始，我们来解析apk的安装流程… 这里跟大姐简单介绍一下android的源码，平时我们使用的android.jar里面的java源码只是android系统源码的一部分，还有好多源码并没有打入到android.jar中，这里为大家推荐一个android源码的地址：https://github.com/android里面根据android系统的不同模块包含了许多android模块的源码。 这里我们找到platform_packages_apps_packageinstaller库，这里面就是android系统安装程序的源码了。 这里我们找到其androidManifest.xml，然后我们来看一下其具体的定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.android.packageinstaller&quot; coreApp=&quot;true&quot;&gt; &lt;original-package android:name=&quot;com.android.packageinstaller&quot; /&gt; ... &lt;application android:label=&quot;@string/app_name&quot; android:allowBackup=&quot;false&quot; android:theme=&quot;@style/Theme.DialogWhenLarge&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.InstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.UninstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/Theme.AlertDialogActivity&quot;&gt; &lt;intent-filter android:priority=&quot;1&quot;&gt; &lt;action android:name=&quot;android.intent.action.DELETE&quot; /&gt; &lt;action android:name=&quot;android.intent.action.UNINSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.UninstallAppProgress&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:exported=&quot;false&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.GrantPermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@style/GrantPermissions&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.REQUEST_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.ManagePermissionsActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot; android:label=&quot;@string/app_permissions&quot; android:theme=&quot;@style/Settings&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_APP_PERMISSIONS&quot; /&gt; &lt;action android:name=&quot;android.intent.action.MANAGE_PERMISSION_APPS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.permission.ui.OverlayWarningDialog&quot; android:excludeFromRecents=&quot;true&quot; android:theme=&quot;@android:style/Theme.DeviceDefault.Light.Dialog.NoActionBar&quot; /&gt; &lt;provider android:name=&quot;.wear.WearPackageIconProvider&quot; android:authorities=&quot;com.google.android.packageinstaller.wear.provider&quot; android:grantUriPermissions=&quot;true&quot; android:exported=&quot;true&quot; /&gt; &lt;activity android:name=&quot;.permission.ui.wear.WarningConfirmationActivity&quot; android:permission=&quot;android.permission.GRANT_RUNTIME_PERMISSIONS&quot; android:theme=&quot;@style/Settings&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt;好吧，这里我们大概看一下Activity的定义，这里我们重点看一下PackageInstallerActivity的定义： 123456789101112131415161718192021&lt;activity android:name=&quot;.PackageInstallerActivity&quot; android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot; android:excludeFromRecents=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:mimeType=&quot;application/vnd.android.package-archive&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.INSTALL_PACKAGE&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;file&quot; /&gt; &lt;data android:scheme=&quot;package&quot; /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.content.pm.action.CONFIRM_PERMISSIONS&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 恩？这里不就是我们刚刚定义的启动安装Apk activity的intent filter？好吧，所以说一开始我们调用的startActivity其实启动的就是PackageInstallerActivity，那么下面我们就看一下PackageInstellerActivity的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 这里我们主要先看一下PackageInstallerActivity的onCreate方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134@Override protected void onCreate(Bundle icicle) { super.onCreate(icicle); mPm = getPackageManager(); mInstaller = mPm.getPackageInstaller(); mUserManager = (UserManager) getSystemService(Context.USER_SERVICE); final Intent intent = getIntent(); if (PackageInstaller.ACTION_CONFIRM_PERMISSIONS.equals(intent.getAction())) { final int sessionId = intent.getIntExtra(PackageInstaller.EXTRA_SESSION_ID, -1); final PackageInstaller.SessionInfo info = mInstaller.getSessionInfo(sessionId); if (info == null || !info.sealed || info.resolvedBaseCodePath == null) { Log.w(TAG, &quot;Session &quot; + mSessionId + &quot; in funky state; ignoring&quot;); finish(); return; } mSessionId = sessionId; mPackageURI = Uri.fromFile(new File(info.resolvedBaseCodePath)); mOriginatingURI = null; mReferrerURI = null; } else { mSessionId = -1; mPackageURI = intent.getData(); mOriginatingURI = intent.getParcelableExtra(Intent.EXTRA_ORIGINATING_URI); mReferrerURI = intent.getParcelableExtra(Intent.EXTRA_REFERRER); } final boolean unknownSourcesAllowedByAdmin = isUnknownSourcesAllowedByAdmin(); final boolean unknownSourcesAllowedByUser = isUnknownSourcesEnabled(); boolean requestFromUnknownSource = isInstallRequestFromUnknownSource(intent); mInstallFlowAnalytics = new InstallFlowAnalytics(); mInstallFlowAnalytics.setContext(this); mInstallFlowAnalytics.setStartTimestampMillis(SystemClock.elapsedRealtime()); mInstallFlowAnalytics.setInstallsFromUnknownSourcesPermitted(unknownSourcesAllowedByAdmin &amp;&amp; unknownSourcesAllowedByUser); mInstallFlowAnalytics.setInstallRequestFromUnknownSource(requestFromUnknownSource); mInstallFlowAnalytics.setVerifyAppsEnabled(isVerifyAppsEnabled()); mInstallFlowAnalytics.setAppVerifierInstalled(isAppVerifierInstalled()); mInstallFlowAnalytics.setPackageUri(mPackageURI.toString()); if (DeviceUtils.isWear(this)) { showDialogInner(DLG_NOT_SUPPORTED_ON_WEAR); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_NOT_ALLOWED_ON_WEAR); return; } final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { Log.w(TAG, &quot;Unsupported scheme &quot; + scheme); setPmResult(PackageManager.INSTALL_FAILED_INVALID_URI); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); finish(); return; } final PackageUtil.AppSnippet as; if (&quot;package&quot;.equals(mPackageURI.getScheme())) { mInstallFlowAnalytics.setFileUri(false); try { mPkgInfo = mPm.getPackageInfo(mPackageURI.getSchemeSpecificPart(), PackageManager.GET_PERMISSIONS | PackageManager.GET_UNINSTALLED_PACKAGES); } catch (NameNotFoundException e) { } if (mPkgInfo == null) { Log.w(TAG, &quot;Requested package &quot; + mPackageURI.getScheme() + &quot; not available. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_PACKAGE_MISSING); return; } as = new PackageUtil.AppSnippet(mPm.getApplicationLabel(mPkgInfo.applicationInfo), mPm.getApplicationIcon(mPkgInfo.applicationInfo)); } else { mInstallFlowAnalytics.setFileUri(true); final File sourceFile = new File(mPackageURI.getPath()); PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); // Check for parse errors if (parsed == null) { Log.w(TAG, &quot;Parse error when parsing manifest. Discontinuing installation&quot;); showDialogInner(DLG_PACKAGE_ERROR); setPmResult(PackageManager.INSTALL_FAILED_INVALID_APK); mInstallFlowAnalytics.setPackageInfoObtained(); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_TO_GET_PACKAGE_INFO); return; } mPkgInfo = PackageParser.generatePackageInfo(parsed, null, PackageManager.GET_PERMISSIONS, 0, 0, null, new PackageUserState()); mPkgDigest = parsed.manifestDigest; as = PackageUtil.getAppSnippet(this, mPkgInfo.applicationInfo, sourceFile); } mInstallFlowAnalytics.setPackageInfoObtained(); //set view setContentView(R.layout.install_start); mInstallConfirm = findViewById(R.id.install_confirm_panel); mInstallConfirm.setVisibility(View.INVISIBLE); PackageUtil.initSnippetForNewApp(this, as, R.id.app_snippet); mOriginatingUid = getOriginatingUid(intent); // Block the install attempt on the Unknown Sources setting if necessary. if (!requestFromUnknownSource) { initiateInstall(); return; } // If the admin prohibits it, or we're running in a managed profile, just show error // and exit. Otherwise show an option to take the user to Settings to change the setting. final boolean isManagedProfile = mUserManager.isManagedProfile(); if (!unknownSourcesAllowedByAdmin || (!unknownSourcesAllowedByUser &amp;&amp; isManagedProfile)) { showDialogInner(DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else if (!unknownSourcesAllowedByUser) { // Ask user to enable setting first showDialogInner(DLG_UNKNOWN_SOURCES); mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_BLOCKED_BY_UNKNOWN_SOURCES_SETTING); } else { initiateInstall(); } } 可以发现，在onCreate方法中，首先执行一些初始化操作，获取PackageManager和Installer、UserManager等对象，然后会根据当前Intent的信息最一些逻辑判断并弹出消息弹窗，我们可以看一下具体的消息弹窗类型： 12345678private static final int DLG_BASE = 0; private static final int DLG_UNKNOWN_SOURCES = DLG_BASE + 1; private static final int DLG_PACKAGE_ERROR = DLG_BASE + 2; private static final int DLG_OUT_OF_SPACE = DLG_BASE + 3; private static final int DLG_INSTALL_ERROR = DLG_BASE + 4; private static final int DLG_ALLOW_SOURCE = DLG_BASE + 5; private static final int DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES = DLG_BASE + 6; private static final int DLG_NOT_SUPPORTED_ON_WEAR = DLG_BASE + 7; 可以发现当分析Intent对象的时候，如果可以得到这样几种结果：不知道apk的来源，package信息错误，存储空间不够，安装时报，来源正确，允许未知来源的apk文件，在wear上不支持等，这样根据不同的消息类型会弹出不同的消息弹窗： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119@Override public Dialog onCreateDialog(int id, Bundle bundle) { switch (id) { case DLG_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_dlg_text) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Finishing off activity so that user can navigate to settings manually&quot;); finish(); }}) .setPositiveButton(R.string.settings, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Launching settings&quot;); launchSecuritySettings(); } }) .setOnCancelListener(this) .create(); case DLG_ADMIN_RESTRICTS_UNKNOWN_SOURCES: return new AlertDialog.Builder(this) .setTitle(R.string.unknown_apps_dlg_title) .setMessage(R.string.unknown_apps_admin_dlg_text) .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_PACKAGE_ERROR : return new AlertDialog.Builder(this) .setTitle(R.string.Parse_error_dlg_title) .setMessage(R.string.Parse_error_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setOnCancelListener(this) .create(); case DLG_OUT_OF_SPACE: // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText = getString(R.string.out_of_space_dlg_text, appTitle.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.out_of_space_dlg_title) .setMessage(dlgText) .setPositiveButton(R.string.manage_applications, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { //launch manage applications Intent intent = new Intent(&quot;android.intent.action.MANAGE_PACKAGE_STORAGE&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); finish(); } }) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { Log.i(TAG, &quot;Canceling installation&quot;); finish(); } }) .setOnCancelListener(this) .create(); case DLG_INSTALL_ERROR : // Guaranteed not to be null. will default to package name if not set by app CharSequence appTitle1 = mPm.getApplicationLabel(mPkgInfo.applicationInfo); String dlgText1 = getString(R.string.install_failed_msg, appTitle1.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.install_failed) .setNeutralButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { finish(); } }) .setMessage(dlgText1) .setOnCancelListener(this) .create(); case DLG_ALLOW_SOURCE: CharSequence appTitle2 = mPm.getApplicationLabel(mSourceInfo); String dlgText2 = getString(R.string.allow_source_dlg_text, appTitle2.toString()); return new AlertDialog.Builder(this) .setTitle(R.string.allow_source_dlg_title) .setMessage(dlgText2) .setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_CANCELED); finish(); }}) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { SharedPreferences prefs = getSharedPreferences(PREFS_ALLOWED_SOURCES, Context.MODE_PRIVATE); prefs.edit().putBoolean(mSourceInfo.packageName, true).apply(); startInstallConfirm(); } }) .setOnCancelListener(this) .create(); case DLG_NOT_SUPPORTED_ON_WEAR: return new AlertDialog.Builder(this) .setTitle(R.string.wear_not_allowed_dlg_title) .setMessage(R.string.wear_not_allowed_dlg_text) .setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() { public void onClick(DialogInterface dialog, int which) { setResult(RESULT_OK); finish(); } }) .setOnCancelListener(this) .create(); } return null; } 消息弹窗的主要作用，用于提示用户当前安装apk文件的特性。都知道android系统在android apk文件之前会解析器manifest文件，这个操作也是早onCreate方法中执行的： 1PackageParser.Package parsed = PackageUtil.getPackageInfo(sourceFile); 我们具体看一下getPackageInfo方法的实现： 12345678910public static PackageParser.Package getPackageInfo(File sourceFile) { final PackageParser parser = new PackageParser(); try { PackageParser.Package pkg = parser.parseMonolithicPackage(sourceFile, 0); parser.collectManifestDigest(pkg); return pkg; } catch (PackageParserException e) { return null; } } 好吧，到了这里是不是代码变得很熟悉了？parseMonolithicPackage就是我们上一节分析的android系统解析manifest文件的过程，具体的可参考：http://blog.csdn.net/qq_23547831/article/details/51203482 而collectManifestDigest方法，我们这里简单的介绍一下，其主要是要争apk的签名是否正确。好吧通过这两部我们就把apk文件的manifest和签名信息都解析完成并保存在了Package中。 接着往下走，在所有的解析完成之后我们会在onCreate方法中执行initiateInstall();方法，刚方法的主要作用是初始化安装。 123456789101112131415161718192021222324252627282930313233343536private void initiateInstall() { String pkgName = mPkgInfo.packageName; // Check if there is already a package on the device with this name // but it has been renamed to something else. String[] oldName = mPm.canonicalToCurrentPackageNames(new String[] { pkgName }); if (oldName != null &amp;&amp; oldName.length &gt; 0 &amp;&amp; oldName[0] != null) { pkgName = oldName[0]; mPkgInfo.packageName = pkgName; mPkgInfo.applicationInfo.packageName = pkgName; } // Check if package is already installed. display confirmation dialog if replacing pkg try { // This is a little convoluted because we want to get all uninstalled // apps, but this may include apps with just data, and if it is just // data we still want to count it as &quot;installed&quot;. mAppInfo = mPm.getApplicationInfo(pkgName, PackageManager.GET_UNINSTALLED_PACKAGES); if ((mAppInfo.flags&amp;ApplicationInfo.FLAG_INSTALLED) == 0) { mAppInfo = null; } } catch (NameNotFoundException e) { mAppInfo = null; } mInstallFlowAnalytics.setReplace(mAppInfo != null); mInstallFlowAnalytics.setSystemApp( (mAppInfo != null) &amp;&amp; ((mAppInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0)); // If we have a session id, we're invoked to verify the permissions for the given // package. Otherwise, we start the install process. if (mSessionId != -1) { startInstallConfirm(); } else { startInstall(); } } 好吧，这里面有调用了startInstallConfirm方法，然后我们看一下startInstallConfirm方法的实现: 12345private void startInstallConfirm() { ... //初始化安装确认界面 ...} 好吧，这个方法的实现比较简单，主要的实现逻辑就是现实该activity的用户界面，平时我们安装某一个应用的时候会弹出一个安装确认页面，还有一个确认和取消按钮，有印象么？其实就是在这里执行的界面初始化操作。 好吧，一般情况下在apk安装确认页面，我们会点击确认按钮执行安装逻辑吧？那么这里我们找一下确认按钮的点击事件： 1234567891011121314151617181920212223242526272829public void onClick(View v) { if (v == mOk) { if (mOkCanInstall || mScrollView == null) { mInstallFlowAnalytics.setInstallButtonClicked(); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, true); // We're only confirming permissions, so we don't really know how the // story ends; assume success. mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult( PackageManager.INSTALL_SUCCEEDED); finish(); } else { startInstall(); } } else { mScrollView.pageScroll(View.FOCUS_DOWN); } } else if (v == mCancel) { // Cancel and finish setResult(RESULT_CANCELED); if (mSessionId != -1) { mInstaller.setPermissionsResult(mSessionId, false); } mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_CANCELLED_BY_USER); finish(); } } 很明显了，这里当我们点击确认按钮的时候会执行startInstall方法，也就是开始执行安装逻辑： 123456789101112131415161718192021222324252627282930313233private void startInstall() { // Start subactivity to actually install the application Intent newIntent = new Intent(); newIntent.putExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO, mPkgInfo.applicationInfo); newIntent.setData(mPackageURI); newIntent.setClass(this, InstallAppProgress.class); newIntent.putExtra(InstallAppProgress.EXTRA_MANIFEST_DIGEST, mPkgDigest); newIntent.putExtra( InstallAppProgress.EXTRA_INSTALL_FLOW_ANALYTICS, mInstallFlowAnalytics); String installerPackageName = getIntent().getStringExtra( Intent.EXTRA_INSTALLER_PACKAGE_NAME); if (mOriginatingURI != null) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_URI, mOriginatingURI); } if (mReferrerURI != null) { newIntent.putExtra(Intent.EXTRA_REFERRER, mReferrerURI); } if (mOriginatingUid != VerificationParams.NO_UID) { newIntent.putExtra(Intent.EXTRA_ORIGINATING_UID, mOriginatingUid); } if (installerPackageName != null) { newIntent.putExtra(Intent.EXTRA_INSTALLER_PACKAGE_NAME, installerPackageName); } if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { newIntent.putExtra(Intent.EXTRA_RETURN_RESULT, true); newIntent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT); } if(localLOGV) Log.i(TAG, &quot;downloaded app uri=&quot;+mPackageURI); startActivity(newIntent); finish(); } 可以发现，点击确认按钮之后我们调用启用了一个新的Activity–&gt;InstallAppProgress，这个Activity主要用于执行apk的安装逻辑了。 123456789101112131415161718192021222324252627@Override public void onCreate(Bundle icicle) { super.onCreate(icicle); Intent intent = getIntent(); mAppInfo = intent.getParcelableExtra(PackageUtil.INTENT_ATTR_APPLICATION_INFO); mInstallFlowAnalytics = intent.getParcelableExtra(EXTRA_INSTALL_FLOW_ANALYTICS); mInstallFlowAnalytics.setContext(this); mPackageURI = intent.getData(); final String scheme = mPackageURI.getScheme(); if (scheme != null &amp;&amp; !&quot;file&quot;.equals(scheme) &amp;&amp; !&quot;package&quot;.equals(scheme)) { mInstallFlowAnalytics.setFlowFinished( InstallFlowAnalytics.RESULT_FAILED_UNSUPPORTED_SCHEME); throw new IllegalArgumentException(&quot;unexpected scheme &quot; + scheme); } mInstallThread = new HandlerThread(&quot;InstallThread&quot;); mInstallThread.start(); mInstallHandler = new Handler(mInstallThread.getLooper()); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(BROADCAST_ACTION); registerReceiver( mBroadcastReceiver, intentFilter, BROADCAST_SENDER_PERMISSION, null /*scheduler*/); initView(); } 可以发现InstallAppProcess这个Activity的onCreate方法中主要初始化了一些成员变量，并调用initView方法，我们在iniTView方法中可以看到： 12345678910void initView() { ... mInstallHandler.post(new Runnable() { @Override public void run() { doPackageStage(pm, params); } }); ...} 经过一些view的初始化操作之后调用了doPackageStage方法，该方法主要是通过调用PackageInstaller执行apk文件的安装，这里就不在详细的介绍了，在apk文件安装完成之后PackageInstaller会发送一个安装完成的广播，刚刚我们在onCreate方法中注册了一个广播接收器，其可以用来接收apk安装完成的广播： 123456789101112private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { final int statusCode = intent.getIntExtra( PackageInstaller.EXTRA_STATUS, PackageInstaller.STATUS_FAILURE); if (statusCode == PackageInstaller.STATUS_PENDING_USER_ACTION) { context.startActivity((Intent)intent.getParcelableExtra(Intent.EXTRA_INTENT)); } else { onPackageInstalled(statusCode); } } }; 这样apk安装完成之后，这里的广播接收器会接收到广播并执行onPackageInstalled方法，执行后续的处理逻辑，那么我们来看一下onPackageInstalled方法的具体实现逻辑： 12345void onPackageInstalled(int statusCode) { Message msg = mHandler.obtainMessage(INSTALL_COMPLETE); msg.arg1 = statusCode; mHandler.sendMessage(msg); } 好吧，这里是发送Handler异步消息，我们来看一下异步消息的处理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch (msg.what) { case INSTALL_COMPLETE: mInstallFlowAnalytics.setFlowFinishedWithPackageManagerResult(msg.arg1); if (getIntent().getBooleanExtra(Intent.EXTRA_RETURN_RESULT, false)) { Intent result = new Intent(); result.putExtra(Intent.EXTRA_INSTALL_RESULT, msg.arg1); setResult(msg.arg1 == PackageInstaller.STATUS_SUCCESS ? Activity.RESULT_OK : Activity.RESULT_FIRST_USER, result); finish(); return; } // Update the status text mProgressBar.setVisibility(View.INVISIBLE); // Show the ok button int centerTextLabel; int centerExplanationLabel = -1; LevelListDrawable centerTextDrawable = (LevelListDrawable) getDrawable(R.drawable.ic_result_status); if (msg.arg1 == PackageInstaller.STATUS_SUCCESS) { mLaunchButton.setVisibility(View.VISIBLE); centerTextDrawable.setLevel(0); centerTextLabel = R.string.install_done; // Enable or disable launch button mLaunchIntent = getPackageManager().getLaunchIntentForPackage( mAppInfo.packageName); boolean enabled = false; if(mLaunchIntent != null) { List&lt;ResolveInfo&gt; list = getPackageManager(). queryIntentActivities(mLaunchIntent, 0); if (list != null &amp;&amp; list.size() &gt; 0) { enabled = true; } } if (enabled) { mLaunchButton.setOnClickListener(InstallAppProgress.this); } else { mLaunchButton.setEnabled(false); } } else if (msg.arg1 == PackageInstaller.STATUS_FAILURE_STORAGE){ showDialogInner(DLG_OUT_OF_SPACE); return; } else { // Generic error handling for all other error codes. centerTextDrawable.setLevel(1); centerExplanationLabel = getExplanationFromErrorCode(msg.arg1); centerTextLabel = R.string.install_failed; mLaunchButton.setVisibility(View.INVISIBLE); } if (centerTextDrawable != null) { centerTextDrawable.setBounds(0, 0, centerTextDrawable.getIntrinsicWidth(), centerTextDrawable.getIntrinsicHeight()); mStatusTextView.setCompoundDrawablesRelative(centerTextDrawable, null, null, null); } mStatusTextView.setText(centerTextLabel); if (centerExplanationLabel != -1) { mExplanationTextView.setText(centerExplanationLabel); mExplanationTextView.setVisibility(View.VISIBLE); } else { mExplanationTextView.setVisibility(View.GONE); } mDoneButton.setOnClickListener(InstallAppProgress.this); mOkPanel.setVisibility(View.VISIBLE); break; default: break; } } }; 可以发现，当apk安装完成之后，我们会更新UI，显示完成和打开按钮，是不是和我们平时安装apk的逻辑对应上了？这时候我们可以看一下这两个按钮的点击事件。 1234567891011public void onClick(View v) { if(v == mDoneButton) { if (mAppInfo.packageName != null) { Log.i(TAG, &quot;Finished installing &quot;+mAppInfo.packageName); } finish(); } else if(v == mLaunchButton) { startActivity(mLaunchIntent); finish(); } } 好吧，比较简单，点击完成按钮，直接finish掉这个activity，点击打开，则直接调用startActivity启动安装的应用，然后直接finish自身。 总结： 代码中执行intent.setDataAndType(Uri.parse(“file://“ + path),”application/vnd.android.package-archive”);可以调起PackageInstallerActivity； PackageInstallerActivity主要用于执行解析apk文件，解析manifest，解析签名等操作； InstallAppProcess主要用于执行安装apk逻辑，用于初始化安装界面，用于初始化用户UI。并调用PackageInstaller执行安装逻辑； InstallAppProcess内注册有广播，当安装完成之后接收广播，更新UI。显示apk安装完成界面； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程","link":"/2020/09/11/apk%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"},{"title":"18 Activity布局绘制流程","text":"这篇文章是承接上一篇文章(Android布局加载流程：android源码解析（十七）–&gt;Activity布局加载流程)来写的，大家都知道Activity在Android体系中扮演者一个界面展示的角色，通过上一篇文章的分析，我们知道Activity是通过Window来控制界面的展示的，一个Window对象就是一个窗口对象，而每个Activity中都有一个相应的Window对象，所以说一个Activity对象也就可以说是一个窗口对象，而Window只是控制着界面布局文件的加载过程，那么界面布局文件的绘制流程是如何的呢？这篇文章主要就是顺着上篇文章的思路，看一下在android系统中Activity的布局文件是如何绘制的。 顺便在这里多说几句，android中所有能显示的东西都是通过Window对象实现了，无论Activity，Dialog，PopupWindow，Toast等。后期我可能也会讲一下Dialog，PopupWindow，Toast等组件的显示过程。 前面有一篇文章中我们介绍过Activity的启动流程，可参考：android源码解析之（十四）–&gt;Activity启动流程在执行ActivityThread的handleLauncherActivity方法中通过Window对象控制了布局文件的加载流程，而Android体系在执行Activity的onResume方法之前会回调ActivityThread的handleResumeActivity方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { ... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } ... // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } ... } 可以看到在在获取了Activity的Window相关参数之后执行了r.activity.makeVisible()方法，看样子这个就是Activity的显示方法，这里我们来具体看一下makeVisible方法的具体实现逻辑： 12345678void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } 首先判断成员变量mWindowAdded是否为true，可以发现mWindowAdded成员变量只有在执行之后才能赋值为true，所以这里的代码的主要逻辑是该if分支只能执行一次。 这里的ViewManager对象是通过getWindowManager()方法获取的，我们来看一下getWindowManager()方法的具体实现: 123public WindowManager getWindowManager() { return mWindowManager; } 好吧，原来就是返回的Activity的mWindowManager的成员变量，那么这个mWindowManager的成员变量是什么时候赋值的呢？上一篇文章我们在Activity的attach方法方法中初始化了Activity的相关成员变量，这里也包括了mWindowManager，我们来看一下mWindowManager的赋值过程： 1mWindowManager = mWindow.getWindowManager(); 好吧，这里的Window.getWindowManager()方法是具体如何实现的呢？ 123public WindowManager getWindowManager() { return mWindowManager; } 那么这里的Window对象的mWindowManager成员变量是具体如何赋值的？ 1234567891011public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mAppToken = appToken; mAppName = appName; mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); if (wm == null) { wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); } mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } 好吧，可以发现mWindowManager = ((WindowManagerImpl)vm).createLocalWindowManager(this)原来是在这里赋值的，所以一个Activity对应这一个新的Window，而这个Window对象内部会对应着一个新的WindowManager对象，我们接着往下看，那么createLoclWindowManager方法是如何实现的呢？ 123public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } 好吧，原来是new出了一个WindowManagerImpl对象，所以回到我们的Activity的makeVisible方法，ViewManager获取的是一个WindowManagerImpl对象，所以Window对象内部的WindowManager对象其实都是一个WindowManagerImpl的实例，都是而且从继承关系上可以看到： WindowManagerImpl –&gt; WindowManager –&gt; ViewManager; 继续往下看： 1wm.addView(mDecor, getWindow().getAttributes()); 这里的mDector成员变量，通过上一篇文章的介绍，我们知道，它是Activity的界面根View，而getWindow.getAttrbutes方法是windowManager中定义的Params内部类，该内部类定义了许多的Window类型，由于这里的vm是WindowManagerImpl的实例，我们来看一下这里的addView的具体实现： 12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } 然后我们具体看一下mGlobal.addView方法，这里的mGlobal是一个WindowManagerGlobal的单例对象，WindowManagerGlobal是Window处理的工具类，那么WindowManagerGlobal的addView具体是如何实现的呢? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } int index = findViewLocked(view, false); if (index &gt;= 0) { if (mDyingViews.contains(view)) { // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); } else { throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; } } 可以发现在WindowManagerGlobal中存在着三个数据列表： 1234private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;(); 其中mViews主要用于保存Activity的mDector也就是Activity的根View，而mRoots主要用于保存ViewRootImpl，mParams主要用于保存Window的LayoutParams，WindowManagerGlobal主要作为WindowManagerImpl的辅助方法类，用于操作View组件。 最后我们调用了root.setView方法，这个方法很重要我们就是在这里实现了我们的root与ViewRootImpl的关联的，除了实现了mDector与ViewRootImpl的相互关联，我们还调用了requestLayout方法，这里我们看一下setView方法的具体实现： 12345public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { ... requestLayout(); ... } 可以看到，在方法体中又调用了requestLayout方法，这个方法其实就是调用执行重绘的请求，我们来看一下这个requestLayout方法具体实现： 12345678@Override public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { checkThread(); mLayoutRequested = true; scheduleTraversals(); } } 可以看到这里有一个checkThread方法，这个方法是检查当前线程的方法，若当前线程非UI线程，则抛出非UI线程更新UI的错误： 123456void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( &quot;Only the original thread that created a view hierarchy can touch its views.&quot;); } } 相信大家平时在编程的过程中肯定会遇到过这个错误，ViewRootImpl是具体更新View的管理类，所有关于View的更新操作都是在这里执行的，自然而然的对于更新线程的检测是在这个类中添加的，一般在更新UI的时候都会调用这个方法用于检测当前执行更新UI的线程是否是UI线程，否则就会抛出这个异常。 继续回到我们的requestLayout方法，这里又调用了scheduleTraversales方法，我们来看一下这个方法的具体实现： 12345678910111213void scheduleTraversals() { if (!mTraversalScheduled) { mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) { scheduleConsumeBatchedInput(); } notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); } } 这里mChoreographer.postCallback，内部会调用一个异步消息，用于执行mTraversalRunnable的run方法，这个mTraversalRunnable是一个Runnable对象，我们来看一下mTraversalRunnable类的定义： 123456final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); } } 在TraversalRunnable类的run方法中调用了doTraversal方法，我们来看一下这个方法的具体实现逻辑： 1234567891011121314151617void doTraversal() { if (mTraversalScheduled) { mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) { Debug.startMethodTracing(&quot;ViewAncestor&quot;); } performTraversals(); if (mProfile) { Debug.stopMethodTracing(); mProfile = false; } } } 好吧，其内部又回调了方法performTraversals方法，这个方法就是整个View的绘制起始方法，从这个方法开始我们的View经过大小测量，位置测量，界面绘制三个逻辑操作之后就可以展示在界面中了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private void performTraversals() { ... // 执行View组件的onMeasure方法，主要用于测量View if (!mStopped || mReportNextDraw) { boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged) { int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); if (DEBUG_LAYOUT) Log.v(TAG, &quot;Ooops, something changed! mWidth=&quot; + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth() + &quot; mHeight=&quot; + mHeight + &quot; measuredHeight=&quot; + host.getMeasuredHeight() + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged); // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); // Implementation of weights from WindowManager.LayoutParams // We just grow the dimensions as needed and re-measure if // needs be int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) { width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; } if (lp.verticalWeight &gt; 0.0f) { height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; } if (measureAgain) { if (DEBUG_LAYOUT) Log.v(TAG, &quot;And hey let's measure once more: width=&quot; + width + &quot; height=&quot; + height); performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); } layoutRequested = true; } } } ... // 主要用于测量View组件的位置 ... final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) { performLayout(lp, desiredWindowWidth, desiredWindowHeight); // By this point all views have been sized and positioned // We can compute the transparent area if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) { // start out transparent // TODO: AVOID THAT CALL BY CACHING THE RESULT? host.getLocationInWindow(mTmpLocation); mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1], mTmpLocation[0] + host.mRight - host.mLeft, mTmpLocation[1] + host.mBottom - host.mTop); host.gatherTransparentRegion(mTransparentRegion); if (mTranslator != null) { mTranslator.translateRegionInWindowToScreen(mTransparentRegion); } if (!mTransparentRegion.equals(mPreviousTransparentRegion)) { mPreviousTransparentRegion.set(mTransparentRegion); mFullRedrawNeeded = true; // reconfigure window manager try { mWindowSession.setTransparentRegion(mWindow, mTransparentRegion); } catch (RemoteException e) { } } } if (DBG) { System.out.println(&quot;======================================&quot;); System.out.println(&quot;performTraversals -- after setFrame&quot;); host.debug(); } } ... // 主要用于View的绘制过程 ... if (!cancelDraw &amp;&amp; !newSurface) { if (!skipDraw || mReportNextDraw) { if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).startChangingAnimations(); } mPendingTransitions.clear(); } performDraw(); } } else { if (viewVisibility == View.VISIBLE) { // Try again scheduleTraversals(); } else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) { for (int i = 0; i &lt; mPendingTransitions.size(); ++i) { mPendingTransitions.get(i).endChangingAnimations(); } mPendingTransitions.clear(); } } mIsInTraversal = false; } 可以看到在方法performTraversals方法，我们调用了performMeasure，performLayout，performDraw三个方法，这几个方法主要用于测量View组件的大小，测量View组件的位置，绘制View组件； 即：测量大小 –&gt; 测量位置 –&gt; 绘制组件 好吧，这里我们调用了performMeasure方法，我们先看一下performMeasure方法的具体实现： 12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } } 可以看到在performMeasure方法中我们又调用了mView的measure方法，这里的mView就是我们一开始的Activity的mDector根组件，这里的measure方法就是调用的mDector组件的measure方法： 12345public final void measure(int widthMeasureSpec, int heightMeasureSpec) { ... onMeasure(widthMeasureSpec, heightMeasureSpec); ... } 在View的measure方法中，又调用了onMeasure方法，由于我们的mDector对象是一个FrameLayout，所以这里的onMeasure执行的是FrameLayout的onMeasure方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) { measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground's minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } } } 可以看到这里调用了一个循环逻辑，获取该View的所有子View，并执行所有子View的measure方法，这样又回到View的measure方法，这样经过一系列的循环遍历过程，如果是ViewGroup就会调用其ViewGroup的onMeasure方法，若果是View组件就会调用View的onMeasure方法，我们来看一下View的onMeasure方法： 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } 可以看到这个方法中调用了setMeasuredDimension方法： 123456789101112protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } setMeasuredDimensionRaw(measuredWidth, measuredHeight); } 好吧，方法体里面又调用了setMeasuredDimensionRaw方法： 123456private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET; } 这样把View组件即其子View的大小测量出来了，并且保存在了成员变量mMeasuredWith和mMeasuredHeight中。 继续回到我们的performTransles方法，然后我们继续看performLayout方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(TAG, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during layout: running second layout pass&quot;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during second layout pass: posting in next frame&quot;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false; } 可以看到在方法体中，我们看到该方法执行了layout方法，我们看一下该layout方法的实现： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 可以看到这个方法体中执行了onLayout方法，这个方法就是具体执行测量位置的方法了，由于我们的mDector是一个FrameLayout，所以跟measure类似的，我们看一下FrameLayout的onLayout方法的实现： 我们看到我们定义了一个循环逻辑，获取所有的validLayoutRequesters也就是需要执行Layout方法的View的集合，通过循环执行view的requestLayout方法。这里我们来看一下requestLayout方法的具体实现： 1234@Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */); } 可以看到这里调用了layoutChildren方法，让我们来看一下layoutChildren方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } final int layoutDirection = getLayoutDirection(); final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } switch (verticalGravity) { case Gravity.TOP: childTop = parentTop + lp.topMargin; break; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; default: childTop = parentTop + lp.topMargin; } child.layout(childLeft, childTop, childLeft + width, childTop + height); } } } 跟measure类似的，这里也是遍历执行View的layout方法，若是ViewGroup则执行具体的ViewGroup的layout方法，若是View，则执行View的layout方法，好吧，我们看一下View的layout的具体实现逻辑： 1234567891011121314151617181920212223242526272829303132public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; } 这样经过layout方法，如果是View组件的话就已经将View组件的位置信息计算出来并保存在对象的成员变量中。 好吧，经过了测量大小与测量位置的逻辑之后，我们最后看一下performTraversals方法中的performDraw方法，这个方法的作用就是执行View组件的绘制逻辑了。 12345private void performDraw() { ... draw(fullRedrawNeeded); ... } 可以看到这里调用了ViewRootImpl的draw方法，然后我们看一下draw方法的实现： 1234567private void draw(boolean fullRedrawNeeded) { ... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } ... } 可以看到这里又调用了drawSoftware方法，看名字这里应该就是调用执行绘制的方法： 12345678private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { ... mView.draw(canvas); ... return true; } 可以看到这里调用了mView的draw方法，这里的mView是我们的mDector，好吧，看一下draw方法的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { drawBackground(canvas); } // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we're done... return; } /* * Here we do the full fledged routine... * (this is an uncommon case where speed matters less, * this is why we repeat some of the tests that have been * done above) */ boolean drawTop = false; boolean drawBottom = false; boolean drawLeft = false; boolean drawRight = false; float topFadeStrength = 0.0f; float bottomFadeStrength = 0.0f; float leftFadeStrength = 0.0f; float rightFadeStrength = 0.0f; // Step 2, save the canvas' layers int paddingLeft = mPaddingLeft; final boolean offsetRequired = isPaddingOffsetRequired(); if (offsetRequired) { paddingLeft += getLeftPaddingOffset(); } int left = mScrollX + paddingLeft; int right = left + mRight - mLeft - mPaddingRight - paddingLeft; int top = mScrollY + getFadeTop(offsetRequired); int bottom = top + getFadeHeight(offsetRequired); if (offsetRequired) { right += getRightPaddingOffset(); bottom += getBottomPaddingOffset(); } final ScrollabilityCache scrollabilityCache = mScrollCache; final float fadeHeight = scrollabilityCache.fadingEdgeLength; int length = (int) fadeHeight; // clip the fade length if top and bottom fades overlap // overlapping fades produce odd-looking artifacts if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) { length = (bottom - top) / 2; } // also clip horizontal fades if necessary if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) { length = (right - left) / 2; } if (verticalEdges) { topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength())); drawTop = topFadeStrength * fadeHeight &gt; 1.0f; bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength())); drawBottom = bottomFadeStrength * fadeHeight &gt; 1.0f; } if (horizontalEdges) { leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength())); drawLeft = leftFadeStrength * fadeHeight &gt; 1.0f; rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength())); drawRight = rightFadeStrength * fadeHeight &gt; 1.0f; } saveCount = canvas.getSaveCount(); int solidColor = getSolidColor(); if (solidColor == 0) { final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG; if (drawTop) { canvas.saveLayer(left, top, right, top + length, null, flags); } if (drawBottom) { canvas.saveLayer(left, bottom - length, right, bottom, null, flags); } if (drawLeft) { canvas.saveLayer(left, top, left + length, bottom, null, flags); } if (drawRight) { canvas.saveLayer(right - length, top, right, bottom, null, flags); } } else { scrollabilityCache.setFadeColor(solidColor); } // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) { matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); } if (drawBottom) { matrix.setScale(1, fadeHeight * bottomFadeStrength); matrix.postRotate(180); matrix.postTranslate(left, bottom); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, bottom - length, right, bottom, p); } if (drawLeft) { matrix.setScale(1, fadeHeight * leftFadeStrength); matrix.postRotate(-90); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, left + length, bottom, p); } if (drawRight) { matrix.setScale(1, fadeHeight * rightFadeStrength); matrix.postRotate(90); matrix.postTranslate(right, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(right - length, top, right, bottom, p); } canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); } 整个View的绘制流程还是比较清楚的，整个执行逻辑还有相应的注释，一共大概需要六步，并且在执行draw方法的过程中，如果包含子View，那么也会执行子View的draw方法，好吧，经过这样一系列的执行逻辑之后，mDector以及子View就被绘制出来了。 总结： Activity执行onResume之后再ActivityThread中执行Activity的makeVisible方法。 View的绘制流程包含了测量大小，测量位置，绘制三个流程； Activty的界面绘制是从mDector即根View开始的，也就是从mDector的测量大小，测量位置，绘制三个流程； View体系的绘制流程是从ViewRootImpl的performTraversals方法开始的； View的测量大小流程:performMeasure –&gt; measure –&gt; onMeasure等方法; View的测量位置流程：performLayout –&gt; layout –&gt; onLayout等方法； View的绘制流程：onDraw等方法； View组件的绘制流程会在onMeasure,onLayout以及onDraw方法中执行分发逻辑，也就是在onMeasure同时执行子View的测量大小逻辑，在onLayout中同时执行子View的测量位置逻辑，在onDraw中同时执行子View的绘制逻辑； Activity中都对应这个一个Window对象，而每一个Window对象都对应着一个新的WindowManager对象（WindowManagerImpl实例）； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程android源码解析之（十四）–&gt;Activity启动流程android源码解析之（十五）–&gt;Activity销毁流程android源码解析（十六）–&gt;应用进程Context创建流程android源码解析（十七）–&gt;Activity布局加载流程","link":"/2020/09/11/Activity%E5%B8%83%E5%B1%80%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"},{"title":"多线程并发知识","text":"Thread 底层调用start的 native方法 并行 及 并发 概念？ 并行，多个线程同时执行的概念。 并发，单位时间内，线程处理数据的能力，吞吐量。 Java默认是多线程 高并发编程的意义及好处？ 平衡使用我们的线程(好处) 不要cpu 过累(意义) 面试题 1.run 和start方法的区别？ .run()时函数调用和线程没有任何关系，.start()方法执行native底层函数，系统最终调度到run函数，这才是线程。 \\2. 如何控制线程的执行顺序？ .join() 函数控制，让t2获取执行权力，能够做到顺序执行 \\3. 多线程中的并行和并发是什么？ 四个车道，四辆车并行的行驶，就是并行。 四个车道，五秒钟多少的车流量，多少的吞吐量，是并发。单位时间内的执行效率 \\4. 在Java中能不能指定CPU去执行某个线程？ 不能，Java是做不到的，唯一能够去干预的是C语言调用内核的API去执行才行。 \\5. 项目开发过程中，你会考虑线程优先级么？ 不会考虑优先级，为什么呢？因为线程的优先级很依赖与系统的平台，所以这个优先级无法对号入座，无法做到你想象中的优先级，属于 不稳定，有风险，因为某些开源框架，也不能依靠线程优先级来设置自己想要的优先级顺序，这个是不可靠的。 例：Java线程优先级有十级，而此时操作系统优先级指有2~3级，那就对应不上了。 \\6. sleep 和 wait 有什么区别？ sleep是休眠，等休眠时间一国，才有执行的资格，注意是有资格，并不能马上就会被执行，什么时候执行，取决于cpu系统调度。 wait是登台，需要唤醒，唤醒后，才有执行的资格。 sleep()：线程进入睡眠状态，不会释放锁 wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁 含义不同: sleep 无条件可以休眠， wait是某些原因与条件 需要等待一下。 \\7. 在Java中能不能强制中断线程的执行 虽然提供了stop函数，但是此函数不推荐使用。因为这种方式很暴力，很危险，例如:下载图片5kb，只下载了4kb等我们可以使用interrupt来 处理我线程的停止，但是注意interrupt只是协作式的方式，并不能绝对保证终中断，并不是抢占式。 \\8. 如何让出当前线程的执行权？ yield() ：让出cpu的执行权，将线程从运行转到可运行状态，但是下个时间片，该线程依然有可能被再次选中运行 \\9. notify()和notifyAll()区别？ ​ notify()可能发生信号丢失的情况。并且可能会导致死锁现象。 ​ 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法( ​ 或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权， ​ 但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。 ​ 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中 如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。 当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程）， 被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池， 而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法， 它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁， 这时锁池中的线程会继续竞争该对象锁。 唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争 ，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。 10.调用yield() 、sleep()、wait()、notify()等方法对锁有何影响？ yield()：让出时间片，不会释放锁 sleep()：线程进入睡眠状态，不会释放锁 wait()：调动方法之前，必须要持有锁。调用了wait()方法以后，锁就会被释放，进入锁的等待队列，方法返回后重新拿到锁 notify()：调动方法之前，必须要持有锁，调用notify()方法本身不会释放锁的。而是通知等待队列中的某一个线程，同步代码块执行完毕后才会释放锁 notifyAll()：同notify，有一点不同在于，notifyAll会发出n个信号（n=等待线程数），而notify只会发出一个信号，通常情况下，尽量选择notifyAll 11.join()函数作用？ 线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作 12.sleep 和 wait 哪个函数才会清除interrupt中断标记？ sleep 在抛出异常的时候，捕获异常之前就已经清除中断标记。 锁、多线程、唤醒机制 13．有几种新启线程的方式？(两种) 1.继承Thread类 2.实现Runnable接口 实现Callable 严格意义上不算。实现Callable的接口对象会封装到FutureTask。FutureTask实现RunnableFuture。RunnableFuture 接口继承了Runnable和Future接口。 线程的生命周期? \\1. 初始 NEW \\2. 运行 RUNNING \\3. 就绪 REDAY \\4. 等待 WAITING \\5. 阻塞 BLOCK \\6. 终止 TERMINATED 运行：获取到时间片cpu调度。 调用wait进入等待 调用notify唤醒 调用synchronized修饰的方法中，未获取到锁 进入阻塞状态 调用sleep进入等待态 调用lock没有拿到锁，进入阻塞态？不会！只是进入等待、等待超时。 只有在synchronized修饰才会进入阻塞态。 锁概念 有一个线程进入，加锁后，其他线程无法进入。 synchronized 隐式锁 可重入锁 内部会完成 锁定解锁底层逻辑。JDK内置锁 无法修改。需要关键字 synchronized lock 显式锁 可以手动控制锁定解锁 唤醒机制 等待区域:wait() 获取对象的锁🔒 synchronized(对象锁){ wait() //释放锁 } 通知区域:notify() 获取对象的锁🔒 synchronized(对象锁){ notify() } 死锁 死锁是指 两个或两个以上的进程在执行过程中，由于竞争资源或者用于彼此通信造成的一种阻塞的现象，若无外力作用，他们 都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 条件 1.多个操作者(M&gt;=2)争夺多个资源(N&gt;=2) (N&lt;=M) 2.争夺资源的顺序不对 3.拿到资源不放手 规范 1.互斥条件 2.请求和保持 3.不剥夺 4.循环 死锁解决，规定争夺资源的顺序，lock.try尝试拿锁。 活锁 线程A、B 锁 1、2 线程A 持有锁1 想 获取锁2 发现线程B持有锁2 释放所有锁 重复 持有锁1 想 获取锁2 线程B 持有锁2 想 获取锁1 发现线程A持有锁1 释放所有锁 重复 持有锁2 想 获取锁1 两个线程都在不停工作。 锁饥饿 ThreadLocal 自定义存在问题。 map存在竞争。 ThreadLocal 实现原理？ thread 变量 class Thread{//持有ThreadLocal.ThreadLocalMap 成员变量 } class ThreadLocalMap{//持有一个Entry[]数组 Entry[] table } class Entry{//每个元素，持有ThreadLocal Object value ThreadLocal&lt;?&gt; k , Object v } CAS基本原理 Compare And Swap 比较和交换 CAS原理 利用现代处理器都支持CAS的指令 循环这个指令，知道成功为止 执行流程 1.get变量值(旧值) 2.计算后得到新值 3.compare内存中变量值和旧值 4.相等 旧值swap为新值 5.不相等 重复操作 CAS问题 ABA问题 开销问题 只能保证一个共享变量的原子操作 Atomic 原子变量类。cas 操作 如何实现原子操作？ 1.synchronized 2.compare and swap(轻量级) 悲观锁(synchronized) 乐观锁(cas) synchronized执行时，阻塞时会上下文切换，非常耗时。 cas 不会进入阻塞 ABA问题 线程1 A–&gt;B 线程执行A–&gt;B 线程2 A–&gt;C–&gt;A 解决ABA问题 版本戳 AtomicReference AtomicMarkableReference(是否改动) AtomicStampedReference(是否改动，改动次数) AtomicReference 解决只能保证一个共享变量的原子操作，可以支持改两个变量。 CAS 比较交换操作 为原子操作，由CPU保证。 线程池 AsynTask内部 线程池 构造函数各个参数的含义？ CorePoolSize 核心线程数 maximumPoolSize 最大线程数 keepAliveTime 存活时间 TimeUnit ThreadFactory BlockingQueue 超过的线程进入阻塞队列 RejectedExecutionHandler 默认拒绝策略 \\1. AbortPolicy 直接抛出异常(默认) \\2. DiscardPolicy 把最新提交的任务废弃 \\3. CallerRunsPolicy 让调用者线程执行任务 \\4. DiscardOldestPolicy 直接丢弃队列中最老的 keepAliveTime TimeUnit 根据这两个参数来控制线程的存活时间，线程池超过数值就会销毁。 什么是线程池？为什么要用线程池？ Thread 线程 操作系统 T1：创建 T2：任务执行 T3：销毁 为了统一管理，节省内存。用到线程池。 \\1. 线程池的创建 \\2. 提交任务 \\3. 关闭线程池 Excute Submit futureTask 有返回值 Shutdown尝试关闭线程池，没有执行的 ShutdownNow 线程的中断，协作机制 合理配置线程 任务特性： CPU密集型 机器的核心数 磁盘虚拟内存 最多+1 可能会产生页缺失，为保证cpu跑满+1 IO密集型 机器的核心数*2 混合型 JDK中的线程池工作原理？ 创建线程池值后，会根据CorePoolSize创建出线程 ，当有提交任务，CorePool里边会执行任务，当线程都在占用，继续有任务提交，超出核心线程数，会创建新线程并添加到BlockingQueue阻塞队列中。当阻塞队列中也满了，根据maximumPool继续创建线程执行。当线程数超出maximumPool大小，使用拒绝策略。 DMA 中断 OS 零拷贝 控制器 OS 内核空间 用户空间 mmap directmeory Java并发基础知识补全启动启动线程的方式只有： 1、X extends Thread;，然后X.start 2、X implements Runnable；然后交给Thread运行 线程的状态Java中线程的状态分为6种： \\1. 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。 \\2. 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。 \\3. 阻塞(BLOCKED)：表示线程阻塞于锁。 \\4. 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。1 \\5. 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。 \\6. 终止(TERMINATED)：表示该线程已经执行完毕。 状态之间的变迁如下图所示 死锁概念是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 举个例子：A和B去按摩洗脚，都想在洗脚的时候，同时顺便做个头部按摩，13技师擅长足底按摩，14擅长头部按摩。 这个时候A先抢到14，B先抢到13，两个人都想同时洗脚和头部按摩，于是就互不相让，扬言我死也不让你，这样的话，A抢到14，想要13，B抢到13，想要14，在这个想同时洗脚和头部按摩的事情上A和B就产生了死锁。怎么解决这个问题呢？ 第一种，假如这个时候，来了个15，刚好也是擅长头部按摩的，A又没有两个脑袋，自然就归了B，于是B就美滋滋的洗脚和做头部按摩，剩下A在旁边气鼓鼓的，这个时候死锁这种情况就被打破了，不存在了。 第二种，C出场了，用武力强迫A和B，必须先做洗脚，再头部按摩，这种情况下，A和B谁先抢到13，谁就可以进行下去，另外一个没抢到的，就等着，这种情况下，也不会产生死锁。 所以总结一下： 死锁是必然发生在多操作者（M&gt;=2个）情况下，争夺多个资源（N&gt;=2个，且N&lt;=M）才会发生这种情况。很明显，单线程自然不会有死锁，只有B一个去，不要2个，打十个都没问题；单资源呢？只有13，A和B也只会产生激烈竞争，打得不可开交，谁抢到就是谁的，但不会产生死锁。同时，死锁还有几个要求，1、争夺资源的顺序不对，如果争夺资源的顺序是一样的，也不会产生死锁； 2、争夺者拿到资源不放手。 学术化的定义死锁的发生必须具备以下四个必要条件。 1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 4）环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。 只要打破四个必要条件之一就能有效预防死锁的发生。 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 避免死锁常见的算法有有序资源分配法、银行家算法。 危害1、线程不工作了，但是整个程序还是活着的2、没有任何的异常信息可以供我们检查。3、一旦程序发生了发生了死锁，是没有任何的办法恢复的，只能重启程序，对正式已发布程序来说，这是个很严重的问题。 解决关键是保证拿锁的顺序一致 两种解决方式 1、 内部通过顺序比较，确定拿锁的顺序； 2、采用尝试拿锁的机制。 其他线程安全问题活锁两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。 解决办法：每个线程休眠随机数，错开拿锁的时间。 线程饥饿低优先级的线程，总是拿不到执行时间 ThreadLocal辨析与Synchonized的比较ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程訪问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。 ThreadLocal的使用ThreadLocal类接口很简单，只有4个方法，我们先来了解一下： • void set(Object value) 设置当前线程的线程局部变量的值。 • public Object get() 该方法返回当前线程所对应的线程局部变量。 • public void remove() 将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。 • protected Object initialValue() 返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。 public final static ThreadLocal RESOURCE = new ThreadLocal();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。 实现解析 上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。 看下ThreadLocal的内部类ThreadLocalMap源码： 可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。 回顾我们的get方法，其实就是拿到每个线程独有的**ThreadLocalMap** 然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。 CAS基本原理什么是原子操作？如何实现原子操作？假定有两个操作A和B(A和B可能都很复杂)，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁， 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。 实现原子操作还可以使用当前的处理器基本都支持CAS()的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。 CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。 CAS实现原子操作的三大问题ABA问题。因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。 ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，这就是ABA问题。 如果你是一个讲卫生讲文明的小伙子，不但关心水在不在，还要在你离开的时候水被人动过没有，因为你是程序员，所以就想起了放了张纸在旁边，写上初始值0，别人喝水前麻烦先做个累加才能喝水。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。 Jdk中相关原子操作类的使用AtomicInteger•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。 •boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。 •int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。 •int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。 AtomicIntegerArray主要是提供原子的方式更新数组里的整型，其常用方法如下。 •int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。 •boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。 更新引用类型原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。 AtomicReference原子更新引用类型。 AtomicStampedReference利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。 AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。 阻塞队列和线程池原理阻塞队列队列 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。 在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。 什么是阻塞队列1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。 2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。 在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序整体处理数据的速度。 在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。 为了解决这种生产消费能力不均衡的问题，便有了生产者和消费者模式。生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。 阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 ·抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（”Queuefull”）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。 ·返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。 ·一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。 ·超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。 常用阻塞队列·ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 ·LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 ·PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 ·DelayQueue：一个使用优先级队列实现的无界阻塞队列。 ·SynchronousQueue：一个不存储元素的阻塞队列。 ·LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 ·LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 以上的阻塞队列都实现了BlockingQueue接口，也都是线程安全的。 有界无界？有限队列就是长度有限，满了以后生产者会阻塞，无界队列就是里面能放无数的东西而不会因为队列长度限制被阻塞，当然空间限制来源于系统资源的限制，如果处理不及时，导致队列越来越大越来越大，超出一定的限制致使内存超限，操作系统或者JVM帮你解决烦恼，直接把你 OOM kill 省事了。 无界也会阻塞，为何？因为阻塞不仅仅体现在生产者放入元素时会阻塞，消费者拿取元素时，如果没有元素，同样也会阻塞。 ArrayBlockingQueue是一个用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证线程公平的访问队列，所谓公平访问队列是指阻塞的线程，可以按照阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对先等待的线程是非公平的，当队列可用时，阻塞的线程都可以争夺访问队列的资格，有可能先阻塞的线程最后才访问队列。初始化时有参数可以设置 LinkedBlockingQueue是一个用链表实现的有界阻塞队列。此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。 Array实现和Linked实现的区别\\1. 队列中锁的实现不同 ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁； LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock \\2. 在生产或消费时操作不同 ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的； LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能 \\3. 队列大小初始化方式不同 ArrayBlockingQueue实现的队列中必须指定队列的大小； LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE PriorityBlockingQueuePriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采取自然顺序升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 DelayQueue非常有用，可以将DelayQueue运用在以下应用场景。 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。 LinkedTransferQueue多了tryTransfer和transfer方法， （1）transfer方法 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。 （2）tryTransfer方法 tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。 LinkedBlockingDequeLinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。 多了addFirst、addLast、offerFirst、offerLast、peekFirst和peekLast等方法，以First单词结尾的方法，表示插入、获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素。另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是JDK的bug，使用时还是用带有First和Last后缀的方法更清楚。在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中。 线程池为什么要用线程池？Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。 如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。 ThreadPoolExecutor 的类关系Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。 ExecutorService接口继承了Executor，在其上做了一些shutdown()、submit()的扩展，可以说是真正的线程池接口； AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法； ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。 ScheduledExecutorService接口继承了ExecutorService接口，提供了带”周期执行”功能ExecutorService； ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。 线程池的创建各个参数含义public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler) corePoolSize线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize； 如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行； 如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。 maximumPoolSize线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize keepAliveTime线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，该参数只在线程数大于corePoolSize时才有用 TimeUnitkeepAliveTime的时间单位 workQueueworkQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过它的corePoolSize的时候，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能。 一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响。 1）当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。 2）由于1，使用无界队列时maximumPoolSize将是一个无效参数。 3）由于1和2，使用无界队列时keepAliveTime将是一个无效参数。 4）更重要的，使用无界queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界队列，也要尽量控制队列的大小在一个合适的范围。 threadFactory创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。 Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-数字-thread-数字”。 RejectedExecutionHandler线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： （1）AbortPolicy：直接抛出异常，默认策略； （2）CallerRunsPolicy：用调用者所在的线程来执行任务； （3）DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； （4）DiscardPolicy：直接丢弃任务； 当然也可以根据应用场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。 线程池的工作机制1）如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 2）如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 3）如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务。 4）如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 提交任务execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。 submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 合理地配置线程池要想合理地配置线程池，就必须首先分析任务特性 要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析。 •任务的性质：CPU密集型任务、IO密集型任务和混合型任务。 •任务的优先级：高、中和低。 •任务的执行时间：长、中和短。 •任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。 CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。由于IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。 混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点儿，比如几千。 如果当时我们设置成无界队列，那么线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。 AbstractQueuedSynchronizer学习AQS的必要性队列同步器AbstractQueuedSynchronizer（以下简称同步器或AQS），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。并发包的大师（Doug Lea）期望它能够成为实现大部分同步需求的基础。 AQS使用方式和其中的设计模式AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，在AQS里由一个int型的state来代表这个状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。 在实现上，子类推荐被定义为自定义同步组件的静态内部类，AQS自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。 同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器。可以这样理解二者之间的关系： 锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节； 同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。 实现者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。 模板方法模式同步器的设计基于模板方法模式。模板方法模式的意图是，定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。我们最常见的就是Spring框架里的各种Template。 实际例子我们开了个蛋糕店，蛋糕店不能只卖一种蛋糕呀，于是我们决定先卖奶油蛋糕，芝士蛋糕和慕斯蛋糕。三种蛋糕在制作方式上一样，都包括造型，烘焙和涂抹蛋糕上的东西。所以可以定义一个抽象蛋糕模型 然后就可以批量生产三种蛋糕 这样一来，不但可以批量生产三种蛋糕，而且如果日后有扩展，只需要继承抽象蛋糕方法就可以了，十分方便，我们天天生意做得越来越赚钱。突然有一天，我们发现市面有一种最简单的小蛋糕销量很好，这种蛋糕就是简单烘烤成型就可以卖，并不需要涂抹什么食材，由于制作简单销售量大，这个品种也很赚钱，于是我们也想要生产这种蛋糕。但是我们发现了一个问题，抽象蛋糕是定义了抽象的涂抹方法的，也就是说扩展的这种蛋糕是必须要实现涂抹方法，这就很鸡儿蛋疼了。怎么办？我们可以将原来的模板修改为带钩子的模板。 做小蛋糕的时候通过flag来控制是否涂抹，其余已有的蛋糕制作不需要任何修改可以照常进行。 AQS中的方法模板方法实现自定义同步组件时，将会调用同步器提供的模板方法， 这些模板方法同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放、同步状态和查询同步队列中的等待线程情况。 可重写的方法 访问或修改同步状态的方法重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。 •getState()：获取当前同步状态。 •setState(int newState)：设置当前同步状态。 •compareAndSetState(int expect,int update)：使用CAS设置当前状态，该方法能够保证状态设置的原子性。 CLH队列锁CLH队列锁即Craig, Landin, and Hagersten (CLH) locks。 CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。 当一个线程需要获取锁时： \\1. 创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用 \\2. 线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred 线程B需要获得锁，同样的流程再来一遍 3.线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked == false) 4.当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点 如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。 CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。 Java中的AQS是CLH队列锁的一种变体实现。 ReentrantLock的实现锁的可重入重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞，该特性的实现需要解决以下两个问题。 1）线程再次获取锁。锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。 2）锁的最终释放。线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。 nonfairTryAcquire方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回true，表示获取同步状态成功。同步状态表示锁被一个线程重复获取的次数。 如果该锁被获取了n次，那么前(n-1)次tryRelease(int releases)方法必须返回false，而只有同步状态完全释放了，才能返回true。可以看到，该方法将同步状态是否为0作为最终释放的条件，当同步状态为0时，将占有线程设置为null，并返回true，表示释放成功。 公平和非公平锁ReentrantLock的构造函数中，默认的无参构造函数将会把Sync对象创建为NonfairSync对象，这是一个“非公平锁”；而另一个构造函数ReentrantLock(boolean fair)传入参数为true时将会把Sync对象创建为“公平锁”FairSync。 nonfairTryAcquire(int acquires)方法，对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁则不同。tryAcquire方法，该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。 深入理解并发编程和归纳总结JMM基础-计算机原理Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java1.5版本对其进行了重构，现在的Java仍沿用了Java1.5的版本。Jmm遇到的问题与现代计算机中遇到的问题是差不多的。 物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 根据《Jeff Dean在Google全体工程大会的报告》我们可以看到 计算机在做一些我们平时的基本操作时，需要的响应时间是不一样的。 （以下案例仅做说明，并不代表真实情况。） 如果从内存中读取1M的int型数据由CPU进行累加，耗时要多久？ 做个简单的计算，1M的数据，Java里int型为32位，4个字节，共有10241024/4 = 262144个整数 ，则CPU 计算耗时：262144 0.6 = 157 286 纳秒，而我们知道从内存读取1M数据需要250000纳秒，两者虽然有差距（当然这个差距并不小，十万纳秒的时间足够CPU执行将近二十万条指令了），但是还在一个数量级上。但是，没有任何缓存机制的情况下，意味着每个数都需要从内存中读取，这样加上CPU读取一次内存需要100纳秒，262144个整数从内存读取到CPU加上计算时间一共需要262144*100+250000 = 26 464 400 纳秒，这就存在着数量级上的差异了。 而且现实情况中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是基本上是无法消除的（无法仅靠寄存器来完成所有运算任务）。早期计算机中cpu和内存的速度是差不多的，但在现代计算机中，cpu的指令速度远超内存的存取速度,由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 在计算机系统中，寄存器划是L0级缓存，接着依次是L1，L2，L3（接下来是内存，本地磁盘，远程存储）。越往上的缓存存储空间越小，速度越快，成本也更高；越往下的存储空间越大，速度更慢，成本也更低。从上至下，每一层都可以看做是更下一层的缓存，即：L0寄存器是L1一级缓存的缓存，L1是L2的缓存，依次类推；每一层的数据都是来至它的下一层，所以每一层的数据是下一层的数据的子集。 在现代CPU上，一般来说L0， L1，L2，L3都集成在CPU内部，而L1还分为一级数据缓存（Data Cache，D-Cache，L1d）和一级指令缓存（Instruction Cache，I-Cache，L1i），分别用于存放数据和执行数据的指令解码。每个核心拥有独立的运算处理单元、控制器、寄存器、L1、L2缓存，然后一个CPU的多个核心共享最后一层CPU缓存L3 Java内存模型（JMM）从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 可见性可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 由于线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，那么对于共享变量V，它们首先是在自己的工作内存，之后再同步到主内存。可是并不会及时的刷到主存中，而是会有一定时间差。很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了 。 要解决共享对象可见性这个问题，我们可以使用volatile关键字或者是加锁。 原子性原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 我们都知道CPU资源的分配都是以线程为单位的,并且是分时调用,操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。而任务的切换大多数是在时间片段结束以后, 那么线程切换为什么会带来bug呢？因为操作系统做任务切换，可以发生在任何一条CPU 指令执行完！注意，是 CPU 指令，CPU 指令，CPU 指令，而不是高级语言里的一条语句。比如count++，在java里就是一句话，但高级语言里一条语句往往需要多条 CPU 指令完成。其实count++包含了三个CPU指令！ volatile详解volatile特性可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步 可以看成 所以volatile变量自身具有下列特性： 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 volatile虽然能保证执行完及时把变量刷到主内存中，但对于count++这种非原子性、多指令的情况，由于线程切换，线程A刚把count=0加载到工作内存，线程B就可以开始工作了，这样就会导致线程A和B执行完的结果都是1，都写到主内存中，主内存的值还是1不是2 volatile的实现原理通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。 Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。 synchronized的实现原理Synchronized在JVM里的实现都是基于进入和退出Monitor对象来实现方法同步和代码块同步，虽然具体实现细节不一样，但是都可以通过成对的MonitorEnter和MonitorExit指令来实现。 对同步块，MonitorEnter指令插入在同步代码块的开始位置，当代码执行到该指令时，将会尝试获取该对象Monitor的所有权，即尝试获得该对象的锁，而monitorExit指令则插入在方法结束处和异常处，JVM保证每个MonitorEnter必须有对应的MonitorExit。 对同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。 JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 synchronized使用的锁是存放在Java对象头里面， 具体位置是对象头里面的MarkWord，MarkWord里默认数据是存储对象的HashCode等信息， 但是会随着对象的运行改变而发生变化，不同的锁状态对应着不同的记录存储方式 了解各种锁自旋锁原理自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 但是线程自旋是需要消耗CPU的，说白了就是让CPU在做无用功，线程不能一直占用CPU自旋做无用功，所以需要设定一个自旋等待的最大时间。 如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 自旋锁的优缺点自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起操作的消耗！ 但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着XX不XX，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。 自旋锁时间阈值自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋次数很重要 JVM对于自旋次数的选择，jdk1.5默认为10次，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间。 JDK1.6中-XX:+UseSpinning开启自旋锁； JDK1.7后，去掉此参数，由jvm控制； 锁的状态一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。 偏向锁引入背景：大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，减少不必要的CAS操作。 偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。它通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。 偏向锁获取过程： 步骤1、 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。 步骤2、 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。 步骤3、 如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。 步骤4、 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word） 步骤5、 执行同步代码。 偏向锁的释放： 偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。 偏向锁的适用场景 始终只有一个线程在执行同步块，在它没有执行完释放锁之前，没有其它线程去执行同步块，在锁无竞争的情况下使用，一旦有了竞争就升级为轻量级锁，升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致stop the word操作； 在有锁的竞争时，偏向锁会多做很多额外操作，尤其是撤销偏向所的时候会导致进入安全点，安全点会导致stw，导致性能下降，这种情况下应当禁用。 jvm开启/关闭偏向锁 开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0 关闭偏向锁：-XX:-UseBiasedLocking 轻量级锁轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁； 轻量级锁的加锁过程： 在代码进入同步块的时候，如果同步对象锁状态为无锁状态且不允许进行偏向（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，当竞争线程尝试占用轻量级锁失败多次之后，轻量级锁就会膨胀为重量级锁，重量级线程指针指向竞争线程，竞争线程也会阻塞，等待轻量级线程释放锁后唤醒他。锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 不同锁的比较","link":"/2020/10/26/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%A8/"},{"title":"中国近代史大纲","text":"一、第一次鸦片战争时期 1.1839年： 林则徐在广州禁烟。 林则徐编写《四洲志》；睁眼看世界第一人； 6月在虎门海滩销烟。英国政府决定发动侵略中国战争。2.1840年： 6月，鸦片战争爆发，英军从广州转攻厦门，攻陷定海，北犯天津。3.1841年： 1月，琦善同英国签订《穿鼻草约》，道光帝不满，派奕山到广州主持军事，对英作战。关天培在虎门炮台抗击英军，壮烈牺牲。 5月，英军进逼广州，弈山投降。三元里人民进行抗英斗争。 9月，定海再次陷落，三总兵抗敌牺牲。4.1842年： 2月，广东水师提督关天培在虎门与英军战死。 6月，陈化成坚守吴淞口以身报国。 7月，海龄，镇江以身报国。 8月，英舰到达南京江面，清政府被迫签订了《中英南京条约》。魏源编著《海国图志》，提出“师夷长技以制夷” 5.1843年： 英国强迫清攻府签订《中英五口通商章程》和《中英虎门条约》，作为《南京条约》的附件。洪秀全创立拜上帝教。6.1844年： 《中美望厦条约》和《中法黄埔条约》签订。7.1851年： 1月11日，洪秀全在广西金田村起义，建号太平天国。 9月，在永安州城建制封王。8.1853年： 3月，太平军占领南京，改名天京，定为都城。颁布《天朝田亩制度》。 4月，发动北伐与西征。 二、第二次鸦片战争时期 1.1856年： 英国利用“亚罗号事件”、法国利用“马神甫事件”发动第二次鸦片战争；秋，“天京事变”发生，严重地削弱了太平天国的领导和军事力量，成为太平天国由盛转衰的分水岭；2.1858年： 沙俄强迫黑龙江将军奕山签订《爱珲条约》。英法联军占领天津。俄、英、法、美强迫清政府分别签订《天津条约》。3.1859年： 6月，英法公使到北京交换条约文本，蓄意挑衅，炮轰大沽口，史荣椿、乐善捐躯。洪仁圩提出了一个统筹全局的改革方案《资政新篇》4.1860年： 英法联军攻占天津、北京。与英、法《北京条约》签订。 三、洋务运动时期 兴起早期维新思想:王韬、郑观应。最早做出完整表述的是冯桂芬。 1.1861年： 11月，那拉氏发动政变（史称“辛酉政变”或“北京政变”）。 中外反动势力勾结起来，共同镇压太平天国运动； 曾国藩创设安庆军械所。它是洋务派办的第一个军事工业。 清政府设立“总理衙门”，由奕担任总理大臣2.1862年： 太平天国军民进行天京保卫战。 总理衙门设立京师同文馆、清末最早设立的″洋务学堂″3.1864年： 7月，天京被湘军攻破、天京陷落，太平天国失败。4.1872年： 李鸿章在上海设立轮船招商局。它是洋务派办的第一个与民用有关的工业； 陈启源在广东南海商办的继昌隆缫丝厂创立（近代中国第一家缫丝厂）。 5.1883年： 12月，中法战争爆发。6.1884年： 8月下旬，法舰突然袭击马尾军港的福建水师。清政府下诏对法国正式宣战。 10月，刘铭传的清军击退进犯台北的法军。 7.1885年： 3月，法舰进犯浙江镇海。 刘永福黑旗军和越南人民配合，在临洮大败法军，收复十多个州县。 冯子材在镇南关大败法军，乘胜追击，收复谅山等要地。 6月，《中法新约》签订。 19世纪70年代 清政府建成北洋水师19世纪70至80年代 “边疆危机”英国从印度侵人西藏，又从缅甸入侵云南； 法国则从越南侵犯广西； 俄国从中亚人侵新疆；日本吞并琉球、侵犯中国台湾。19世纪90年代资产阶级维新派创办的学会主要有强学会 洋务派兴办军用工业： 1865年，李鸿章筹办上海江南制造总局,当时国内最大的兵工厂；同年,李鸿章在南京设立金陵机器局； 1866年，左宗棠在福建创办福州船政局，附设有船政学堂，是当时国内最大的造船厂； 1867年，崇厚在天津建立天津机器局； 1890年，张之洞在汉阳创办湖北枪炮厂。 民用企业（官督商办）：1873年李鸿章创办轮船招商局、开平矿务局、天津电报局和上海机器织布局 1869年，方举赞在上海开设发昌机器厂，中国民族资本主义产生 1881年，中国人第一条铁路唐胥铁路建成通车 四、维新变法时期 1.1888年： 康有为第一次向光绪帝上书，要求变法。成立北洋舰队2.1894年： 朝鲜东学党起义，日本乘机出兵朝鲜，占领汉城。 7月，日军突然袭击在牙山附近的中国运输船和驻军，挑起侵略中国的甲午战争。 左宝贵在平壤战役牺牲。 在黄海战役中，邓世昌、林永升等牺牲。 日军侵入辽东半岛，东北人民英勇抗敌，保卫国土。 孙中山在美国檀香山成立兴中会。喊出了”振兴中华”这个时代的最强音。3.1895年： 在威海卫战役中，北洋海军覆灭。清政府向日本求和，被迫签订中日《马关条约》。 徐骧领导的台湾义军和刘永福配合，抗击日军； 康有为等“公车上书”，反对同日本议和，请求变法。使维新思想发展成为爱国救亡运动。 康有为在北京创办《中外记闻》、严复《救亡决论》，喊出了”救亡”的口号；4.1896年： 康有为写了《新学伪经考》、《孔子改制考》、《人类公理》； 梁启超写了《变法通议》； 谭嗣同写了《仁学》； 严复翻译了《天演论》（”物竞天择”、”适者生存”）等。5.1897年： 德国强占胶州湾，民族危机严重；梁启超任主笔的上海《时务报》、严复主办的天津《国闻报》以及湖南的《湘报》等。严复译述的《天演论》在 《国闻报》上定期发表。 6.1898年： 6月，光绪帝颁布《定国是诏》任康有为为总理衙门章京。接着又派谭嗣同、杨锐、刘光第、林旭等人参预变法。 9月，那拉氏（慈禧太后）发动政变，囚禁光绪帝，杀害谭嗣同、杨锐、刘光第、林旭等六人（即戊戌六君子）。史称“戊戌政变”。戊戌变法失败。 五、八国联军侵华战争时期 1.1899年： 秋，山东平原县义和团在朱红灯领导下举行武装起义“扶清灭洋”；美国提出侵略中国的“门户开放”政策；2.1900年： 夏，在京津地区义和团运动的影响下，其他各地也爆发了义和团运动，全国掀起了反帝反封建斗争的浪潮； 6月，八国联军侵略中国。义和团在廊坊、老龙头车站、紫竹林租界等地抗击八国联军； 围攻北京东交民巷使馆和西什库教堂，在北仑配合清军阻击八国联军； 7月17日至21，沙俄出兵侵略我国东北，制造江东六十四屯惨案 ；与1900年7月16日发生的海兰泡惨案，并称为“庚子俄难”；3.1901年： 9月，《辛丑条约》签订。 六、辛亥革命时期 1.1902年： 2月8日，梁启超创办《新民丛报》； 5月21日，张之洞创立湖北师范学院；2.1903年： 5月27日，邹容著《革命军》，章炳麟为《革命军》作序。 5月，章炳麟的《驳康有为论革命书》在《苏报》上发表。3.1904年： 2月8日，日本偷袭旅顺，日俄战争爆发； 2月15日，华兴会成立； 7月3日，科学补习所在武昌成立； 资产阶级革命团体华兴会、光复会、岳王会、科学补习所成立。 陈天华著《猛回头》和《警世钟》。4.1905年： 中国同盟会在日本东京成立，提出政治纲领，选举孙中山为总理，创办了《民报》。5.1906年： 革命党在萍乡、醴陵、浏阳起义，安源矿工六千人参加斗争，最终失败。6.1907年： 孙中山领导潮州、惠州、钦州、廉州和镇南关起义，旋败。徐锡麟在安徽起义，失败被害。秋瑾准备在浙江响应，被捕慷慨就义。7.1910年： 广州新军起义、黄花岗起义；“皇族内阁”成立8.1911年： 4月，孙中山和黄兴发动广州起义； 5月，保路运动爆发。四川最为激烈； 10月10日，（共进会和文学社）武昌起义爆发。革命首先在武汉三镇取得胜利，成立湖北军政府，改国号为中华民国。9.1912年： 元旦，中华民国临时大总统孙中山在南京就职，宣告中华民国成立。接着成立临时参议院，不久，颁布参议院制定的《中华民国临时约法》、《告 各友邦书》。《中国邻国临时约法》中国历史上第一步具有资产阶级共和国宪法性质的大典； 2月，清帝退位。孙中山辞职，袁世凯窃取了革命果实，接任中华民国临时大总统。宋教仁等准备组织责任内阁，以限制袁世凯的权力：将同盟会改 组为国民党。 10.1913年： 3月，袁世凯派人在上海火车站杀害了宋教仁；非法签订善后大借款； 7月，主要在九江、南京一带，史称“赣宁之役”，称“二次革命”。；11.1914年： 孙中山在日本组织中华革命党，坚持反袁武装斗争； 秋、日本派兵入侵山东，取代德国在山东的侵略地位； 七、新文化运动时期 提倡民主科学，反对专制迷信，主张文学革命1.1915年： 1月，日本提出灭亡中国的《二十一条》。 5月9日，“五九国耻”日，接受《二十一条》； 9月15日，陈独秀创办《青年杂志》，在创刊号上发表《敬告青年》一文，提出民主和科学的口号，掀起新文化运动。 12月12日，袁世凯当上了中华帝国皇帝，改年：号为“洪宪”。 12月15日，蔡锷、唐继尧在云南组织”护国军”，形成护国运动。2.1916年： 袁世凯在绝望中死去。黎元洪继任总统。 总理段祺瑞操纵北京政府实权。 杜亚泉在《东方杂志》上抨击新文化运动，拉开中西文化论战序幕3.1917年： 张勋复辟失败。段祺瑞下令对德宣战，宣布不再恢复《临时约法》和国会。 孙中山在广州发动第一次护法运动。 陈独秀任北大文科学长； 俄国十月革命胜利，极大促进了马克思主义在中国的传播。4.1918年： 鲁迅发表《狂人日记》，号召人民起来推翻吃人的旧社会。 李大钊发表《法、俄革命之比较观》、《庶民的胜利》和《布尔什维主义的胜利》，热情歌颂十月社会主义革命。 5月，护法运动失败，标志着整个中国民族资产阶级领导的旧民主主义革命的终结。5.1919年： 《新青年》出版“马克思研究专号”、李大钊发表《我的马克思主义观》； 5月4日，“五四”运动爆发；巴黎和会上中国外交的失败是直接导火索。 6月，中心转移到上海。“五四运动”是新民主主义革命的开端 邓中夏、高君宇北京大学马克思学说研究会 陈独秀上海马克思主义研究会 新民学会、互助社、觉悟社； 10月，将中华革命党改组为中国国民党；八、第一次国共合作时期 1.1920年： 8月，孙中山传令粤军陈炯明回师广东，讨伐桂系军阀金春煊、陆荣延。陈望道第一翻译《共产党宣言》 11月，孙中山领导第二次护法运动 陈独秀在上海创办中国共产党第一个早期组织，陈独秀，李汉俊、李达；2.1921年： 7月23日，中共一大在上海召开，标志中国共产党成立； 8月，中国劳动组合书记部成立，中国共产党领导工人运动的专门机关； 9月，孙平广西，统一两广；3.1922年： 1月－3月，香港中国海员大罢工 6月，陈炯明炮轰，孙登永丰舰； 7月，中共二大召开，制定反帝反封建的民主革命纲领， 党的最高纲领是实现社会主义、共产主义 当前阶段的纲领是：打倒军阀,推翻国际帝国主义的压迫; 统一中国为真正民主共和国。 8月9日，孙离广赴上；二次革命战争失败；标志资产阶级领导的旧民主主义革命走到了历史尽头； 9月，安阳路矿工罢工；4.1923年： 2月，京汉铁路工人举行“二七”大罢工；从1922年1月香港海员罢工到1923年2月京汉铁路工人罢工，在中国共产党的领导、组织、推动下，中国掀起了第一个工人运动的髙潮。（包括安源路矿工人罢工、开滦五矿工人罢工） 6月，中共三大在广州召开，决定同国民党合作，建立革命统一战线，标志着第一次国共合作的正式形成5.1924年： 1月，中国国民党“一大”召开，提出“新三民主义”，革命统一战线正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面； 5月，黄埔军校的建立； 7月，国民党设立农民部，林伯渠、澎湃；广州开办农民运动讲义所，澎湃、阮啸仙、毛泽东； 10月23日，冯玉祥发动北京政变6.1925年： 3月12日，孙中山先生逝世； 5月30日，发生“五卅”惨案，“五卅”反帝运动爆发；7.1925年6月－1926年10月： 香港工人大罢工，当时世界上罢工时间最长的一次；8.1926年： 3月，毛泽东发表《中国社会各阶级的分析》；蒋介石策动“中山舰事件”； 5月，蒋介石提出“整理党务案”； 7月，国民革命军出师北伐，推翻北洋军阀； 9月1日，毛泽东发表《国民革命与农民运动》一文，指出：”农民问题乃国民革命的中心问题”，”所谓国民革命运动，其大部分即是农民运动”。9.1926年10月－1927年3月： 上海工人三次武装起义；10.1927年： 1月，武汉和九江人民收回英租界；国民政府从广州迁到武汉，武汉成为当时全国革命的中心； 3月，毛泽东发表《湖南农民运动考察报告》； 4月12日，蒋介石在上海发动反革命政变；“四·一二”反革命政变； 4月18日，蒋介石在南京成立国民政府； 4月27日至5月9日，中国共产党第五次全国代表大会在武汉召开； 5月，夏斗寅、许克祥叛变 7月15日，汪精卫在武汉召开“分共”会议，制造“七·一五”反革命政变。 第二次国内革命战争爆发；政变后，宁汉合流；国共合作破裂，国民革命失败 8月1日，“八一”南昌起义；打响了武装反抗国民党反动统治的第一枪。这是中国共产党独立领导革命战争、创建人民军队和武装夺取政权的开端。 8月7日，在汉口召开“八七会议”，彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。 毛泽东在会上强调“政权是由枪杆子中取得的”；八七会议”开始了从大革命失败到土地革命战争兴起的历史性转折。 9月，毛泽东领导湘赣边秋收起义；失败后，三湾改编，明确了共产党对军队的绝对领导，武装夺取政权的保证； 10月，毛泽东率领工农革命军在井冈山创立革命根据地； 12月11日，广州起义； 中国革命由此发展到一个新的阶段，即土地革命战争时期（十年内战时期）；11.1928年： 4月，井冈山会师，成立中国工农红军第四军； 6月，南京国民政府宣布改定新约； 10月，国民党中央常务委员会通过了《训政纲领》； 10月和11月，毛泽东写了《中国的红色政权为什么能够存在？》和《井冈山的斗争》，阐述了共产党领导的土地革命、武装斗争与革命根据地建设者三者之间的辩证统一关系。强调“工农武装割据”的思想； 12月29日，张学良东北易帜，南京国民政府在形式上完成了全国统一12.1930年： 1月，毛泽东在《星星之火，可以燎原》中指出：红军、游击队和红色区域的建设和发展，是半殖民地中国在无产阶级领导之下的农民战争的最高形式和半殖民地农民斗争发展的必然结果，并且是促进全国革命高潮的最重要因素。 5月，1、毛泽东在《反对本本主义》，阐明了坚持辩证唯物主义的思想路线（即坚持理论与实际相结合的原则）的极端重要性，提出了“没有调査，没有发言权”和“中国革命斗争的胜利要靠中国同志了解中国情况”的重要思想，表现了毛泽东开辟新道路、创造新理论的革命首创精神。 2、农村包围城市、武装夺取政权理论的提出，标志着中国化的马克思主义即毛泽东思想的初步形成。 九、抗日战争时期 1.1931年： 9月18日，日本帝国主义发动“九·一八”事变； 11月，中华苏维埃第一次全国代表大会召开，中华苏维埃共和国临时中央政府成立；2.1932年： 1月28日，日本帝国主义发动“一·二八”事变，十九路军奋起抗战； 2月东北全境沦陷； 3月，日本扶植前清逊帝溥仪建立伪满洲国3.1934年： 4月，共产党提出，宋庆龄、何香凝、李杜签名发表了《中国人民对日作战的基本纲领》 10月，工农红军第五次反“围剿”失败，中央革命根据地主力红军开始长征；4.1935年： 1月，遵义会议召开；解决组织问题、军事问题；确立毛为代表的马克思主义主线的领导地位，生死攸关转折点；毛泽东、周恩来、王稼祥负责军事行动； 2月，东北抗日联军建立； 6月，四川懋功，红一，红四会师； 8月1日，中共中央发表八一宣言（《为抗日救国告全国同胞书》）； 10月，陕北吴起镇，中央红军同十五军团胜利会师； 12月9日，“一二·九”运动爆发（反对华北自治、打倒日本帝国主义、停止内战，一致对外）； 12月，中共中央瓦窑堡会议，毛泽东发表《论反对日本帝国主义的策略》，通过了《中央关于目前政治形势与党的任务决议》，阐明党的抗日民族 统一战线的新政策，批判党内的关门主义和对于革命的急性病,系统地解决了党的政治路线上的问题。； 华北事变；5.1936年： 5月，全国各界救国联合会成立； 7月，西康甘孜，红四方面军，红二、六方面军会师； 10月，甘肃会宁、静宁将台堡，红一、红二、红四在胜利会师，长征胜利结束；红四张国焘 徐向前 12月，张学良、杨虎城扣押蒋介石，西安事变，抗日民族统一战线初步形成； 毛泽东写了《中国革命战争的战略问题》,总结土地革命战争中党内在军事问题上的大争论，系统地说明了有关中国革命战争战略方面的诸问题。6.1937年： 7月7日，“芦沟桥事变”，抗日战争开始； 7月15日，中共提出国共合作的抗日宣言； 7月28日，赵登禹抗日殉国； 8月13日，日本发动“八·一三”事变，蓄意已久地为扩大侵华战争在中国上海制造的事变； 8月22日，中共洛川会议，会议通过了《关于目前形势和党的任务的决定》颁布《抗日救国十大纲领》； 9月，国民党公布国共合作抗日宣言，抗日民族统一战线建立；八路军平型关大捷； 10月，八路军创立第一个抗日根据地——晋察冀根据地； 12月13日，南京沦陷。日军制造南京大屠杀7.1938年： 3月，李宗仁指挥军队开展徐州会战，台儿庄战役是抗战以来正面战场取得的战果最大的一次胜利； 5月，毛泽东发表《论持久战》； 10月，中共召开六届六中全会，毛泽东明确提出了”马克思主义的中国化”这个命题； 10月，广州、武汉失守，抗战进入相持阶段； 12月，汪精卫投降日本。8.1939年： 1月，五届五中全会，国民党成立”防共委员会”，确定了”防共、限共、溶共、反共”的方针9.1940年： 1月，毛泽东发表《新民主主义论》； 3月，汪精卫伪国民政府在南京成立； 5月，枣宜会战国民党张自忠捐躯； 8－11月，彭德怀指挥八路军发动百团大战；10.1941年： 1月，国民党发动第二次反共高潮——皖南事变； 5月，毛泽东作了《改造我们的学习》的报告； 12月，日军发动太平洋战争，美、英对日宣战，整个世界格局发生变化。11.1941－1942年： 中国共产党采取“三三制”原则， 加强抗日民主政权建设， 实行减租减息政策， 开展大生产运动和整风运动， 进行反“扫荡”斗争，保卫解放区；12.1942年： 1月，中、美、英、苏等26国共同签署《联合国宣言》 缅甸北部对日作战以身殉职的是中国远征军戴安澜 十、国共内战时期 1945-1949 1.1945年： 4月，中共“七大”召开；同美国、英国、苏联发起旧金山会议(联合国制宪会议)董必武前往； 8月8日，苏联对日宣战； 8月15日，日本宣布无条件投降； 9月2日，日本正式签订投降书； 9月3日，抗战胜利纪念日； 8月25日，中共中央在《对目前时局的宣言》中提出的口号是“和平、民主、团结”； 8月28日－10月10日，国共重庆谈判，签订《双十协定》； 9月，“向北发展，向南防御”； 10月中下旬，上党、邯郸战役，粉碎国民党的局部进攻； 12月1日，昆明学生发动“一二·一”爱国运动； 2.1946年： 1月10日，国共两党签订停战协定；政协会议开幕； 2月10日，国民党特务在重庆制造的破坏“庆祝政协成功大会”的事件，校场口惨案 6月，国民党发动全面内战，第三次国内革命战争开始；起点是大局围攻中原解放区； 6月23日，上海人民团体联合会、学生和平存进为反对内战，联合发起组成上海人民和平请愿团，下关惨案； 12月30日，北平学生发动抗议美军暴行的运动； 3.1947年： 2月28日，台湾人民举行“二·二八”起义； 3月－7月，延安保卫战，孟良崮战役，粉碎国民党的重点进攻； 5月20日，全国学生发动“反饥饿、反内战、反迫害”的爱国运动； 6月30日，刘邓大军挺进大别山； 7月，人民解放军开始全国规模的反攻； 9月，中共全国土地会议召开，公布《中国土地法大纲》； 10月10日，《中国人民解放军宣言》发表；打到蒋介石，解放全中国；4.1948年： 9月－11月，辽沈战役； 11月－1949年1月，淮海战役； 12月－1949年1月，平津战役；5.1949年： 1月，将革命进行到底； 3月，西柏坡中共七届二中全会；规定政治、经济、外交基本政策；农业国转变工业国、新民主主义社会转变社会主义社会方向；提出“两个务必”要求； 4月21日，毛泽东、朱德发而进军令，解放军渡江作战； 4月23日，解放南京，国民党反动统治结束； 6月30日，毛泽东发表《论人民民主专政》； 9月21日，中国人民政治协商会议第一届全体会议开幕； 10月1日，中华人民共和国成立，民主革命终结和社会主义革命开始；标志着中国进入了新民主主义社会； 1948 9月－11月 辽沈战役 中国近代史解放战争的“三大战役”之一，战役结束后，中国人民解放军首次在兵力数量方面超越国民党军。 11月－次年1月 淮海战役 淮海战役是三大战役中解放军牺牲最重，歼敌数量最多，政治影响最大、战争样式最复杂的战役。 12月－次年1月 平津战役 解放战争中具有决定意义的三大战役中的最后一个战役。平津战役胜利结束，人民解放军进驻北平城，北平宣告完全解放。 十一、中华人民共和国成立和巩固时期：1949—1953年： 1.1950年： 7月，中国共产党召开七届三中全会，毛做《为争取国家财政经济状况的基本好转而斗争的》报告，创建三个条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减；2.1950年10月—1953年7月， 中国人民志愿军抗美援朝； 中央人民政府颁布《中华人民共和国土地改革法》，规定废除地主阶级封建剥削的土地所有制，实行农民的土地所有制。 毛泽东在《在晋绥干部会议上的讲话》第一次全面、系统地提出了新民主主义革命的总路线和总政策，即“无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命”；3.1950—1952年底： 土地改革。土地改革的完成，彻底废除了我国存在两千多年的封建土地制度，地主阶级被消灭，农民成为土地的主人； 使人民政权更加巩固，农村生产力大大解放，为国家的工业化建设准备了条件；4.1951年： 5月，同西藏地方政府达成关于和平解放西藏办法的协议； 10月，西藏和平解放； 标志着祖国大陆获得了统一，各族人民实现了大团结；5.1951年底-1952年春 开展反贪污、反浪费、反官僚主义的“三反”运动，处决了犯有严重贪污罪的天津地委前任书记刘青山、现任书记张子善；6.1952年 1月26日，五反运动是指建国初期在资本主义工商业者中开的反行贿、反偷税漏税、反盗骗国家财产、反偷工减料、反盗窃国家经济情报的斗争； 十二、向社会主义过渡时期：1953—1956年： 1.1953—1957年： 第一个五年计划。一五计划的完成使我国开始改变了工业落后的面貌，向社会主义工业化迈进； “一化三改”。“一化”即社会主义工业化，就是要发展生产力。 “三改”即对农业、手工业、资本主义工商业的社会主义改造，其中对农业、手工业实行合作化，对资本主义工商业实行公私合营 对资本主义工商业采取利用、限制、改造的政策，对资产阶级采取赎买政策。 在经过委托加工、计划订货、统购包销、委托经销代销等一系列从初级到高级的国家资本主义过渡形式2.1953年底： 周恩来在接见印度代表团时提出和平共处五项原则，成为处理国与国之间关系的基本准则。3.1954年9月： 第一届全国人民代表大会制定了《中华人民共和国宪法》，这是我国第一部社会主义类型的宪法。4.1955年： 周恩来出席万隆会议（亚非国际会议），提出“求同存异”的方针，促进了会议的圆满成功，也促进了中国同亚非各国的团结与合作。 十三、探索建设社会主义道路时期（全面建设社会主义时期）：1956—1966年： 1.1956年： 4月25日，毛在中央政治局扩大会议上作了《论十大关系》的讲话，调动一切积极因素，为社会主义事业服务。为探索适合中国国情的社会主义建设道路提出了许多重要的思想原则，从思想上、理论上为八大的召开作了重要的准备。 8月30日至9月12日，在北京举行了八大预备会议。毛泽东在会上作了《增强党的团结，继承党的传统》的讲话，指出八大召开的目的和宗旨是： 总结七大以来的经验，团结全党，团结国内外一切可以团结的力量，为建设社会主义中国而奋斗。号召全党要继承优良传统，反对主观主义、宗派主义和官僚主义。 中共提出“百花齐放，百家争鸣”的方针，使文学艺术创作出现了崭新的局面。 2.1956年： 中共八大召开。这是探索建设社会主义道路的良好开端。陈云提出“三个主体，三个补充”思想。党和人民当前的主要任务是把我国从落后的农业国变为先进的的工业国； 三大改造完成，实现了把生产资料私有制转变为社会主义公有制的任务，标志着我国初步建立起社会主义的基本制度，进入社会主义初级阶段； 长春第一汽车制造厂建成投产、沈阳机床厂建成投产、北京电子管厂建成投产、沈阳飞机制造厂试制成功；3.1957年： 2月，毛在最高国务会议上发表《关于正确处理人民内部矛盾的问题》讲话，区分和处理敌我和人民内部两类矛盾的学说；强制-专制；民主-说服教育-团批团； 武汉长江大桥通车；青藏、康藏、新藏公路通车；4.1958年： “大跃进”和人民公社化运动开始。这是党在探索建设社会主义道路中的一次严重失误。5.20世纪60年代初： 西藏地区完成民主改革，废除了封建农奴制度，百万农奴翻身当家做了主人，进入社会主义阶段。6.1961年春： 中共八届九中全会，决定对国民经济实行“调整、巩固、充实、提高”方针的会议 党和政府全面调整国民经济 ,恢复发展生产。7.1962年春： 中共重要为统一思想、总结经验教训和明确工作方向召开了“七千人会议”8.1964年： 10月16日：我国第一颗原子弹爆炸成功，打破了帝国主义的核垄断。 12月，周恩来第三届人大第一次会议，四个现代化 十四、“文化大革命”时期：1966—1976年： 1966年： 中国战略导弹部队组建成功，主要担任核反击任务。 1967年： 6月17日中国成功试爆第一枚氢弹 1970年： 我国成功发射第一颗人造地球卫星——东方红1号。 1971年： 7月，基辛格秘密访华。 9月13日，九一三事件，林彪反革命集团被粉碎。 10月25日，第26届联合国大会恢复了我国在联合国的合法席位。 1972年： 2月，尼克松访华，中美双方在上海签署了《中美联合公报》，中美关系开始走向正常化。日本首相田中角荣访华，中日建交。 1973年： 袁隆平在世界上首次育成籼型杂交水稻。 1976年： 10月，粉碎江青反革命集团（“四人帮”），标志“文化大革命”结束。 十五、社会主义现代化建设的新时期（改革开放时期）：1978年至今 1978年： 关于真理标准问题的讨论展开。这是一场深刻的思想解放运动，为十一届三中全会的召开奠定了思想基础。 12月，中共十一届三中全会召开。这是建国以来党的历史上具有深远意义的转折，是改革开放的开端，从此我国进入社会主义现代化建设的新时期。 1979年： 1月，《告台湾同胞书》 中美建交。 3月，邓小平在中央理论工作务虚会上明确提出必须坚持四项基本原则。 坚持社会主义道路，坚持人民民主专政，坚持共产党的领导，坚持马克思列宁主义，毛泽东思想。 1980年： 我国在广东的深圳,珠海,汕头和福建的厦门建立经济特区，开始对外开放。 1982年： 中共十二大，邓小平提出建设有中国特色的社会主义，全国人大颁布了第四部《中华人民共和国宪法》。 1984年： 12月，中英《关于香港问题的联合申明》 1985年： 3月，《关于科学技术体制改革的决定》 5月，《关于教育体制改革的决定》 1986年： 颁布《中华人民共和国义务教育法》和《中华人民共和国民法通则》。 1987年： 4月，中葡《关于澳门问题的联合生命》 10月25日-11月1日，中共十三大，邓小平阐明了社会主义初级阶段理论，提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线，即以经济建设为中心，坚持四项基本原则，坚持改革开放。台湾当局调整“三不”政策，两岸关系发生了历史性的变化。制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标 1988年： 4月13日，海南经济特区； 1990年： 中国首次成功举办亚洲运动会。1990年台湾成立了海峡交流基金会。 1991年： 大陆成立了海峡两岸关系协会。 1992年：扩大改革，开放上海浦东位新的经济特区；海基会与海协会达成“九二共识”，即“海峡两岸均坚持一个中国原则”。 1992年初：邓小平南巡讲话，强调发展才是硬道理。南巡讲话进一步解放了人们的思想，对建设有中国特色的社会主义产生了深远影响。 1992年：中共十四大，提出建立社会主义市场经济体制，确立了邓小平理论在全党的指导地位，形成了以江泽民为核心的第三代领导集体。 1993年：“汪辜会谈”（海协会会长汪道涵和海基会董事长辜振甫在新加坡举行的会谈），将“加强两岸经济交流，互补互利”写入协议，标志着海峡两岸关系的发展迈出了历史性的重要一步。 14. 1995年初：1月，江泽民发表《为促进祖国统一大业的完成而继续奋斗》，提出“八项主张”，成为新时期推进祖国和平统一进程的指导思想。 1997年：7月1日：香港回归，中华人民共和国香港特别行政区正式成立。9月12日至18日，中共十五大，把邓小平理论写入党章，确立为党的指导思想。通过了关于《中国共产党章程修正案》的决议； 1999年：12月20日：澳门回归，中华人民共和国澳门特别行政区正式成立。我国成功发射第一艘无人飞船“神舟一号”。 20世纪90年代：党和政府提出“科教兴国”战略，把九年义务教育作为科教兴国的奠基工程。 20世纪末：中国整体上进入小康社会。 2000年：全国基本普及九年义务教育。 2001年：12月11日，加入世贸组织，标志着对外开放进入一个新阶段。中国在上海成功举办了亚太经合组织会议（APEC会议）。这是中国迄今举行的规模最大、规格最高的多边外交活动。 2002年：11月8日至14日，中共十六大北京召开；高举邓小平理论伟大旗帜，全面贯彻“三个代表”重要思想，继往开来，与时俱进，全面建设小康社会，加快推进社会主义现代化，为开创中国特色社会主义事业新局面而奋斗； 2003年：我国成功发射第一艘载人飞船“神州五号”。 2004年：9月，中共十六届四中全会提出的战略任务是构建社会主义和谐社会； 2005年3月14日第十届人民大表大会三次会议，反分裂国家法 2007年：10月15日至21日，中共十七大明确指出，高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制； 2008年：中国成功举办了奥运会和残奥会。 2010年：5月，中央新疆工作会议上中央正式批准霍尔果斯、喀什设立经济特区。 2011年：确立建设社会主义文化强国战旅目标的会议是 2013年：11月，中共十八届三中全会做出《关于全面深化改革若干重大问题的决定》，提出了全面深化改革的知道思想、重要方针、目标任务、政治举措，明确了全面深化改革的总目标、时间表、路线图，成为知道新形势下全面深化改革的纲领性文件；2017年：第十二届全国人大常委会第二十九次会议通过的法律《中华人民共和国国歌法》 主要运动： 四一二事变 1927年4月12日 上海 蒋中正大规模逮捕、处决中国共产党党员，并取缔苏联顾问。 七一五事变 1927年7月15日 武汉 汪精卫分工事件 九一八事变 1931年9月18日 东北 日本帝国主义发动“九·一八”事变 一二八事变 1932年1月28日 上海 日本帝国主义发动“一·二八”事变，淞沪会战，蒋光鼐蔡延凯抗击 一二九运动 1935年12也9日 北平 抗议日本侵占；北平爱国学生举行的抗日游行运动； 七七事变 1937年7月7日 卢沟桥 抗日战争开始 八一三事变 1937年8月13日 上海 蓄意已久地为扩大侵华战争在中国上海制造的事变 一二一运动 1945年12月1日 昆明 反对内战，争取自由；吹响了国统区爱国学生运动的第一声号角； 校场口惨案 1946年2月10 重庆 庆祝政协成功大会 下关惨案 1946年6月23日 上海 和平请愿团 一二三O运动 1946年12月30日 北平 抗议驻华美军暴行； 五二O运动 1947年5月20日 南京 反饥饿，反内战，挽救教育危机； 香港海员罢工 1922年1月 香港 中国工人阶级第一次直接同帝国主义势力进行的有组织的较量；工人运动第一个高潮起点。 主要党派： 兴中会 1894年11月 美国檀香山； 中国同盟会 1905年8月 日本东京； 中华革命军 1914年7月 日本东京； 中国国民党 1919年10月 中国上海； 中国 土地革命战争前中期，中国共产党内出现的主要错误倾向： “左”倾盲目主义 1927.11-1928.4 “左”倾冒险主义 1930.6-1930.9 “左”倾教条主义 1931.1-1935.1 为国捐躯的清政府爱国将领 第一次鸦片战争 关天培 1841.2 虎门 陈化成 1842.6 吴淞西炮台 海龄 1842.7 镇江 第二次鸦片战争 史荣椿 1859.6 大沽炮台 乐善 1859.6 大沽炮台 甲午战争 左宝贵 1894 平壤战役 丁汝昌 1895.2.11 北洋舰队 邓世昌 1894 甲午海战 林永升 1894 甲午海战 刘步蝉 重要将领介绍： 赵登禹，抗日牺牲； 佟麟阁，抗日牺牲； 张自忠，枣宜会战； 戴安澜，缅甸抗战； 李宗仁，台儿庄战役； 谢晋元，上海四行仓库牺牲； 蒋光鼐蔡延凯，淞沪会战； 一大党，二大纲。三大连国搞合作，四大五大净瞎忙。八一南昌第一枪，八七政权要靠抢。秋收工农来战斗，三湾改编新军装。遵义生死转折点，瓦窑战线要统一。洛川纲领有十条，七大老毛思想立。七届二中进城忙，七届三中复元气。八大主矛搞建设，九大十大不能提。十一三中搞开放，十一六中评价毛。十二小平提中特，十三别忘三步跑。十三一中两基本，十四泽民建市场。十五小平进党章，十六三代要小康。十七科观入党章，三届人大现代化。务虚四项要坚持，十八三中改革大。十九建成奔小康 1.封建社会的基本特点？（过） 经济上，封建土地所有制占主导地位，小农经济是其基本生产结构； 政治上，实行高度中央集权的封建君主专制制度； 文化上，以儒家思想为核心； 社会结构上，是族权和政权相结合的封建宗法等级制度； 2.近代中国社会的主要矛盾及其影响？（过） 帝国主义和中华民族的矛盾，封建社会和人民大众的矛盾，帝国主义和中华民族的矛盾是主要矛盾； 两对主要矛盾相互交织在一起，贯穿了整个半殖民地半封建社会的始终，对中国社会的发展变化起这决定性作用； 相互关系： 当外国列强向中国发动侵略战争时，阶级矛盾降到次要地位，民族矛盾上升到主要地位； 当外国侵略者同中国封建政权相勾结，共同镇压中国革命，尤其是封建地主阶级对人民的压迫特别残酷时，阶级矛盾上升为主要矛盾； 3.近代以来中华民族面临的历史任务？（过） 两大历史任务： 一是求得民族独立和人民解放； 二是实现国家繁荣富强和人民共同富裕； 相互区别，相互联系； 前者要从根本上推翻中国半殖民地半封建社会的统治秩序，着重解决生产关系问题； 后者要改变近代中国经济、文化和社会落后的地位和状况，是要充分发展近代民族工商业，着重解决生产力问题； 只有完成第一大任务，才能为第二大任务的完成创造条件。 争取民族独立和人民解放是实现国家繁荣富强和人民共同富裕的前提条件。争取民族独立和人民解放的最终目的是使中国走向现代化，实现国家繁 荣富强和人民共同富裕，是中国民族自立于世界民族之林； 4.太平天国农民战争的历史意义？（过） 它沉重打击了封建统治阶级，强烈撼动了清政府的统治根基。它坚持了14年之久，革命的势力先后扩展到18个省，其规模之大，时间之长，影响之深，是以往历次农民起义都比不上的。 它是中国旧式农民战争的最高峰。它把千百年来农民对拥有土地的渴望，在《天朝田亩制度》中比较完整的表达了出来。《资政新篇》则是中国近代史上第一个比较系统的发展资本主义的方案。 它冲击了孔子和儒家经典的正统权威。在一定程度上削弱了封建统治的精神支柱。 它有力的打击了外国侵略势力。 它和亚洲其他国家的民族解放运动汇合在一起，冲击了西方殖民主义在亚洲的统治。 5.简述太平天国定都天京后，先后颁布的两个重要纲领及其特点？（过） 1853年冬颁布《天朝田亩制度》，这是一个以解决农民土地问题为中心的比较完整的社会改革方案，最能体现太平天国社会理想； 太平天国后期提出《资政新篇》，这是一个带有鲜明资本主义色彩的改革与建设方案； 6.太平天国农民战争失败的主要原因？（过） 缺乏先进阶级的领导（根本原因）。农民阶级不是新的生产力和生产关系的代表，带有小生产者所固有的阶级局限性； 没有科学理论的指导，它是以拜上帝教来发动、组织群众的，但是拜上帝教教义不是科学的思想理论； 对外国资本主义列强缺乏理性的认识，笼统地把信奉上帝的西方人都视为“洋兄弟”； 7.资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战（过） 要不要变法； 要不要兴民权、设议院、实行君主立宪； 要不要废八股、改科举和兴学堂； 8.资产阶级革命派同改良派论战的主要内容及重要意义？（过） 1905年至1907年，孙中山为代表的革命派和以康有为为代表的改良派，分别以《民报》和《新民从报》为主要舆论阵地展开论战 要不要以革命手段推翻清政府，论战焦点； 要不要推翻帝制，实现共和； 要不要社会革命； 论战以革命派的胜利告终； 重要意义： 划清了革命与改良的界限； 是资产阶级民主思想和三民主义思想得到了更广泛的传播； 9.近代中国工人阶级的特点？（过） 深受帝国主义、封建势力和资产阶级三重压迫和剥削，革命性最强； 人数虽少，但相对集中，便于形成革命的力量和传播先进的思想； 主要由破产农民和家庭手工业者转化而来，同农民有着天然关系，便于结成工农联盟； 10.洋务运动的指导思想和举办的洋务事业是什么？（过） 洋务运动的指导思想是“中学为体，西学为用”。 兴办近代企业，最早兴办的是军用工业，70年代开始兴办民用企业； 建立新式海陆军； 创办新式学堂、派遣留学生； 11.洋务运动失败的主要原因？（过） 洋务运动具有封建性； 洋务运动对西方列强具有依赖性，企图仰仗西方列强来达到“求强”、“求富”的目的； 洋务企业的管理具有腐朽性，对企业采取的是封建衙门式的管理方法； 洋务运动的指导思想是“中学为体，西学为用”，只注重西法练兵和办企业，而不去改变落后的政治制度； 12.洋务运动的历史作用？（过） 促进了中国早期工业和民族资本主义的发展； 开辟了一批新式学堂，派出了最早的留学生，成为中国近代教育的开端； 传播了新知识，打开了人们的眼界； 引起了社会风气和价值观念的改变； 资产阶级思想与封建主义思想第一次正面交锋是维新派和守旧派的论战 论战主要问题： 要不要变法； 要不要兴民权、设议院、实行君主立宪； 要不要废八股、改科举和兴学堂； 13.戊戌变法的主要内容： 改革政府机构，裁撤冗官，任用维新人士； 鼓励私人兴办工矿企业； 开办新式学堂吸引人才，翻译西方书籍，传播新思想； 创办报刊，开放言论； 训练新式陆军海军同时规定，科举考试废除八股文，取消多余的衙门和无用的官职； 14.戊戌变法的意义：（过） 是一次具有爱国救亡意义的变法维新运动， 是一场资产阶级性质的的政治改革，也是一次思想启蒙运动， 这次变法促进了思想解放，并且对思想文化的发展和促进中国近代社会的进步起了重要推动作用。 15.戊戌失败原因：（过） 根本原因 资产阶级维新派力量过于弱小，即资产阶级的软弱性；慈禧所代表的顽固派掌握实权，实力强大。 直接原因 缺乏正确的理论指导； 缺乏坚强的组织领导； 脱离广大人民群众，只寄希望于没有实权的皇帝和极少数的官僚； 对帝国主义抱有不切实际的幻想； 16.辛亥革命的历史局限性是什么？（过） 没有提出彻底的反对帝国主义和反封建主义的革命纲领； 没有充分发动和依靠民众； 没有建立坚强的革命政党； 17.辛亥革命的历史意义：（过） 1）推翻了清王朝，结束了中国数千年的君主专制统治； 2）创建了中华民国； 3）颁布了中国历史上第一部具有资产阶级共和国宪法性质的《临时约法》，使人民获得了一些民主权利； 4）开创了完全意义上的近代民族民主革命； 5）给中国先进分子以巨大的刺激和深刻的启发，使他们觉悟到必须另谋新的救国救民之路。 局限性：辛亥革命以同旧势力的妥协而告终，没有从根本上改变中国半殖民地半封建社会的性质。 18.1912年建立的南京临时革命政府是一个资产阶级共和国性质的革命政权？ 在人员构成上，资产阶级革命派控制着政权； 其实行的各项政策措施，集中体现了中国民族资产阶级的愿望和利益； 临时参议院颁布《中华民国临时约法》，是中国历史上第一步具有资产阶级共和国宪法性质的大点； 19.新文化运动的历史意义？ 它是资产阶级民主主义的新文化同封建主义旧文化的斗争，是辛亥革命的思想文化领域的延续，沉重打击了封建专制主义； 它大力宣传了民主和科学，启发了人民的理智和民主主义觉悟，将人们从封建专制所造成的蒙昧中解放出来，开启了思想解放的潮流； 它为中国先进分子接受马克思主义做了准备，为以五四运动为开端的中国新民主主义革命创造了思想文化上的条件； 20.同盟会在日本东京成立： 创办机关刊物《民报》； 提出“驱除鞑虏，恢复中华，创立民国，平均地权”的纲领； 并概括为“民族”、“民权”、“民生”的“三民主义”； 这是近代中国第一个领导资产阶级革命的全国性政党，它的成立标志着中国资产阶级民主革命进人到一个新的阶段。 21.简述孙中山三民主义学说的主要内容及其意义？ 民主主义，包括“驱除鞑虏，恢复中华”。一是以革命手段推翻清王朝，二是变“次殖民地”的中国为独立的中国； 民权主义，“创立民国”，指推翻封建君主专制制度，建立资产阶级民主共和国； 民生主义，“平均地权”，基本方案是：核定地价，按价征税，涨价归公，按价售卖； 意义： 这是一个比较完备的民主主义的革命纲领，推动了革命思想的传播和革命运动的发展； 22.五四运动的历史特点及意义？（过） 五四运动是中国近代史上一次彻底反帝国反封建的革命运动，是一场真正群众性的革命运动； 促进了马克思主义在中国的广泛传播; 促进马克思主义同中国工人运动的结合; 五四运动是中国新民主主义革命的开端; 无产阶级逐渐替代资产阶级成为近代中国民族民主革命的领导者； 23.八一南昌起义的历史意义是什么？（过） 打响武装反抗国民党反动统治的第一枪; 它成为共产党独立领导革命战争、创建人民军队和武装夺取政权的伟大开端； 揭开土地革命战争的序幕； 体现了中国共产党人为实行中国人民的根本利益和中国民族的解放事业而前赴后继的革命精神 24.中国共产党成立的历史意义？ 它标志着中国革命终于有了一个坚强的领导核心，有了可依赖的组织者和领导者； 中国革命从此有了科学的指导思想，中国共产党以马克思列宁主义基本原理观察和分析中国的问题，为中国指明了斗争目标、革命前途和胜利之路； 它沟通了中国革命与世界革命的联系，把中华民族的解放运动同世界无产阶级社会主义革命运动相联结，是中国革命有了新的前途； 自从有了中国共产党，中国革命的革命就焕然一新了； 25.毛泽东领导的湘赣边界秋收起义的特点？ 它放弃了“左派国民党”运动的旗号，公开打出了“工农革命军”的气质； 它不仅是军队的行动，而且有数量众多的工农武装参加； 26.三湾改编的主要内容？ 将原有的一个师缩编为一个团； 在部队中建立共产党各级组织，将党的支部建在连上； 成立各级士兵委员会，部队内部实行民主管理； 27.1926年至1927年，北伐战争直接打击的目标和战略方针？ 北伐的直接目标是打倒帝国主义支持的北洋军阀：吴佩孚、孙传芳、张作霖； 北伐的战略方针：首先进军两湖，消灭吴佩孚，然后引兵东向，消灭孙传芳，最后，北上解决张作霖； 28.八七会议的主要内容是什么？ 彻底清算大革命后期陈独秀右倾机会主义错误； 选出了以瞿秋白为首的中央临时政治局； 确立了土地革命和武装斗争的方针； 毛泽东提出了“须知政权是由枪杆子中取得的”重要理论； 29.遵义会议集中解决的主要问题及其意义？（过） 遵义会议集中解决了当时具有决定意义的军事和组织问题； 意义： 开始确立了以毛泽东为代表的马克思主义正确线路在党中央的领导地位； 在极其危机的情况下挽救了中国共产党、挽救了中国工农红军、挽救了中国革命； 成为中国共产党历史上一个生死攸关的转折点； 为党和革命事业转危为安、不断打开新局面提供了最重要的保证； 30.洛川会议指定的《抗日救国十条纲领》的主要内容是什么？ 要打倒日本帝国主义，关键在于实行全国军事总动员、全国人民的总动员，使抗战成为全面的全民族的抗战； 必须改革政治机构，给人民以充分的抗日民主权利，并适当改善工农大众的生活； 必须坚持统一战线中无产阶级的领导权，在敌后放手发动独立自主的山地游击战争，在国统区放手发动抗日的群众运动； 31.井冈山根据地创建的历史意义？ 它点燃了“工农武装割据”的星星之火，为共产党领导的其他各地的起义武装树立了榜样； 它从实践上开辟了一条在敌我力量十分悬殊的情况下，共产党深入农村保存和发展革命力量的正确道路； 32.中国工农红军长征胜利的历史意义？ 中国工农红军的长征是一部伟大的革命英雄主义史诗。它粉碎了国民党“围剿”红军、消灭革命力量的企图，是中国革命转危为安的关键 通过长征，中国革命的大本营放在了西北，这位迎接中国人民抗日救亡的新高潮准备了条件； 长征保存并锤炼了中国革命的骨干力量，这是党和红军极为宝贵的精华； 长征播撒了革命的火种，它为沿途的人民群众宣布，只有在中国共产党的领导下，中国各族人民才能翻身得解放； 中国共产党人和红军将士用生命和热血铸就了伟大的长征精神； 33.中国革命统一战线中的两个联盟及其关系是什么？ 一个是劳动者的联盟，主要是工人、农民和城市小资产阶级的联盟，这是最基本的、重要的； 一个是劳动者与非劳动者的联盟，主要是劳动者民族资产阶级的联盟，包括一部分大资产阶级的暂时联盟，这是辅助的、重要的； 34.中国共产党在全民族抗战中的中流砥柱作用？ 中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键。中国共产党自成立之日起就把实现中华民族伟大复兴作为自己的历史使命。 在抗日战争中，中国共产党坚持全面抗战路线，制定了正确战略策略，开辟广大敌后战场，成为坚持抗战的中坚力量；中国共产党以自己的政治主张，坚定意志、模范行动，支撑起全民族救亡图存的希望，引领着夺取战争胜利的正确方向。成为夺取战争胜利的民族先锋。 35.中国人民抗日战争胜利的主要原因？ 以爱国主义为核心的伟大民族精神是中国人民抗日战争胜利的决定因素； 中国共产党的中流砥柱作用是中国人民抗日战争胜利的关键； 全民族抗战是中国人民抗日战争胜利的主要法宝； 世界所有爱好和平和正义的国家和人民、国际组织以及各种反法西斯力量的同情和支持，是中国人民抗日战争胜利的国际条件； 36.中国人民抗日战争在世界反法西斯战争中的地位？ 中国人民抗日战争是世界反法西斯战争的东方主战场。中国抗战开始最早，持续时间最长，牵制和抗击了日本军国主义的主要兵力，对日本侵略者的彻底覆灭起到了决定性作用； 中国人民的持久抗战，遏制了日本的“北进”计划，迟滞了日本的“南进”步伐，达达减轻了其他战场的压力，为盟国军队完成战略转折和实施战略反攻创造了有利条件； 中国作为亚太地区盟军对日作战的重要后方基地，为盟军提供了大量战略物资和军事情报，中国军队出锅作战，不近打击了日本，还对盟军给与了实际支援； 中国为战胜法西斯、维护世界和平付出了巨大的牺牲，做出了伟大的贡献； 37.中国共产党抗日民族统一战线的策略总方针是什么？ 发展进步势力，进步势力主要指工人、农民和城市小资产阶级； 争取中间势力，中间势力主要指民族资产阶级、开明绅士和地方实力派； 孤立顽固势力，顽固势力主要指大地主大资产阶级的抗日拍，以蒋介石集团为代表的国民党亲英美派； 38.中国新民主主义革命胜利的基本经验？ 建立广泛的统一战线。这是坚持和发展革命的政治基础。统一战线中存在着两个联盟：一个是劳动者的联盟，一个是劳动者与非劳动者的联盟，必 须坚持依靠第一个联盟，争取建立和夸大第二个联盟； 坚持革命的武装斗争，中国革命只能以长期的武装斗争作为主要形式：中国革命必须走农村包围城市、武装夺取政权的道路；必须建立一直党绝对 领导下的新式人民军队； 加强共产党自身的建设，着重从思想上建党：培育和发扬理论与实际相结合、密切联系群众和自我批评的作风；成为统一战线和武装斗争这两个武 器以实行对敌冲锋陷阵的英勇战士，成为中国各族人民拥戴的领导核心； 39.新民主主义社会的五种经济成分及特点？ 社会主义性质的国营经济； 半社会主义性质的合作社经济； 农民和手工业者的个体经济； 私人资本主义经济； 国家资本主义经济； 特点：既有社会主义因素，又有资本主义因素，本身具有过渡性； 40.在《论持久战》一文中，毛泽东如何阐述抗日战争是持久战，最后胜利属于中国？ 中日双发存在着相互矛盾的四个特点：敌强我弱，敌小我大，敌退步我进步，敌寡助我多助； 一方面，日本是强国，中国是弱国，强国弱国的对比，决定了抗日战争只能是持久战； 一方面，日本是效果，发动的事退步的、野蛮的侵略战争，在国际上失道寡助；而中国是大国，进行的是进步的、正义的反侵略战争，国际上得道 多助； 中国已经有了代表中华民族和中国人民根本利益的共产党及其领导的人民军队和抗日根据地。因此，最后胜利是中国的； 41.毛泽东在《论持久战》中对抗日战争历史进程的阐述。 中国抗日战争将经过战略防御、战略相持、战略反攻三个阶段； 战略相持阶段，时中国抗日战争取得最后胜利的最关键的阶段； 只要坚持持久抗战、坚持抗日民族统一战线，中国将在这个阶段获得转弱为强的力量； 42.简述中国新民主主义革命取得胜利的主要原因？ 一是有了中国工人阶级的先锋队，中国共产党的领导。它以马克思列宁主义基本原理与中国实际相结合的毛泽东思想作为一切工作的指针，制定出符合中国国情和人民利益的纲领、路线、方针和政策；他具有远见，最富有牺牲精神，最坚定，从而赢得了中国人民的衷心拥护； 二是人民群众和各界人士的广泛参加和大力支持。工人、农民、城市小资产阶级群众是民主革命的主要力量；随着斗争的发展，民族资产阶级也逐步向共产党靠拢； 三是国际无产阶级和人民群众的支持； 43.中国共产党在过渡时期总路线的内容及其特点？ 要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、手工业和对资本主义工商业的社会主义改造。 这是社会主义建设同社会主义改造同时并举的总路线，体现了生产力和变革生产关系的有机统一。 44.全国解放战争时期，各民主党派与中国共产党团结合作的重要表现？ 在重庆谈判和政协会议期间，各民主党派作为“第三方面”，同共产党一起反对国民党反动派的内战、独裁政策，为和平民主二共同努力。 在国民党当局撕毁政协协议、发面全面内战后，民主党派中的大多数同共产党保持一致，拒绝参加国民党一手包办的“国民大会”、反对国民党炮制的“宪法” 45.毛泽东提出的社会主义现代化建设的战略目标和步骤？ 社会主义现代化建设的战略目标：把中国建设成为一个具有现代农业、现代工业、现代国防和现代科学强国。 社会主义现代化建设的步骤：采取“两步走”的发展战略， 第一步，建立一个独立的比较完整的工业体系和国民经济体系； 第二步，全面实现农业、工业、国防和科学技术的现代化，是中国的经济走向世界前列； 46.新中国建立初期中国共产党面临的主要问题和考验？ 能不能保卫住人民胜利的成果，巩固新生的人民政权； 能不能战胜严重的经济困难，迅速恢复和发展国民经济； 能不能巩固民族独立，维护国家主权和安全。 能不能经受住执政的考验，继续保持谦虚、谨慎、不骄、不躁的作风和艰苦奋斗的作风。 47.七大召开 大会提出党的政治路线是： 放手发动群众，壮大人民力量，在党的领导下，打败日本侵略者，解放全国人民，建立一个新民主主义的中国。 大会强调毛泽东思想为全党的指导思想。 大会通过的新党章强调了群众路线和党的民主集中制原则。 这次大会是团结的大会，胜利的大会，为抗日战争和夺取新民主主义革命在全国的胜利奠定了基础。 48.毛泽东发表《论十大关系》一文的意义？ 它是以毛泽东为主要代表的中国共产党人开始探索中国自己的社会主义建设道路的标志； 从经济和政治方面提出了新的指导方针，为中共八大（1956年）的召开做了理论准备； 49.四个现代化？ 农业现代化、工业现代化、国防现代化、科学技术现代化 50.简述1979年3月，邓小平提出的四项基本原则及坚持这些原则的重要性？ 坚持社会主义道路，坚持人民民主专政，坚持共产党领导，坚持马克思列宁主义、毛泽东思想； 这是实现四个现代化的根本气体，如果动摇了其中的任何一项，也就动摇了整个社会主义现代化建设事业； 51.简述毛泽东等老一代革命家探索中国社会主义民主政治建设道路的理论贡献？ 第一，要造成一个又有集中又有民权，又有纪律又有自由，又有统一意志，又有个人心情舒畅、生动活泼的政治局面； 第二，把正确处理人民内部矛盾作为国家政治生活的主题，坚持人民民主，团结一切可以团结的力量； 第三，处理好中国共产党同各民主党派的关系，坚持长期共存、互相监督的方针，巩固和扩大爱国统一战线； 第四，切实保障人民当家做主的各项权利，尤其是人民参与国家和社会事务管理的权利； 第五，社会主义法制要保护劳动人民利益，保护社会主义经济基础，保护社会主义生产力； 52.中共八大如何分析我国社会主义改造完成后国内的矛盾和主要任务？ 社会主义改造完成后，我们国内的主要矛盾，已经是人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，已经是人民对于经济文 化迅速发展需要同当前经济文化不能满足人民需要的状况之间的矛盾； 当合全国人民的主要任务是集中力量来解决这个矛盾，把我国尽快从落后的农业国变成先进的工业国； 53.中共八大提出的我国经济建设和政治建设的指导方针时什么？ 在经济建设上，大会坚持既反保守又反冒进，即在综合平衡中稳步前进的方针； 再政治建设上，大会要求继续加强我国的人民民主专政，加强国内各民族的团结，继续巩固人民民主统一战线，逐步指定完善的法律，建立健全的法制； 54.社会主义改造基本完成的意义？ 社会主义改造的基本完成，使社会主义基本经济制度在中国全面地建立起来了，是中国进入社会主义社会的最重要的标志； 社会主义改造是在生产关系方面由私有制到公有制的一场伟大的变革，对生产力的发展支持起到了促进作用； 通过社会主义改造，中国共产党领导全国各族人民创造性地完成了由新民主主义到社会主义的过渡，实现了中国历史上最深刻的社会制度； 55.中国经历的三次历史性巨变？ 第一次是辛亥革命，推翻通知中国几千年的君主专制制度； 第二次是中华人民共和国的成立和社会主义制度的建立； 第三次是改革开放，为实现社会主义现代化而奋斗； 56.我国农村社会主义改造的过渡性经济组织形式以及其性质是什么？ 第一是互助组，这是具有社会主义萌芽性质的经济组织； 第二是初级农业生产合作社，这是具有半社会主义性质的经济组织； 第三是高级农村生产合作社，这是具有社会主义性质的经济组织； 57.“三个主体，三个补充”的内容是什么？ 国家经营和集体经营为主体，一定数量的个体经营为补充； 计划生产是主体，一定范围的自由生产为补充； 国家市场是主题，一定范围的自由市场为补充； 58.中共十三大指定的社会主义现代化建设“三步走”的战略部署是什么？ 第一步，实现国民生产总值比1980年翻一番，解决人民的温饱问题； 第二步，到20世纪末，使国民生产总值再增长一倍，人民生产达到小康水平； 第三步，到21世纪中叶，人均国民生产总值达到中等发达国家水平，人民生活比较富裕，基本实现现代化； 60.一二九运动及其历史意义是什么？ 1935年12月9日，在中国共产党救亡图存、全民抗战的号召和中共北平临时工作委员会的领导下，北平学生举行声势浩大的抗日游戏，遭到国民党军警镇压。 一二九运动打击了日本帝国主义侵略中国并吞并华北的计划，促进了中华民族的觉醒，标志着中国人民抗日救亡运动新高潮的到来。 在20世纪30年代后期和40年代前期，毛泽东撰写了《〈共产党人〉发刊词》、《中国革命和中国共产党》、《新民主主义论》等一批重要的理论著作。新民主主义理论的系统阐明，标志着毛泽东思想得到多方面展开而达到成熟。1937年夏，毛泽东在延安抗日军政大学讲授《实践论》、《矛盾论》，科学地阐明了党的马克思主义的思想路线。平型关大捷 八路军出师以来打的第一个大胜仗 中共一大，标志中国共产党成立；纲领是：革命军队必须与无产阶级一起推翻资本家阶级的政权；确定党的根本政治目的是实行社会革命。中共二大，制定反帝反封建的民主革命纲领；中共三大，决定同国民党合作，建立革命统一战线；国民党一大，标志着第一次国共合作的正式形成；形成了以广州为中心的反对帝国主义和封建军阀的革命新局面；中共四大，通过了《对于民族革命运动之议决案》，陈独秀当选为中央总书记兼中央组织部主任，彭述之任中央宣传部主任，张国焘任中央工农部主任，蔡和森、瞿秋白任中央宣传部委员；中共五大，大会通过了《政治形势与党的任务议决案》《土地问题议决案》等；“八七会议”，在汉口召开，彻底清算了大革命后期的陈独秀右倾机会主义错误，确定了土地革命和武装反抗国民党反动统治的总方针，并选出了以瞿秋白为首的中央临时政治局。中共六届六中全会，毛提出了”马克思主义的中国化”这个命题；中共七届二中全会，规定政治、经济、外交基本政策；农业国转变工业国、新民主主义社会转变社会主义社会方向；提出“两个务必”要求；中共七届三中全会，毛做《为争取国家财政经济状况的基本好转而斗争的》报告，创建三个条件，土地改革的完成，现有工商业的调整，国家机构所需经费的大量节减；中共七大，通过了新的党章，确定以马克思列宁主义与中国革命实践相统一的毛泽东思想作为全党一切工作的指针；中共八大，探索建设社会主义道路的开端。陈提“三个主体，三个补充”思想。党和人民主要任务是把我国从落后的农业国变为先进的的工业国；中共十一届三中全会，这是建国以来党的历史上具有深远意义的转折，是改革开放的开端，从此我国进入社会主义现代化建设的新时期。中共十二大，邓小平提出建设有中国特色的社会主义，全国人大颁布了第四部《中华人民共和国宪法》。中共十三大，邓阐明了社会主义初级阶段理论，提出了党在社会主义初级阶段的“一个中心、两个基本点”基本路线，即以经济建设为中心，坚持四项基本原则，坚持改革开放。制定了下一步经济体制改革和政治体制改革的基本任务和奋斗目标；中共十四大，提出建立社会主义市场经济体制，确立了邓小平理论在全党的指导地位，形成了以江泽民为核心的第三代领导集体。中共十五大，把邓小平理论写入党章，确立为党的指导思想。通过了关于《中国共产党章程修正案》的决议；中共十六届四中全会，提出的战略任务是构建社会主义和谐社会；中共十七大，明确指出高举中国特色社会主义伟大旗帜最根本的是要坚持中国特色社会主义道路、中国特色社会主义理论体制；中共十八届三中全会，发表《关于全面深化改革若干重大问题的决定》，提出了全面深化改革的知道思想、重要方针、目标任务、政治举措，明确了全面深化改革的总目标、时间表、路线图，成为知道新形势下全面深化改革的纲领性文件；中共十八大,进入全面建成小康社会决定性阶段召开的一次十分重要的大会。审议并通过《中国共产党章程（修正案）》中共十九大,作了题为《决胜全面建成小康社会 夺取新时代中国特色社会主义伟大胜利》的报告。主题是：不忘初心，牢记使命，高举中国特色社会主义伟大旗帜，决胜全面建成小康社会，夺取新时代中国特色社会主义伟大胜利，为实现中华民族伟大复兴的中国梦不懈奋斗。是在全面建成小康社会决胜阶段、中国特色社会主义发展关键时期召开的一次十分重要的大会。","link":"/2020/10/16/%E5%8E%86%E5%8F%B2%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%97%A7%EF%BC%89/"},{"title":"14 activity启动流程","text":"好吧，终于要开始讲解Activity的启动流程了，Activity的启动流程相对复杂一下，涉及到了Activity中的生命周期方法，涉及到了Android体系的CS模式，涉及到了Android中进程通讯Binder机制等等， 首先介绍一下Activity，这里引用一下Android guide中对Activity的介绍： An activity represents a single screen with a user interface. For example, an email application might have one activity that shows a list of new emails, another activity to compose an email, and another activity for reading emails. Although the activities work together to form a cohesive user experience in the email application, each one is independent of the others. As such, a different application can start any one of these activities (if the email application allows it). For example, a camera application can start the activity in the email application that composes new mail, in order for the user to share a picture. 英文不太好，这里就不献丑了，这里介绍的Activity的大概意思就是说，activity在Android系统中代表的就是一个屏幕，一个App就是由许多个不同的Acitivty组成的，并且不同进程之间的Activity是可以相互调用的。 在介绍Activity的启动流程之前，我们先介绍几个概念： Activity的生命周期 protected void onCreate(Bundle savedInstanceState);protected void onRestart();protected void onStart();protected void onResume();protected void onPause();protected void onStop();protected void onDestory();以上为Activity生命周期中的各个时期的回调方法，在不同的方法中我们可以执行不同的逻辑。关于Activity生命周期的详细介绍可以参考： Android activity的生命周期 Activity的启动模式 activity启动时可以设置不同的启动模式，主要是：standrand，singleTop，singleTask，instance等四种启动模式，不同的启动模式在启动Activity时会执行不同的逻辑，系统会按不同的启动模式将Activity存放到不同的activity栈中。关于Activity启动模式的详细介绍，可以参考： Android任务和返回栈完全解析 Activity的启动进程 在Manifest.xml中定义Activity的时候，Activity默认是属于进程名称为包名的进程的，当然这时候是可以指定Activity的启动进程，所以在Activity启动时首先会检测当前Activity所属的进程是否已经启动，若进程没有启动，则首先会启动该进程，并在该进程启动之后才会执行Activity的启动过程。 Intent启动Activity的方式 Intent启动Activity分为两种，显示启动和隐士启动，显示启动就是在初始化Intent对象的时候直接引用需要启动的Activity的字节码，显示引用的好处就是可以直接告诉Intent对象启动的Activity对象不需要执行intent filter索引需要启动哪一个Activity，但是显示引用不能启动其他进程的Activity对象，因为无法获取其他进程的Activity对象的字节码，而隐式启动则可以通过配置Intent Filter启动其他进程的Activity对象，因此在应用内，我们一般都是使用显示启动的方式启动Activity，而如果需要启动其他应用的Activity时，一般使用隐式启动的方式。 Android Framework层的CS模式通过前几篇文章的介绍我们知道android系统在启动过程中会执行这样的逻辑： Zygote进程 --&gt; SystemServer进程 --&gt; 各种系统服务 --&gt; 应用进程 在Actvity启动过程中，其实是应用进程与SystemServer进程相互配合启动Activity的过程，其中应用进程主要用于执行具体的Activity的启动过程，回调生命周期方法等操作，而SystemServer进程则主要是调用其中的各种服务，将Activity保存在栈中，协调各种系统资源等操作。 Android系统进程间通讯Binder机制Android系统存了Zygote进程和SystemServer进程以及各种应用进程等，为了能够实现各种进程之间的通讯，Android系统采用了自己的进程间通讯方式Binder机制。其中主要涉及到了四种角色：Binder Client，Binder Server，Binder Manager， Binder driver。各种角色之间的关系可以参考下面这张图的介绍： 好吧，前面我们介绍了一些Activity启动过程中需要的相关知识点，下面我们开始Activity启动流程的讲解。。。。 还记得前面我们讲过的Launcher启动流程么？可以参考：android源码解析之（十）–&gt;Launcher启动流程在这篇文章中我们说Launcher启动之后会将各个应用包名和icon与app name保存起来，然后执行icon的点击事件的时候调用startActivity方法： 123456789101112131415161718192021222324@Override protected void onListItemClick(ListView l, View v, int position, long id) { Intent intent = intentForPosition(position); startActivity(intent); }protected Intent intentForPosition(int position) { ActivityAdapter adapter = (ActivityAdapter) mAdapter; return adapter.intentForPosition(position); }public Intent intentForPosition(int position) { if (mActivitiesList == null) { return null; } Intent intent = new Intent(mIntent); ListItem item = mActivitiesList.get(position); intent.setClassName(item.packageName, item.className); if (item.extras != null) { intent.putExtras(item.extras); } return intent; } 可以发现，我们在启动Activity的时候，执行的逻辑就是创建一个Intent对象，然后初始化Intent对象，使用隐式启动的方式启动该Acvitity，这里为什么不能使用显示启动的方式呢？ 这是因为Launcher程序启动的Activity一般都是启动一个新的应用进程，该进程与Launcher进程不是在同一个进程中，所以也就无法引用到启动的Activity字节码，自然也就无法启动该Activity了。 继续，我们查看startActivity方法的具体实现： 一:开始请求执行启动Activity MyActivity.startActivity()Activity.startActivity()Activity.startActivityForResultInstrumentation.execStartActivtyActivityManagerNative.getDefault().startActivityAsUser() 在我们的Activity中调用startActivity方法，会执行Activity中的startActivity1234@Override public void startActivity(Intent intent) { this.startActivity(intent, null); }然后在Activity中的startActivity方法体里调用了startActivity的重载方法，这里我们看一下其重载方法的实现： 12345678910@Override public void startActivity(Intent intent, @Nullable Bundle options) { if (options != null) { startActivityForResult(intent, -1, options); } else { // Note we want to go through this call for compatibility with // applications that may have overridden the method. startActivityForResult(intent, -1); } } 由于在上一步骤中我们传递的Bunde对象为空，所以这里我们执行的是else分支的逻辑，所以这里调用了startActivityForResult方法，并且传递的参数为intent和-1. 注意：通过这里的代码我们可以发现，其实我们在Activity中调用startActivity的内部也是调用的startActivityForResult的。那么为什么调用startActivityForResult可以在Activity中回调onActivityResult而调用startActivity则不可以呢？可以发现其主要的区别是调用startActivity内部调用startActivityForResult传递的传输requestCode值为-1，也就是说我们在Activity调用startActivityForResult的时候传递的requestCode值为-1的话，那么onActivityResult是不起作用的。实际上，经测试requestCode的值小于0的时候都是不起作用的，所以当我们调用startActivityForResult的时候需要注意这一点。 好吧，我们继续往下看，startActivityForResult方法的具体实现： 12345678910111213141516171819202122232425262728293031323334public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode &gt;= 0) { // If this start is requesting a result, we can avoid making // the activity visible until the result is received. Setting // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the // activity hidden during this time, to avoid flickering. // This can only be done when a result is requested because // that guarantees we will get information back when the // activity is finished, no matter what happens to it. mStartedActivity = true; } cancelInputsAndStartExitTransition(options); // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } } 可以发现由于我们是第一次启动Activity，所以这里的mParent为空，所以会执行if分之，然后调用mInstrumentation.execStartActivity方法，并且这里需要注意的是，有一个判断逻辑： 123if (requestCode &gt;= 0) { mStartedActivity = true;} 通过注释也验证了我们刚刚的说法即，调用startActivityForResult的时候只有requestCode的值大于等于0，onActivityResult才会被回调。 然后我们看一下mInstrumentation.execStartActivity方法的实现。在查看execStartActivity方法之前，我们需要对mInstrumentation对象有一个了解？什么是Instrumentation？Instrumentation是android系统中启动Activity的一个实际操作类，也就是说Activity在应用进程端的启动实际上就是Instrumentation执行的，那么为什么说是在应用进程端的启动呢？实际上acitivty的启动分为应用进程端的启动和SystemServer服务进程端的启动的，多个应用进程相互配合最终完成了Activity在系统中的启动的，而在应用进程端的启动实际的操作类就是Intrumentation来执行的，可能还是有点绕口，没关系，随着我们慢慢的解析大家就会对Instrumentation的认识逐渐加深的。 可以发现execStartActivity方法传递的几个参数：this，为启动Activity的对象；contextThread，为Binder对象，是主进程的context对象；token，也是一个Binder对象，指向了服务端一个ActivityRecord对象；target，为启动的Activity；intent，启动的Intent对象；requestCode，请求码；options，参数； 这样就调用了Imstrument.execStartActivity方法了： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { ... try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { throw new RuntimeException(&quot;Failure from system&quot;, e); } return null; } 我们发现在这个方法中主要调用ActivityManagerNative.getDefault().startActivity方法，那么ActivityManagerNative又是个什么鬼呢？查看一下getDefault()对象的实现： 123static public IActivityManager getDefault() { return gDefault.get(); } 好吧，相当之简单直接返回的是gDefault.get()，那么gDefault又是什么呢？ 12345678910111213private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() { protected IActivityManager create() { IBinder b = ServiceManager.getService(&quot;activity&quot;); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service binder = &quot; + b); } IActivityManager am = asInterface(b); if (false) { Log.v(&quot;ActivityManager&quot;, &quot;default service = &quot; + am); } return am; } }; 可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现： 123456789101112static public IActivityManager asInterface(IBinder obj) { if (obj == null) { return null; } IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ActivityManagerProxy(obj); } 好吧，最后直接返回一个ActivityManagerProxy对象，而ActivityManagerProxy继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的ActivityManagerProxy和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示：Binder接口 –&gt; ActivityManagerNative/ActivityManagerProxy –&gt; ActivityManagerService； 这样，ActivityManagerNative与ActivityManagerProxy相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不同等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。 好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。 继续往下卡，我们调用的是： 12345int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); 这里通过我们刚刚的分析，ActivityManagerNative.getDefault()方法会返回一个ActivityManagerProxy对象，那么我们看一下ActivityManagerProxy对象的startActivity方法： 123456789101112131415161718192021222324252627282930313233public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) { data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); } else { data.writeInt(0); } if (options != null) { data.writeInt(1); options.writeToParcel(data, 0); } else { data.writeInt(0); } mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; } 这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。 以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。 二：ActivityManagerService接收启动Activity的请求 ActivityManagerService.startActivity()ActvityiManagerService.startActivityAsUser()ActivityStackSupervisor.startActivityMayWait()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.startActivityUncheckedLocked()ActivityStackSupervisor.startActivityLocked()ActivityStackSupervisor.resumeTopActivitiesLocked()ActivityStackSupervisor.resumeTopActivityInnerLocked() 好吧，代码量比较大，慢慢看，首先看一下ActivityManagerService.startActivity的具体实现； 12345678@Override public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) { return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId()); } 可以看到，该方法并没有实现什么逻辑，直接调用了startActivityAsUser方法，我们继续看一下startActivityAsUser方法的实现： 123456789101112@Override public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) { enforceNotIsolatedCaller(&quot;startActivity&quot;); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, &quot;startActivity&quot;, null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null); } 可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，下面我们来看一下这个方法的具体实现： 1234567891011121314151617final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) { ... int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); ... return res; } 这个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法： 1234567891011121314151617final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) { int err = ActivityManager.START_SUCCESS; ... err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); ... return err; } 这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法： 12345678910111213final int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) { ... ActivityStack.logStartActivity(EventLogTags.AM_CREATE_ACTIVITY, r, r.task); targetStack.mLastPausedActivity = null; targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) { // Don't set focus on an activity that's going to the back. mService.setFocusedActivityLocked(r, &quot;startedActivity&quot;); } return ActivityManager.START_SUCCESS; } startActivityUncheckedLocked方法中只要执行了不同启动模式不同栈的处理，并最后调用了startActivityLocked的重载方法： 1234567final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) { ... if (doResume) { mStackSupervisor.resumeTopActivitiesLocked(this, r, options); } } 这个startActivityLocked方法主要执行初始化了windowManager服务，然后调用resumeTopActivitiesLocked方法： 1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) { if (targetStack == null) { targetStack = mFocusedStack; } // Do targetStack first. boolean result = false; if (isFrontStack(targetStack)) { result = targetStack.resumeTopActivityLocked(target, targetOptions); } for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) { // Already started above. continue; } if (isFrontStack(stack)) { stack.resumeTopActivityLocked(null); } } } return result; } 可以发现经过循环逻辑判断之后，最终调用了resumeTopActivityLocked方法： 123final boolean resumeTopActivityLocked(ActivityRecord prev) { return resumeTopActivityLocked(prev, null); } 然后调用： 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) { if (mStackSupervisor.inResumeTopActivity) { // Don't even start recursing. return false; } boolean result = false; try { // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) { mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); } result = resumeTopActivityInnerLocked(prev, options); } finally { mStackSupervisor.inResumeTopActivity = false; } return result; } 继续调用resumeTopActivityInnerLocked方法： 12345678910private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) { ... if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); } ... return true; } 经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。 三：执行栈顶Activity的onPause方法 ActivityStack.startPausingLocked()IApplicationThread.schudulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage();ActivityThread.H.handleMessage()ActivityThread.handlePauseActivity()ActivityThread.performPauseActivity()Activity.performPause()Activity.onPause()ActivityManagerNative.getDefault().activityPaused(token)ActivityManagerService.activityPaused()ActivityStack.activityPausedLocked()ActivityStack.completePauseLocked()ActivityStack.resumeTopActivitiesLocked()ActivityStack.resumeTopActivityLocked()ActivityStack.resumeTopActivityInnerLocked()ActivityStack.startSpecificActivityLocked 好吧，方法比较多也比较乱，首先来看startPausingLocked方法： 1234567891011121314151617181920212223242526final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) { ... if (prev.app != null &amp;&amp; prev.app.thread != null) { if (DEBUG_PAUSE) Slog.v(TAG_PAUSE, &quot;Enqueueing pending pause: &quot; + prev); try { EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); } catch (Exception e) { // Ignore exception, if process died other code will cleanup. Slog.w(TAG, &quot;Exception thrown during pause&quot;, e); mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } } else { mPausingActivity = null; mLastPausedActivity = null; mLastNoHistoryActivity = null; } ... } 可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。 这里的ApplicationThread可以和ActivityManagerNative对于一下：通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯 然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现： 12345678public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? 1 : 0) | (dontReport ? 2 : 0), configChanges); } 发送了PAUSE_ACTIVITY_FINISHING消息，然后看一下sendMessage的实现方法： 123private void sendMessage(int what, Object obj, int arg1, int arg2) { sendMessage(what, obj, arg1, arg2, false); } 调用了其重载方法： 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) { if (DEBUG_MESSAGES) Slog.v( TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what) + &quot;: &quot; + arg1 + &quot; / &quot; + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) { msg.setAsynchronous(true); } mH.sendMessage(msg); } 最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现： 123456789101112public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { ... case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityPause&quot;); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ...} 可以发现其调用了handlePauseActivity方法： 123456789101112131415161718192021222324252627private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) { ActivityClientRecord r = mActivities.get(token); if (r != null) { //Slog.v(TAG, &quot;userLeaving=&quot; + userLeaving + &quot; handling pause of &quot; + r); if (userLeaving) { performUserLeavingActivity(r); } r.activity.mConfigChangeFlags |= configChanges; performPauseActivity(token, finished, r.isPreHoneycomb()); // Make sure any pending writes are now committed. if (r.isPreHoneycomb()) { QueuedWork.waitToFinish(); } // Tell the activity manager we have paused. if (!dontReport) { try { ActivityManagerNative.getDefault().activityPaused(token); } catch (RemoteException ex) { } } mSomeActivitiesChanged = true; } } 然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现： 12345final Bundle performPauseActivity(IBinder token, boolean finished, boolean saveState) { ActivityClientRecord r = mActivities.get(token); return r != null ? performPauseActivity(r, finished, saveState) : null; } 然后调用其重载方法： 12345678final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState) { ... mInstrumentation.callActivityOnPause(r.activity); ... return !r.activity.mFinished &amp;&amp; saveState ? r.state : null; } 这样回到了mInstrumentation的callActivityOnPuase方法： 123public void callActivityOnPause(Activity activity) { activity.performPause(); } 呵呵，原来最终回调到了Activity的performPause方法： 1234567891011121314final void performPause() { mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onPause()&quot;); } mResumed = false; } 终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。 然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。 1234567891011@Override public final void activityPaused(IBinder token) { final long origId = Binder.clearCallingIdentity(); synchronized(this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { stack.activityPausedLocked(token, false); } } Binder.restoreCallingIdentity(origId); } 可以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，继续看一下activityPausedLocked方法的实现： 1234567final void activityPausedLocked(IBinder token, boolean timeout) { ... if (DEBUG_STATES) Slog.v(TAG_STATES, &quot;Moving to PAUSED: &quot; + r + (timeout ? &quot; (due to timeout)&quot; : &quot; (pause complete)&quot;)); completePauseLocked(true); ... } 然后执行了completePauseLocked方法： 12345678910111213141516171819202122private void completePauseLocked(boolean resumeNext) { ... if (resumeNext) { final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDown()) { mStackSupervisor.resumeTopActivitiesLocked(topStack, prev, null); } else { mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(null); if (top == null || (prev != null &amp;&amp; top != prev)) { // If there are no more activities available to run, // do resume anyway to start something. Also if the top // activity on the stack is not the just paused activity, // we need to go ahead and resume it to ensure we complete // an in-flight app switch. mStackSupervisor.resumeTopActivitiesLocked(topStack, null, null); } } } ... } 经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第二步中解析的方法中了，这样经过resumeTopActivitiesLocked –&gt;ActivityStack.resumeTopActivityLocked() –&gt;resumeTopActivityInnerLocked –&gt;startSpecificActivityLocked好吧，我们看一下startSpecificActivityLocked的具体实现： 123456789101112131415161718192021222324252627282930313233void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) { try { if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !&quot;android&quot;.equals(r.info.packageName)) { // Don't add this if it is a platform component that is marked // to run in multiple processes, because this is actually // part of the framework so doesn't make sense to track as a // separate apk in the process. app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); } realStartActivityLocked(r, app, andResume, checkConfig); return; } catch (RemoteException e) { Slog.w(TAG, &quot;Exception when starting activity &quot; + r.intent.getComponent().flattenToShortString(), e); } // If a dead object exception was thrown -- fall through to // restart the application. } mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true); } 可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。 四：启动Activity所属的应用进程 关于如何启动应用进程，前面的一篇文章已经做了介绍，可参考： android源码解析之（十一）–&gt;应用进程启动流程 这里在简单的介绍一下 ActivityManagerService.startProcessLocked()Process.start()ActivityThread.main()ActivityThread.attach()ActivityManagerNative.getDefault().attachApplication()ActivityManagerService.attachApplication() 好吧，首先看一下startProcessLocked()方法的具体实现： 12345private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) { startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */); } 然后回调了其重载的startProcessLocked方法： 123456789101112131415private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ... boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = &quot;android.app.ActivityThread&quot;; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;Start proc: &quot; + app.processName); checkTime(startTime, &quot;startProcess: asking zygote to start proc&quot;); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, &quot;startProcess: returned from zygote!&quot;); ... } 可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名“android.app.ActivityThread”: 123456789101112131415161718192021public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { Log.e(LOG_TAG, &quot;Starting VM process through Zygote failed&quot;); throw new RuntimeException( &quot;Starting VM process through Zygote failed&quot;, ex); } } 然后调用了startViaZygote方法： 123456789101112131415161718private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(Process.class) { ... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); } } 继续查看一下zygoteSendArgsAndGetResult方法的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { /** * See com.android.internal.os.ZygoteInit.readArgumentList() * Presently the wire format to the zygote process is: * a) a count of arguments (argc, in essence) * b) a number of newline-separated argument strings equal to count * * After the zygote process reads these it will write the pid of * the child or -1 on failure, followed by boolean to * indicate whether a wrapper process was used. */ final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); int sz = args.size(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); if (arg.indexOf('\\n') &gt;= 0) { throw new ZygoteStartFailedEx( &quot;embedded newlines not allowed&quot;); } writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); result.pid = inputStream.readInt(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } result.usingWrapper = inputStream.readBoolean(); return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); } } 可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。 为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。 好了，这时候我们看一下ActivityThread的main方法的实现逻辑。 123456789101112131415161718192021222324public static void main(String[] args) { ... Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;); } 在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。 12345678910private void attach(boolean system) { ... final IActivityManager mgr = ActivityManagerNative.getDefault(); try { mgr.attachApplication(mAppThread); } catch (RemoteException ex) { // Ignore } ...} 刚刚我们已经分析过ActivityManagerNative是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的： 123456789@Override public final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); } } 可以发现其回调了attachApplicationLocked方法，我们看一下这个方法的实现逻辑。 12345678910111213141516171819private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { ... // See if the top visible activity is waiting to run in this process... if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; } } ... return true; } 该方法执行了一系列的初始化操作，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了，O(∩_∩)O哈哈~ 五：执行启动Acitivity ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked()IApplicationThread.scheduleLauncherActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()Instrumentation.callActivityOnCreate()Activity.onCreate()ActivityThread.handleResumeActivity()ActivityThread.performResumeActivity()Activity.performResume()Instrumentation.callActivityOnResume()Activity.onResume()ActivityManagerNative.getDefault().activityResumed(token) 首先看一下attachApplicationLocked方法的实现： 1234567891011121314151617181920212223242526272829303132boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) { continue; } ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) { if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) { try { if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; } } } } } if (!didSomething) { ensureActivitiesVisibleLocked(null, 0); } return didSomething; } 可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑： 1234567891011121314final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ... return true; } 可以发现与第三步执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLauncherActivity方法，所以真正执行的是ActivityThread中的scheduleLauncherActivity，所以我们看一下ActivityThread中的scheduleLauncherActivity的实现： 1234567891011121314151617181920212223242526272829303132333435@Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); } 好吧，还是那套逻辑，ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法： 1234567891011121314private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) { Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); } ... } 可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了。。。 12345678910111213141516171819202122232425262728293031323334353637private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { ...Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { if (!mInstrumentation.onException(activity, e)) { throw new RuntimeException( &quot;Unable to instantiate activity &quot; + component + &quot;: &quot; + e.toString(), e); } } ... activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } ... if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } ... return activity; } 可以发现这里我们需要的Activity对象终于是创建出来了，而且他是以反射的机制创建的，现在还不太清楚为啥google要以反射的方式创建Activity，先不看这些，然后在代码中其调用Instrumentation的callActivityOnCreate方法。 123456public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) { prePerformCreate(activity); activity.performCreate(icicle); postPerformCreate(activity); } 然后执行activity的performCreate方法。。。。好吧，都转晕了。。。 12345final void performCreate(Bundle icicle) { onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon(); } O(∩_∩)O哈哈~，第二个生命周期方法出来了，onCreate方法。。。。 在回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart();方法，好吧，看一下他的实现方式： 123456789101112131415final void performStart() { mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStart()&quot;); } mFragments.dispatchStart(); mFragments.reportLoaderStart(); mActivityTransitionState.enterReady(this); } 好吧，还是通过Instrumentation调用callActivityOnStart方法： 123public void callActivityOnStart(Activity activity) { activity.onStart(); } 然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O哈哈~ 还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) { // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; // TODO Push resumeArgs into the activity for consideration ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) { final Activity a = r.activity; if (localLOGV) Slog.v( TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; + a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow + &quot;, finished: &quot; + a.mFinished); final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; // If the window hasn't yet been added to the window manager, // and this guy didn't finish itself or start another activity, // then go ahead and add the window. boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { } } if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } // Get rid of anything left hanging around. cleanUpPendingRemoveWindows(r); // The window is now visible if it has been added, we are not // simply finishing, and we are not starting another activity. if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { r.tmpConfig.setTo(r.newConfig); if (r.overrideConfig != null) { r.tmpConfig.updateFrom(r.overrideConfig); } if (DEBUG_CONFIGURATION) Slog.v(TAG, &quot;Resuming activity &quot; + r.activityInfo.name + &quot; with newConfig &quot; + r.tmpConfig); performConfigurationChanged(r.activity, r.tmpConfig); freeTextLayoutCachesIfNeeded(r.activity.mCurrentConfig.diff(r.tmpConfig)); r.newConfig = null; } if (localLOGV) Slog.v(TAG, &quot;Resuming &quot; + r + &quot; with isForward=&quot; + isForward); WindowManager.LayoutParams l = r.window.getAttributes(); if ((l.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) != forwardBit) { l.softInputMode = (l.softInputMode &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)) | forwardBit; if (r.activity.mVisibleFromClient) { ViewManager wm = a.getWindowManager(); View decor = r.window.getDecorView(); wm.updateViewLayout(decor, l); } } r.activity.mVisibleFromServer = true; mNumVisibleActivities++; if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, &quot;Scheduling idle handler for &quot; + r); Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { } } } else { // If an exception was thrown when trying to resume, then // just end this activity. try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, false); } catch (RemoteException ex) { } } } 可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。 1234567891011121314151617181920212223242526272829303132333435363738394041public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide) { ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, &quot;Performing resume of &quot; + r + &quot; finished=&quot; + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) { if (clearHide) { r.hideForNow = false; r.activity.mStartedActivity = false; } try { r.activity.onStateNotSaved(); r.activity.mFragments.noteStateNotSaved(); if (r.pendingIntents != null) { deliverNewIntents(r, r.pendingIntents); r.pendingIntents = null; } if (r.pendingResults != null) { deliverResults(r, r.pendingResults); r.pendingResults = null; } r.activity.performResume(); EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName()); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to resume activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } } return r; } 在方法体中，最终调用了r.activity.performResume();方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现： 12345final void performResume() { ... mInstrumentation.callActivityOnResume(this); ... } 好吧，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。 1234567891011121314public void callActivityOnResume(Activity activity) { activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) { final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); } } } } O(∩_∩)O哈哈~，第四个生命周期方法出现了，onResume方法。。。 终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有，哈哈，别着急。 有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，咦？对了onStop方法还没回调呢，O(∩_∩)O哈哈~，对了缺少的就是对onStop方法的回调啊。 好吧，具体的逻辑我们下一步再说 六：栈顶Activity执行onStop方法 Looper.myQueue().addIdleHandler(new Idler())Idler.queueIdle()ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.stopActivityLocked()IApplicationThread.scheduleStopActivity()ActivityThread.scheduleStopActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleStopActivity()ActivityThread.performStopActivityInner()ActivityThread.callCallActivityOnSaveInstanceState()Instrumentation.callActivityOnSaveInstanceState()Activity.performSaveInstanceState()Activity.onSaveInstanceState()Activity.performStop()Instrumentation.callActivityOnStop()Activity.onStop() 回到我们的handleResumeActivity方法，在方法体最后有这样的一代码： 1Looper.myQueue().addIdleHandler(new Idler()); 这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现： 1234567891011121314151617181920212223242526272829303132333435363738private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (localLOGV) Slog.v( TAG, &quot;Reporting idle of &quot; + a + &quot; finished=&quot; + (a.activity != null &amp;&amp; a.activity.mFinished)); if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { // Ignore } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } if (stopProfiling) { mProfiler.stopProfiling(); } ensureJitEnabled(); return false; } } 这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法： 123456789101112131415161718192021@Override public final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId); } 然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法： 12345678910111213141516171819202122final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { ... // Stop any activities that are scheduled to do so but have been // waiting for the next one to start. for (int i = 0; i &lt; NS; i++) { r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) { if (r.finishing) { stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); } else { stack.stopActivityLocked(r); } } } ... return r; } 可以发现在其中又调用了ActivityStack.stopActivityLocked方法： 123456789final void stopActivityLocked(ActivityRecord r) { if (DEBUG_SWITCH) Slog.d(TAG_SWITCH, &quot;Stopping: &quot; + r); if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) { ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... } } 好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) { sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); } 然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。 12345private void handleStopActivity(IBinder token, boolean show, int configChanges) { ... performStopActivityInner(r, info, show, true); ... } 然后我们看一下performStopActivityInner的实现逻辑： 1234567891011121314151617181920212223242526private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) { ... // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } if (!keepShown) { try { // Now we are idle. r.activity.performStop(); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.stopped = true; } } } 好吧，看样子在这个方法中执行了两个逻辑，一个是执行Activity的onSaveInstance方法一个是执行Activity的onStop方法，我们先看一下callCallActivityOnSaveInstanceState的执行逻辑： 1234567891011private void callCallActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 好吧，又是通过Instrumentation来执行。。。 1234public void callActivityOnSaveInstanceState(Activity activity, Bundle outState, PersistableBundle outPersistentState) { activity.performSaveInstanceState(outState, outPersistentState); } 又间接调用了Activity的performSaveInstanceState方法： 123456final void performSaveInstanceState(Bundle outState) { onSaveInstanceState(outState); saveManagedDialogs(outState); mActivityTransitionState.saveState(outState); if (DEBUG_LIFECYCLE) Slog.v(TAG, &quot;onSaveInstanceState &quot; + this + &quot;: &quot; + outState); } 呵呵，这里调用到了，我们以前经常会重写的onSaveInstanceState方法。 然后我们看一下performStopActivityInner中调用到的Activity方法的performStop方法： 1234567891011121314151617181920212223242526272829303132333435363738final void performStop() { mDoReportFullyDrawn = false; mFragments.doLoaderStop(mChangingConfigurations /*retain*/); if (!mStopped) { if (mWindow != null) { mWindow.closeAllPanels(); } if (mToken != null &amp;&amp; mParent == null) { WindowManagerGlobal.getInstance().setStoppedState(mToken, true); } mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); if (!mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + mComponent.toShortString() + &quot; did not call through to super.onStop()&quot;); } synchronized (mManagedCursors) { final int N = mManagedCursors.size(); for (int i=0; i&lt;N; i++) { ManagedCursor mc = mManagedCursors.get(i); if (!mc.mReleased) { mc.mCursor.deactivate(); mc.mReleased = true; } } } mStopped = true; } mResumed = false; } 还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。 123public void callActivityOnStop(Activity activity) { activity.onStop(); } O(∩_∩)O哈哈~，最后一个生命周期方法终于出来了，onStop()….. 总结： Activity的启动流程一般是通过调用startActivity或者是startActivityForResult来开始的 startActivity内部也是通过调用startActivityForResult来启动Activity，只不过传递的requestCode小于0 Activity的启动流程涉及到多个进程之间的通讯这里主要是ActivityThread与ActivityManagerService之间的通讯 ActivityThread向ActivityManagerService传递进程间消息通过ActivityManagerNative，ActivityManagerService向ActivityThread进程间传递消息通过IApplicationThread。 ActivityManagerService接收到应用进程创建Activity的请求之后会执行初始化操作，解析启动模式，保存请求信息等一系列操作。 ActivityManagerService保存完请求信息之后会将当前系统栈顶的Activity执行onPause操作，并且IApplication进程间通讯告诉应用程序继承执行当前栈顶的Activity的onPause方法； ActivityThread接收到SystemServer的消息之后会统一交个自身定义的Handler对象处理分发； ActivityThread执行完栈顶的Activity的onPause方法之后会通过ActivityManagerNative执行进程间通讯告诉ActivityManagerService，栈顶Actiity已经执行完成onPause方法，继续执行后续操作； ActivityManagerService会继续执行启动Activity的逻辑，这时候会判断需要启动的Activity所属的应用进程是否已经启动，若没有启动则首先会启动这个Activity的应用程序进程； ActivityManagerService会通过socket与Zygote继承通讯，并告知Zygote进程fork出一个新的应用程序进程，然后执行ActivityThread的mani方法； 在ActivityThead.main方法中执行初始化操作，初始化主线程异步消息，然后通知ActivityManagerService执行进程初始化操作； ActivityManagerService会在执行初始化操作的同时检测当前进程是否有需要创建的Activity对象，若有的话，则执行创建操作； ActivityManagerService将执行创建Activity的通知告知ActivityThread，然后通过反射机制创建出Activity对象，并执行Activity的onCreate方法，onStart方法，onResume方法； ActivityThread执行完成onResume方法之后告知ActivityManagerService onResume执行完成，开始执行栈顶Activity的onStop方法； ActivityManagerService开始执行栈顶的onStop方法并告知ActivityThread； ActivityThread执行真正的onStop方法； 另外对android源码解析方法感兴趣的可参考我的： android源码解析之（一）–&gt;android项目构建过程android源码解析之（二）–&gt;异步消息机制android源码解析之（三）–&gt;异步任务AsyncTaskandroid源码解析之（四）–&gt;HandlerThreadandroid源码解析之（五）–&gt;IntentServiceandroid源码解析之（六）–&gt;Logandroid源码解析之（七）–&gt;LruCacheandroid源码解析之（八）–&gt;Zygote进程启动流程android源码解析之（九）–&gt;SystemServer进程启动流程android源码解析之（十）–&gt;Launcher启动流程android源码解析之（十一）–&gt;应用进程启动流程android源码解析之（十二）–&gt;系统启动并解析Manifest的流程android源码解析之（十三）–&gt;apk安装流程","link":"/2020/09/11/activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"title":"ADB命令大全(转)","text":"ADB，即 Android Debug Bridge，它是 Android 开发/测试人员不可替代的强大工具，也是 Android 设备玩家的好玩具。 持续更新中，欢迎提 PR 和 Issue 补充指正，觉得有用的可以将 此 GitHub 仓库 Star 收藏备用。 注： 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。 Other languages: :gb: English 基本用法 命令语法 为命令指定目标设备 启动/停止 查看 adb 版本 以 root 权限运行 adbd 指定 adb server 的网络端口 设备连接管理 查询已连接设备/模拟器 USB 连接 无线连接（需要借助 USB 线） 无线连接（无需借助 USB 线） 应用管理 查看应用列表 所有应用 系统应用 第三方应用 包名包含某字符串的应用 安装 APK 卸载应用 清除应用数据与缓存 查看前台 Activity 查看正在运行的 Services 查看应用详细信息 查看应用安装路径 与应用交互 启动应用/ 调起 Activity 调起 Service 停止 Service 发送广播 强制停止应用 收紧内存 文件管理 复制设备里的文件到电脑 复制电脑里的文件到设备 模拟按键/输入 电源键 菜单键 HOME 键 返回键 音量控制 媒体控制 点亮/熄灭屏幕 滑动解锁 输入文本 查看日志 Android 日志 按级别过滤日志 按 tag 和级别过滤日志 日志格式 清空日志 内核日志 查看设备信息 型号 电池状况 屏幕分辨率 屏幕密度 显示屏参数 android_id IMEI Android 系统版本 IP 地址 Mac 地址 CPU 信息 内存信息 更多硬件与系统属性 修改设置 分辨率 屏幕密度 显示区域 关闭 USB 调试模式 允许/禁止访问非 SDK API 状态栏和导航栏的显示隐藏 实用功能 屏幕截图 录制屏幕 重新挂载 system 分区为可写 查看连接过的 WiFi 密码 设置系统日期和时间 重启手机 检测设备是否已 root 使用 Monkey 进行压力测试 开启/关闭 WiFi 刷机相关命令 重启到 Recovery 模式 从 Recovery 重启到 Android 重启到 Fastboot 模式 通过 sideload 更新系统 安全相关命令 启用/禁用 SELinux 启用/禁用 dm_verity 更多 adb shell 命令 查看进程 查看实时资源占用情况 查看进程 UID 其它 常见问题 启动 adb server 失败 com.android.ddmlib.AdbCommandRejectedException adb 的非官方实现 相关命令 致谢 参考链接 基本用法命令语法adb 命令的基本语法如下： 1adb [-d|-e|-s &lt;serialNumber&gt;] &lt;command&gt; 如果只有一个设备/模拟器连接时，可以省略掉 [-d|-e|-s &lt;serialNumber&gt;] 这一部分，直接使用 adb &lt;command&gt;。 为命令指定目标设备如果有多个设备/模拟器连接，则需要为命令指定目标设备。 参数 含义 -d 指定当前唯一通过 USB 连接的 Android 设备为命令目标 -e 指定当前唯一运行的模拟器为命令目标 -s &lt;serialNumber&gt; 指定相应 serialNumber 号的设备/模拟器为命令目标 在多个设备/模拟器连接的情况下较常用的是 -s &lt;serialNumber&gt; 参数，serialNumber 可以通过 adb devices 命令获取。如： 123456$ adb devicesList of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出里的 cf264b8f、emulator-5554 和 10.129.164.6:5555 即为 serialNumber。 比如这时想指定 cf264b8f 这个设备来运行 adb 命令获取屏幕分辨率： 1adb -s cf264b8f shell wm size 又如想给 10.129.164.6:5555 这个设备安装应用（这种形式的 serialNumber 格式为 &lt;IP&gt;:&lt;Port&gt;，一般为无线连接的设备或 Genymotion 等第三方 Android 模拟器）： 1adb -s 10.129.164.6:5555 install test.apk 遇到多设备/模拟器的情况均使用这几个参数为命令指定目标设备，下文中为简化描述，不再重复。 启动/停止启动 adb server 命令： 1adb start-server （一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。） 停止 adb server 命令： 1adb kill-server 查看 adb 版本命令： 1adb version 示例输出： 12Android Debug Bridge version 1.0.36Revision 8f855a3d9b35-android 以 root 权限运行 adbdadb 的运行原理是 PC 端的 adb server 与手机端的守护进程 adbd 建立连接，然后 PC 端的 adb client 通过 adb server 转发命令，adbd 接收命令后解析运行。 所以如果 adbd 以普通权限执行，有些需要 root 权限才能执行的命令无法直接用 adb xxx 执行。这时可以 adb shell 然后 su 后执行命令，也可以让 adbd 以 root 权限执行，这个就能随意执行高权限命令了。 命令： 1adb root 正常输出： 1restarting adbd as root 现在再运行 adb shell，看看命令行提示符是不是变成 # 了？ 有些手机 root 后也无法通过 adb root 命令让 adbd 以 root 权限执行，比如三星的部分机型，会提示 adbd cannot run as root in production builds，此时可以先安装 adbd Insecure，然后 adb root 试试。 相应地，如果要恢复 adbd 为非 root 权限的话，可以使用 adb unroot 命令。 指定 adb server 的网络端口命令： 1adb -P &lt;port&gt; start-server 默认端口为 5037。 设备连接管理查询已连接设备/模拟器命令： 1adb devices 输出示例： 1234List of devices attachedcf264b8f deviceemulator-5554 device10.129.164.6:5555 device 输出格式为 [serialNumber] [state]，serialNumber 即我们常说的 SN，state 有如下几种： offline —— 表示设备未连接成功或无响应。 device —— 设备已连接。注意这个状态并不能标识 Android 系统已经完全启动和可操作，在设备启动过程中设备实例就可连接到 adb，但启动完毕后系统才处于可操作状态。 no device —— 没有设备/模拟器连接。 以上输出显示当前已经连接了三台设备/模拟器，cf264b8f、emulator-5554 和 10.129.164.6:5555 分别是它们的 SN。从 emulator-5554 这个名字可以看出它是一个 Android 模拟器，而 10.129.164.6:5555 这种形为 &lt;IP&gt;:&lt;Port&gt; 的 serialNumber 一般是无线连接的设备或 Genymotion 等第三方 Android 模拟器。 常见异常输出： 没有设备/模拟器连接成功。 1List of devices attached 设备/模拟器未连接到 adb 或无响应。 12List of devices attachedcf264b8f offline USB 连接通过 USB 连接来正常使用 adb 需要保证几点： 硬件状态正常。 包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好。 Android 设备的开发者选项和 USB 调试模式已开启。 可以到「设置」-「开发者选项」-「Android 调试」查看。 如果在设置里找不到开发者选项，那需要通过一个彩蛋来让它显示出来：在「设置」-「关于手机」连续点击「版本号」7 次。 设备驱动状态正常。 这一点貌似在 Linux 和 Mac OS X 下不用操心，在 Windows 下有可能遇到需要安装驱动的情况，确认这一点可以右键「计算机」-「属性」，到「设备管理器」里查看相关设备上是否有黄色感叹号或问号，如果没有就说明驱动状态已经好了。否则可以下载一个手机助手类程序来安装驱动先。 通过 USB 线连接好电脑和设备后确认状态。 1adb devices 如果能看到 1xxxxxx device 说明连接成功。 无线连接（需要借助 USB 线）除了可以通过 USB 连接设备与电脑来使用 adb，也可以通过无线连接——虽然连接过程中也有需要使用 USB 的步骤，但是连接成功之后你的设备就可以在一定范围内摆脱 USB 连接线的限制啦！ 操作步骤： 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 将设备与电脑通过 USB 线连接。 应确保连接成功（可运行 adb devices 看是否能列出该设备）。 让设备在 5555 端口监听 TCP/IP 连接： 1adb tcpip 5555 断开 USB 连接。 找到设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 通过 IP 地址连接设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 确认连接状态。 1adb devices 如果能看到 1&lt;device-ip-address&gt;:5555 device 说明连接成功。 如果连接不了，请确认 Android 设备与电脑是连接到了同一个 WiFi，然后再次执行 adb connect &lt;device-ip-address&gt; 那一步； 如果还是不行的话，通过 adb kill-server 重新启动 adb 然后从头再来一次试试。 断开无线连接 命令： 1adb disconnect &lt;device-ip-address&gt; 无线连接（无需借助 USB 线）注：需要 root 权限。 上一节「无线连接（需要借助 USB 线）」是官方文档里介绍的方法，需要借助于 USB 数据线来实现无线连接。 既然我们想要实现无线连接，那能不能所有步骤下来都是无线的呢？答案是能的。 在 Android 设备上安装一个终端模拟器。 已经安装过的设备可以跳过此步。我使用的终端模拟器下载地址是：Terminal Emulator for Android Downloads 将 Android 设备与要运行 adb 的电脑连接到同一个局域网，比如连到同一个 WiFi。 打开 Android 设备上的终端模拟器，在里面依次运行命令： 12susetprop service.adb.tcp.port 5555 找到 Android 设备的 IP 地址。 一般能在「设置」-「关于手机」-「状态信息」-「IP地址」找到，也可以使用下文里 查看设备信息 - IP 地址 一节里的方法用 adb 命令来查看。 在电脑上通过 adb 和 IP 地址连接 Android 设备。 1adb connect &lt;device-ip-address&gt; 这里的 &lt;device-ip-address&gt; 就是上一步中找到的设备 IP 地址。 如果能看到 connected to &lt;device-ip-address&gt;:5555 这样的输出则表示连接成功。 节注一： 有的设备，比如小米 5S + MIUI 8.0 + Android 6.0.1 MXB48T，可能在第 5 步之前需要重启 adbd 服务，在设备的终端模拟器上运行： 1restart adbd 如果 restart 无效，尝试以下命令： 12stop adbdstart adbd 应用管理查看应用列表查看应用列表的基本命令格式是 1adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER] 即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下： 参数 显示列表 无 所有应用 -f 显示应用关联的 apk 文件 -d 只显示 disabled 的应用 -e 只显示 enabled 的应用 -s 只显示系统应用 -3 只显示第三方应用 -i 显示应用的 installer -u 包含已卸载应用 &lt;FILTER&gt; 包名包含 &lt;FILTER&gt; 字符串 所有应用命令： 1adb shell pm list packages 输出示例： 12345678910111213package:com.android.smoketestpackage:com.example.android.livecubespackage:com.android.providers.telephonypackage:com.google.android.googlequicksearchboxpackage:com.android.providers.calendarpackage:com.android.providers.mediapackage:com.android.protipspackage:com.android.documentsuipackage:com.android.gallerypackage:com.android.externalstorage...// other packages here... 系统应用命令： 1adb shell pm list packages -s 第三方应用命令： 1adb shell pm list packages -3 包名包含某字符串的应用比如要查看包名包含字符串 mazhuang 的应用列表，命令： 1adb shell pm list packages mazhuang 当然也可以使用 grep 来过滤： 1adb shell pm list packages | grep mazhuang 安装 APK命令格式： 1adb install [-lrtsdg] &lt;path_to_apk&gt; 参数： adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下： 参数 含义 -l 将应用安装到保护目录 /mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=&quot;true&quot; 的应用 -s 将应用安装到 sdcard -d 允许降级覆盖安装 -g 授予所有运行时权限 运行命令后如果见到类似如下输出（状态为 Success）代表安装成功： 123[100%] /data/local/tmp/1.apk pkg: /data/local/tmp/1.apkSuccess 上面是当前最新版 v1.0.36 的 adb 的输出，会显示 push apk 文件到手机的进度百分比。 使用旧版本 adb 的输出则是这样的： 12312040 KB/s (22205609 bytes in 1.801s) pkg: /data/local/tmp/SogouInput_android_v8.3_sweb.apkSuccess 而如果状态为 Failure 则表示安装失败，比如： 123[100%] /data/local/tmp/map-20160831.apk pkg: /data/local/tmp/map-20160831.apkFailure [INSTALL_FAILED_ALREADY_EXISTS] 常见安装失败输出代码、含义及可能的解决办法如下： 输出 含义 解决办法 INSTALL_FAILED_ALREADY_EXISTS 应用已经存在，或卸载了但没卸载干净 adb install 时使用 -r 参数，或者先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_INVALID_APK 无效的 APK 文件 INSTALL_FAILED_INVALID_URI 无效的 APK 文件名 确保 APK 文件名里无中文 INSTALL_FAILED_INSUFFICIENT_STORAGE 空间不足 清理空间 INSTALL_FAILED_DUPLICATE_PACKAGE 已经存在同名程序 INSTALL_FAILED_NO_SHARED_USER 请求的共享用户不存在 INSTALL_FAILED_UPDATE_INCOMPATIBLE 以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致 先 adb uninstall &lt;packagename&gt; 再安装 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE 请求的共享用户存在但签名不一致 INSTALL_FAILED_MISSING_SHARED_LIBRARY 安装包使用了设备上不可用的共享库 INSTALL_FAILED_REPLACE_COULDNT_DELETE 替换时无法删除 INSTALL_FAILED_DEXOPT dex 优化验证失败或空间不足 INSTALL_FAILED_OLDER_SDK 设备系统版本低于应用要求 INSTALL_FAILED_CONFLICTING_PROVIDER 设备里已经存在与应用里同名的 content provider INSTALL_FAILED_NEWER_SDK 设备系统版本高于应用要求 INSTALL_FAILED_TEST_ONLY 应用是 test-only 的，但安装时没有指定 -t 参数 INSTALL_FAILED_CPU_ABI_INCOMPATIBLE 包含不兼容设备 CPU 应用程序二进制接口的 native code INSTALL_FAILED_MISSING_FEATURE 应用使用了设备不可用的功能 INSTALL_FAILED_CONTAINER_ERROR 1. sdcard 访问失败;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 确认 sdcard 可用，或者安装到内置存储;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_INVALID_INSTALL_LOCATION 1. 不能安装到指定位置;2. 应用签名与 ROM 签名一致，被当作内置应用。 1. 切换安装位置，添加或删除 -s 参数;2. 打包时不与 ROM 使用相同签名。 INSTALL_FAILED_MEDIA_UNAVAILABLE 安装位置不可用 一般为 sdcard，确认 sdcard 可用或安装到内置存储 INSTALL_FAILED_VERIFICATION_TIMEOUT 验证安装包超时 INSTALL_FAILED_VERIFICATION_FAILURE 验证安装包失败 INSTALL_FAILED_PACKAGE_CHANGED 应用与调用程序期望的不一致 INSTALL_FAILED_UID_CHANGED 以前安装过该应用，与本次分配的 UID 不一致 清除以前安装过的残留文件 INSTALL_FAILED_VERSION_DOWNGRADE 已经安装了该应用更高版本 使用 -d 参数 INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE 已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限 INSTALL_PARSE_FAILED_NOT_APK 指定路径不是文件，或不是以 .apk 结尾 INSTALL_PARSE_FAILED_BAD_MANIFEST 无法解析的 AndroidManifest.xml 文件 INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 解析器遇到异常 INSTALL_PARSE_FAILED_NO_CERTIFICATES 安装包没有签名 INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES 已安装该应用，且签名与 APK 文件不一致 先卸载设备上的该应用，再安装 INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING 解析 APK 文件时遇到 CertificateEncodingException INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME manifest 文件里没有或者使用了无效的包名 INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID manifest 文件里指定了无效的共享用户 ID INSTALL_PARSE_FAILED_MANIFEST_MALFORMED 解析 manifest 文件时遇到结构性错误 INSTALL_PARSE_FAILED_MANIFEST_EMPTY 在 manifest 文件里找不到找可操作标签（instrumentation 或 application） INSTALL_FAILED_INTERNAL_ERROR 因系统问题安装失败 INSTALL_FAILED_USER_RESTRICTED 用户被限制安装应用 在开发者选项里将「USB安装」打开，如果已经打开了，那先关闭再打开。 INSTALL_FAILED_DUPLICATE_PERMISSION 应用尝试定义一个已经存在的权限名称 INSTALL_FAILED_NO_MATCHING_ABIS 应用包含设备的应用程序二进制接口不支持的 native code INSTALL_CANCELED_BY_USER 应用安装需要在设备上确认，但未操作设备或点了取消 在设备上同意安装 INSTALL_FAILED_ACWF_INCOMPATIBLE 应用程序与设备不兼容 INSTALL_FAILED_TEST_ONLY APK 文件是使用 Android Studio 直接 RUN 编译出来的文件 通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK does not contain AndroidManifest.xml 无效的 APK 文件 is not a valid zip file 无效的 APK 文件 Offline 设备未连接成功 先将设备与 adb 连接成功 unauthorized 设备未授权允许调试 error: device not found 没有连接成功的设备 先将设备与 adb 连接成功 protocol failure 设备已断开连接 先将设备与 adb 连接成功 Unknown option: -s Android 2.2 以下不支持安装到 sdcard 不使用 -s 参数 No space left on device 空间不足 清理空间 Permission denied … sdcard … sdcard 不可用 signatures do not match the previously installed version; ignoring! 已安装该应用且签名不一致 先卸载设备上的该应用，再安装 参考：PackageManager.java adb install 内部原理简介 adb install 实际是分三步完成： push apk 文件到 /data/local/tmp。 调用 pm install 安装。 删除 /data/local/tmp 下的对应 apk 文件。 所以，必要的时候也可以根据这个步骤，手动分步执行安装过程。 卸载应用命令： 1adb uninstall [-k] &lt;packagename&gt; &lt;packagename&gt; 表示应用的包名，-k 参数可选，表示卸载应用但保留数据和缓存目录。 命令示例： 1adb uninstall com.qihoo360.mobilesafe 表示卸载 360 手机卫士。 清除应用数据与缓存命令： 1adb shell pm clear &lt;packagename&gt; &lt;packagename&gt; 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。 命令示例： 1adb shell pm clear com.qihoo360.mobilesafe 表示清除 360 手机卫士的数据和缓存。 查看前台 Activity命令： 1adb shell dumpsys activity activities | grep mFocusedActivity 输出示例： 1mFocusedActivity: ActivityRecord{8079d7e u0 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher t42} 其中的 com.cyanogenmod.trebuchet/com.android.launcher3.Launcher 就是当前处于前台的 Activity。 查看正在运行的 Services命令： 1adb shell dumpsys activity services [&lt;packagename&gt;] &lt;packagename&gt; 参数不是必须的，指定 &lt;packagename&gt; 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。 &lt;packagename&gt; 不一定要给出完整的包名，比如运行 adb shell dumpsys activity services org.mazhuang，那么包名 org.mazhuang.demo1、org.mazhuang.demo2 和 org.mazhuang123 等相关的 Services 都会列出来。 查看应用详细信息命令： 1adb shell dumpsys package &lt;packagename&gt; 输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。 &lt;packagename&gt; 表示应用包名。 输出示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Activity Resolver Table: Non-Data Actions: android.intent.action.MAIN: 5b4cba8 org.mazhuang.guanggoo/.SplashActivity filter 5ec9dcc Action: \"android.intent.action.MAIN\" Category: \"android.intent.category.LAUNCHER\" AutoVerify=falseRegistered ContentProviders: org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider}ContentProvider Authorities: [org.mazhuang.guanggoo.fileProvider]: Provider{7a3c394 org.mazhuang.guanggoo/com.tencent.bugly.beta.utils.BuglyFileProvider} applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo}Key Set Manager: [org.mazhuang.guanggoo] Signing KeySets: 501Packages: Package [org.mazhuang.guanggoo] (c1d7f): userId=10394 pkg=Package{55f714c org.mazhuang.guanggoo} codePath=/data/app/org.mazhuang.guanggoo-2 resourcePath=/data/app/org.mazhuang.guanggoo-2 legacyNativeLibraryDir=/data/app/org.mazhuang.guanggoo-2/lib primaryCpuAbi=null secondaryCpuAbi=null versionCode=74 minSdk=15 targetSdk=25 versionName=1.1.74 splits=[base] apkSigningVersion=2 applicationInfo=ApplicationInfo{7754242 org.mazhuang.guanggoo} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ RESIZEABLE_ACTIVITIES ] dataDir=/data/user/0/org.mazhuang.guanggoo supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2017-10-22 23:50:53 firstInstallTime=2017-10-22 23:50:25 lastUpdateTime=2017-10-22 23:50:55 installerPackageName=com.miui.packageinstaller signatures=PackageSignatures{af09595 [53c7caa2]} installPermissionsFixed=true installStatus=1 pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.READ_PHONE_STATE android.permission.INTERNET android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_WIFI_STATE android.permission.READ_LOGS android.permission.WRITE_EXTERNAL_STORAGE android.permission.READ_EXTERNAL_STORAGE install permissions: android.permission.INTERNET: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true User 0: ceDataInode=1155675 installed=true hidden=false suspended=false stopped=true notLaunched=false enabled=0 gids=[3003] runtime permissions: android.permission.READ_EXTERNAL_STORAGE: granted=true android.permission.READ_PHONE_STATE: granted=true android.permission.WRITE_EXTERNAL_STORAGE: granted=true User 999: ceDataInode=0 installed=false hidden=false suspended=false stopped=true notLaunched=true enabled=0 gids=[3003] runtime permissions:Dexopt state: [org.mazhuang.guanggoo] Instruction Set: arm64 path: /data/app/org.mazhuang.guanggoo-2/base.apk status: /data/app/org.mazhuang.guanggoo-2/oat/arm64/base.odex [compilation_filter=speed-profile, status=kOatUpToDa te] 查看应用安装路径命令: 1adb shell pm path &lt;PACKAGE&gt; 输出应用安装路径 输出示例: 123adb shell pm path ecarx.weatherpackage:/data/app/ecarx.weather-1.apk 与应用交互主要是使用 am &lt;command&gt; 命令，常用的 &lt;command&gt; 如下： command 用途 start [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Activity startservice [options] &lt;INTENT&gt; 启动 &lt;INTENT&gt; 指定的 Service broadcast [options] &lt;INTENT&gt; 发送 &lt;INTENT&gt; 指定的广播 force-stop &lt;packagename&gt; 停止 &lt;packagename&gt; 相关的进程 &lt;INTENT&gt; 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。 用于决定 intent 对象的选项如下： 参数 含义 -a &lt;ACTION&gt; 指定 action，比如 android.intent.action.VIEW -c &lt;CATEGORY&gt; 指定 category，比如 android.intent.category.APP_CONTACTS -n &lt;COMPONENT&gt; 指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app/.ExampleActivity &lt;INTENT&gt; 里还能带数据，就像写代码时的 Bundle 一样： 参数 含义 --esn &lt;EXTRA_KEY&gt; null 值（只有 key 名） `-e –es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt;` string 值 --ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; boolean 值 --ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; integer 值 --el &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt; long 值 --ef &lt;EXTRA_KEY&gt; &lt;EXTRA_FLOAT_VALUE&gt; float 值 --eu &lt;EXTRA_KEY&gt; &lt;EXTRA_URI_VALUE&gt; URI --ecn &lt;EXTRA_KEY&gt; &lt;EXTRA_COMPONENT_NAME_VALUE&gt; component name --eia &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt;[,&lt;EXTRA_INT_VALUE...] integer 数组 --ela &lt;EXTRA_KEY&gt; &lt;EXTRA_LONG_VALUE&gt;[,&lt;EXTRA_LONG_VALUE...] long 数组 启动应用/ 调起 Activity命令格式： 1adb shell am start [options] &lt;INTENT&gt; 例如： 1adb shell am start -n com.tencent.mm/.ui.LauncherUI 表示调起微信主界面。 1adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es \"toast\" \"hello, world\" 表示调起 org.mazhuang.boottimemeasure/.MainActivity 并传给它 string 数据键值对 toast - hello, world。 调起 Service命令格式： 1adb shell am startservice [options] &lt;INTENT&gt; 例如： 1adb shell am startservice -n com.tencent.mm/.plugin.accountsync.model.AccountAuthenticatorService 表示调起微信的某 Service。 另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个： 1adb shell am startservice -n com.android.systemui/.SystemUIService 停止 Service命令格式： 1adb shell am stopservice [options] &lt;INTENT&gt; 发送广播命令格式： 1adb shell am broadcast [options] &lt;INTENT&gt; 可以向所有组件广播，也可以只向指定组件广播。 例如，向所有组件广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED 又例如，只向 org.mazhuang.boottimemeasure/.BootCompletedReceiver 广播 BOOT_COMPLETED： 1adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n org.mazhuang.boottimemeasure/.BootCompletedReceiver 这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。 既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机： action 触发时机 android.net.conn.CONNECTIVITY_CHANGE 网络连接发生变化 android.intent.action.SCREEN_ON 屏幕点亮 android.intent.action.SCREEN_OFF 屏幕熄灭 android.intent.action.BATTERY_LOW 电量低，会弹出电量低提示框 android.intent.action.BATTERY_OKAY 电量恢复了 android.intent.action.BOOT_COMPLETED 设备启动完毕 android.intent.action.DEVICE_STORAGE_LOW 存储空间过低 android.intent.action.DEVICE_STORAGE_OK 存储空间恢复 android.intent.action.PACKAGE_ADDED 安装了新的应用 android.net.wifi.STATE_CHANGE WiFi 连接状态发生变化 android.net.wifi.WIFI_STATE_CHANGED WiFi 状态变为启用/关闭/正在启动/正在关闭/未知 android.intent.action.BATTERY_CHANGED 电池电量发生变化 android.intent.action.INPUT_METHOD_CHANGED 系统输入法发生变化 android.intent.action.ACTION_POWER_CONNECTED 外部电源连接 android.intent.action.ACTION_POWER_DISCONNECTED 外部电源断开连接 android.intent.action.DREAMING_STARTED 系统开始休眠 android.intent.action.DREAMING_STOPPED 系统停止休眠 android.intent.action.WALLPAPER_CHANGED 壁纸发生变化 android.intent.action.HEADSET_PLUG 插入耳机 android.intent.action.MEDIA_UNMOUNTED 卸载外部介质 android.intent.action.MEDIA_MOUNTED 挂载外部介质 android.os.action.POWER_SAVE_MODE_CHANGED 省电模式开启 （以上广播均可使用 adb 触发） 强制停止应用命令： 1adb shell am force-stop &lt;packagename&gt; 命令示例： 1adb shell am force-stop com.qihoo360.mobilesafe 表示停止 360 安全卫士的一切进程与服务。 收紧内存命令：1adb shell am send-trim-memory &lt;pid&gt; &lt;level&gt; pid: 进程 IDlevel: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE 命令示例： 1adb shell am send-trim-memory 12345 RUNNING_LOW 表示向 pid=12345 的进程，发出 level=RUNNING_LOW 的收紧内存命令。 文件管理复制设备里的文件到电脑命令： 1adb pull &lt;设备里的文件路径&gt; [电脑上的目录] 其中 电脑上的目录 参数可以省略，默认复制到当前目录。 例： 1adb pull /sdcard/sr.mp4 ~/tmp/ 小技巧：设备上的文件路径可能需要 root 权限才能访问，如果你的设备已经 root 过，可以先使用 adb shell 和 su 命令在 adb shell 里获取 root 权限后，先 cp /path/on/device /sdcard/filename 将文件复制到 sdcard，然后 adb pull /sdcard/filename /path/on/pc。 复制电脑里的文件到设备命令： 1adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt; 例： 1adb push ~/sr.mp4 /sdcard/ 小技巧：设备上的文件路径普通权限可能无法直接写入，如果你的设备已经 root 过，可以先 adb push /path/on/pc /sdcard/filename，然后 adb shell 和 su 在 adb shell 里获取 root 权限后，cp /sdcard/filename /path/on/device。 模拟按键/输入在 adb shell 里有个很实用的命令叫 input，通过它可以做一些有趣的事情。 input 命令的完整 help 信息如下： 12345678910111213141516171819202122Usage: input [&lt;source&gt;] &lt;command&gt; [&lt;arg&gt;...]The sources are: mouse keyboard joystick touchnavigation touchpad trackball stylus dpad gesture touchscreen gamepadThe commands and default sources are: text &lt;string&gt; (Default: touchscreen) keyevent [--longpress] &lt;key code number or name&gt; ... (Default: keyboard) tap &lt;x&gt; &lt;y&gt; (Default: touchscreen) swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen) press (Default: trackball) roll &lt;dx&gt; &lt;dy&gt; (Default: trackball) 比如使用 adb shell input keyevent &lt;keycode&gt; 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 KeyEvent，摘引部分我觉得有意思的如下： keycode 含义 3 HOME 键 4 返回键 5 打开拨号应用 6 挂断电话 24 增加音量 25 降低音量 26 电源键 27 拍照（需要在相机应用里） 64 打开浏览器 82 菜单键 85 播放/暂停 86 停止播放 87 播放下一首 88 播放上一首 122 移动光标到行首或列表顶部 123 移动光标到行末或列表底部 126 恢复播放 127 暂停播放 164 静音 176 打开系统设置 187 切换应用 207 打开联系人 208 打开日历 209 打开音乐 210 打开计算器 220 降低屏幕亮度 221 提高屏幕亮度 223 系统休眠 224 点亮屏幕 231 打开语音助手 276 如果没有 wakelock 则让系统休眠 下面是 input 命令的一些用法举例。 电源键命令： 1adb shell input keyevent 26 执行效果相当于按电源键。 菜单键命令： 1adb shell input keyevent 82 HOME 键命令： 1adb shell input keyevent 3 返回键命令： 1adb shell input keyevent 4 音量控制增加音量： 1adb shell input keyevent 24 降低音量： 1adb shell input keyevent 25 静音： 1adb shell input keyevent 164 媒体控制播放/暂停： 1adb shell input keyevent 85 停止播放： 1adb shell input keyevent 86 播放下一首： 1adb shell input keyevent 87 播放上一首： 1adb shell input keyevent 88 恢复播放： 1adb shell input keyevent 126 暂停播放： 1adb shell input keyevent 127 点亮/熄灭屏幕可以通过上文讲述过的模拟电源键来切换点亮和熄灭屏幕，但如果明确地想要点亮或者熄灭屏幕，那可以使用如下方法。 点亮屏幕： 1adb shell input keyevent 224 熄灭屏幕： 1adb shell input keyevent 223 滑动解锁如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 input swipe 来解锁。 命令（参数以机型 Nexus 5，向上滑动手势解锁举例）： 1adb shell input swipe 300 1000 300 500 参数 300 1000 300 500 分别表示起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标。 输入文本在焦点处于某文本框时，可以通过 input 命令来输入文本。 命令： 1adb shell input text hello 现在 hello 出现在文本框了。 查看日志Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。 Android 日志命令格式： 1[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ... 常用用法列举如下： 按级别过滤日志Android 的日志分为如下几个优先级（priority）： V —— Verbose（最低，输出得最多） D —— Debug I —— Info W —— Warning E —— Error F —— Fatal S —— Silent（最高，啥也不输出） 按某级别过滤日志则会将该级别及以上的日志输出。 比如，命令： 1adb logcat *:W 会将 Warning、Error、Fatal 和 Silent 日志输出。 （注： 在 macOS 下需要给 *:W 这样以 * 作为 tag 的参数加双引号，如 adb logcat &quot;*:W&quot;，不然会报错 no matches found: *:W。） 按 tag 和级别过滤日志&lt;filter-spec&gt; 可以由多个 &lt;tag&gt;[:priority] 组成。 比如，命令： 1adb logcat ActivityManager:I MyApp:D *:S 表示输出 tag ActivityManager 的 Info 以上级别日志，输出 tag MyApp 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。 日志格式可以用 adb logcat -v &lt;format&gt; 选项指定日志输出格式。 日志支持按以下几种 &lt;format&gt;： brief 默认格式。格式为： 1&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 1D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 process 格式为： 1&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt; 示例： 1D( 1785) Disconnected process message: 10, size: 0 (HeadsetStateMachine) tag 格式为： 1&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt; 示例： 1D/HeadsetStateMachine: Disconnected process message: 10, size: 0 raw 格式为： 1&lt;message&gt; 示例： 1Disconnected process message: 10, size: 0 time 格式为： 1&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt; 示例： 108-28 22:39:39.974 D/HeadsetStateMachine( 1785): Disconnected process message: 10, size: 0 threadtime 格式为： 1&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt; 示例： 108-28 22:39:39.974 1785 1832 D HeadsetStateMachine: Disconnected process message: 10, size: 0 long 格式为： 12[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ]&lt;message&gt; 示例： 12[ 08-28 22:39:39.974 1785: 1832 D/HeadsetStateMachine ]Disconnected process message: 10, size: 0 指定格式可与上面的过滤同时使用。比如： 1adb logcat -v long ActivityManager:I *:S 清空日志1adb logcat -c 内核日志命令： 1adb shell dmesg 输出示例： 1234567&lt;6&gt;[14201.684016] PM: noirq resume of devices complete after 0.982 msecs&lt;6&gt;[14201.685525] PM: early resume of devices complete after 0.838 msecs&lt;6&gt;[14201.753642] PM: resume of devices complete after 68.106 msecs&lt;4&gt;[14201.755954] Restarting tasks ... done.&lt;6&gt;[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC&lt;6&gt;[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC&lt;6&gt;[14201.872498] PM: Syncing filesystems ... done. 中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。 通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。 查看设备信息型号命令： 1adb shell getprop ro.product.model 输出示例： 1Nexus 5 电池状况命令： 1adb shell dumpsys battery 输入示例： 123456789101112Current Battery Service state: AC powered: false USB powered: true Wireless powered: false status: 2 health: 2 present: true level: 44 scale: 100 voltage: 3872 temperature: 280 technology: Li-poly 其中 scale 代表最大电量，level 代表当前电量。上面的输出表示还剩下 44% 的电量。 屏幕分辨率命令： 1adb shell wm size 输出示例： 1Physical size: 1080x1920 该设备屏幕分辨率为 1080px * 1920px。 如果使用命令修改过，那输出可能是： 12Physical size: 1080x1920Override size: 480x1024 表明设备的屏幕分辨率原本是 1080px 1920px，当前被修改为 480px 1024px。 屏幕密度命令： 1adb shell wm density 输出示例： 1Physical density: 420 该设备屏幕密度为 420dpi。 如果使用命令修改过，那输出可能是： 12Physical density: 480Override density: 160 表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。 显示屏参数命令： 1adb shell dumpsys window displays 输出示例： 1234WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731 deferred=false layoutNeeded=false 其中 mDisplayId 为 显示屏编号，init 是初始分辨率和屏幕密度，app 的高度比 init 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。 android_id命令： 1adb shell settings get secure android_id 输出示例： 151b6be48bac8c569 IMEI在 Android 4.4 及以下版本可通过如下命令获取 IMEI： 1adb shell dumpsys iphonesubinfo 输出示例： 123Phone Subscriber Info: Phone Type = GSM Device ID = 860955027785041 其中的 Device ID 就是 IMEI。 而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）： 123adb shellsuservice call iphonesubinfo 1 输出示例： 1234Result: Parcel( 0x00000000: 00000000 0000000f 00360038 00390030 '........8.6.0.9.' 0x00000010: 00350035 00320030 00370037 00350038 '5.5.0.2.7.7.8.5.' 0x00000020: 00340030 00000031 '0.4.1... ') 把里面的有效内容提取出来就是 IMEI 了，比如这里的是 860955027785041。 参考：adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop Android 系统版本命令： 1adb shell getprop ro.build.version.release 输出示例： 15.0.2 IP 地址每次想知道设备的 IP 地址的时候都得「设置」-「关于手机」-「状态信息」-「IP地址」很烦对不对？通过 adb 可以方便地查看。 命令： 1adb shell ifconfig | grep Mask 输出示例： 12inet addr:10.130.245.230 Mask:255.255.255.252inet addr:127.0.0.1 Mask:255.0.0.0 那么 10.130.245.230 就是设备 IP 地址。 在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP： 1adb shell ifconfig wlan0 输出示例： 1wlan0: ip 10.129.160.99 mask 255.255.240.0 flags [up broadcast running multicast] 或 12345678wlan0 Link encap:UNSPEC inet addr:10.129.168.57 Bcast:10.129.175.255 Mask:255.255.240.0 inet6 addr: fe80::66cc:2eff:fe68:b6b6/64 Scope: Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:496520 errors:0 dropped:0 overruns:0 frame:0 TX packets:68215 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3000 RX bytes:116266821 TX bytes:8311736 如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）： 1adb shell netcfg 输出示例： 123456789101112131415161718192021wlan0 UP 10.129.160.99/20 0x00001043 f8:a9:d0:17:42:4dlo UP 127.0.0.1/8 0x00000049 00:00:00:00:00:00p2p0 UP 0.0.0.0/0 0x00001003 fa:a9:d0:17:42:4dsit0 DOWN 0.0.0.0/0 0x00000080 00:00:00:00:00:00rmnet0 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet1 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet3 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet2 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet4 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet6 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet5 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rmnet7 DOWN 0.0.0.0/0 0x00000000 00:00:00:00:00:00rev_rmnet3 DOWN 0.0.0.0/0 0x00001002 4e:b7:e4:2e:17:58rev_rmnet2 DOWN 0.0.0.0/0 0x00001002 4e:f0:c8:bf:7a:cfrev_rmnet4 DOWN 0.0.0.0/0 0x00001002 a6:c0:3b:6b:c4:1frev_rmnet6 DOWN 0.0.0.0/0 0x00001002 66:bb:5d:64:2e:e9rev_rmnet5 DOWN 0.0.0.0/0 0x00001002 0e:1b:eb:b9:23:a0rev_rmnet7 DOWN 0.0.0.0/0 0x00001002 7a:d9:f6:81:40:5arev_rmnet8 DOWN 0.0.0.0/0 0x00001002 4e:e2:a9:bb:d0:1brev_rmnet0 DOWN 0.0.0.0/0 0x00001002 fe:65:d0:ca:82:a9rev_rmnet1 DOWN 0.0.0.0/0 0x00001002 da:d8:e8:4f:2e:fe 可以看到网络连接名称、启用状态、IP 地址和 Mac 地址等信息。 Mac 地址命令： 1adb shell cat /sys/class/net/wlan0/address 输出示例： 1f8:a9:d0:17:42:4d 这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 adb shell netcfg 命令来查看。 CPU 信息命令： 1adb shell cat /proc/cpuinfo 输出示例： 1234567891011121314151617181920212223Processor : ARMv7 Processor rev 0 (v7l)processor : 0BogoMIPS : 38.40processor : 1BogoMIPS : 38.40processor : 2BogoMIPS : 38.40processor : 3BogoMIPS : 38.40Features : swp half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivtCPU implementer : 0x51CPU architecture: 7CPU variant : 0x2CPU part : 0x06fCPU revision : 0Hardware : Qualcomm MSM 8974 HAMMERHEAD (Flattened Device Tree)Revision : 000bSerial : 0000000000000000 这是 Nexus 5 的 CPU 信息，我们从输出里可以看到使用的硬件是 Qualcomm MSM 8974，processor 的编号是 0 到 3，所以它是四核的，采用的架构是 ARMv7 Processor rev 0 (v71)。 内存信息命令： 1adb shell cat /proc/meminfo 输出示例： 12345678910111213141516171819202122232425262728293031323334353637MemTotal: 1027424 kBMemFree: 486564 kBBuffers: 15224 kBCached: 72464 kBSwapCached: 24152 kBActive: 110572 kBInactive: 259060 kBActive(anon): 79176 kBInactive(anon): 207736 kBActive(file): 31396 kBInactive(file): 51324 kBUnevictable: 3948 kBMlocked: 0 kBHighTotal: 409600 kBHighFree: 132612 kBLowTotal: 617824 kBLowFree: 353952 kBSwapTotal: 262140 kBSwapFree: 207572 kBDirty: 0 kBWriteback: 0 kBAnonPages: 265324 kBMapped: 47072 kBShmem: 1020 kBSlab: 57372 kBSReclaimable: 7692 kBSUnreclaim: 49680 kBKernelStack: 4512 kBPageTables: 5912 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 775852 kBCommitted_AS: 13520632 kBVmallocTotal: 385024 kBVmallocUsed: 61004 kBVmallocChunk: 209668 kB 其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。 更多硬件与系统属性设备的更多硬件与系统属性可以通过如下命令查看： 1adb shell cat /system/build.prop 这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。 输出里还包括一些其它有用的信息，它们也可通过 adb shell getprop &lt;属性名&gt; 命令单独查看，列举一部分属性如下： 属性名 含义 ro.build.version.sdk SDK 版本 ro.build.version.release Android 系统版本 ro.build.version.security_patch Android 安全补丁程序级别 ro.product.model 型号 ro.product.brand 品牌 ro.product.name 设备名 ro.product.board 处理器型号 ro.product.cpu.abilist CPU 支持的 abi 列表[节注一] persist.sys.isUsbOtgEnabled 是否支持 OTG dalvik.vm.heapsize 每个应用程序的内存上限 ro.sf.lcd_density 屏幕密度 节注一： 一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 ro.product.cpu.abilist 属性名查找不到，可以这样试试： 1adb shell cat /system/build.prop | grep ro.product.cpu.abi 示例输出： 12ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi 修改设置注： 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。 修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。 分辨率命令： 1adb shell wm size 480x1024 表示将分辨率修改为 480px * 1024px。 恢复原分辨率命令： 1adb shell wm size reset 屏幕密度命令： 1adb shell wm density 160 表示将屏幕密度修改为 160dpi。 恢复原屏幕密度命令： 1adb shell wm density reset 显示区域命令： 1adb shell wm overscan 0,0,0,200 四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。 恢复原显示区域命令： 1adb shell wm overscan reset 关闭 USB 调试模式命令： 1adb shell settings put global adb_enabled 0 恢复： 用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。 去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。 允许/禁止访问非 SDK API允许访问非 SDK API： 12adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1 禁止访问非 SDK API： 12adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps 不需要设备获得 Root 权限。 命令最后的数字的含义： 值 含义 0 禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。 1 仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。 2 禁止调用深灰名单和黑名单中的接口。 3 禁止调用黑名单中的接口，但允许调用深灰名单中的接口。 状态栏和导航栏的显示隐藏本节所说的相关设置对应 Cyanogenmod 里的「扩展桌面」。 命令： 1adb shell settings put global policy_control &lt;key-values&gt; &lt;key-values&gt; 可由如下几种键及其对应的值组成，格式为 &lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;。 key 含义 immersive.full 同时隐藏 immersive.status 隐藏状态栏 immersive.navigation 隐藏导航栏 immersive.preconfirms ? 这些键对应的值可则如下值用逗号组合： value 含义 apps 所有应用 * 所有界面 packagename 指定应用 -packagename 排除指定应用 例如： 1adb shell settings put global policy_control immersive.full=* 表示设置在所有界面下都同时隐藏状态栏和导航栏。 1adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3 表示设置在包名为 com.package1 和 com.package2 的应用里隐藏状态栏，在除了包名为 com.package3 的所有应用里隐藏导航栏。 实用功能屏幕截图截图保存到电脑： 1adb exec-out screencap -p &gt; sc.png 如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法： 先截图保存到设备里： 1adb shell screencap -p /sdcard/sc.png 然后将 png 文件导出到电脑： 1adb pull /sdcard/sc.png 可以使用 adb shell screencap -h 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义： 参数 含义 -p 指定保存文件为 png 格式 -d display-id 指定截图的显示屏编号（有多显示屏的情况下） 实测如果指定文件名以 .png 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。 另外一种一行命令截图并保存到电脑的方法： Linux 和 Windows 1adb shell screencap -p | sed \"s/\\r$//\" &gt; sc.png Mac OS X 1adb shell screencap -p | gsed \"s/\\r$//\" &gt; sc.png 这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 sed for Windows 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。 而在 Mac 下使用系统自带的 sed 命令会报错： 1sed: RE error: illegal byte sequence 需要安装 gnu-sed，然后使用 gsed 命令： 1brew install gnu-sed 录制屏幕录制屏幕以 mp4 格式保存到 /sdcard： 1adb shell screenrecord /sdcard/filename.mp4 需要停止时按 Ctrl-C，默认录制时间和最长录制时间都是 180 秒。 如果需要导出到电脑： 1adb pull /sdcard/filename.mp4 可以使用 adb shell screenrecord --help 查看 screenrecord 命令的帮助信息，下面是常见参数及含义： 参数 含义 –size WIDTHxHEIGHT 视频的尺寸，比如 1280x720，默认是屏幕分辨率。 –bit-rate RATE 视频的比特率，默认是 4Mbps。 –time-limit TIME 录制时长，单位秒。 –verbose 输出更多信息。 重新挂载 system 分区为可写注：需要 root 权限。 /system 分区默认挂载为只读，但有些操作比如给 Android 系统添加命令、删除自带应用等需要对 /system 进行写操作，所以需要重新挂载它为可读写。 步骤： 进入 shell 并切换到 root 用户权限。 命令： 12adb shellsu 查看当前分区挂载情况。 命令： 1mount 输出示例： 12345678910111213141516171819202122232425rootfs / rootfs ro,relatime 0 0tmpfs /dev tmpfs rw,seclabel,nosuid,relatime,mode=755 0 0devpts /dev/pts devpts rw,seclabel,relatime,mode=600 0 0proc /proc proc rw,relatime 0 0sysfs /sys sysfs rw,seclabel,relatime 0 0selinuxfs /sys/fs/selinux selinuxfs rw,relatime 0 0debugfs /sys/kernel/debug debugfs rw,relatime 0 0none /var tmpfs rw,seclabel,relatime,mode=770,gid=1000 0 0none /acct cgroup rw,relatime,cpuacct 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0tmpfs /mnt/asec tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0tmpfs /mnt/obb tmpfs rw,seclabel,relatime,mode=755,gid=1000 0 0none /dev/memcg cgroup rw,relatime,memory 0 0none /dev/cpuctl cgroup rw,relatime,cpu 0 0none /sys/fs/cgroup tmpfs rw,seclabel,relatime,mode=750,gid=1000 0 0none /sys/fs/cgroup/memory cgroup rw,relatime,memory 0 0none /sys/fs/cgroup/freezer cgroup rw,relatime,freezer 0 0/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/userdata /data ext4 rw,seclabel,nosuid,nodev,relatime,noauto_da_alloc,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/cache /cache ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/persist /persist ext4 rw,seclabel,nosuid,nodev,relatime,data=ordered 0 0/dev/block/platform/msm_sdcc.1/by-name/modem /firmware vfat ro,context=u:object_r:firmware_file:s0,relatime,uid=1000,gid=1000,fmask=0337,dmask=0227,codepage=cp437,iocharset=iso8859-1,shortname=lower,errors=remount-ro 0 0/dev/fuse /mnt/shell/emulated fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0/dev/fuse /mnt/shell/emulated/0 fuse rw,nosuid,nodev,relatime,user_id=1023,group_id=1023,default_permissions,allow_other 0 0 找到其中我们关注的带 /system 的那一行： 1/dev/block/platform/msm_sdcc.1/by-name/system /system ext4 ro,seclabel,relatime,data=ordered 0 0 重新挂载。 命令： 1mount -o remount,rw -t yaffs2 /dev/block/platform/msm_sdcc.1/by-name/system /system 这里的 /dev/block/platform/msm_sdcc.1/by-name/system 就是我们从上一步的输出里得到的文件路径。 如果输出没有提示错误的话，操作就成功了，可以对 /system 下的文件为所欲为了。 查看连接过的 WiFi 密码注：需要 root 权限。 命令： 123adb shellsucat /data/misc/wifi/*.conf 输出示例： 123456789101112131415161718network={ ssid=\"TP-LINK_9DFC\" scan_ssid=1 psk=\"123456789\" key_mgmt=WPA-PSK group=CCMP TKIP auth_alg=OPEN sim_num=1 priority=13893}network={ ssid=\"TP-LINK_F11E\" psk=\"987654321\" key_mgmt=WPA-PSK sim_num=1 priority=17293} ssid 即为我们在 WLAN 设置里看到的名称，psk 为密码，key_mgmt 为安全加密方式。 设置系统日期和时间注：需要 root 权限。 命令： 123adb shellsudate -s 20160823.131500 表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。 重启手机命令： 1adb reboot 检测设备是否已 root命令： 12adb shellsu 此时命令行提示符是 $ 则表示没有 root 权限，是 # 则表示已 root。 使用 Monkey 进行压力测试Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。 简单用法： 1adb shell monkey -p &lt;packagename&gt; -v 500 表示向 &lt;packagename&gt; 指定的应用程序发送 500 个伪随机事件。 Monkey 的详细用法参考 官方文档。 开启/关闭 WiFi注：需要 root 权限。 有时需要控制设备的 WiFi 状态，可以用以下指令完成。 开启 WiFi： 12adb rootadb shell svc wifi enable 关闭 WiFi： 12adb rootadb shell svc wifi disable 若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 Killed。 刷机相关命令重启到 Recovery 模式命令： 1adb reboot recovery 从 Recovery 重启到 Android命令： 1adb reboot 重启到 Fastboot 模式命令： 1adb reboot bootloader 通过 sideload 更新系统如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。 以 Recovery 模式下更新为例： 重启到 Recovery 模式。 命令： 1adb reboot recovery 在设备的 Recovery 界面上操作进入 Apply update-Apply from ADB。 注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 Apply update from ADB。 通过 adb 上传和更新系统。 命令： 1adb sideload &lt;path-to-update.zip&gt; 安全相关命令启用/禁用 SELinux启用 SELinux 12adb rootadb shell setenforce 1 禁用 SELinux 12adb rootadb shell setenforce 0 启用/禁用 dm_verity启用 dm_verity 12adb rootadb enable-verity 禁用 dm_verity 12adb rootadb disable-verity 更多 adb shell 命令Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 adb shell 里可以调用。本文档前面的部分内容已经用到了 adb shell 命令。 查看进程命令： 1adb shell ps 输出示例： 12345678USER PID PPID VSIZE RSS WCHAN PC NAMEroot 1 0 8904 788 ffffffff 00000000 S /initroot 2 0 0 0 ffffffff 00000000 S kthreadd...u0_a71 7779 5926 1538748 48896 ffffffff 00000000 S com.sohu.inputmethod.sogou:classicu0_a58 7963 5926 1561916 59568 ffffffff 00000000 S org.mazhuang.boottimemeasure...shell 8750 217 10640 740 00000000 b6f28340 R ps 各列含义： 列名 含义 USER 所属用户 PID 进程 ID PPID 父进程 ID NAME 进程名 查看实时资源占用情况命令： 1adb shell top 输出示例： 1234567891011121314User 0%, System 6%, IOW 0%, IRQ 0%User 3 + Nice 0 + Sys 21 + Idle 280 + IOW 0 + IRQ 0 + SIRQ 3 = 307 PID PR CPU% S #THR VSS RSS PCY UID Name 8763 0 3% R 1 10640K 1064K fg shell top 131 0 3% S 1 0K 0K fg root dhd_dpc 6144 0 0% S 115 1682004K 115916K fg system system_server 132 0 0% S 1 0K 0K fg root dhd_rxf 1731 0 0% S 6 20288K 788K fg root /system/bin/mpdecision 217 0 0% S 6 18008K 356K fg shell /sbin/adbd ... 7779 2 0% S 19 1538748K 48896K bg u0_a71 com.sohu.inputmethod.sogou:classic 7963 0 0% S 18 1561916K 59568K fg u0_a58 org.mazhuang.boottimemeasure ... 各列含义： 列名 含义 PID 进程 ID PR 优先级 CPU% 当前瞬间占用 CPU 百分比 S 进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程） #THR 线程数 VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PCY 调度策略优先级，SP_BACKGROUND/SPFOREGROUND UID 进程所有者的用户 ID NAME 进程名 top 命令还支持一些命令行参数，详细用法如下： 1234567Usage: top [ -m max_procs ] [ -n iterations ] [ -d delay ] [ -s sort_column ] [ -t ] [ -h ] -m num 最多显示多少个进程 -n num 刷新多少次后退出 -d num 刷新时间间隔（单位秒，默认值 5） -s col 按某列排序（可用 col 值：cpu, vss, rss, thr） -t 显示线程信息 -h 显示帮助文档 查看进程 UID有两种方案： adb shell dumpsys package &lt;packagename&gt; | grep userId= 如： 12$ adb shell dumpsys package org.mazhuang.guanggoo | grep userId= userId=10394 通过 ps 命令找到对应进程的 pid 之后 adb shell cat /proc/&lt;pid&gt;/status | grep Uid 如： 123456$ adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394 28635 770 1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid: 10394 10394 10394 10394gemini:/ $ 其它如下是其它常用命令的简单描述，前文已经专门讲过的命令不再额外说明： 命令 功能 cat 显示文件内容 cd 切换目录 chmod 改变文件的存取模式/访问权限 df 查看磁盘空间使用情况 grep 过滤输出 kill 杀死指定 PID 的进程 ls 列举目录内容 mount 挂载目录的查看和管理 mv 移动或重命名文件 ps 查看正在运行的进程 rm 删除文件 top 查看进程的资源占用情况 常见问题启动 adb server 失败出错提示 1error: protocol fault (couldn't read status): No error 可能原因 adb server 进程想使用的 5037 端口被占用。 解决方案 找到占用 5037 端口的进程，然后终止它。以 Windows 下为例： 12345netstat -ano | findstr LISTENING...TCP 0.0.0.0:5037 0.0.0.0:0 LISTENING 1548... 这里 1548 即为进程 ID，用命令结束该进程： 1taskkill /PID 1548 然后再启动 adb 就没问题了。 com.android.ddmlib.AdbCommandRejectedException在 Android Studio 里新建一个模拟器，但是用 adb 一直连接不上，提示： 1234com.android.ddmlib.AdbCommandRejectedException: device unauthorized.This adb server's $ADB_VENDOR_KEYS is not setTry 'adb kill-server' if that seems wrong.Otherwise check for a confirmation dialog on your device. 在手机上安装一个终端然后执行 su 提示没有该命令，这不正常。 于是删除该模拟器后重新下载安装一次，这次就正常了。 adb 的非官方实现 fb-adb - A better shell for Android devices (for Mac). 相关命令 aapt am dumsys pm uiautomator 致谢感谢朋友们无私的分享与补充（排名不分先后）。 zxning，linhua55，codeskyblue，seasonyuu，fan123199，zhEdward，0x8BADFOOD，keith666666，shawnlinboy，s-xq，lucky9322。 参考链接 Android Debug Bridge ADB Shell Commands logcat Command-line Tool Android ADB命令大全 adb 命令行的使用记录 Android ADB命令大全(通过ADB命令查看wifi密码、MAC地址、设备信息、操作文件、查看文件、日志信息、卸载、启动和安装APK等) 那些做Android开发必须知道的ADB命令 adb shell top 像高手一样使用ADB命令行（2）","link":"/2019/10/11/README/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"},{"name":"面试题","slug":"面试题","link":"/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"壁纸路径","slug":"壁纸路径","link":"/tags/%E5%A3%81%E7%BA%B8%E8%B7%AF%E5%BE%84/"},{"name":"Mac系统","slug":"Mac系统","link":"/tags/Mac%E7%B3%BB%E7%BB%9F/"},{"name":"谷歌云","slug":"谷歌云","link":"/tags/%E8%B0%B7%E6%AD%8C%E4%BA%91/"},{"name":"so文件","slug":"so文件","link":"/tags/so%E6%96%87%E4%BB%B6/"},{"name":"ndk","slug":"ndk","link":"/tags/ndk/"},{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/%E7%BF%BB%E5%A2%99/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"ShadowRocket","slug":"ShadowRocket","link":"/tags/ShadowRocket/"},{"name":"小火箭","slug":"小火箭","link":"/tags/%E5%B0%8F%E7%81%AB%E7%AE%AD/"},{"name":"Appstore","slug":"Appstore","link":"/tags/Appstore/"},{"name":"vpn","slug":"vpn","link":"/tags/vpn/"},{"name":"AAPT","slug":"AAPT","link":"/tags/AAPT/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"ApkBuilder","slug":"ApkBuilder","link":"/tags/ApkBuilder/"},{"name":"Dex工具","slug":"Dex工具","link":"/tags/Dex%E5%B7%A5%E5%85%B7/"},{"name":"zipalign工具","slug":"zipalign工具","link":"/tags/zipalign%E5%B7%A5%E5%85%B7/"},{"name":"keystore","slug":"keystore","link":"/tags/keystore/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"开车司机","slug":"开车司机","link":"/tags/%E5%BC%80%E8%BD%A6%E5%8F%B8%E6%9C%BA/"},{"name":"番号","slug":"番号","link":"/tags/%E7%95%AA%E5%8F%B7/"},{"name":"pornograhic","slug":"pornograhic","link":"/tags/pornograhic/"},{"name":"spread pornograhic content","slug":"spread-pornograhic-content","link":"/tags/spread-pornograhic-content/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"序列化","slug":"序列化","link":"/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"ClashX","slug":"ClashX","link":"/tags/ClashX/"},{"name":"加速器","slug":"加速器","link":"/tags/%E5%8A%A0%E9%80%9F%E5%99%A8/"},{"name":"Shadowsocks","slug":"Shadowsocks","link":"/tags/Shadowsocks/"},{"name":"V2Ray","slug":"V2Ray","link":"/tags/V2Ray/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/%E6%90%AC%E7%93%A6%E5%B7%A5/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python3","slug":"Python3","link":"/tags/Python3/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"人工智能","slug":"人工智能","link":"/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"},{"name":"小游戏开发","slug":"小游戏开发","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"},{"name":"ADB","slug":"ADB","link":"/tags/ADB/"},{"name":"热修复","slug":"热修复","link":"/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"底层","slug":"底层","link":"/tags/%E5%BA%95%E5%B1%82/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"并发","slug":"并发","link":"/tags/%E5%B9%B6%E5%8F%91/"},{"name":"Thread","slug":"Thread","link":"/tags/Thread/"},{"name":"ThreadPool","slug":"ThreadPool","link":"/tags/ThreadPool/"},{"name":"Java基础知识","slug":"Java基础知识","link":"/tags/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"近代史","slug":"近代史","link":"/tags/%E8%BF%91%E4%BB%A3%E5%8F%B2/"},{"name":"近代历史","slug":"近代历史","link":"/tags/%E8%BF%91%E4%BB%A3%E5%8E%86%E5%8F%B2/"},{"name":"历史题","slug":"历史题","link":"/tags/%E5%8E%86%E5%8F%B2%E9%A2%98/"},{"name":"命令行","slug":"命令行","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}],"categories":[{"name":"Android基础","slug":"Android基础","link":"/categories/Android%E5%9F%BA%E7%A1%80/"},{"name":"Mac应用","slug":"Mac应用","link":"/categories/Mac%E5%BA%94%E7%94%A8/"},{"name":"科学上网","slug":"科学上网","link":"/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"精品美文","slug":"精品美文","link":"/categories/%E7%B2%BE%E5%93%81%E7%BE%8E%E6%96%87/"},{"name":"IOS应用","slug":"IOS应用","link":"/categories/IOS%E5%BA%94%E7%94%A8/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"学习资料","slug":"学习资料","link":"/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"},{"name":"自考","slug":"自考","link":"/categories/%E8%87%AA%E8%80%83/"}]}