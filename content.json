{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"SSH通用命令","text":"Quick Start查看当前ss服务器所开放的端口1$ ss -lntp | grep ssserver 查看当前ss服务器的密码，通过以下命令可见ss的配置文件1$ ps aux | grep ssserver 用cat查看下配置文件1$ cat /etc/shadowsocks.json 修改ss密码1$ vi /etc/shadowsocks.json 按i键进入编辑模式，修改密码为123456“password”:”123456”, 重启ss即可1$ service shadowsocks restart 启动：service shadowsocks start停止：service shadowsocks stop重启：service shadowsocks restart状态：service shadowsocks status","link":"/2019/02/20/SSH常用命令/"},{"title":"Android 经典蓝牙通讯传输Demo","text":"BlueUtils经典蓝牙搜索，连接，数据传输小DEMO 通过经典模式 搜索 蓝牙应用。蓝牙有蓝牙1.0、蓝牙2.0、蓝牙3.0、蓝牙4.0之类的以数字结尾的蓝牙版本号，而实际上，在最新的标准中，已经不再使用数字版本号作为蓝牙版本的区分了，取而代之的是经典蓝牙与低功耗蓝牙（BLE）这两种区别。BLE 蓝牙不做过多讲解。具体的信息大家可以参考。 https://www.jianshu.com/p/fc46c154eb77 (经典蓝牙) https://www.jianshu.com/p/3a372af38103 (BLE蓝牙) 流程 发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信 经典蓝牙和低功耗蓝牙除了配对/绑定这个环节是一样的之外，其它三个环节都是不同的。 截图 详解 公司最近在要做一个蓝牙与串口通讯的项目，然后就涉及到手机端与蓝牙的连接及数据交互。大致需求就是通过手机搜索硬件蓝牙 设备，然后连接上蓝牙，通过手机端的指令消息来获取串口信息，在通过蓝牙返回数据到手机端。在这之前看了一些开源的项目， 包括BluetoothKit，FastBle，BluetoothHelper等其中BluetoothKit和FastBle只支持BLE 模式蓝牙，因为硬件的模式是 经典模式，后来自己在两个项目的基础上做了一些修改，然后可以搜索到经典蓝牙。但是怎么也是连接不上我们的硬件设备。（应 该是底层不是经典蓝牙连接导致。）后来发现了BluetoothHelper项目。在这个项目的基础上做了一些修改及优化 ，能够满足 项目需求，现在将这个项目做了分包及优化。然后在这分享自己的一些踩坑心得。 第一步：声明所需要的权限&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt; 使用蓝牙所需要的权限 &lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt; 使用扫描和设置蓝牙的权限（申明这一个权限必须申明上面一个权限） 在Android5.0之前，是默认申请GPS硬件功能的。而在Android 5.0 之后，需要在manifest 中申明GPS硬件模块功能的使用。 &lt;!-- Needed only if your app targets Android 5.0 (API level 21) or higher. --&gt; &lt;uses-feature android:name=&quot;android.hardware.location.gps&quot; /&gt; 在 Android 6.0 及以上，还需要打开位置权限。如果应用没有位置权限，蓝牙扫描功能不能使用（其它蓝牙操作例如连接蓝牙设备和写入数据不受影响）。 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&gt; 第二步：初始化实例在页面首先初始化一个BlueManager。 private BlueManager bluemanage; bluemanage = BlueManager.getInstance(getApplicationContext()); 第三步：设置实例监听 然后为这个蓝牙管理器设置监听(OnSearchDeviceListener，OnConnectListener，OnSendMessageListener，OnReceiveMessageListener) /** * 初始化蓝牙管理，设置监听 */ public void initBlueManager() { bluemanage = BlueManager.getInstance(getApplicationContext()); bluemanage.setOnSearchDeviceListener(onSearchDeviceListener); bluemanage.setOnConnectListener(onConnectListener); bluemanage.setOnSendMessageListener(onSendMessageListener); bluemanage.setOnReceiveMessageListener(onReceiveMessageListener); bluemanage.requestEnableBt(); } 第四步：开启蓝牙搜索蓝牙设备通过调用 bluemanage.requestEnableBt()开启蓝牙， 调用searchDevices 获取蓝牙设备。在做蓝牙操作前，要确保各个监听器已经设置好。 搜索监听如下： onSearchDeviceListener =new OnSearchDeviceListener() { @Override public void onStartDiscovery() { Log.d(TAG, &quot;onStartDiscovery()&quot;); } @Override public void onNewDeviceFound(BluetoothDevice device) { Log.d(TAG, &quot;new device: &quot; + device.getName() + &quot; &quot; + device.getAddress()); } @Override public void onSearchCompleted(List&lt;BluetoothDevice&gt; bondedList, List&lt;BluetoothDevice&gt; newList) { Log.d(TAG, &quot;SearchCompleted: bondedList&quot; + bondedList.toString()); Log.d(TAG, &quot;SearchCompleted: newList&quot; + newList.toString()); } @Override public void onError(Exception e) { e.printStackTrace(); } } 通过 BlueManager里的searchDevices方法，里边其实就是获取了一个BluetoothAdapter然后，通过调用mBluetoothAda pter.startDiscovery()方法来搜索经典蓝牙设备。这里如果调用 mBluetoothAdapter.startLeScan(mLeScanCallback); 搜索的就是BLE蓝牙。然后在这之前需要动态注册一个BroadcastReceiver来监听 蓝牙的搜索情况，在通过onReceive中去判 断设备的类型，是不是新设备，是不是已经连接过。将设备加入集合当中。 搜索代码如下 /** * discovery the devices. */ public void searchDevices() { try { if (mCurrStatus == STATUS.FREE) { mCurrStatus = STATUS.DISCOVERING; checkNotNull(mOnSearchDeviceListener); if (mBondedList == null) mBondedList = new ArrayList&lt;&gt;(); if (mNewList == null) mNewList = new ArrayList&lt;&gt;(); if (mBluetoothAdapter == null) { mOnSearchDeviceListener.onError(new NullPointerException(DEVICE_HAS_NOT_BLUETOOTH_MODULE)); return; } if (mReceiver == null) mReceiver = new Receiver(); // ACTION_FOUND IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); mContext.registerReceiver(mReceiver, filter); // ACTION_DISCOVERY_FINISHED filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); mContext.registerReceiver(mReceiver, filter); mNeed2unRegister = true; mBondedList.clear(); mNewList.clear(); if (mBluetoothAdapter.isDiscovering()) //先判断是否在扫描 mBluetoothAdapter.cancelDiscovery();//取消扫描 mBluetoothAdapter.startDiscovery(); //开始扫描蓝牙 mOnSearchDeviceListener.onStartDiscovery(); } } catch (Exception e) { e.printStackTrace(); } } 第五步：连接蓝牙设备 当调用connectDevice(mac)方法时，因为连接蓝牙是一很耗时的操作，所以需要开启一个线程去连接蓝牙。 /** * 连接bluetooth * * @param mac */ public void connectDevice(String mac) { try { if (mCurrStatus != STATUS.CONNECTED) { if (mac == null || TextUtils.isEmpty(mac)) throw new IllegalArgumentException(&quot;mac address is null or empty!&quot;); if (!BluetoothAdapter.checkBluetoothAddress(mac)) throw new IllegalArgumentException(&quot;mac address is not correct! make sure it&apos;s upper case!&quot;); if (mReadable = false) { mReadable = true; } if (mWritable = false) { mWritable = true; } if (onConnectListener != null) { onConnectListener.onConnectStart(); ConnectDeviceRunnable connectDeviceRunnable = new ConnectDeviceRunnable(mac); checkNotNull(mExecutorService); mExecutorService.submit(connectDeviceRunnable); } } else { Log.i(&quot;blue&quot;, &quot;the blue is connected !&quot;); } } catch (IllegalArgumentException e) { e.printStackTrace(); } } 在连接的线程run方法中，通过调用mBluetoothAdapter.getRemoteDevice 获取远程蓝牙信息，通过 createInsecureRfcommSocketToServiceRecord获得一个与远程蓝牙的socket连接。通过这个socket连接获取输入 流和输出流进行数据的读写。 if (onConnectListener == null) { Log.i(&quot;blue&quot;, &quot;the connectListener is null !&quot;); return; } BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(mac); mBluetoothAdapter.cancelDiscovery(); mCurrStatus = STATUS.FREE; Log.d(TAG, &quot;prepare to connect: &quot; + remoteDevice.getAddress() + &quot; &quot; + remoteDevice.getName()); mSocket = remoteDevice.createInsecureRfcommSocketToServiceRecord(UUID.fromString(Constants.STR_UUID)); onConnectListener.onConnectting(); mSocket.connect(); mInputStream = mSocket.getInputStream(); mOutputStream = mSocket.getOutputStream(); mCurrStatus = STATUS.CONNECTED; onConnectListener.onConectSuccess(); 第六步：向蓝牙设备发送消息当设备连接成功之后，就可以给蓝牙设备发送消息了。 通过调用bluemanage.sendMessage(MessageBean mesaage， needResponse)方法，在bluemange里会开起一个WriteRunnable写线程和一个ReadRunnable去获取输入流和输出流 的实时数据，读线程只会在第一次发消息时初始化一次。以后都是用这个线程去读从蓝牙返回的数据。写数据的线程 在每次调用的时候都会从新初始化。(待优化) 在WriteRunnable中的润写数据 writer.write(item.text); writer.newLine(); writer.flush(); 在WriteRunnable 的run方法中通过mOutputStream流将数据传送给蓝牙设备,当蓝牙接受到消息之后会和串口进行 通信，具体的通信协议是根据各个厂商自己协商的。当串口接受数据执行操作，获取数据然后在返回数据给蓝牙，蓝 牙也就有返回数据。 第七步：从蓝牙设备读取消息在ReadRunnable中从mInputStream里不断的读取数据。这里有一个问题，就是有的时候从蓝牙 口读取的数据并不是一个完整的数据，这里是一个坑。首先你需要知道你需要什么数据，什么格式，数据的长度。这 里我们的数据的格式类似是一帧一帧，而且我们的帧长度固定大小是10。那么我们就可以在这里做一些你想做的事了。 坑 有时候从蓝牙socket 中读取的数据不完整读数据不完整，是因为我们开启线程之后会一直读，有时候蓝牙并没有返回数据，或者没有返回完整数据，这个时候 我们需要在这做一些特殊处理。 int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } 通过以上代码可以确保读的数据不会是0。通过下边的代码可以确保读到完整数据之后才会走我的回调，保证了数据 的完整性。这里的what只是我用来区分当前读到的数据是进度信息，还是真正想要的信息。 if (onReceiveMessageListener == null) { Log.i(&quot;blue&quot;, &quot;the receiverMessageListener is null !&quot;); return; } mReadable = true; InputStream stream = mInputStream; while (mCurrStatus != STATUS.CONNECTED &amp;&amp; mReadable) ; checkNotNull(stream); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; StringBuilder builder = new StringBuilder(); while (mReadable) { int count = 0; while (count == 0) { count = stream.available();//输入流中的数据个数。 } if (count == 10 &amp;&amp; what) { int num = stream.read(buffer); String progress = TypeConversion.bytesToHexStrings(buffer); Log.i(&quot;progress&quot;, progress); onReceiveMessageListener.onProgressUpdate(progress, 0); } else if (count &gt;= 10) { what = false; int num = stream.read(buffer); String detect = TypeConversion.bytesToHexStrings(buffer); builder.append(detect); Log.i(&quot;detect&quot;, detect); if (detect.endsWith(&quot;04 &quot;)) { number++; } if (number == 5) { onReceiveMessageListener.onDetectDataFinish(); onReceiveMessageListener.onNewLine(builder.toString().trim()); builder.delete(0, builder.length()); } else { onReceiveMessageListener.onDetectDataUpdate(detect); } } } 当读到满足条件的完整数据，就会调用ReceiveMessageListener 中的各个方法。到这里从蓝牙读取数据的流程， 大致介绍完。 下边是BlueManager提供的一些方法：requestEnableBt() 开启蓝牙 searchDevices() 搜索蓝牙设备 connectDevice() 连接蓝牙设备 closeDevice() 断开蓝牙连接 sendMessage() 发送消息 close() 关闭销毁蓝牙 结尾BlueManager大概的使用流程及大致原理就说到这里，口才不是很好，平常也不怎么写博客，有什么问题大家可以 探讨一下。项目代码部分参考BluetoothHelper 项目，在此基础上做了一些分包优化。如有雷同，不属巧合， 我就是抄的你的。哈哈哈哈~~ 希望对那些在踩蓝牙坑的小伙伴有帮助~~~ Contact MeQQ: 798774875 Email: moruoyiming123@gmail.com GitHub: https://github.com/moruoyiming","link":"/2018/06/06/Android经典蓝牙通讯传输DEMO/"},{"title":"快速手动搭建SS服务器简明详细教程","text":"优惠购买搬瓦工搬瓦工VPS相对其它的云服务产商来说，性价比高，使用起来速度快。通过优惠码购买还能再降低最多 %6 的一些费用。在这基础上使用优惠码可以少一些费用，根据你对配置的需要进行选择服务器，以下是可以获取优惠码的链接： | 搬瓦工配置 | 搬瓦工费用 | 优惠链接 || — | — | — || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $25.99/半年 | 点击进入 || SPECIAL 40G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 40 GB RAID-10RAM内存: 2048 MBCPU处理器: 1x Intel XeonTransfer流量: 2000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $27.99/季 | 点击进入 || SPECIAL 20G KVM PROMO V3 - LOS ANGELES - CN2 SSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 1x Intel XeonTransfer流量: 1000 GB/月连接速度: 1 Gigabit洛杉矶机房，CN2路线，使用中国的直线路线，速度加快 | $29.99 /半年 | 点击进入 || 80G KVM – PROMOSSD硬盘: 80 GB RAID-10RAM内存: 4 GBCPU处理器: 4x Intel XeonTransfer流量: 3 TB/mo连接速度: 1 GigabitMultiple locations | $19.99/月 | 点击进入 || 20G KVM – PROMOSSD硬盘: 20 GB RAID-10RAM内存: 1024 MBCPU处理器: 2x Intel XeonTransfer流量: 1 TB/mo连接速度: 1 GigabitMultiple locations | $49.99/年 | 点击进入 || 40G KVM – PROMOSSD硬盘: 40 GB RAID-10RAM内存: 2 GBCPU处理器: 3x Intel XeonTransfer流量: 2 TB/mo连接速度: 1 GigabitMultiple locations | $99.99/年 | 点击进入 || 160G KVM – PROMOSSD硬盘: 160 GB RAID-10RAM内存: 8 GBCPU处理器: 5x Intel XeonTransfer流量: 4 TB/mo连接速度: 1 GigabitMultiple locations | $39.99/月 | 点击进入 || 3200G KVM – PROMOSSD硬盘: 320 GB RAID-10RAM内存: 16 GBCPU处理器: 6x Intel XeonTransfer流量: 5 TB/mo连接速度: 1 GigabitMultiple locations | $79.99/月 | 点击进入 | 进入之后就可以获取优惠码了，选择完之后不要急着点击 「Add to Cart」。 这时候就可以获取隐藏的优惠码了，我们对着这个网页：鼠标右击--&gt;查看网页源代码。 接着 Ctrl + F 搜索 code ，这时候你就会看到 Try this promo code: xxxx，这里的xxxx就是优惠吗，把它复制下来。 页面的 Location 就是选择服务器的地址，到时访问谷歌的时候会显示你当前访问的地址。好了，我们点击「Add to Cart」。 接下来，进入结算页面，我们刚才复制的优惠码就派上用场了，将你刚刚复制的优惠码复制进去然后点击 「Validate Code」，看！是不是优惠了！一般人不知道这种操作: 接着点击「CheckOut」完成付款即可。付款的时候选择 Alipay 就可以使用支付宝付款。 获取搬瓦工服务器的ip，端口，账号密码购买完毕后你就拥有一台你自己的服务器了，接着点击Services下的MyServices，可以看到你的服务器： 我们点击「KiwiVM Control Panel」进入管理界面： 可以看到你服务器的信息: 有了搬瓦工服务器的IP地址和端口,我们就可以连接了： 账号是root，密码可以在这里获取： 使用 SSH 工具连接到搬瓦工服务器 远程连接工具我一直用的是 SecureCRT , 当然你也可以使用其它的 SSH 工具。破解版的SecureCRT可以在百度网盘这里获取： 链接: https://pan.baidu.com/s/11W4WHjCjmiNw6einQNrcPg 提取码: tyux 开始快读搭建ss服务器安装 wget ：1yum install wget 执行安装ss：1wget –no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh 获取shadowsocks.sh读取权限1chmod +x shadowsocks.sh 设置ss密码端口和加密方式当你输入./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log后就可以设置密码和端口号了： 设置完密码和端口号之后，我们选择加密方式，这里选择 7： 接着按任意键进行安装。 安装ss完成等一会之后，就安装完成了，它会给你显示你需要连接vpn的信息： 可以看到需要连接ss的ip地址，密码，端口，和加密方式。 将这些信息保存起来，那么这时候你就可以使用它们来科学上网啦。 使用Shadowsocks打开 Shadowsocks 客户端，输入ip地址，密码，端口，和加密方式。接着点击确定，右下角会有个小飞机按钮，右键–&gt;启动代理。 这时候就可以科学上网了。 访问以下 Youtube 和 Google 试试看，速度还可以的： 使用BBR加速器让访问速度加速，飞起来！使用 BBR 加速工具。 安装 BBR1wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh 获取读写权限1chmod +x bbr.sh 启动BBR安装1./bbr.sh 接着按任意键，开始安装，坐等一会。安装完成一会之后它会提示我们是否重新启动vps，我们输入 y 确定重启服务器。 重新启动之后，输入 lsmod | grep bbr 如果看到 tcp_bbr 就说明 BBR 已经启动了。 再访问一下 Youtube，1080p 超高清，很顺畅不卡顿！ 本文为转载，出处 https://www.cnbanwagong.com/6.html","link":"/2019/02/21/搬瓦工快速手动搭建SS(Shadowsocks)服务器/"},{"title":"JNI 串口通讯库 SerialPort开发封装","text":"SerialportManagerJNI 串口通讯库 SerialPort开发封装前言 最近工作比较清闲，闲来无事，把原先项目用到的串口通讯项目所涉及到的知识及项目简化出来一个库，方便以后开发新项目。同时希望 对其他小伙伴有所帮助。项目涉及到 ndk工程构建及硬件串口通讯。期间涉及到硬件屏幕功能开发这里不做多介绍。 下面从NDK项目构建开始说起。 NDK是Google为便于Android开发提供的一种原生开发集：Native Development Kit，而且也是一个包含API、构建工具、交叉编译、调 试器、文档示例等一系列的工具集，可以帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成APK。 与NDK密切相关的另一个词汇则是JNI，它是NDK开发中的枢纽，Java与底层交互绝大多数都是通过它来完成的，那么接下来看看什么是 JNI? JNI：Java Native Interface 也就是java本地接口，它是一个协议，这个协议用来沟通java代码和本地代码(c/c++)。通过这个 协议，Java类的某些方法可以使用原生实现，同时让它们可以像普通的Java方法一样被调用和使用，而原生方法也可以使用Java对象， 调用和使用Java方法。也就是说，使用JNI这种协议可以实现：java代码调用c/c++代码，而c/c++代码也可以调用java代码。 那为什么要使用NDK开发呢？ 我们都知道，java是半解释型语言，很容易被反汇编后拿到源代码文件，在开发一些重要协议时，我们为了安全起见，使用C语言来编写 这些重要的部分，来增大系统的安全性。 在一些复杂性的计算中，要求高性能的场景中，C/C++更加的有效率，代码也更便于复用。 当然还有其他的优点，这些都驱使我们选择相对来说高效和安全的DNK来开发我们的应用程序。 NDK环境搭建1.下载NDK 首先下载NDK，可以从AndroidStudio中的SDK Manager中下载，也可自己单独下载 点击按钮进入 或者进入http://www.androiddevtools.cn/ 下载 Windows 64-bit Mac OS X 如单独下载 1). 解压NDK的zip包，注意路径目录不要出现空格和中文，这里建议大家把包解压到SDK目录里面，并命名为ndk-bundle，好处是，启动AS的时候会检查它并直接添加到ndk.dir中，减少我们的配置工作； 2). 配置path : 把解压好的路径添加到环境变量path中； 3). ndk-build：cd到解压后NDK的根目录，执行ndk-build命令。 2.安装配置NDK AndroidStudio 点击File -&gt; Other Settings -&gt; Default Project Strjucture 如图 到这里NDK配置完成，接下来 开始 NDK 开发。 NDK项目开发 在library 中的 build.gradle 文件中的 defaultConfig 中 配置 ndk { moduleName &quot;serial_port&quot; // 设置支持的SO库架构 abiFilters &apos;armeabi&apos;, &apos;x86&apos;, &apos;armeabi-v7a&apos;, &apos;x86_64&apos;, &apos;arm64-v8a&apos; } 在android 中配置 sourceSets { main { jni.srcDirs = [&apos;src/main/jni&apos;, &apos;src/main/jni/&apos;] } } externalNativeBuild { ndkBuild { path &apos;src/main/jni/Android.mk&apos; } } 如图 Android.mk 文件中配置如下内容 Android.mk用法详解 # # Copyright 2009 Cedric Priscal # # Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an &quot;AS IS&quot; BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) TARGET_PLATFORM := android-3 LOCAL_MODULE := serial_port //项目名称 LOCAL_SRC_FILES := SerialPort.c //底层c LOCAL_LDLIBS := -llog include $(BUILD_SHARED_LIBRARY) 在main目录下创建一个jni文件目录，并将 Android.mk 文件放到jni文件下 直接使用网上 SerialPort.java 类，里边封装底层方法 package com.serialport.library.core; import java.io.File; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; /** * Created by Jian on 2017/8/7. * 用来加载SO文件，通过JNI的方式打开关闭串口 */ public class SerialPort { private static final String TAG = &quot;SerialPort&quot;; /* * Do not remove or rename the field mFd: it is used by native method close(); */ private FileDescriptor mFd; private FileInputStream mFileInputStream; private FileOutputStream mFileOutputStream; public SerialPort(File device, int baudrate, int flags) throws SecurityException, IOException { /* Check access permission */ if (!device.canRead() || !device.canWrite()) { try { /* Missing read/write permission, trying to chmod the file */ Process su; su = Runtime.getRuntime().exec(&quot;/system/bin/su&quot;); String cmd = &quot;chmod 666 &quot; + device.getAbsolutePath() + &quot;\\n&quot; + &quot;exit\\n&quot;; su.getOutputStream().write(cmd.getBytes()); if ((su.waitFor() != 0) || !device.canRead() || !device.canWrite()) { throw new SecurityException(); } } catch (Exception e) { e.printStackTrace(); throw new SecurityException(); } } mFd = open(device.getAbsolutePath(), baudrate, flags); if (mFd == null) { throw new IOException(); } mFileInputStream = new FileInputStream(mFd); mFileOutputStream = new FileOutputStream(mFd); } // Getters and setters public InputStream getInputStream() { return mFileInputStream; } public OutputStream getOutputStream() { return new FileOutputStream(mFd); } // JNI private native static FileDescriptor open(String path, int baudrate, int flags); public native void close(); static { System.loadLibrary(&quot;serial_port&quot;); } } 点击”View-&gt;Tool Windows-&gt;Terminal”，即在Studio中进行终端命令行工具.执行如下命令生成c语言头文件: cd 到目录java/ 下执行 javah -o SerialPort.h -jni com.serialport.library.core.SerialPort javah -o SerialPort.h -jni com.serialport.library.core.SerialPort com.serialport.library.core 为包名。 SerialPort.h 文件如下 /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class com_serialport_library_core_SerialPort */ #ifndef _Included_com_serialport_library_core_SerialPort #define _Included_com_serialport_library_core_SerialPort #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *, jclass, jstring, jint, jint); /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 并把 SerialPort.h 头文件转移到jni文件夹下 创建实现头文件的.C源文件，将 com_serialport_library_core 为SerialPort.java 文件位置，将该 path 替换成其他 项目包名 符号.换成_ /* * Copyright 2009-2011 Cedric Priscal * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;jni.h&gt; #include &quot;SerialPort.h&quot; #include &quot;android/log.h&quot; static const char *TAG = &quot;serial_port&quot;; #define LOGI(fmt, args...) __android_log_print(ANDROID_LOG_INFO, TAG, fmt, ##args) #define LOGD(fmt, args...) __android_log_print(ANDROID_LOG_DEBUG, TAG, fmt, ##args) #define LOGE(fmt, args...) __android_log_print(ANDROID_LOG_ERROR, TAG, fmt, ##args) static speed_t getBaudrate(jint baudrate) { switch (baudrate) { case 0: return B0; ... default: return -1; } } /* * Class: com_serialport_library_core_SerialPort * Method: open * Signature: (Ljava/lang/String;II)Ljava/io/FileDescriptor; */ JNIEXPORT jobject JNICALL Java_com_serialport_library_core_SerialPort_open (JNIEnv *env, jclass thiz, jstring path, jint baudrate, jint flags) { int fd; speed_t speed; jobject mFileDescriptor; /* Check arguments */ { speed = getBaudrate(baudrate); if (speed == -1) { /* TODO: throw an exception */ LOGE(&quot;Invalid baudrate&quot;); return NULL; } } /* Opening device */ { jboolean iscopy; const char *path_utf = (*env)-&gt;GetStringUTFChars(env, path, &amp;iscopy); LOGD(&quot;Opening serial port %s with flags 0x%x&quot;, path_utf, O_RDWR | flags); fd = open(path_utf, O_RDWR | flags); LOGD(&quot;open() fd = %d&quot;, fd); (*env)-&gt;ReleaseStringUTFChars(env, path, path_utf); if (fd == -1) { /* Throw an exception */ LOGE(&quot;Cannot open port&quot;); /* TODO: throw an exception */ return NULL; } } /* Configure device */ { struct termios cfg; LOGD(&quot;Configuring serial port&quot;); if (tcgetattr(fd, &amp;cfg)) { LOGE(&quot;tcgetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } cfmakeraw(&amp;cfg); cfsetispeed(&amp;cfg, speed); cfsetospeed(&amp;cfg, speed); if (tcsetattr(fd, TCSANOW, &amp;cfg)) { LOGE(&quot;tcsetattr() failed&quot;); close(fd); /* TODO: throw an exception */ return NULL; } } /* Create a corresponding file descriptor */ { jclass cFileDescriptor = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jmethodID iFileDescriptor = (*env)-&gt;GetMethodID(env, cFileDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, cFileDescriptor, &quot;descriptor&quot;, &quot;I&quot;); mFileDescriptor = (*env)-&gt;NewObject(env, cFileDescriptor, iFileDescriptor); (*env)-&gt;SetIntField(env, mFileDescriptor, descriptorID, (jint) fd); } return mFileDescriptor; } /* * Class: com_serialport_library_core_SerialPort * Method: close * Signature: ()V */ JNIEXPORT void JNICALL Java_com_serialport_library_core_SerialPort_close (JNIEnv *env, jobject thiz) { jclass SerialPortClass = (*env)-&gt;GetObjectClass(env, thiz); jclass FileDescriptorClass = (*env)-&gt;FindClass(env, &quot;java/io/FileDescriptor&quot;); jfieldID mFdID = (*env)-&gt;GetFieldID(env, SerialPortClass, &quot;mFd&quot;, &quot;Ljava/io/FileDescriptor;&quot;); jfieldID descriptorID = (*env)-&gt;GetFieldID(env, FileDescriptorClass, &quot;descriptor&quot;, &quot;I&quot;); jobject mFd = (*env)-&gt;GetObjectField(env, thiz, mFdID); jint descriptor = (*env)-&gt;GetIntField(env, mFd, descriptorID); LOGD(&quot;close(fd = %d)&quot;, descriptor); close(descriptor); } 到此 NDK 项目搭建完成。接下来 介绍一下 SerialPortManager 类库 下图为类库的介绍 SerialPort.java 封装底层开关串口方法 SerialPortFinder.java 获取所有串口方法 OnS3DataReceiverListener.java 和 OnS6DataReceiverListener.java 是串口响应数据监听。当接收到串口数据会调 接口方法，我们的硬件设备S3口监听主板数据，S6口监听硬件屏幕数据。 BaseProtocol.java 提供指令封装方法。根据各个设备硬件串口协议，继承、封装。 SerialportManager.java 串口管理对象 SerialportManager.java 串口管理对象，该对象为单例。底层对 SerialPort 进行封装、管理。 private SerialPort mSerialPort; mSerialPort = new SerialPort(new File(path), baudrate, 0);//根据串口名，波特率 生成串口管理对象 mOutputStream = mSerialPort.getOutputStream(); //获取串口的输出流 mInputStream = mSerialPort.getInputStream(); //获取串口的输入流 开启一个新线程循环读取串口信息 if (mReadThread == null) { mReadThread = new ReadThread(); mReadThread.start(); } 线程方法中通过输入流获取串口数据 返回数据为byte数组，当获取到数据回调 onS3DataReceiverListener 接口方法 private class ReadThread extends Thread { @Override public void run() { super.run(); while (!isStop &amp;&amp; !isInterrupted()) { int size; try { if (mInputStream == null) { return; } byte[] buffer = new byte[64]; size = mInputStream.read(buffer); if (size &gt; 0) { if (null != onS3DataReceiverListener) { onS3DataReceiverListener.onS3DataReceive(buffer, size); } } Thread.sleep(10); } catch (Exception e) { Log.i(&quot;readthread&quot;, &quot;throw exception !&quot; + e.toString()); e.printStackTrace(); return; } } } } 下面介绍一下如何使用类库，我们项目串口用的是S3、S6口，如果想用其他串口 请修改SerialportManager中的path/screenpath 如果baudrate也想改也修改对应的数值即可。 SerialportManager.getInstance().setOnS3DataReceiverListener(this);//设置主板串口回调 SerialportManager.getInstance().setOnS6DataReceiverListener(this);//设置屏幕串口回调 SerialportManager.getInstance().InitThread();//初始化对应 读写线程 //因有不同主板类型，屏幕类型。这里对其做了一次封装 SenderManager.getInstance().getSender().sendStartDetect(); 设备开机会轮训配置串口，根据主板类型屏幕类型，生成对应管理对象。然后进行串口数据通讯。当我们串口读到我们的输入数据，会 想onS3DataReceiverListener.onS3DataReceive 回调返回数据。再界面我们拿到数据坐相应操作 @Override public void onS3DataReceive(byte[] buffer, int size) { byte[] mBufferTemp = new byte[size]; System.arraycopy(buffer, 0, mBufferTemp, 0, size); int length = mBufferTemp.length - 1; String tempdata = TypeConversion.bytes2HexString(mBufferTemp); Log.i(&quot;serialport&quot;,tempdata); } 当界面跳转时要及时将OnS3DataReceiverListener、OnS6DataReceiverListener监听remove掉，避免造成内存泄漏。 @Override protected void onPause() { super.onPause(); SerialportManager.getInstance().removeOnS3DataReceiverListener(); SerialportManager.getInstance().removeOnS6DataReceiverListener(); }","link":"/2018/05/10/SerialportManager/"}],"tags":[{"name":"ss","slug":"ss","link":"/tags/ss/"},{"name":"翻墙","slug":"翻墙","link":"/tags/翻墙/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"蓝牙开发","slug":"蓝牙开发","link":"/tags/蓝牙开发/"},{"name":"搬瓦工","slug":"搬瓦工","link":"/tags/搬瓦工/"},{"name":"串口通讯","slug":"串口通讯","link":"/tags/串口通讯/"},{"name":"Serialport","slug":"Serialport","link":"/tags/Serialport/"}],"categories":[{"name":"科学上网","slug":"科学上网","link":"/categories/科学上网/"},{"name":"安卓开发","slug":"安卓开发","link":"/categories/安卓开发/"}]}