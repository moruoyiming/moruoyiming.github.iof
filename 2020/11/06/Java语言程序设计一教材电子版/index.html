<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><meta name="keywords" content="[object Object]"><meta name="description" content="第**1**章    java 语言基础
本章内容**(**一般掌握 3%~5%)
本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。


Java 语言特点



Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个项目开发小组，目标是设计嵌在消费性电子产品的小型分布式系统软件，能够适用于异构网络、多主机体系结构，能实现信息安全传递。项目小组的最初设想是用 C++语言完成这个目标。由于 C++语言的复杂性和不安全性，不能胜任这项工作。为此，项目小组开发一个取名为 Oak 的语言。
Oak 语言在消费性电子产品市场上没有获得青睐。但在当时，Internet 开始流行，人们发明了一种网络传输协议， 这种协议可以在文本中插入图片和声音，能使单调的 Internet 世界变得图文并茂。虽然 Web 页面拥用图文和声音，但仍然是静态的，不具备交互性。要让页面拥有动态画面，并能交互，需要在 Web 页面中嵌入一会段程序。由于在 Internet 上运行的数以千计不同类的计算机，这就要求编写这种程序的语言必须具有平台无关性，并要求语言必须简练，支撑环境要小，而安全性却很高。Oak 语言恰好能够满足这些要求。
将 Oak 语言正式应用于 Internet 还需要进一步完善，还要求有一个支持它的 Web 浏览器。能用于编写浏览器，并获得浏览器扶持的新版本 Oak 语言取名 Java。Internet 得到 Java 语言的支持，可以实现真正的交互，人们使用浏览器能“漫游”丰富多彩的 Internet 世界。
Java 语言是适用于分布式计算环境的面向对象编程语言，它虽类似 C 和C++，但比 C++简单，忽略了许多为提高计算效率，初学者较难掌握的程序语言特性。"><meta name="author" content="Jian"><title>Java语言设计一教材电子版 - Brigitte Jian&#039;Blog</title><meta description="第**1**章    java 语言基础 本章内容**(**一般掌握 3%~5%) 本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。   Java 语言特点    Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个"><meta property="og:type" content="article"><meta property="og:title" content="Java语言设计一教材电子版"><meta property="og:url" content="http://yoursite.com/2020/11/06/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%95%99%E6%9D%90%E7%94%B5%E5%AD%90%E7%89%88/"><meta property="og:site_name" content="Jian&#039;Blog"><meta property="og:description" content="第**1**章    java 语言基础 本章内容**(**一般掌握 3%~5%) 本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。   Java 语言特点    Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-11-06T03:16:33.064Z"><meta property="article:modified_time" content="2020-11-06T03:29:00.681Z"><meta property="article:author" content="Jian"><meta property="article:tag" content="Java"><meta property="article:tag" content="Java基础"><meta property="article:tag" content="自考"><meta property="article:tag" content="Java4747"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="http://yoursite.com/img/avatar.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2020/11/06/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%95%99%E6%9D%90%E7%94%B5%E5%AD%90%E7%89%88/"},"headline":"Java语言设计一教材电子版","image":["http://yoursite.com/img/avatar.png"],"datePublished":"2020-11-06T03:16:33.064Z","dateModified":"2020-11-06T03:29:00.681Z","author":{"@type":"Person","name":"Jian"},"description":"第**1**章    java 语言基础 本章内容**(**一般掌握 3%~5%) 本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。   Java 语言特点    Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个"}</script><link rel="alternative" href="/atom.xml" title="Brigitte Jian&#039;Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-152725054-2" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-152725054-2');</script><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/e-style.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><script data-ad-client="ca-pub-8241795889030186" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><link rel="stylesheet" href="/live2d/waifu.css"><script type="text/javascript" async src="/live2d/autoload.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.png" alt="Brigitte Jian&#039;Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">电影</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://moruoyiming.github.io/"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqad6gy72j23sw2j4x6r.jpg" alt="Java语言设计一教材电子版"></span></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2020-11-06  <a class="commentCountImg" href="/2020/11/06/Java%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%95%99%E6%9D%90%E7%94%B5%E5%AD%90%E7%89%88/#comment-container"><span class="display-none-class">2cc2b31eb7bd534895d90458f8d26188</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="2cc2b31eb7bd534895d90458f8d26188">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 小时  <i class="fas fa-pencil-alt"> </i>27.9 k</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Java语言设计一教材电子版</h1><div class="content"><p><strong>第**</strong>1<strong>**章</strong>    <strong>java</strong> <strong>语言基础</strong></p>
<p><strong>本章内容**</strong>(<strong>**一般掌握</strong> <strong>3%~5%)</strong></p>
<p>本章重点：应用程序和小应用程序的基础知识，程序的开发过程，基本数据类型。本章难点：程序的开发过程，了解一种 Java 程序的开发环境。</p>
<ol>
<li><ol>
<li><strong>Java</strong> <strong>语言特点</strong></li>
</ol>
</li>
</ol>
<p>Java 语言最初的应用对象是消费性电子产品(即 PDA 、电子游戏机、电视机顶盒之类的产品)。为了进入消费性电子产品市场，SUN 公司专门成立了一个项目开发小组，目标是设计嵌在消费性电子产品的小型分布式系统软件，能够适用于异构网络、多主机体系结构，能实现信息安全传递。项目小组的最初设想是用 C++语言完成这个目标。由于 C++语言的复杂性和不安全性，不能胜任这项工作。为此，项目小组开发一个取名为 Oak 的语言。</p>
<p>Oak 语言在消费性电子产品市场上没有获得青睐。但在当时，Internet 开始流行，人们发明了一种网络传输协议， 这种协议可以在文本中插入图片和声音，能使单调的 Internet 世界变得图文并茂。虽然 Web 页面拥用图文和声音，但仍然是静态的，不具备交互性。要让页面拥有动态画面，并能交互，需要在 Web 页面中嵌入一会段程序。由于在 Internet 上运行的数以千计不同类的计算机，这就要求编写这种程序的语言必须具有平台无关性，并要求语言必须简练，支撑环境要小，而安全性却很高。Oak 语言恰好能够满足这些要求。</p>
<p>将 Oak 语言正式应用于 Internet 还需要进一步完善，还要求有一个支持它的 Web 浏览器。能用于编写浏览器，并获得浏览器扶持的新版本 Oak 语言取名 Java。Internet 得到 Java 语言的支持，可以实现真正的交互，人们使用浏览器能“漫游”丰富多彩的 Internet 世界。</p>
<p>Java 语言是适用于分布式计算环境的面向对象编程语言，它虽类似 C 和C++，但比 C++简单，忽略了许多为提高计算效率，初学者较难掌握的程序语言特性。<br> <a id="more"></a><br>Java 语言主要有以下<strong>特点</strong>：</p>
<ol>
<li><ol>
<li><ol>
<li><strong>强类型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java 语言是一种强类型语言，强类型能约束程序员必须遵守更多的编程规定，也能让编译器检测出程序中尽可能多的错误。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>编译和解释</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java 语言是一种高级编程语言，用 Java 语言编写的源程序在计算机上运行需经过编译和解释执行两个严格区分的阶段。Java 语言的编译程序先将 Java 源程序翻译成机器无关的字节码(bytecode)，不是通常的编译程序将源程序翻译成计算机的机器代码。运行时，Java 的运行系统和链接需要执行的类，并作必要的优化后，解释执行字节码程序。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>自动无用内存回收功能</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java 语言具有自动无用内存回收功能，程序可以按需使用内存，但不需要对无用内存显式地撤销分配。系统有一个垃圾收集器(garbage collector)，自动收集程序不再使用的内存。这样，能避免显式的撤销分配所引起的安全问题。Java 语言不再含有任何不安全的语言成分。例如，没有指针，数组元素都要检查下标是否越界。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>面向对象</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>面向对象是程序员编写大型程序、有效控制程序复杂性的重要手段。Java 语言在面向对象方面，比 C++更“纯”，它的所有数据类型，包括布尔类型、整形、字符型等，都有相应的类，程序可完全基于对象编写。</p>
<p>面向对象语言主要有<strong>封装性、继承性和多态性</strong>三个特点。封装就是将实现细节隐藏起来，只给出如何使用的信息。数据及数据上的操作用类封装，对象是类的实例，外界使用对象中的数据及可用的操作受到一定的限制。继承体现众多的一种层次对象的特性，下一层的类可从上一层的类继承定义，从上一层类派生的类的对象能继承上一层对象的特性，同时可以改变和扩充一些特性，以适应其自身的特点。多态性的意义主要体现在逻辑上相同的不同层次上的操作，使用相同的操作名，根据具体对象，能自动选择对应的操作。Java 语言很实用地实现了这三种特性。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>与平台无关</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>与平台无关</strong>是对程序<strong>可移植性最直接最有效的支持</strong>。Java 语言的设计者在设计时重点考虑了 Java 程序的可移植性，采用多种机制来保证可移植性，其中最主要的是定义了一种虚拟机(virtual machine),以及虚拟机使用的 java 字节码。在任何平台上,Java 源程序被 Java 编译器编译成虚拟机能够识别的字节码。这样，只要有 Java 虚拟机的平台，就能解释执行 java 字节码程序，从而实现 Java 与平台无关。另外，Java 语言还采用基于国际标准的数据类</p>
<p>型，在任何平台上，同上种数据类型是一致的。例如，用 int 标识 32 位二进制位(bit)整型数据，那么无论在哪一台计算机上，Java 的int 数据都是 32 位整数。相反，C 语言会随着硬软件平台的改变，用 int 标识的整数位数也可能不全相同。</p>
<p>Java 语言提高可移植性的代价是降低程序的执行效率。出于 java 语言也是一种解释执行的语言，Java 程序的执行速度与 C 程序的执行速度有较大的差别。不过，为了尽量弥补执行效率低的缺陷，java 的字节码在设计上非常接近现代计算机的机器码，这有助于提高解释执行的速度。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>安全性</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java 是在网络环境中使用的编程语言，必须考虑安全性问题，主要有以下两个方面：</p>
<p><strong>设计的安全防范</strong>：Java 语言没有指针，避免程序因为指针使用不当，访问不应该访问的内存空间；提供数组元素上标检测机制，禁止程序越界访问内存；提供内存自动回收机制，避免程序遗漏或重复释放内存。</p>
<p><strong>运行安全检查</strong>：为了防止字节码程序可能被非法改动，解释执行前，先对字节码程序作检查，防止网络“黑客” 对字节码程序已作了恶意改动，达到破坏系统的目的。最后，浏览器限制下载的小应用程序不允许访问本地文件， 避免小应用程序破坏本地文件。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>分布式计算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java 语言支持客户机/服务器计算模式。Java 程序能利用 URL 对象，能访问网络上的对象，如同访问本地的文件一样，实现数据分布。另外，Java 的客户机/服务器模式也可以把计算从服务器分散到客户机端，实现操作分布。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>多线程</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>线程是比进程更小的一种可并发执行的单位，每个进程都有自己独立的内存空间和其他资源，当进程切换时需要进行数据和资源的保护与恢复。若干协同工作的线程可以共享内存空间和资源，线程切换不需要数据的保护与恢复。</p>
<p>Java 的运行环境采用多线程实现，可以利用系统的空闲时间执行诸如内存回收等操作；Java 语言提供语言级多线程支持，用 Java 语言能直接编写多线程程序。</p>
<ol>
<li><ol>
<li><strong>Java</strong> <strong>应用程序和小应用程序</strong></li>
</ol>
</li>
</ol>
<p>Java 程序可以是独立的应用程序和能在浏览器上执行的小应用程序(Applet)。两种 Java 程序都由一个或多个扩展名为“.class”的文件组成。都需要 java 虚拟机(JVM)载入并翻译。这两种程序的主要区别是：小应用程序只能在与 Java 兼容的容器中运行，可以嵌入在 HTML 网页内，在网络上发布，当网页被浏览时，在浏览器中运行。小应程序的运行还要受到严格的安全限制，例如，它不能访问用计算机上的文件。Java 应用程序没有这些限制，也不支持网页嵌入和下载运行。</p>
<p>小应用程序和应用程序在代码编写上也有很大差异。一个小应用程序必须定义成一个 Applet 类的子类，应用程序可以是 Applet 类的子类，也可以不是。应用程序必须在一个类中定义一个 main()方法，该方法代表应用程序的入口。而小应用程序不必定义 main()方法，它的执行由 Applet 类中定义的多个方法控制。</p>
<p>[例 1.1] 一个非常简单的应用程序。</p>
<p>public class Example1_1{//这是我的第一个应用程序public static void main(String []args){</p>
<p>System.Out.println(“你好!欢迎你学习 Java 语言。”);</p>
<p>}</p>
<p>}</p>
<p>上述 java 程序的执行将输出以下字样： 你好!欢迎你学习 Java 语言。</p>
<p>一个应用程序由若干个类组成，上面这个应用程序只有一个类，类的名字是 Example1_1。public 是 java 语言的关键字，表示声明的类 Example1_1 是公用的。class 也是关键字，用来声明类。最外层的一对花括号以及括号内的内容叫做类体。public static void main(String []args)是类 Example1_1 的一个方法。一个应用程序必须只有一个类含有main()方法，这个类是应用程序的主类。public static void 是对 main()方法的说明。应用程序的 main()方法必须被说明成 public static void。表示 main()方法的访问权限是公有的，它是一个类方法，没有结果返回，参见第 3 章。String []args 或 String args[]，声明 main()方法的参数是一个字符串数组，参见第 4 章。</p>
<p><strong>Java</strong> <strong>源程序命名受**</strong>严格的限制<strong>。</strong>Java<strong> </strong>源文件的<strong><strong>扩展名必须是</strong></strong>“<strong>**.java”</strong>如果源文件中有多个类，<strong>那么**</strong>只能有一个<strong>**public</strong> <strong>类；如果源文件中有</strong> <strong>public</strong> <strong>类，那么源文件的**</strong>名字<strong><strong>必须</strong></strong>与<strong><strong>这个</strong></strong>类<strong><strong>的</strong></strong>名字完全相同**。例如，例 1.1 应用程序的源文件名必须是 Example1_1.java。如果源文件没有 public 类，那么源文件的名字只要和某个类的名字相同即可。</p>
<p>[例 1.2]一个简单的小应用程序，用一同颜色显示两行文字： 欢迎你学习 Java 语言。</p>
<p>只要认真学习，多上机实习，一定能学好 Java 语言。import java.applet.*;</p>
<p>import java.awt.*;</p>
<p>public class Example1_2 extends Applet{ public void paint(Graphics g){</p>
<p>g.setColor(Color.blue);//设置显示的颜色为 blue g.drawString(“欢迎你学 Java 语言”,30,20); g.setColor(Color.red);//设置显示的颜色为 red</p>
<p>g.drawString(“只要认真学习，多上机实习，一定能学好 Java 语言。”,30,50);</p>
<p>}</p>
<p>}</p>
<p>一个小应用程序也出若干个类组成，其中必须有一个类，它继承系统提供的 Applet 类，这个类是小应用程序的主类。</p>
<p>主类必须是 public 的，源文件名必须与小应用程序的主类名相同。上述程序的源文件名必须是 Example1_2.java。小应用程序的结构参见 3.5 节。</p>
<p>在结束这一节之前，先讨论一下程序中经常出现的注释。注释是程序中的说明文字，用于帮助阅读程序，它不是语句，不会影响程序的执行效率。Java 语言的注释有三种形式：</p>
<p>行注释 // 变量 r 是贺的半径</p>
<p>块注释 /<em> 以下程序段是采用冒泡排序对数组元素实现从小到大排序 </em>/ 文档注释 /<em> </em>类 Student 是学生类*/</p>
<p>行注释用于简短地说明前面代码的意义或功能。注释内容至行末结束，不能跨行。例如：</p>
<p>int fontsize =30 ;//标题字体大小</p>
<p>块注释是多行注释，用于说明下面程序段的算法、功能等，块注释不可嵌套使用。文档注释能被实用程序 javadoc 接受，它能自动生成程序的 HTML 文档。</p>
<ol>
<li><ol>
<li><strong>Java</strong> <strong>程序的开发过程</strong></li>
</ol>
</li>
</ol>
<p>Java 程序的开发过程如图 1.1 所示。对于 Java 应用程序，<strong>先编写</strong> <strong>Java</strong> <strong>源程序</strong>，源程序<strong>经</strong> <strong>Java</strong> <strong>编译器编译后产生码文件</strong>，最后由 Java 解释器<strong>解释执行字节码</strong>文件。对于小应用程序，<strong>先编写源程序</strong>，然后经 Java 编译器<strong>编译后，产生字节码文件</strong>，最后由 <strong>Web</strong> <strong>浏览器解释执行字节码文件</strong>。</p>
<p>以下以使用 SUN 公司提供的 Java JDK(java Developer’s Kit)为例，并假设 Java JDK 安装在 d:\java 目录下，则在该目录下还应包含以下几个文件和子目录：</p>
<ol>
<li><p>子目录 d:\java\bin,这个子目录是 Java JDK 的核心，其中最主要的可执行文件有：</p>
</li>
<li><ol>
<li>javac—编译器</li>
<li>java—解释器</li>
<li>jdb—调试器</li>
<li>appletviewer—java Applet 解释器</li>
</ol>
</li>
<li><p>子目录 d:\java\lib，这个子目录存储的是函数库。</p>
</li>
</ol>
<p>编写源程序时，使用一个文字编辑器，输入源程序文件，并保存。键入编译命令，使用 Java 编译器编译 Java 源程序。键入解释命令，通过解释器解释执行 Java 应用程序的字节码文件。对于小应用程序需通过支持 Java 的浏览器解释执行字节码文件。</p>
<p>设输入前面所述 Java 程序，源文件名为 Example1_1.java，保存在 D：\java 目录下。Java 编译器的使用格式是：</p>
<p>javac [选项] 源文件</p>
<p>例如，可用以下命令编译以上输入的 Java 应用程序： javac d:\java\Example1_1.java</p>
<p>编译时，可能编译器指定选项，java JDK 编译器的选项参见表 1-1。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-classpath&lt;路径&gt;</td>
<td>引用类的路径表</td>
</tr>
<tr>
<td>-d&lt;目录&gt;</td>
<td>编译后类文件存放的目录</td>
</tr>
<tr>
<td>-g</td>
<td>生成调试信息表</td>
</tr>
<tr>
<td>-ng</td>
<td>不生成调试信息表</td>
</tr>
<tr>
<td>-nowarn</td>
<td>关闭编译器警告功能</td>
</tr>
<tr>
<td>-o</td>
<td>优化类文件</td>
</tr>
<tr>
<td>-verbose</td>
<td>显示编译过程中的详细信息</td>
</tr>
</tbody>
</table>
<p>Java 解释器 java.exe 用来解释执行 Java 类文件，解释器的使用格式为： java [选项]类名[参数]</p>
<p>其中，类名指定的类必须是 main()方法的，即是一个 Java 应用程序。</p>
<p>对于使用开发环境情况来说，编辑源程序、编译、执行和调试直接使用环境提供的工具，使开发程序变得非常简单。例如，使用 Eclipse 开发环境。在 eclipse 环境下开发 Java 程序的方法请参见附录 F。</p>
<ol>
<li><ol>
<li><strong>标识符和关键字</strong></li>
</ol>
</li>
</ol>
<p>如同别的程序语言一样，Java 语言也有基本符号，由基本符号按一定的构词规则构成标识符等基本词汇，再由基本词汇和关键字按语言的句法构成 Java 程序。</p>
<ol>
<li><strong>字符集</strong></li>
</ol>
<p>Java 语言使用 <strong>Unicode</strong> <strong>字符集</strong>，共有 65535 个字符，包括： (1) 数字符 10 个(0~9)。</p>
<ol>
<li>英文字母大、小写字符各 26 个(A~Z 和 a~z)。</li>
<li>下划线字符，美元符号。</li>
<li>文字字符，(汉字，日文片假名、平假名和朝鲜文字等)。</li>
<li><p>其他用于构成特殊符号的字符集。</p>
</li>
<li><p><strong>标识符</strong></p>
</li>
</ol>
<p>标识符用于命名程序对象。例如，类名、变量名、方法名等。Java 语言的标识符可以按以下规则任意命名：</p>
<ol>
<li><ol>
<li>由字母(包括英文字母、下划线字符、美元字符、文字字符)和数字字符组成。</li>
<li>限定标识符的第一个字符不能是数字符。</li>
</ol>
</li>
</ol>
<p>例如，下列 4 个字符串都可以个为标识符： Boy_$、$63Girl、颜色、小伙子</p>
<p>而以下 4 个字符不能作为标识符： 46A、%Val、c+2、Hello!</p>
<p>前两是因为首字符不合理，后两个含有不允许在标识符中出现的字符。除了按上述规则命名的习惯约定：</p>
<p>一般变量名、方法名用小写英文字母开头；文字和常数用大写字母命名；类名首字母用大写字母；包名全部用小写字母。命名习惯是一种公共约定，Java 语言的语法并没有这种限制，但是培养良好的编程习惯有利于程序维护和协作开发。</p>
<ol>
<li><strong>关键字</strong></li>
</ol>
<p>为了表示程序结构、定义和修饰等，Java 语言引入一组关键字，参见附录 A。关键字是上些英文单词，在语言中， 关键字已经被赋予特定的意义，不能用这些关键字作为标识符命名程序对象。在 Java 语言中，关键字的作用有以下多个方面：</p>
<p>描述程序结构、声明类、定义类的成员、简单数据类型、值和变量、异常情况处理、实例(对象)的创建和检验、流程控制等。</p>
<p>Java 语言中所有关键字均由小写字母组成。每个关键字在程序中出现有特定位置和使用方法的要求。关键字不可以用做变量、方法、类或标号的标识符(名字)。</p>
<ol>
<li><ol>
<li><strong>基本数据类型</strong></li>
</ol>
</li>
</ol>
<p>Java 语言是强类型语言，每个变量和表达式都有确定的类型，在变量赋值时要进行<strong>类型兼容性检验</strong>。数据类型可分</p>
<p>为<strong>基本数据类型</strong>和<strong>非基本数据类型</strong>两大类。</p>
<p><strong>基本数据类型</strong>也称为<strong>原始数据类型</strong>，是系统预先规定的一些常用类型。它们是：<strong>整数类型、浮点数**</strong>(<strong><strong>实数</strong></strong>)<strong><strong>类型、字符</strong></strong>(<strong><strong>文字</strong></strong>)<strong><strong>类型、逻辑类型</strong></strong>(<strong><strong>布尔型</strong></strong>)**。</p>
<p><strong>非基本数据类型</strong>也称为<strong>复合数据类型</strong>，是由基本类型组合的新类型。<strong>非基本数据类型</strong>分为：<strong>数组、字符串、类、接</strong></p>
<p><strong>口</strong>。</p>
<p>本小节只介绍基本数据类型，非基本数据类型将在以后章节中分别介绍。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>逻辑类型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>逻辑类型用关键字 boolean 标识，所以也称布尔型。逻辑类型只有真和假两个值，true 表示真,false 表示假。以下是逻辑变量定义的例子：</p>
<p>boolean b; boolean bool;</p>
<p>boolean flg1,flg2, 美丽；//一次定义多个变量</p>
<p>boolean b1 = true,b2= false,丑=false;//定义时可以赋初值</p>
<p>逻辑变量用于记录某种条件成立与否，也用语句中作条件判断。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>字符类型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>字符类型用关键字 char 标识。字符型数据是一个字符2个字节，内部表示是字符的 Unicode 代码，共用 65535 个不同</p>
<p>的字符。在 Java 程序中，<strong>字符常量</strong>有<strong>普通字符</strong>和<strong>转义字符</strong>常两种。</p>
<p><strong>用单引号括住一个字符，表示一个普通字符常量</strong>。例如，’a’、’B’、’$’、’国’。对于被语言用作特定意义的字符，或者不能显式显示的字符，需用转义字符标记它们。</p>
<p>例如，换行符用\n 标记，水平制表符用\t 标记。常用的转义字符的标记方法见表 1-2。其中，<strong>\nnn</strong> 是用<strong>八进制代码</strong>表示的字符，<strong>\unnnn</strong> 是用<strong>十六进制代码</strong>表示的字符。例如：\141 表示字母 a，\u0061 也表示字母 a.以下是字符变量定义的例子：</p>
<p>char ch; char ch1,ch2,漂亮;</p>
<p>char ch3 = ‘A’,ch4 = ‘家’,丑=’假’;//定义时可以赋给初值表 1-2 转义字符及其含义</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>退格(Backspace 键)</td>
</tr>
<tr>
<td>\n</td>
<td>换行符，光标位置移到下一行首</td>
</tr>
<tr>
<td>\r</td>
<td>回车符，光标位置移到当前行首</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表符(Tab 键)</td>
</tr>
<tr>
<td>\v</td>
<td>竖向退格符</td>
</tr>
<tr>
<td>\f</td>
<td>走纸换页</td>
</tr>
<tr>
<td>\</td>
<td>反斜杠符\</td>
</tr>
<tr>
<td>\’</td>
<td>单引号符’</td>
</tr>
<tr>
<td>\”</td>
<td>双引号符”</td>
</tr>
<tr>
<td>\nnn</td>
<td>n 为 8 进制数字，用八进制数据表示字符的代码</td>
</tr>
<tr>
<td>\unnnn</td>
<td>n 为 16 进制数字，用 16 进制数据表示字符的代码</td>
</tr>
</tbody>
</table>
<ol>
<li><ol>
<li><ol>
<li><strong>整数类型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>整数是不带小数点和指数的数值数据。由于计算机只能表示整数的一个子集，表达更大范围内的整数需要更多的二进制位，Java 语言将整型数据按数值范围大水不同分成四种：</p>
<p>(1) 基本型：用 int 标识。4 个字节，32 位，取值范围是-231~231 -1，即-2147483648~2147483647。</p>
<ol>
<li>字节型：用 byte 标识。1 个字节，8 位，取值范围是-2<strong>7</strong>~2<strong>7</strong> -1，即-128~127。</li>
</ol>
<p>(3) 短整型：用 short 标识。2 个字节，16 位，取值范围是-216~216 -1，即-23768~32767</p>
<p>(4) 长整型：用 long 标识。8 个字节，64 位，取值范围是-264~264 -1，即-923372036854775808L~923372036854775807L <strong>每种**</strong>整数类型<strong><strong>处理不同范围的整数值，并且</strong></strong>都是带符号<strong>**的</strong>。</p>
<p>整型常量有<strong>十进制、八进制和十六进制</strong>三种写法。如下 面的示例所示：</p>
<p>1234(十进制)，0777(八进制，以数字 0 开头)，0x3ABC(十六进制，以 0x 开头，后随数字符和英文 A 到F)，5333L 或 5333l(以字母 L 或l 结尾是长整数)。</p>
<p>以下是整型变量定义的实例：</p>
<p>int I；int x,积;byte 字节变量;//一个字节整型变量，该变量的名为字节变量</p>
<p>long z,sum;int w =12,len =-1230;long big = 9876L;//定义同时可以赋初值。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>浮点数类型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>浮点数类型也称实型，浮点数是带小数点或指数的数值数据。 Java 语言的浮点数有单精度和双精度两种。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>单精度型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>单精度型 用float 标识，占 4 个字节，32 位，取值-10<strong>38</strong>~10<strong>38</strong>。float 型常是的书写的方法是在实数之后加上字母 <strong>F**</strong>或<strong>**f.</strong>例如：23.54f,12389.987F。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>双精度型</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>双精度型 用double 标识，占 8 个字节，64 位，取值-10<strong>308</strong>~10<strong>308</strong>。double 型常是的<strong>书写的方法有两种</strong>： <strong>一种是直接写一个实数</strong>，<strong>或在实数后面加上字母</strong> <strong>D</strong> <strong>或**</strong>d.**例如：123.5439、123.5439D, 123.5439d。另一种是科学计数法，用 10 的方幂表示(用字符 e 或E 表示幂底 10)。例如：123.24e40(科学计数法表示，值为</p>
<p>123.24 乘 10 的 40 次方)。</p>
<p>以下是浮点数类型变量定义的例子:</p>
<p>float x,y;</p>
<p>double v=12.86,u=2431098.987D;</p>
<p>float u=12.36f;</p>
<p>浮点数类型与整数不同，当执行运算时如果出现某种不正常的状态，浮点数类型不会抛出异常。例如， 如果用 0 除浮点数类型的变量，则计算结果是一个特别的无限值。</p>
<p><strong>习题</strong></p>
<ol>
<li><ol>
<li><p>指出 Java 语言的主要特点和 Java 程序的执行过程。答：主要特点：</p>
</li>
<li><ol>
<li>强类型，(2) <strong>编译和解释，**</strong>(<strong><strong>3</strong></strong>)<strong> </strong>自动无用内存回收功能，<strong><strong>(</strong></strong>4<strong>**)</strong> <strong>面向对象，</strong> <strong>(5**</strong>)<strong> </strong>与平台无关<strong><strong>，</strong></strong>(6)<strong><strong>安全性，</strong></strong>(7)<strong><strong>分布式计算，</strong></strong>(8)<strong>**多线程。</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><strong>Java</strong> <strong>程序的执行过程：是解释执行。**</strong>1.javac<strong> </strong>[<strong><strong>选项</strong></strong>]<strong> </strong>源文件<strong><strong>==</strong></strong>编译**</p>
<ol>
<li><ol>
<li><strong>java</strong> <strong>[**</strong>选项<strong>**]</strong> <strong>类名**</strong>[<strong><strong>参数</strong></strong>] ==<strong>**执行</strong></li>
</ol>
</li>
<li><p>说出开发与运行 Java 程序的主要步骤。</p>
</li>
</ol>
<p>对于 Java 应用程序，<strong>先编写</strong> <strong>Java</strong> <strong>源程序</strong>，源程序<strong>经</strong> <strong>Java</strong> <strong>编译器编译后产生字节码文件</strong>，最后由 Java 解释器<strong>解释执行字节码</strong>文件。对于小应用程序，<strong>先编写源程序</strong>，然后经 Java 编译器<strong>编译后，产生字节码文件</strong>，最后由 <strong>Web</strong> <strong>浏览器解释执行字节码文件</strong>。</p>
<ol>
<li>如何区分应用程序和小应用程序？</li>
</ol>
<p>(1)小应用程序只能在与 Java 兼容的容器中运行，可以嵌入在 HTML 网页内，在网络上发布，当网页被浏览时，在浏览器中运行。小应程序的运行还要受到严格的安全限制，例如，它不能访问用计算机上的文件。Java 应用程序没有这些限制，也不支持网页嵌入和下载运行。</p>
<p>(2)一个小应用程序必须定义成一个 Applet 类的子类，应用程序可以是 Applet 类的子类，也可以不是。应用程序必须在一个类中定义一个 main()方法，该方法代表应用程序的入口。而小应用程序不必定义 main()方法，它的执行由 Applet 类中定义的多个方法控制。</p>
<ol>
<li>说出 Java 源文件的命名规则。</li>
</ol>
<p><strong>Java</strong> <strong>源文件的**</strong>扩展名必须是<strong><strong>“</strong></strong>.java”<strong>如果源文件中有多个类，</strong>那么<strong><strong>只能有一个</strong></strong>public<strong> </strong>类；如果源文件中有<strong> </strong>public<strong> </strong>类，那么源文件的<strong><strong>名字</strong></strong>必须<strong><strong>与</strong></strong>这个<strong><strong>类</strong></strong>的<strong>**名字完全相同</strong></p>
<ol>
<li>选择一种上机环境，参照实例，编写一个输出“hello world!”字样的 Java 程序。</li>
<li>Java 语言使用什么字符集？共有多少个不同的字符？</li>
</ol>
<p>Java 语言使用 <strong>Unicode</strong> <strong>字符集</strong>，共有 65535 个字符</p>
<p>(1)数字符 10 个(0~9)。</p>
<p>(2)英文字母大、小写字符各 26 个(A~Z 和 a~z)。</p>
<p>(3)下划线字符，美元符号。</p>
<p>(4)文字字符，(汉字，日文片假名、平假名和朝鲜文字等)。</p>
<p>(5)其他用于构成特殊符号的字符集。</p>
<ol>
<li>Java 语言标识符的命名规则是什么、</li>
</ol>
<p>1.由字母(包括英文字母、下划线字符、美元字符、文字字符)和数字字符组成。</p>
<p>2.限定标识符的第一个字符不能是数字符。</p>
<ol>
<li>Java 有哪些基本数据类型，它们的常量又是如何书写的？</li>
</ol>
<p><strong>整数类型、浮点数**</strong>(<strong><strong>实数</strong></strong>)<strong><strong>类型、字符</strong></strong>(<strong><strong>文字</strong></strong>)<strong><strong>类型、逻辑类型</strong></strong>(<strong><strong>布尔型</strong></strong>)**。</p>
<ol>
<li>指出下列内容哪些是 Java 语言的整型常量，哪些是浮点数类型常量，哪些两者都不是。1)E-4, 都不是</li>
</ol>
<p>2)A423, 都不是</p>
<p>3)-1E-31, double类型</p>
<p>4)0xABCL, long类型整型</p>
<p>5).32E31, double类型</p>
<p>6)087,十进制整型</p>
<p>7)0xL, 都不是</p>
<p>8)003, 八进制整型</p>
<p>9)0x12.5, 都不是</p>
<p>10)077, 八进制整型</p>
<p>11)11E, 都不是</p>
<p>12)056L, long类型整型</p>
<p>13)0., double类型</p>
<p>14).0 double类型</p>
<p>0.、.0 、.32E31、-1E-31是baidouble类型；</p>
<p>0x12.5、11E、0xL、A423、E-4是非法的数据；</p>
<p>056L、0xABCL是long类型整型；</p>
<p>077、003是八进制整型；</p>
<p>087是十进制整型；</p>
<p><strong>第</strong> <strong>2</strong> <strong>章</strong> <strong>运算和语句</strong></p>
<p>本章主要内容<strong>(**</strong>次重点<strong> </strong>10%)**</p>
<ul>
<li>数据运算</li>
<li>语句</li>
<li>Java 程序实例</li>
</ul>
<p>本章重点：算术运算、自增和自减运算、关系运算和逻辑，Java 语句以及 java 程序实例。</p>
<p>本章难点：自增和自减运算、位运算和移位运算，while 语句、do…while 语句、for 语句和 Java 程序实例。</p>
<ol>
<li><ol>
<li>数据运算</li>
</ol>
</li>
</ol>
<p>在高级语言中，运算由表达式表示。<strong>表达式</strong>由<strong>运算符**</strong>和<strong><strong>运算分量</strong></strong>组成<strong>，运算分量可以是常量、变量和方法调用。Java 语言的基本运算可分成以下几类</strong>：赋值运算，算术运算，自增和自减运算，关系运算，逻辑运算，条件运算和字符串连接运算**等。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>赋值运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>在 Java 语言中，符号“=”是赋值运算符，不是“相等”(相等运算符是“==”，见关系运算符的叙述)。赋值运算分为两类：一是简单赋值运算；二是复合赋值运算。</p>
<ol>
<li><strong>简单赋值运算</strong></li>
</ol>
<p>简单赋值运算的一般形式如下： 变量 = 表达式</p>
<p>赋值运算的执行过程是：</p>
<ol>
<li><ol>
<li>计算赋值运算符的右端的表达式。</li>
<li>当赋值运算符两侧不一致时，将表达式值的类型自动转换成变量的类型。</li>
<li>将表达式的值赋值给变量，即存储到与变量对应的存储单元中。</li>
</ol>
</li>
</ol>
<p>完成一个赋值运算的表达式称为赋值表达式，赋值表达式是先计算表达式的值，然后将表达式的值赋值给变量。例如，表达式 x=x+1，表示完成表达式 x+1 的计算，将计算结果赋值给变量 x。</p>
<p>这里的类型转换是指数值数据的类型自动转换，这样的<strong>自动转换**</strong>只<strong>．</strong>能<strong>．</strong>由<strong>．</strong>简单类型向复<strong>**杂类型转换</strong>，<strong>不能**</strong>从复<strong><strong>杂</strong></strong>的转换成简单的**。即如下所示的从左到右转换：</p>
<p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p>
<p>例如，以下代码说明 int 类型能自动转换成 double 类型： int j=3;</p>
<p>double y=2.0;</p>
<p>y=j;//j 的值为 3，y 的值为 3.0</p>
<p>以下则是不正确的代码，double 类型不能自动转换成 int 类型。j=y;</p>
<p>Java 语言约定赋值运算也有值，它的值就是赋予变量的值，因此，赋值运算的结果可以继续赋值。例如： int j;</p>
<p>double y=2.0;</p>
<p>y=j=3;//j 的值为 3，,y 的值为 3.0</p>
<p>赋值运算符结合性“自右至左”，当连续有多上赋值运算时，是从右至左逐个赋值。</p>
<ol>
<li><strong>复合赋值运算</strong></li>
</ol>
<p>在程序中，经常遇到在变量现在值的基础上作某种修正的运算。例如x=x+5</p>
<p>这类运算的特点是：变量既要参与运算，又要接受赋值。为避免对同一个变量的地址重复计算，引入复合赋值运算符。常用的复合赋值运算符有：</p>
<p>+=、-=、*=、/=、%= 例如：</p>
<p>x+=5;//等价于 x=x+5</p>
<p>x <em>=u+v;//等价于 x=x</em>(u+v),这里括号不能省略a+=a-=b+2;//等价于 a=a+(a=a-(b+2))</p>
<p>记θ 为某个双目运算符，复合赋值运算</p>
<p>xθ=e</p>
<p>的等效表达式为x= xθ(e)</p>
<p><strong>当**</strong>e<strong> </strong>是一个复<strong><strong>杂表达式时，等效表达式的</strong></strong>括号是必需<strong>**的。</strong></p>
<ol>
<li><ol>
<li><ol>
<li><strong>算术运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>算术运算要求<strong>运算分量</strong>的类型是<strong>数值类型</strong>的(整数类型和浮点数类型)。运算时，只需一个运算分量的是单目运算，需两个运算分量的是双目运算。算术运算的运算符是：</p>
<p>单目算术运算符：＋（取正）、－（取负）</p>
<p>双目算术运算符：＋（加）、－（减）、＊（乘）、/（除）、％（求余数） 说明：</p>
<ol>
<li>加、减、乘、除和求余数运算都是双目运算符，结合性都是从左至右。取正和取负是单目运算符，结合性是从右至左，其优先级高于＋、－、＊，％等双目运算符。</li>
<li>“/”为<strong>除法运算符</strong>，当<strong>除数和被除数均为整数</strong>类型数据时，则<strong>结果**</strong>也是<strong><strong>整数类型</strong></strong>数据**。例如７/4 的结果为１。</li>
<li>“％”为求余数运算符，<strong>求余数运算所得**</strong>结果的符号<strong>与</strong>被除的符号相同**。例如：５％３的结果为２，－５％３ 的结果为－２，５％－３的结果为２。</li>
</ol>
<p>用算术运算符、运算分量和括号连接起来，符合 Java 语言语法规则的计算式，称为算术表达式。例如，如果变量 x 和y 已经被正确声明，并且已经赋予初值，则以下的式子就是一个正确的算术表达式：</p>
<p>X<em>2+y</em>(x-5)</p>
<ol>
<li><ol>
<li><ol>
<li><strong>自增和自减运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>自增运算符“++”和自减运算符“–”是单目运算符，要求运算分量是数值类型的变量。其作用是变量的值增１或减１。这两个运算符与变量结合有以下四种可能形式：</p>
<p>++i 前缀形式，表示在引用变量 i 之前，先使 i 加１，以加１后的 i 值为运算结果。</p>
<p>–i 前缀形式, 表示在引用变量 i 之前, 先使i 减１，以减１后的 i 值为运算结果。</p>
<p>i++ 后缀形式，表示在收用变量 i 之后，才使 i 加１，即以增１前的 i 值为运算结果。i– 后缀形式，表示在引用变量 i 之后，才使 i 减１，即以减１前的 i 值为运算结果。例如：</p>
<p>i=4;j=++i;//i 结果为５，j 的结果为５ i=4;j=i++;//i 结果为５，j 的结果为 4 i=4;j=–i;//i 结果为 3，j 的结果为 3 i=4;j=i–;//i 结果为 3，j 的结果为 4</p>
<p>上述例子说明，<strong>对变量采用自增或自减，用前缀形式或用后缀形式，对**</strong>变量<strong><strong>本身来说，</strong></strong>效果是相同的<strong><strong>，但</strong></strong>表达式<strong><strong>的</strong></strong>值<strong><strong>不相同</strong></strong>。前缀形式是变量运算之后的新值，后缀形式是变量运算之前的值。**</p>
<p><strong>自增自减运算</strong>能使程序更为简洁和高效，但在使用时需注意“＋＋”和“――”运算的运算<strong>只能是变量</strong>，<strong>不能是**</strong>常<strong>**量或表达式</strong>。例如，４++或（i+j）++都不是合法的。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>关系运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>关系运算用来表达两个表达式值的比较，运算结果是布尔型。有６种关系运算符：</p>
<p>＜（小于）、＜＝（小于等于）、＞（大于）、＞＝（大于等于）、＝＝（等于）、！＝（不等于） 关系运算对左右两侧的值进行比较，如果比较运算的结果成立，则值为 true；不成立为 false.</p>
<p>上述６个关系运算符的优先级不完全相同。＜、＜＝、＞、＞＝的优先级高于＝＝，！＝。</p>
<p>例如，表达式 x&gt;y==c&lt;d,等价于(x&gt;y)==(c&lt;d)。该表达式的意义是 x&gt;y 与 c&lt;d,或同时成立或同时不成立。关系运算符的优先级低于算术运算符的优先级。</p>
<p>例如：x&gt;u+v,等价于 x&gt;(u+v).</p>
<p>关系运算符的结合方向是自左至右。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>逻辑运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>逻辑运算用于描述逻辑表达式，实现连续多个条件的<strong>逻辑与、逻辑或、逻辑否定</strong>的判定。有３个逻辑运算符：</p>
<p>＆＆（逻辑与）、||（逻辑或）、！（逻辑否定）</p>
<p>其中：运算符＆＆和||是双目运算符、运算符！是单目运算符。逻辑运算的操作数必须是布尔型的，结果也是布尔型的。</p>
<p><strong>逻辑否定</strong>“！”的优先级<strong>高于**</strong>算术运算符<strong>的优先级。</strong>逻辑与<strong>“＆＆”和</strong>逻辑或<strong>“||”的优先级</strong>低于<strong>**关系运算符</strong>的优先</p>
<p>级。</p>
<p>表２-1 是逻辑运算的“真值表”，表中列出当运算分量 a 和b 的值在不同组合情况下，各种逻辑运算的结果。表２-1 逻辑运算真值表</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>!a</th>
<th>!b</th>
<th>a&amp;&amp;b</th>
<th>a\</th>
<th>\</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<p>a&gt;b&amp;&amp;x&gt;y    等价于 (a&gt;b)&amp;&amp;(x&gt;y) a!=b||x!=y        等价于(a!=b)||(x!=y)</p>
<p>x==0||x&lt;y&amp;&amp;z&gt;y    等价于(x==y)||((x&lt;y)&amp;&amp;(z&gt;Y))</p>
<p>!a&amp;&amp;b||x&gt;y&amp;&amp;z<y 等价于((!a)&&b)||((x>y)&amp;&amp;(z&lt;y))</p>
<p>逻辑运算符用来描述逻辑表达式。例如，闰年的条件是：每４年一个闰年，但每１００年少一个闰年，每４０ ０年又增加一个闰年。如果年份用整数类型变量 year 表示，则 year 年是闰年的条件是：</p>
<p>（year 能被４整除，但不能被１００整除）或（year 能被４００整除） 用逻辑表达式可描述如下：</p>
<p>（year/%4==0&amp;&amp;year%100!=0）||year%400==0</p>
<p>需要<strong>特别指出的是</strong>，<strong>逻辑与和逻辑或的运算符有以下性质，**</strong>Java<strong> </strong>语言利用这些性质，在进行连续的逻辑运算时，<strong> </strong>不分逻辑与和逻辑或的优先级<strong>**进行计算，而是顺序进行逻辑与和逻辑或的计算</strong>，<strong>一旦逻辑子表达式或逻辑子表</strong>  <strong>达式或逻辑表达式能确定结果，这不再继续计算</strong>。</p>
<p>（１） 对表达式 a&amp;&amp;b,当 a 为 false 时，结果为 false，不必再计算 b；仅当 a 为 true 时，才需计算 b。</p>
<p>（２） 对表达式 a||b，当 a 为 true 是，结果为 true，不i再计算 b;仅当 a 为 false 时，才需计算 b。</p>
<p>例如：设有 a=b=c=1,计算++a&gt;=1||++b&lt;++c。从左到右顺序逻辑或表达式，先计算子表达式++a&gt;=1,变量 a 的值变为２，++a&gt;=1 为 true,整个逻辑或表达式的值已经为 true，不再计算右边的子表达式++b&lt;++c。因而变量 b 和c 的值不变，仍为１。</p>
<p>在具体编写程序时，也应利用以上性质。用逻辑与表达两个条件必须同时成立时，如果条件不成立，条件２的值不便计算，则逻辑表达式应写成：</p>
<p>条件１＆＆条件２</p>
<p>避免在条件１不成立情况下，计算条件２。例如，要表示 y/x&gt;2 和 x!=0 同时成立，应写成： x!=0&amp;&amp;y/x&gt;2</p>
<p>当x 为０时，不会 y/x。而写成： y/x&gt;2&amp;&amp;x!=0</p>
<p>是不正确的，因为当x 为０时，不能计算 y/x。对于逻辑或也有类似情况。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>条件运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>条件运算是一个三目运算，一般形式如下： <strong>逻辑表达式？表达式１：表达式２</strong></p>
<p>条件运算的执行过程是：</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li>计算逻辑表达式</li>
<li>如果逻辑表达式的值为 true，则计算表达式１，并以表达式１的值为条件运算的结果（不再计算表达式２）</li>
<li>如果逻辑表达式的为 false,则计算表达式２，并以表达式２的值为条件运算的结果（未计算表达式１）。例如：</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>x&gt;y ? x+5 : y-4</p>
<p>如果 x&gt;y 条件为 true，则上述表达式取 x+5 的值，否则取 y-4 的值。</p>
<p>条件运算符（？：）的优先级高于赋值运算符，低于逻辑运算符，也低于关系运算符和算术运算符。例如：max = x&gt;y ?x+5:y-4</p>
<p>等价于：max = ((x&gt;y)?x+5:(y-4)) 条件运算符的性为“自右至左”。例如</p>
<p>x&gt;y?x:u?v?u:v</p>
<p>等价于：x&gt;y?x:(u&gt;v?u:v)</p>
<p>条件表达式的返回值类型由表达式１和表达式２的类型确定。如果表达式１值的字节数比表达式２的值的字节数多， 则条件表达式值的类型与表达式１的类型相同；反之，则与表达式２的类型相同。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>其他运算</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>除前面介绍的运算外，还有许多运算，本节只介绍位运算和移位运算。位运算和移位运算实现对二进制位串数据的运算，主要应用于与计算机内部表示直接有关的运算，读者可以跳过这些内容。</p>
<ol>
<li><ol>
<li><strong>语句</strong></li>
</ol>
</li>
</ol>
<p>一个计算过程由一系列计算步骤组成。一个计算步骤或用一个，或用一个计算流程控制实现。程序语言用描述计算步骤。在 Java 语言中，<strong>语句分为**</strong>基本语句、控制结构语句以及<strong> </strong>package<strong> </strong>语句和<strong>**import</strong> <strong>语句</strong>等。其中控制结构语句包括复合语句、if 语句、switch 语句、循环语句和 try…catch 语句。其中循环语句有 while 语句、do…while 语句、for 语句三种。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>基本语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>基本语句主要有表达式语句、空语句、break 语句、continue 语句、return 语句等。基本语句都以分号为结束符。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>表达式语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>在赋值表达式、自增自减表达式和方法调用表达式之后加上分号即变成语句，称它们是表达式语句。例如，表达式“k++”,写成 “k++;”就是一个表达语句。最典型的表达式语句是赋值表达式构成的语句，譬如：</p>
<p>k=k+2; m=n=j=3;</p>
<p>赋值表达式语句在程序中经常使用，习惯又称为赋值语句。</p>
<p>另一个典型的表达式语句是方法调用表达式之后接上分号： 方法调用；</p>
<p>该表达式语句虽未保留方法调用的返回值，但方法调用会引起实参向形参传递信息和执行方法体，将使变量获得输入数据；调用输出方法使程序输出计算结果等。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>空语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>空语句是只有一个分号的语句，其形式为</p>
<p>；</p>
<p>实际上，空语句是什么也不做的语句。语言引入空语句是出于以下实用上的考虑。例如，循环控制结构的句法需要一个语句作为循环体，当要循环执行的动作由循环控制部分完成时，就不需要有一个实际意义的循环体，这时就需要用一个空语句作为循环体。另外，语言引入空语句使语句序列中连续出现多个分号不再是一种错误，编译系统遇到这种情况，就认为单独的分号是空语句。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>break</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>break 语句必须出现在多路按值选择结构或循环结构中，break 语句的执行强制结束它所在的控制结构，让程序从这个控制结构的后继语句继续执行。break 语句的书写形式是</p>
<p>break;</p>
<p>break 语句的应用，将在介绍 switch 语句和循环语句时作进一步讨论。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>continue</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>continue 语句只能出现在循环结构中，continue 语句的执行将忽略它所在的循环体中在它之后的语句。如果continue 语句在 while 语句或 do…while 语句的循环体中，使控制转入对循环条件表达式的计算和测试；如果出现在 for 语句的循环体中，使控制转入到对 for 控制结构的表达式 3 的求值。简单地说，continue 语句提早结束当前轮次循环，进入下一轮次循环。continue 语句的书写形式是</p>
<p>continue;</p>
<p>continue 语句的应用，将在循环语句中进一步讨论。</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li><strong>return</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>return 语句只能出现在方法体中，return 语句的执行将结束方法的执行，将控制返回到方法调用处。return 语句有两种形式：</p>
<p>return ; 或 return 表达式；</p>
<p>第一种形式只有用于不返回结果的方法体中，第二种形式用于有返回结果的方法体中。执行第二种形式的 return 语</p>
<p>句时，方法在返回前先计算 return 后的表达式，并以该表达式值作为方法返回值，带回到方法调用处继续计算。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>复合语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>复杂计算经常被分解为一个计算步骤序列。整个计算步骤序列在逻辑上是一个整体，要求计算机从计算步骤序列的第一个计算步骤开始，顺序执行每个计算步骤，直至最后一个计算步骤。</p>
<p>在 Java 语言中，用花括号括住一个顺序执行的计算步骤序列描述顺序结构，这样的顺序结构称作复合语句。复合语句中的每个计算步骤可以是单个语句，也可以是一个控制结构，特别情况也可以为空。</p>
<p>以交换两个整型变量 x 和y 的值为例，实现变量 x 和y 值的交换可分解为以下顺序执行的三个赋值步骤： temp =x;</p>
<p>x=y; y=temp;</p>
<p>把交换变量 x 和y 的值作为一个不可分割的整体来考虑，应把上述 3 个语句写成如下形式的复合语句:</p>
<p>{</p>
<p>int temp; temp = x; x =y; y=temp;</p>
<p>}</p>
<p>在构造复合语句时，这完成指定的工作，可能需要临时工作变量。例如，以上例子中的 temp 变量。在语句序列中插入变量定义，引入只有复合语句内的语句可使用的临时变量。用复合语句描述计算步骤序列，并定义自己专用的局部变量，使复合语句有很强的独立性，它不再要求外面为它定义专用变量。一个计算步骤序列用复合语句描述后， 它已经是一种单个语句。复合语句常被用作其他控制结构的成分语句。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>if</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>根据当前情况选择不同的计算，需用选择控制结构实现。有两种选择控制结构：两路条件选择结构和多路按值选择结构。</p>
<p>两路条件选择由一个条件和两个供选择的分支语句执行。</p>
<p>两路条件选择结构用 if 语句描述。if 语句根据条件表达式的值为 true 或 false，从两个语句中选取一个语句执行。if 语句的一般形式为</p>
<p>if(条件表达式) 语句 1</p>
<p>else</p>
<p>语句 2</p>
<p>if 语句的执行过程是：</p>
<ol>
<li><ol>
<li><ol>
<li><ol>
<li>计算条件表达式的值。</li>
<li>测试表达式的值并选择语句执行。如果表达式的值为 true，则执行语句 1；否则执行语句 2 。注意，无论条件表达的值是 true 还是 false，只执行语句 1 或语句 2 中的一个，不会两个都执行。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>当if 语句中的语句 2 为空语句时，可简写成： if(条件表达式)</p>
<p>语句</p>
<p>这种形式的 if 语句的执行过程是：</p>
<ol>
<li>计算表达式的值</li>
<li>测试表达式的值。若表达式的值为 true，则执行它的成分语句后结束 if 语句。否则，立即结束 if 语句。</li>
</ol>
<p>在if 语句中的语句 1、语句 2 可以是任何语句。当它们中的某一个是由多个语句组成时，必须将它们用花括号括住。</p>
<p>当if 语句中供选择的语句又是 if 语句时，if 语句就呈嵌套的形式，这时应注意 else 与if 的对应关系。java 语言约定：else 与它前面最接近的 if 对应。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>switch</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>经常遇到这样的选择控制，对变量表达式的每一个可能的值分别作不同的计算。如果用两路条件选择结构描述这样的选择控制，由于要逐一测试是否等于某个值，if 语句嵌套的层次就很深，程序的可读性和可修改性也很差。多路按值选择结构可避免这个问题。<strong>表达式的值的类型只能是</strong> <strong>char,byte short</strong> <strong>int</strong> <strong>类型**</strong>。**</p>
<p>在 Java 语言中，用switch 语句描述多路按值选择结构。switch 语句包含一个表达式，用于按表达式值的不同作相应选择。另外，还有一系列由 case 开头的子句和一个可选的 default 开头的子句，每个子句有一个可能为空的语句序列。switch 语句一般形式为：()</p>
<p>switch(表达式){</p>
<p>case 常量表达式 1：语句序列 1;break; case 常量表达式 2：语句序列 2;break; case 常量表达式 n: 语句序列 n;break; default: 语句序列 n+1;break;</p>
<p>}</p>
<p><strong>2.2.5</strong> <strong>try…catch</strong> <strong>语句</strong>try{</p>
<p>语句块//执行该语句块，可能会发生异常</p>
<p>}catch(异常类型 e){</p>
<p>异常发生时要执行的语句；</p>
<p>}，{</p>
<p>无论异常发生与否，都要执行的语句。</p>
<p>}</p>
<p>一个try 可以有多个 catch 和它标识的语句块。<strong>catch</strong> <strong>的内容可以为空，但是**</strong>{}<strong>**不可省</strong>。</p>
<ol>
<li><ol>
<li><ol>
<li>while 语句。</li>
<li>do…while 语句。</li>
<li>for 语句</li>
<li>嵌套的循环结构</li>
<li>循环体内的 continue 和break 语句</li>
<li>package 语句package 包名；</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>package 语句必须出现在源程序文件的起始行，表示出现在该文件中的所有类都属于这个程序包。如果有多个源程序的程序包声明使用相同的包名，则表示这些源程序文件中的全部类都属于这个程序名。包名是一个目录名，其中也可以有路径。如果 源程序文件的首行没有 package 语句，则被默认为是无名包，存于当前目录中。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>import</strong> <strong>语句</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>import 语句用于引入所需要的类。import 语句的格式为： import 包名.类名；</p>
<p>如果要从一个包中引入多个类，则可以用通配符“* ”。</p>
<p><strong>在一个</strong> <strong>Java</strong> <strong>源程序中可以有**</strong>多个<strong> </strong>import<strong> </strong>语句<strong>**，它们必须出现在</strong> <strong>package</strong> <strong>之后**</strong>，<strong><strong>类的定义之前</strong></strong>。**</p>
<ol>
<li><ol>
<li><ol>
<li>java 应用程序的基本结构[package 包名；]</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>import 包名.类名；</p>
<p>…</p>
<p>[public] class 类名{ int val= …</p>
<p>public static void main(String args[])</p>
<p>{</p>
<p>…</p>
<p>}</p>
<p>}</p>
<p><strong>java</strong> <strong>程序由**</strong>类和对象<strong><strong>构成，而</strong></strong>类又由方法和成员变量<strong><strong>构成。</strong></strong>java<strong> </strong>的方法由<strong><strong>语句</strong></strong>构成，而语句又由<strong><strong>标识符和运算符</strong></strong>构成。**</p>
<ol>
<li><ol>
<li>java 程序实例</li>
</ol>
</li>
</ol>
<p><strong>第３章</strong>    <strong>面向对象编程基础</strong></p>
<p><strong>本章主要内容**</strong>(<strong><strong>重点内容：</strong></strong>15%)** 面向对象的基本概念</p>
<p>Java 的类和对象接口</p>
<p>基本类</p>
<p>Java 小应用程序基础</p>
<p>本章重点：Java 语言的类、对象、继承、接口以及 Java 小应用程序基础本章难点：继承、多态性、接口</p>
<p><strong>3**</strong>．１面向对象的基本概念**</p>
<p>自计算机诞生到现在，程序设计语言发展经历了面向机器、面向过程和面向对象３个阶段。面向机器阶段用机器指令，即机器语言，或用助记符代替机器指令的汇编语言编写程序。使用<strong>面向机器</strong>的语言编写程序，编程模式是：</p>
<p><strong>程序＝数据＋指令</strong></p>
<p>编程时，需要考虑的内容包括计算机的硬件特性、数据位置安排、Ｉ/Ｏ设备的控制细节等。这类程序的缺陷是程序的可读性、可维护性、可移植性极差，因此编程效率很低。面向机器语言主要应用于一般的科学计算和简单控制处理。<strong>面向过程阶段</strong>是使用高级程序设计语言编程，有代表性的语言有 FORTRAN、PASCAL、C、COBOL 等。用面向过程语言</p>
<p>编程，编程模式是：</p>
<p><strong>程序＝数据结构＋算法</strong></p>
<p>编程时，需要考虑的内容是程序做什么、怎么做，重点考虑每个实现细节。采用的主要技术是结构化控制结构和模块化设计。这类程序除科学计算外，大量应用于一般的应用程序开发。这种编程技术的缺陷是不适宜应用于图形用户界面、事件驱动编程，难以开发超大规模的应用程序，特别是随着程序规模的进一趟扩大，系统变和非常难以维护。</p>
<p><strong>面向对象</strong>阶段是目前正广泛流行的编程方法。面向对象编程语言有 Smalltalk、C++、Java 等。面向对象编程语言提供一种全新的编程技术。用面向对象编程，编程模式改为：</p>
<p><strong>程序＝对象＋消息</strong></p>
<p>程序设计者考虑的是对象的描述、对象间的关系、类的管理、什么时候和什么地方调用对象的哪一种方法。面向对象编程的适应范围大大扩大，能适用于大规模应用程序的解决方案、网络计算等。对于编程者来说，最大的优点是面向对象编程能有效支持重用，使超大规模的程序也变行相对容易维护。</p>
<p>面向对象程序设计语言引入许多概念和机制，包括<strong>抽象、对象、消息、类、继承、多态性</strong>等。本节先介绍这些概念和机制，随后将详细介绍 Java 语言如何体现和应用这些概念和机制。</p>
<ol>
<li><strong>抽象</strong></li>
</ol>
<p>抽象（abstraction）是程序设计中最经常使用的技术之一，因为<strong>抽象**</strong>是有效控制程序复<strong>**杂性的重要手段</strong>。在设计初始阶段，采用自顶向下的设计方法，暂时不关心具体细节，首先设计出抽象的算法；随后，抽象的算法步骤逐步被具体的实现替换。程序设计中利用抽象，在面向过程阶段，系统按函数和模块进行设计。在面向对象阶段，利用抽象按<strong>类</strong>设计。<strong>类</strong>是目前支持<strong>抽象</strong>的最好工具。</p>
<ol>
<li><strong>对象</strong></li>
</ol>
<p>在实际生活中，人们每时每刻与对象打交道，例如，汽车、自行车，在特定的应用领域都是对象（Object）。这些现实世界中的<strong>对象</strong>都有<strong>状态、行为和名称</strong>。例如，自行车的品牌、两个轮子的尺寸、行进中的速度等能描述自行车的状态；自行车提供包括加速、减速、刹车等行为。在面向对象语言中，<strong>对象的名称用于程序引用对象，对象的成员变量，用于存储对象的状态信息，对象的方法用于描述对象的行为</strong>。</p>
<ol>
<li><strong>消息</strong></li>
</ol>
<p>一个应用程序总会包含许多对象，通过这些对象之间的交互，实现更高级、更复杂的行为。例如，小张用他的自行车上学读书，在上学的过程中，小张骑着自行车，一会儿让车加速，一会儿让车减速，一会儿又刹车。总之， 一路上，小张与他的自行车一直在进行交互，直到学校。</p>
<p>在程序系统中，<strong>对象之间的交互</strong>通过<strong>相互发送消息</strong>（Message）实现。当对象Ａ希望对象Ｂ执行Ｂ的一个方法时，用对象Ａ发送消息给对象Ｂ来实现。消息发送时，如果还需要其他参数，消息可带参数一起发送。</p>
<ol>
<li><strong>类</strong></li>
</ol>
<p>通常程序系统中会有许多同样类型的对象。例如，每个同学都有一辆自行车。尽管每辆自行车的主人不同，各自行车当时所处的状态不同，但是，自行车所包含的属性、自行车能提供的行为是相同的人们可以统一给出同类对</p>
<p>象的各项属性和能提供的所有行为，据此，区别自行车和汽车是不同种类的对象。如同避免重复描述每辆自行车的属性和行为一样，为了避免程序逐一描述同类中的每个对象的所有属性，详细给出对象的每个方法的描述，<strong>把同一**</strong>类对象的所有共同的属性和行为放在一起描述。这种声明对象共有属性和行为的机制称为<strong>**类</strong>。类的声明定义了类的  所有对象的共有的属性和方法。这样，如果程序声明了自行车类的共有属性和方法，则小张的自行车是自行车类一个实例。如果程序需要，可随时由自行车类创建小王的自行车、小李的自行车等。所以类是对一组相同对象的描述， <strong>类概括了同类对象的共有性质：**</strong>数据和方法<strong>。</strong>类的每个对象都有自己的标识，但它们具有相同的一组属性和提供相<strong>  </strong>同的一组方法**。</p>
<ol>
<li><strong>继承</strong></li>
</ol>
<p>除对象按类划分外，不是同一类的对象可能会存在某些相似性。<strong>继承</strong>（Inheritance）<strong>就是在已有类基础上</strong>，<strong>扩充属**</strong>性，或<strong><strong>扩充与改写</strong></strong>其某些方法，生成新的类，这个方式称为<strong>**继承</strong>。继承定义的类称为子类，被继承的类称为<strong>超类**</strong>（父类<strong>**）</strong>，子类自动含有父类具有的属性和方法。继承具有传递性。例如，自行车可分为山地自行车、比赛用自行车等。山地自行车、比赛用自行车都是自行车类的子类。所之，自行车类是山地自行车、比赛用自行车的超类。<strong>超类声明**</strong>定义共同的特性，子类继承超类的共有特性，还可增加某些特殊性，并可扩充和修正部分行为。<strong>如同大家非常熟悉的几何图形，抽象的几何图形有位置、面积等共同特性，有求面积等方法。四边形、三角形、点都是几何图形的子类。同样四边形又可以有普通的四边形、长方形、菱形等。采用继承声明定义的子类可以有父类的属性和方法，也可以增加新的属性和方法，并可以对父类的某些方法给出新的定义。例如，各种类别的几何图形有不同的求面积的方法。继承的</strong>最大好处<strong>是</strong>对象能按层次划分**，并在子类中，与父类相同的属性和方法可以不再重复声明。继承体现了面向对象方法与现实世界中人们的抽象思维方式保持一致。</p>
<ol>
<li><strong>多态性</strong></li>
</ol>
<p>多态性（Polymorphism）有多种表现形式，这里所说的<strong>多态性**</strong>是指类型适应性多态性，这来自继承，不同继承<strong>**层次的对象对同样的方法有不同的实现</strong>。类型适应性多态性要求自动按对象的实际类型正确调用它的方法。例如， 各类几何图形构成一个继承体系，每种几何图形有特定的求面积方法。一个以几何图形对象为参数的方法 f()运行时，如果需要求这个参数对象的面积，系统根据对象的实际类型，自动按实际对象的类型选取正确的求面积方法。在方法 f()运行之前，只知道参数将对应一个几何图形对象，不知道它是三角形、圆，还是其他别的几何图形。这样，在方法 f()运行之前不能确定参数的求面积方法。这种多态性要求直至方法 f()运行时，知道了与参数对应的实际对象的类型，才确定求面积方法。这种类型适应性的多态性需要采用动态联编（Dynamic Binding）技术实现。</p>
<p><strong>联编</strong>是将发送给对象的<strong>消息与</strong>含执行该消息方法的<strong>对象连接起来</strong>。当联编在<strong>编译和连接阶段**</strong>实现<strong>时，这样的联编过程称为</strong>静态联编<strong>；当</strong>联编<strong>推迟至</strong>运行时间<strong>**实现</strong>时，该联编过程称为<strong>动态联编</strong>。动态联编是面向对象语言必须具有的一种能力，是实现上述多态性的技术基础。</p>
<p><strong>３．２</strong> <strong>Java</strong> <strong>的类和对象</strong></p>
<p>本节介绍 Java 语言的面向对象机制，内容包括类和对象，以及支持面向对象编程提供的一些机制。<strong>３．２．１</strong> <strong>类</strong></p>
<p>类是一种类型，类封装对象的属性和方法，是同一类对象的模板。Java 程序的主要部分是描述类。<strong>１．类的声明</strong></p>
<p>声明一个新类的基本格式如下： class 类名//声明新类的基本格式</p>
<p>{</p>
<p>类体</p>
<p>｝</p>
<p>其中关键字 class 引导一个类的声明，类名是一个标识符。类体给出类的成员变量定义和方法定义，其中类的成员变量用于存储对象的属性，方法描述对象的行为。类体中<strong>不能有**</strong>独立的执行代码<strong>，</strong>所有的执行代码<strong><strong>只能出现在方法中</strong></strong>。**[例 ３.1]学生类 Student 的声明。</p>
<p>class Student{</p>
<p>float height,weight; String name,sex,no;</p>
<p>void setStudent(String n, String s, String o){ name= n;sex =s;no=o; System.out.println(“name:”+name);</p>
<p>System.out.println(“sex:”+sex); System.out.println(“no:”+no);</p>
<p>}</p>
<p>void setWH(float w,float h){ weight = w; height = h;</p>
<p>}</p>
<p>}</p>
<p>在类 Student 中，定义了５个成员变量：height、weight、name、sex 和 no;２个方法：setStudent()和 setＷＨ()。<strong>２．成员变量</strong></p>
<p>成员变量定义的一般形式如下： [修饰字] 类型 变量名；</p>
<p>其中，修饰字可以空缺，修饰字用于对成员变量限制其访问权限，成员的访问权限有<strong>４种</strong>：<strong>private**</strong>、<strong><strong>protected</strong></strong>、<strong>**public</strong> <strong>和友好的</strong>，参见 3.2.5 节。变量的类型可以是任何数据类型，变量的名字是一个标识符。Java 中<strong>成员变量的名字**</strong>可以与<strong>类的</strong>方法的名字<strong>**相同</strong>。</p>
<p>成员变量对类内定义的方法都有效。类的方法中也可定义变量，这种变量称为局部变量，局部变量只在定义它的方法中有效。以下代码示意引用成员变量和局部变量的合法性：</p>
<p>class A{</p>
<p>int x; int f(){</p>
<p>int a = 1; x = a;</p>
<p>}</p>
<p>int g()</p>
<p>{</p>
<p>}</p>
<p><strong>３．方法</strong></p>
<p>int y; y= a+x;</p>
<p>}</p>
<p>方法给出对象的行为，方法的声明如同Ｃ语言函数定义。方法声明的一般形式如下： 返回值类型 方法名（类型 参数名，…，类型 参数名）</p>
<p>｛</p>
<p>方法体</p>
<p>}</p>
<p>返回值类型声明方法返回值的数据类型。如果方法无返回值，就用 void 关键字。方法可以没有参数，多个参数用逗号分隔，参数类型可以是任何数据类型。</p>
<p>[例 3.2]方法的例子，类Ｂ有方法 u()和 v()。class B{</p>
<p>double x,y;</p>
<p>int u(int x,int y){ return x<em>x+y</em>y+1;</p>
<p>}</p>
<p>float v(int a, float b){ return a<em>x+b</em>y;</p>
<p>}</p>
<p>}</p>
<p>如果某方法中的<strong>参数名或局部变量的名**</strong>与<strong>**类的成员变量</strong>的<strong>名相同</strong>，则<strong>成员变量</strong>在这个方法内暂时被<strong>隐藏</strong>。例如， 在以下类Ｂ的声明中，方法u()中的参数x 和y 与成员变量x 和y 同名，方法u()中的x 和 y 引用的参数 x 和 y。<strong>如果**</strong>成员变量<strong><strong>在方法内被</strong></strong>隐藏<strong>**，又在方法中要引用成员变量，必须使用</strong> <strong>this</strong>（参见 3.2.7 中关于关键字 this</p>
<p>的叙述），<strong>thi**</strong>s<strong> </strong>表示调用该方法的<strong>**当前对象</strong>。 class Jerry{</p>
<p>int x,z;</p>
<p>void g(int z){ int x = 5+z; this.x = x; this .z = z;</p>
<p>}</p>
<p>}</p>
<p>参数名和局部变量名可随意命名，建议尽量使用互不相同的名。</p>
<p>在 Java 程序中，类的方法可以重载。<strong>方法重载</strong>是指在<strong>一个类中**</strong>定义多个相同名字的方法<strong>，但这些</strong>方法或者参数<strong><strong>个数不同</strong></strong>或者顺序参数的<strong>**类型不同</strong>。</p>
<p>[例 3.4]方法重载的例子，类Ｃ的４个 fun（）方法或因参数个数不同，或因参数的类型顺序不同，是４个合理的重载方法。</p>
<p>class C{</p>
<p>float fun(float s){ return s*s;</p>
<p>}</p>
<p>float fun(float x,int y){ return x<em>x+y</em>y;</p>
<p>}</p>
<p>float fun(int x,float y){ return x<em>x+y</em>y;</p>
<p>}</p>
<p>float fun(float x,float y){ return x<em>x+y</em>y;</p>
<p>}</p>
<p>}</p>
<p>编译器将根据方法调用时的<strong>参数个数和参数类型及顺序</strong>确定调用的是哪一个方法。例如，调用方法 fun()时， 如果提供一个 float 参数，则是调用第一个 fun()方法，如果参数有两个，且第一个是 float 参数，第二个是int 参数，则是调用第二个 fun()方法。方法参数的名称不能用来区分重载方法。</p>
<p><strong>４．构造方法</strong></p>
<p><strong>构造方法是一种特殊的方法，这种方法的名与它的类名相同，并且不返回结果，也不写上</strong> <strong>void</strong> <strong>关键字</strong>。<strong>构造**</strong>方法<strong><strong>的作用</strong></strong>是创建类的对象<strong>，</strong>并给对象初始化<strong>。</strong>构造方法是<strong>**公共方法</strong>，<strong>但程序**</strong>不能显式调用<strong>**构造方法</strong>。程序运行时  ，当有对象要创建时，由系统自动调用构造方法。</p>
<p>[例 3.5]类内定义构造方法的例子。类 Point 定义了两个构造方法。class Point{</p>
<p>int x,y; Point(){</p>
<p>x=10;y=20;</p>
<p>}</p>
<p>Point(int x,int y){ this.x=x; this.y=y;</p>
<p>}</p>
<p>int getX(){return x;} int getY(){return y;};</p>
<p>}</p>
<p>如果类的声明没有定义构造方法，系统就增补一个没有参数的默认构造方法。</p>
<p><strong>３**</strong>.2.2<strong> </strong>对<strong> </strong>象**</p>
<p>类被声明后，就可用类创建对象，被创建的对象称为类的实例。程序使用对象需依次经历４个步骤：<strong>声明**</strong>对象、<strong><strong>创</strong></strong>建<strong><strong>对象、</strong></strong>使用<strong><strong>对象和</strong></strong>撤销<strong>**对象</strong>。</p>
<p><strong>１．声明对象</strong></p>
<p>由于类是一种引用类型（参见节后面叙述的对象的内存模型），声明对象只是命名一个变量，这个变量能引用类的对象。由于对象还没有创建，所以也暂不要为对象分配内存。声明对象的一般形式为：</p>
<p>类名    对象名； 例如，代码： Point p1,p2;</p>
<p>这里的 Point 是前面声明的类名，上述代码声明 p1,p2 两个对象。<strong>２．创建对象</strong></p>
<p>创建对象就是为对象<strong>分配内存</strong>，为对象分配内存也称为类的<strong>实例化</strong>。一般形式为： <strong>new</strong> 构造方法([参数表])</p>
<p>其中参数被构造方法用于给对象设置初值。例如，代码： p1 = new Point();p2= new Point(30,40);</p>
<p>对象p1 用无参数的构造方法初始化，使 p1 的x 坐标为 10,y 的坐标为 20，对象 p2 用带两个参数的构造方法初始化，使 p2 的x 坐标为 30,y 坐标为 40。</p>
<p>对象创建的两个也可一起完成，一般格式为：</p>
<p>类名 对象名 ＝ new 构造方法（[参数表]） 例如，代码：</p>
<p>Point p3 = new Point(),p4=new Point(60,70);</p>
<p>同时创建两个 Point 对象，p3 的坐标为 10，y 的坐标为 20;p4 的坐标为 60,y 坐标为 70。<strong>３．对象的内存模型</strong></p>
<p>Java 语言将类型分成<strong>基本类型和引用类型</strong>两种。第２章介绍的整型、浮点型、字符型等是基本类型，程序引用这种类型的变量，采用直接访问形式。</p>
<p>在 Java 语言中，数组类型和类类型是引用类型。程序访问引用类型的变量采用间接访问方式。<strong>４．使用对象</strong></p>
<p>程序使用对象有多种情况：或为对象<strong>设置状态</strong>、或<strong>获取</strong>对象的<strong>状态</strong>、或<strong>改变</strong>对象的<strong>状态</strong>、或<strong>应用</strong>对象的某种<strong>方法</strong>。前三种需要访问对象的成员变量，最后一种要调用对象的方法。程序通过操作符“<strong>.</strong>”对某对象的成员变量进行访问和方法调用。一般形式为：</p>
<p>对象名.成员变量</p>
<p>对象名.方法（[参数表]）</p>
<p>参见例３.6，程序首先创建对象 p1 和p2，并利用对象提供的方法 getX()和 getY()，用代码 p1.getX()获得对象 p1 的属性值，p2.getY()获得对象 p2 的y 属性值。由于类 Point 声明中，成员变量是 public 的（参见 3.2.5 访问权限），程序也可以直接用代码 p1.x 获得对象 p1 的x 属性值；用代码 p2.y 获得对象 p2 的y 的属性值。</p>
<p>[例 3.6]使用对象的程序例子public class Examle3_1{</p>
<p>public static void main(String []args){ Point p1,p2,p3;</p>
<p>p1 = new Point();</p>
<p>p2 = new Point(40,50);</p>
<p>p3= new Point(p1.getX()+p2.getX(),p1.getY()+p2.getY());</p>
<p>System.out.println(“p3.x=”+p3.getX()+”,p3.y=”+getY()); Point p4 = new Point(p1.x,p.y); System.out.println(“p4.x=”+p4.x+”,p4.y=”+p4.y);</p>
<p>}</p>
<p>}</p>
<p>//这里是类 Point 声明代码，限于篇幅，这里不再给出，参见３.5 中 Point 类的定义。</p>
<p><strong>3.2.3</strong> <strong>实例变量和类变量</strong></p>
<p>类的成员变量又分为实例变量和类变量。在定义成员变量时，用关键字 <strong>static</strong> <strong>修饰</strong>的是<strong>类变量</strong>，定义时<strong>未用**</strong>static<strong> </strong>修饰<strong>的是</strong>实例变量**。例如，以下代码定义成员变量 x 是实例变量，成员变量 y 是类变量。</p>
<p>class D{ float x; static int y;</p>
<p>…</p>
<p>}</p>
<p>由前面的示例程序看出，程序定义的每个对象都有自己的实例变量。例如，前面程序中，对象 p1,p2,p3 和 p4 都有自己的实例变量 x 和 y。类变量是类的所有对象共享成员变量，一个类变量在类中只有一个，它属于整个类， 而不属于类的某个对象。<strong>引用**</strong>类变量<strong>途径有两条，或</strong>通过类<strong>，或</strong>通过对象**，格式如下：</p>
<p><strong>类名**</strong>.<strong><strong>类变量</strong></strong>名<strong>    </strong>或<strong> </strong>对象名<strong><strong>.</strong></strong>类变量名**</p>
<p>不同对象的实例变量将被分配不同的内存空间。改变类的某一个对象的实例变量的值不会影响其他对象的实例</p>
<p>变量。</p>
<p><strong>类变量的**</strong>内存只有一处<strong>**，让类的所有对象共享</strong>。从类的任一对象改变类变量，类的其他对象都能发现这个改变。</p>
<p><strong>３．２．４</strong> <strong>实例方法和类方法</strong></p>
<p>如同类的成员变量有实例变量和类变量两种一样，类的方法也有两种：实例方法和类方法。在方法定义时，冠以修饰字static 的方法称为类方法，没有冠以 static 修饰字的方法是实例方法。</p>
<p>[例 3.7]类 D 定义了一个实例方法，两个类方法。class D{</p>
<p>int a;//实例变量static int c;//类变量</p>
<p>float max(int x,int y)//实例方法</p>
<p>｛a = x&gt;y?x:y;｝</p>
<p>static int setCount(int c0)//类方法</p>
<p>{ c=c0;}</p>
<p>static void incCount(int step)//类方法</p>
<p>｛c+=step;｝</p>
<p>}</p>
<p>类中的实例方法可以互相调用，并可调用类方法。<strong>类方法也能相互调用</strong>，<strong>但不能直接</strong>调用实例方法，<strong>除非</strong>类方法<strong>引**</strong>入局部对象<strong>，然后</strong>通过局部对象调用实例方法<strong>。另外，</strong>类方法能<strong><strong>直接引用</strong></strong>类变量<strong>，</strong>不能引用<strong>**实例变量</strong>。实例方法可引用  实例变量，也可引用类变量。例如 ，例 3.8 给出的类声明中有些是合法的代码，而有些是不合法的代码。</p>
<p>[例 3.8]含不合法的代码的例子。程序的注释指明合法和不合法的原因class E{</p>
<p>float u;</p>
<p>static float v;</p>
<p>static void setUV(boolean f){</p>
<p><strong>u</strong> = s_m(f);// 非法，类方法不可以调用实例变量 <strong>u</strong> v = s_m(f);//合法，类方法可以调用类方法</p>
<p>v = r_m(!f);//非法，类方法不能直接调用实例方法。</p>
<p>}</p>
<p>static float s_m(boolean f){</p>
<p>return f?u:v;//非法，类方法只能 类变量</p>
<p>}</p>
<p>float r_m(boolean f){</p>
<p>return f?u:v;//合法，实例方法能引用实例变量和类变量</p>
<p>}</p>
<p>}</p>
<p>实例方法可以访问类变量和当前对象的实例变量。<strong>实例方法必须通过对象调用</strong>，不能通过类名调用。类方法只能类变量，</p>
<p>不能够访问实例变量。类方法除了可以通过实例对象调用之外，还可以通过类名调用。</p>
<p>[例 3.9]说明类变量用法的，应用程序。改写 Point 类的声明，在 Point 类中增加一个类变变量 pCount,它的初值为 0。在构造方法中，有类变量 pCount 增 1 的代码，这能记录类的对象个数。</p>
<p>public class Example3_2{</p>
<p>public static void main(String args[]){ Point p1,p2,p3;</p>
<p>p1 = new Point();</p>
<p>p2 = new Point(40,50);</p>
<p>p3 = new Point(p1.getX()+p2.getX(),p1.getY()+p2.getY());</p>
<p>System.out.println(“p3.x=”+p3.getX()+”,p3.y=”+p3.getY()); Point p4 = new Point(p1.x,p2.y); System.out.println(“p4.x=”+p4.x+”,p4.y=”+p4.y);</p>
<p>System.out.println(“程序共有 Point 对象”+Point.pointNum()+ “个”);</p>
<p>}</p>
<p>}</p>
<p>class Point{ int x,y;</p>
<p>static int pCount =0; Point(){</p>
<p>x=10; y=20;</p>
<p>pCount++;</p>
<p>}</p>
<p>Point(int x,int y){ this.x = x; this.y=y; pCount++;</p>
<p>}</p>
<p>static int pointNum(){return pCount;} int getX(){ return x; }</p>
<p>int getY(){ return y; }</p>
<p>}</p>
<p>由于 java 系统内设废弃内存回收程序，所以一般情况下，一个对象使用结束后，程序不必特别通知系统撤销对象。但有时为提高系统资源的利用率，程序也可通过调用方法 <strong>finialize</strong>()<strong>显式通知系统</strong>，<strong>请求系统撤销对象</strong>。</p>
<ol>
<li><ol>
<li><ol>
<li><strong>访问权限</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>访问权限实现访问控制。在类的成员中引入权限控制，保护类的成员不在非期望的情况下被引用。在类声明中，除了类中方法总能访问类的成员变量外，Java 语言为其他类的方法访问本类成员变量和方法，提供以下 4 种访问权限：</p>
<p>public:设置没有限制的访问权限，其他类的方法都能访问。private：设置最强限制的访问权限，其他类的方法都不能访问。protected:只限于<strong>子类和同一包中的类</strong>的方法能访问。</p>
<p><default>：(无修饰，友好的)<strong>只允许同一包中类</strong>的方法访问。</p>
<ol>
<li><strong>public(**</strong>共有<strong>**)</strong></li>
</ol>
<p>类的成员变量被设置成 public 访问权限，则类外的任何方法都能访问它。这样的成员变量就没有任何安全性，在应用程序中很少使用。通常，只有为对象设定的功能性方法被设置 public 访问权限，让类外的方法可以通过对象调用这样的方法，让对象完成它的服务功能。</p>
<ol>
<li><strong>private(**</strong>私有<strong>**)</strong></li>
</ol>
<p>类的成员变量被设置 private 访问权限，则类外的任何方法都不能访问它。方法被设置成私有的，通常这些方法是类内部专用的方法。类通常另定义一些 public 访问权限的方法，通过这些方法访问的成员变量，这样的成员变量的安全性能得到有效的保证。</p>
<ol>
<li><strong>protected**</strong>(<strong><strong>受保护</strong></strong>)**</li>
</ol>
<p>受保护访问权限是一种公有权限和私有权限之间的访问权限。例如，在类 A 的声明中，成员 x 被定义成是受保护的， 则类A 的子类和与类 A 同一包中的别的类可以访问类 A 的受保护成员 x；但对于不是类 A 的子类或与类 A 不在同一包中别的类来说，不可访问受保护成员 x。通常同一包中的一些类与定义受保护成员的类有许多相关性，为了提高系统的效率，让这些相关类的方法可直接访问，这样的成员可考虑设置受保护访问权限。</p>
<ol>
<li><strong>友好变量和友好方法</strong></li>
</ol>
<p>没有修饰的成员变量和方法称为友好变量和友好方法。与受保护访问权限比较，如果只允许同一包中的相关类的方法访问，不让类的子类和其他类的方法访问时，可设置成友好变量和友好方法。</p>
<p>在同一源程序文件中的类，总是在同一包中，如果声明类 A 的源文件中用 import 语句引入了另外一个包中的类C，并用类 C 创建了一个对象 c，那么对象 c 将不能访问类 A 的友好变量和友好方法。如果一个类被修饰为 public 的，那么可以在任何另外一个类中使用该类创建对象。如果一个类不加任何修饰，那么在另外一个类中使用这个类创建对象时，要保证它们是在同一包中。</p>
<p>访问权限说明能访问的范围，表 3-1 是访问权限表，其中打勾的表示可访问，没有打勾的表示不可访问。</p>
<p>表 3-1 访问权限表</p>
<table>
<thead>
<tr>
<th></th>
<th>同类</th>
<th>同包的其他类</th>
<th>所有其他类</th>
<th>不同包的子类</th>
</tr>
</thead>
<tbody>
<tr>
<td>public</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
<tr>
<td>private</td>
<td>YES</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>YES</td>
<td>YES</td>
<td></td>
<td>YES</td>
</tr>
<tr>
<td>&lt;无修饰&gt;(友好)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li><ol>
<li><ol>
<li>继承</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>继承是面向对象语言的重要机制。借助继承，可以扩展原有的代码，应用到其他程序中，而不必重新编写这些代码。在 java 语言中，<strong>继承是通过扩展原有的类，声明新类来实现的</strong>。扩展声明的新类称为子类，原有的类称为超类(父类)。继承机制规定，子类可以拥有超类的所有属性和方法，也可以扩展定义自己特有的属性，增加新方法和重新定义超类的方法。</p>
<p>java 语言<strong>不支持**</strong>多重继承<strong>，限定一个类只能有一个超类。在子类声明中加入 </strong>extends** 子句来指定超类。格式如下： class 子类名 extends 超类名</p>
<p>{</p>
<p>类体</p>
<p>}</p>
<p>例如，代码：</p>
<p>class E extends D</p>
<p>{…}</p>
<p>声明类 E 的超类是类 D，这里假定类 D 已在某处声明。类声明时，如果缺省 extends 子句，未指定超类，则该类的超类是系统声明的类 java.lang.Object.</p>
<p><strong>子类对父类的继承性</strong>，<strong>java</strong> <strong>语言作以下规定</strong>：</p>
<p><strong>子类自然地继承其父类的**</strong>不是<strong> </strong>private<strong> </strong>的成员变量<strong><strong>作为自己的成员变量，并且自然地继承父类中</strong></strong>不是<strong> </strong>private<strong> </strong>的<strong><strong>方</strong></strong>法<strong>**作为自己的方法。</strong></p>
<p>[例 3.10]继承声明子类的例子</p>
<p>程序先声明 Mother 类，定义了一些成员变量和方法。类 Daughter 继承类 Mother,并增加了一些成员变量和方法。 通过Daughter 类对象 girl，能调用从 Mother 类继承的方法，也能调用 Daughter 类新增的方法，或重新定义的方法。class Mother{</p>
<p>private int money; float weith,height;</p>
<p>String speak(String s){return s;} float getWeitht(){return weight;} float getHeight(){return height;} String dance(){return “我会跳舞”;}</p>
<p>}</p>
<p>class Daughter extends Mother{ String cat;</p>
<p>String sing(String s){return s;}</p>
<p>String dance(){return “我是小舞蹈演员”;}</p>
<p>}</p>
<p>public class Example3_10{</p>
<p>public static void main(String argc[]){ Daughter girl =new Daughter(); girl.cat=”漂亮的帽子”;</p>
<p>girl.weight = 35.0f; girl.height =120.0f;</p>
<p>System.out.println(girl.speak(“ 我 是 女 儿 ”)); System.out.println(girl.speak(“我像母亲一样很会说话”)); System.out.println(girl.speak(“我重”+girl.weight + “公斤”)); System.out.println(girl.speak(“我高”+ girl.height + “公分”)); System.out.println(girl.speak(“我还比母亲多一顶”+girl.cat)); System.out.println(girl.sing(“ 我 还 能 唱 歌 ”)); System.out.println(girl.dance());</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是： 我是女儿</p>
<p>我像母亲一样很会说话我重 35.0 公斤</p>
<p>我高 120.0 公分</p>
<p>我还比母亲多一顶漂亮的帽子我还能唱歌</p>
<p>在例 3.10 的程序中，子类 Daughter 中声明的方法 dance()，跟超类中的方法 dance(),方法的<strong>名字、参数的个数和类型完全相同</strong>，<strong>超类的</strong> <strong>dance()**</strong>方法在子类中<strong>就被</strong>隐藏<strong>。当子类对象调用方法 dance()时，自然调用子类的 dance()方法。</strong>超类方法在子类中隐藏称为<strong>**重写或置换</strong>。当子类中定义的成员变量和超类中成员变量同名时，超类的成员变量同样会在子类中被隐藏。子类对成员变量的隐藏和方法的重写可以把超类的状态和行为改变为自身的状态和行为。对于子类对象， 如果子类重写了超类的方法，则子类对象调用这个方法时，调用子类方法。如果子类继承了超类的方法(未重写)，则会调用超类方法。</p>
<ol>
<li>多态性</li>
</ol>
<p>参见例 3.11，程序声明表示几何形状的类 Shape，通过继承类 Shape 声明圆类 Circle 和长方形类 Rectangle.这 3 个类都定义了求面积方法 area()。另在主类 Example3_11 中定义了一个方法 returnArea()，该方法以 Shape 类对象为参数，利用参数对象求出几何图形的面积。</p>
<p>面向对象语言规定，<strong>子类对象**</strong>也是<strong>**超类对象</strong>，<strong>凡超类对象可以应用的地方，子类对象也适用</strong>。将子类对象交给原本处理超类对象的方法 returnArea()时，方法 returnArea()也一样能正确工作。这样，调用方法 returnArea()时，可以提供Shape 类的对象，也可 Circle 类对象，或 Rectangle 类对象。即程序分别用Circle 类对象c 和 Rectangle 类对象r 调用方法 returnArea()也能正确执行。</p>
<p>上述要求，给编译系统带来了一个新问题。因为方法 reaturnArea()在被调用之前，是不知道调用的参数对象具体是哪一种类型，编译暂时不能利用参数s 的类型是Shape,就推断代码 s.area()是调用 Shape 类的求面积方法。如是这样，就会产生错误结果。这种<strong>编译时暂不绑定调用哪个方法，必须在运行时才绑定调用方法的技术称为**</strong>动态<strong>**联编</strong>。而代码 s.area()根据 s 在执行时实际对象的类型不同，调用同名的不同方法，是面向对象语言的一种多态性。解决这种多态性必须采用动态联编技术。由于 Java 语言采用动态联编技术，保证以下程序能得到希望的结果。</p>
<p>有人也将调用<strong>重载方法作为多态性之一</strong>。重载能由调用时提供的参数个数和参数的类型顺序，在编译时就能确定被调用的方法，这种多态性<strong>不需要</strong>动态联编技术的支持。</p>
<p>[例 3.11]说明多态性的程序例子</p>
<p>class Shape{ float area()//</p>
<p>{return 0.0f;}</p>
<p>}</p>
<p>class Circle extends Shape{ float R;</p>
<p>Circle(float r)</p>
<p>{</p>
<p>R = r;</p>
<p>}</p>
<p>float area()</p>
<p>{return 3.1415926f<em>R</em>R;}</p>
<p>}</p>
<p>class Rectange extends Shape{ float W,H;</p>
<p>Rectangle(float w,float h)</p>
<p>{W=w;H=h;}</p>
<p>float area()//</p>
<p>{return W*H;}</p>
<p>}</p>
<p>public class Example3_11{</p>
<p>public static void main(String args[]){ Circle c;</p>
<p>Rectangle r;</p>
<p>c = new rectangle(3.0f,4.0f); System.out.println(“ 圆 面 积 =”+returnArea(c)); System.out.println(“长方形面积=”+returnarea(r));</p>
<p>}</p>
<p>static float returnArea(Shape s){ return s.area();</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是： 圆面积=31.415925</p>
<p>长方形面积=12.0</p>
<ol>
<li><strong>多层继承</strong></li>
</ol>
<p>继承声明的新类，又可被其他类再继承，从而构成多层继承。参见例 3.12，程序首先声明交通工具的类(Vehicle)， 再利用交通工具类，继承声明一个飞行器子类(Aircraft);</p>
<p>又从飞行器(Aricraft)类继承声明两个子类，螺旋直升机(Whirlybird)类和喷气机(Jet)类。这样，Whirlybird 类和Jet 类就是多层继承的类。</p>
<p>[例 3.12]一个多层继承的例子。class Vehircle{</p>
<p>public void start(){System.out.println(“Starting…”);}</p>
<p>}</p>
<p>class Aricraft extends Vehicle{</p>
<p>public void fly(){System.out.println(“Flying…”);}</p>
<p>}</p>
<p>class Whirlybird extends Aircraft{</p>
<p>public void whirl(){System.out.println(“Whirling…”);}</p>
<p>}</p>
<p>class Jet extends Aircraft{</p>
<p>public void zoom(){System.out.println(“Zooming…”);}</p>
<p>}</p>
<ol>
<li><strong>多层继承中构造方法的调用顺序</strong></li>
</ol>
<p>参见例 3.13，类D 继承类 C，类C 继承类 B，类B 继承 A。当创建一个类 D 的对象 obj 时，由于类 D 的继承性，对象obj 含有它所继承的各超类的成员变量，需要调用所继承各超类的构造方法。问题是这样构造方法的调用顺序是怎样的。例子说明构造方法的<strong>调用顺序与类的继承顺序一致</strong>，从最高层次的超类开始，按继承调用各类的构造方法，如果子类的构造方法要调用超类的构造方法，就从超类继承的成员变量初始化，用代码 super(参见 3.2.7 关于关键字super 的叙述)，<strong>并且代码必须是**</strong>构造方法的第一条语句**。</p>
<p>[例 3.13］说明多层继承中构造方法调用顺序的例子class A{</p>
<p>int a; A(int a)</p>
<p>{this.a = a; System.out.println(“Constructing A”);}</p>
<p>}</p>
<p>class B extends A{ int b;</p>
<p>B(int a,int b)</p>
<p>{super(a);this.b=b;System.out.println(“Constructing B”);}</p>
<p>}</p>
<p>class C extends B{ int c;</p>
<p>C(int a,int b,int c)</p>
<p>{super(a,b);this.c = c;System.out.println(“Constructing C”);}</p>
<p>}</p>
<p>class D extends C{ int d;</p>
<p>D(int a,int b,int c,int d)</p>
<p>{super(a,b,c);this.d = d;System.out.println(“Constructing D”);}</p>
<p>}</p>
<p>class Example3_13{</p>
<p>public static void main(String args[]){ D obj = new D(1,2,3,4);</p>
<p>System.out.println(“对象 obj 的值是:”+obj.a+</p>
<p>“,”+obj.b+ “,”+obj.c + “,”+obj.d); System.out.println(“Main Program!”);</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是： Constructing A Constructing B Constructing C Constructing D</p>
<p>对象obj 的值是：1，2，3，4 Main Program!</p>
<p><strong>3.2.7 Java</strong> <strong>面向对象的其他机制</strong></p>
<p>为了构造和编写面向对象程序的需要，Java 语言还引入一些非常用用的机制。本小节介绍其中对程序构造和编写比较有用的一些机制。</p>
<p>​    <strong>1.</strong>    <strong>final</strong> <strong>类、**</strong>final<strong> </strong>方法和<strong> </strong>final<strong> </strong>变量**</p>
<p>final 的意义是<strong>最终的</strong>，用于修饰类、方法和变量，其意思是“<strong>不能改变</strong>”。<strong>禁止改变</strong>可能是考虑到“设计”和“效率”两个方面。</p>
<p>在类声明之前用 final 修饰，声明类是 final 类，final 类是<strong>不能被再继承</strong>的类，即它<strong>不能再有子类</strong>。例如，以下代码声明类C 是 final 类：</p>
<p>final class C{</p>
<p>…</p>
<p>}</p>
<p>用 final 修饰的变量，声明该变量的值不能被改变。不能被改变的变量相当于一个常量。final 变量主要用于以下<strong>两**</strong>个方面<strong>：</strong>或是一个编译期的常数，<strong><strong>它永</strong></strong>远不会改变<strong><strong>；或在初始化后，</strong></strong>不希望它再改变**。例如，以下代码声明 FINALVAR 是一个 final 变量：</p>
<p>final int FINALVAR = 100;</p>
<p>final 局部变量在定义时可以暂不设定初值，但是一经初始化，以后就不能再改变。例如，以下代码： final int AFINAL;</p>
<p>… …//假设这里的代码没有对 AFINAL 赋值AFINAL=1;//以后不能再给 AFINAL 再赋值</p>
<p>常用 final 声明常量，常量名习惯全部用大写字母命名。</p>
<ol>
<li><strong>abstract</strong> <strong>类和</strong> <strong>abstract</strong> <strong>方法</strong></li>
</ol>
<p>abstract 类称为抽象类。抽象类只声明一种模板，没有具体实现代码的类。只有它的<strong>子类才能</strong>是有实际意义的类。所以<strong>抽象类**</strong>不可<strong>**有实例</strong>。即不能用抽象类声明或创建对象。</p>
<p>abstract 方法称为抽象方法。抽象方法只能出现在抽象类中，抽象方法没有实现的代码。如果一个类是抽象类的子类，则必须具体实现超类的抽象方法。<strong>抽象类**</strong>可以没有<strong>**抽象方法</strong>，但<strong>有抽象方法的类**</strong>一定<strong>**是抽象类</strong>。</p>
<p>[例 3.14]含抽象类和抽象方法的程序。abstract class Shape{</p>
<p>int x,y;</p>
<p>void MoveTo(int newx,int newy){x = newx;y=newy;} Shape(int newx,int newy){x=newx;y=newy;} abstract void Draw();</p>
<p>}</p>
<p>class Square extends Shape{ int len;</p>
<p>Square(int px,intpy,int l){super(px,py);len =l;} void Draw(){</p>
<p>System.out.print(“我是正方形”);</p>
<p>System.out.print(“我的中心位置是：”+”(“+x”,”+y+”),”); System.out.println(“我的边长是：”+len);</p>
<p>//以x,y 为中心，边长 len 的正方形</p>
<p>}</p>
<p>}</p>
<p>class Circle extends Shape{ int radius;</p>
<p>Circle(int px,int py,int r){super(px,py);radius=r;} void Draw(){</p>
<p>System.out.print(“我是圆形”);</p>
<p>System.out.print(“我的中心位置是：”+”(“+x”,”+y+”),”); System.out.print(“我的半径是:”+radius);</p>
<p>//以 x,y 为圆心，半径为 radius 的圆</p>
<p>}</p>
<p>}</p>
<p>class ShapeDraw{</p>
<p>void draw(Shape obj)</p>
<p>{obj.Draw();}//利用动态联编，按实际对象调用相应的 Draw()方法</p>
<p>}</p>
<p>public class Example3_14{</p>
<p>public static void main(String args[]){ ShapeDraw sd = new ShapeDraw(); Square s = new Square(10,10,5); Circle c = new Circle(30,30,5);</p>
<p>sd.draw(s);//以 s 为实参调用 sd 的 draw 方法sd.draw(c);//以 s 为实参调用 sd 的 draw 方法</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是：</p>
<p>我是正方形，我的中心位置是：(10，10)，我的边长是：20 我是圆形，我的中心位置是：(30，30)，我的半径是 5</p>
<ol>
<li><strong>关键字</strong> <strong>super</strong></li>
</ol>
<p>子类隐藏了超类的成员变量或者<strong>覆盖</strong>了<strong>超类方法</strong>后，利用关键字 super，子类方法可以引用超类的成员变量和被覆盖的方法。使用 super 有 3 种情况：使用 super 调用超类的构造方法，参见多层继承中构造方法的调用顺序；使用 super 调用超类被子类覆盖的方法；使用 super 访问超类被子类隐藏的成员变量。</p>
<p>[例 3.15]使用 super 调用超类构造方法、超类方法和超类成员变量的程序。class A{</p>
<p>int x;</p>
<p>A( int inf){x = inf;}</p>
<p>void method(){System.out.println(“我是类 A 的方法!值是”+x);} int getX(){return x;}</p>
<p>}</p>
<p>class B extends A{ double x;</p>
<p>B(int a,double b)</p>
<p>{</p>
<p>super(a); x = b;</p>
<p>}</p>
<p>void method(){System.out.println(“我是类 B 的方法!值是”+x);}</p>
<p>}</p>
<p>class C extends B{ char x;</p>
<p>C(int a,double b,char c){ super(a,b);</p>
<p>x=c;</p>
<p>}</p>
<p>void method(){ char chCx =x;</p>
<p>int iAx = this.getX(); super.method();</p>
<p>System.out.println(“我是类 C 的方法!值是”+x);</p>
<p>System.out.println(“我获得的信息是：”+“chCx=”+x+chCx+”,dBx=”+dBx+”,iAx=”+iAx);</p>
<p>}</p>
<p>}</p>
<p>public class Example3_15{</p>
<p>public static void main(String args[]){ C c = new C(2,3,0,’C’);</p>
<p>c.method();</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是：</p>
<p>我是类 B 的方法!值是 3。0 我是类 C 的方法!值是 C</p>
<p>我获得的信息是：chCx=CC,dBx=3.0,iAx=2</p>
<ol>
<li><strong>关键字</strong> <strong>this</strong></li>
</ol>
<p>关键字 <strong>this</strong> 用来指<strong>对象自己</strong>。<strong>this</strong> 的作用有多种，例如，将对象自己作为参数，调用别的方法；<strong>当方法的局部变量**</strong>隐藏成员变量时，利用<strong> </strong>this<strong> </strong>引用<strong><strong>成员变量；在构造函数内</strong></strong>调用<strong>**另一构造函数等</strong>。参见以下示例。</p>
<p>Class B{ int b,c;</p>
<p>B(){this(2,3);}</p>
<p>B(int x,int y){b =x ;c=y;}</p>
<p>}</p>
<ol>
<li>类之间的 is-a 和 has-a 关系</li>
</ol>
<p>在两个相关的类之间，例如，类 A 和类 B，可能会有 is-a 和 has-a 关系。参见例 3.16，类 A 是继承扩展类B，则子类A 和超类 B 之间是 is-a 关系，类 B 的所有成员类 A 也有，类 A 也是一个类 B。</p>
<p>[例 3.16]类 A 继承扩展类 B，类 A 和类B 之间有is-a 关系。class B{</p>
<p>int b;</p>
<p>B(int x){b =x;}</p>
<p>void write(){System.out.println(“这是来自 B 的输出!”);}</p>
<p>}</p>
<p>class A extends B{ int a;</p>
<p>A(int x,int y){</p>
<p>super(x); a = y; write();</p>
<p>System.out.printn(“我是子类 A!”+ “b=”+b+ “,a=”+a);</p>
<p>}</p>
<p>}</p>
<p>public class Example3_16{</p>
<p>public static void main(String args[])</p>
<p>{</p>
<p>a obj = new A(1,2);</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是： 这是来自类 B 的输出! 我是子类 A!b=1,a=2</p>
<p>如果类A 的某个成员变量的类型是B，则类A 和类B 之间是has-a 关系，即<strong>类**</strong>A<strong> </strong>包含<strong>有</strong>类<strong> </strong>B**。例 3.17 是 has-a 关系例子，类 A 中成员变量 b 的类型是 B。</p>
<p>[例 3.17]类 A 的某个成员变量的类型是 B，类 A 和类B 之间是 has-a 关系。</p>
<p>class A{</p>
<p>B b; int a;</p>
<p>A(int x,int y,int z){ b = new B(x,y);</p>
<p>a = z; b.write();</p>
<p>}</p>
<p>}</p>
<p>class B{</p>
<p>int b1,b2; B(int x,int y){</p>
<p>b1= x;b2=y;</p>
<p>}</p>
<p>void write(){</p>
<p>System.out.println(“这是来自类 B 的输出!”);</p>
<p>}</p>
<p>}</p>
<p>public class Example3_17{</p>
<p>public static void main(String args[]){ A obj = new A(1,2,3);</p>
<p>}</p>
<p>}</p>
<p>程序输出结果是： 这是来自类 B 的输出!</p>
<ol>
<li>内部类(inner class)</li>
</ol>
<p>Java 语言也允许在类声明内部嵌套类声明。嵌套的类可以是静态的或者是非静态的。<strong>静态类**</strong>不能直接引用其包含类的成员，<strong>**必须实例化</strong>，所以不经常使用。非静态的嵌套类，因为需要进行事件处理，非常流行。参见例 3.18，类 B 在类A 的内部声明，而且在类 A 的构造方法中实例化一个类 B 的内部对象。</p>
<p>[例 3.18]一个含内部类的程序class A{</p>
<p>B obj;</p>
<p>A(){obj = new B(); obj.print();} class B{</p>
<p>public void print(){ System.out.println(“内部类 B…”);</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>public class Example3_18{</p>
<p>public static void main(String args[])</p>
<p>{</p>
<p>A obj = new A();</p>
<p>}</p>
<p>}</p>
<ol>
<li><ol>
<li><strong>接口</strong></li>
</ol>
</li>
</ol>
<p>Java 程序中的类只能继承一个类，这种继承称为单继承。Java 语言虽不允许一个类继承多个类，但允许一个类实现多个接口。接口(Interface)有与类相似的基本形式。<strong>接口有常量定义和方法定义，但没有方法的实现代码</strong>。可以将接口想象为一个“纯“抽象类。接口给出某种特定功能的一组方法的规范，而并未真正地实现每个方法，方法的实现要在实现这个接口的类中完成。接口也是对一些类为实现某些控制所建立的一个”协议“。例如，为键盘操作建立一个键盘操作，</p>
<p>定义了响应键盘操作的一组方法，给出每个方法的规范：方法的名称、返回值类型，参数个数与参数类型。实现键盘控制的一些类，加为它们对键盘操作的目的各有不同，各有不同的实现方案，但都必须按接口给定的规范给出自己的实现。形象地说，接口对实现接口的类提出这样的要求：“实现我的所有类，都应该包含像我现在这种样子，并给出方法的全部实现 ”。</p>
<p>类除了能继承一个类之外，还可实现多个接口。这样，对有继承并实现接口的类来说，实际上有了多个超类，实现有控制的多重继承。</p>
<p>接口的优点是很明显的。例如，在程序开发的早期建立一组协议而不给出具体实现，便于设计更合理的类层次。所以， 接口比多继承更强、更容易控制。</p>
<ol>
<li><strong>接口的定义</strong></li>
</ol>
<p>接口定义包括接口声明和接口体两部分。一般形式如下？ [public]interface 接口名 [extends 超接口表]{</p>
<p>接口体</p>
<p>}</p>
<p>接口名通常以 <strong>able</strong> <strong>或</strong> <strong>ible</strong> <strong>结尾</strong>，意指能做什么。接口是一种只由常量定义和抽象方法组成的特殊类。public 修饰的类是公共接口，可以被所有的类和接口使用；而没有 public 修饰的接口只能被同一个包中的其他类和接口使用。</p>
<ol>
<li><strong>接口体</strong></li>
</ol>
<p>接口体中的内容是一系列常量定义和方法定义。其中方法定义是一种方法声明，不提供方法的实现(没有方法体)， 用分号“；”结尾。方法的实现在“使用”这个接口的各个类中，故称使用接口的类为接口的实现。以下是一个 接口定义的示例：</p>
<p>interface Sleepable{ final int max=100;</p>
<p>void sleepSometime(int deltaT); float work (float x,float y);</p>
<p>}</p>
<p><strong>接口</strong> <strong>的**</strong>所有变量<strong>**都默认为</strong> <strong>final static</strong> <strong>属性；所有的**</strong>方法<strong>**都默认为是</strong> <strong>public abstract</strong> <strong>属性。</strong></p>
<p>一个类通过使用关键字 implements 声明自己使用一个或多个接口。实现多个接口时，接口名之间用逗号隔开。以下示例代码说明类 Pig 继承类 Animal 并实现两个接口 eatable 和 sleepable。</p>
<p>class Pig extends Animal implements Eatable, Sleepable</p>
<p>{…}</p>
<p><strong>如果一个类要实现某个接口，那么这个类**</strong>必须实现该接口的所有方法<strong>**，为这些方法实现的方法体</strong>。<strong>在实现接口</strong>  <strong>的方法时，方法的名字、返回值类型、参数个数及类型必须与接口中的定义的方法完全一致，并**</strong>一定要用<strong> </strong>public<strong> </strong>修饰<strong>**。</strong>如果接口的方法的返回值类型不是 void,那么在实现该方法的体中至少要有一个 return 语句；如果方法不返回值，则为 void 类型，类体除了两个大括号外，可以没有任何语句。</p>
<p>[例 3.19]声明接口和类实现接口的例子。interface Computable{</p>
<p>final int MAX =100; void speak(String s); int f(int x);</p>
<p>int g(int x,int y);</p>
<p>}</p>
<p>class A implements Computable{ int no;</p>
<p><strong>public</strong> int f(int x){ int sum = 0;</p>
<p>for(int i=0;i&lt;=x;i++){sum =sum+i;} return sum;</p>
<p>}</p>
<p><strong>public</strong> int g(int x,int y)</p>
<p>{</p>
<p>return x*y;</p>
<p>}</p>
<p><strong>public</strong> void speak(String s){</p>
<p>}</p>
<p>}</p>
<p>class B implements Computable{ int no;</p>
<p>public int f(int x){ int sum =0;</p>
<p>for(int i=0;i&lt;=x;i++){sum = sum+i*i;} return sum;</p>
<p>}</p>
<p>public int g(int x,int y){return x+y;} public void speak(String s){</p>
<p>}</p>
<p>public class Example3_19{</p>
<p>public static void main(String args[]){ A Li;</p>
<p>B Tom;</p>
<p>Li = new A(); Li.no =951898; Tom = new B();Tom.no = 951899;</p>
<p>System.out.print(“Li 的编号：”+Li.no+ “,最大值：”+Li.MAX); System.out.print(“, 从 1 到 100 求 和 =”+Li.f(100)); System.out.print(“,3 与 4 的 积 =”+Li.g(3,4)); System.out.print(“,Tom 的编号：”+Tom.no+ “，最大值：”+ Tom.MAX); System.out.print(“, 从 1 平 方 加 到 9 平 方 =”+Tom.f(9)); System.out.print(“,5 与 6 的和=”+Tom.g(5,6));</p>
<p>}</p>
<p>}</p>
<p>程序的输出结果是：</p>
<p>Li 的编号：951898，最大值：100，从 1 到 100 求和=5050，3 与 4 的积=12</p>
<p>Tom 的编号：951899，最大值：100，从 1 平方加到 9 平方=285，5 与 6 的和=11</p>
<ol>
<li><ol>
<li><strong>基本类</strong></li>
</ol>
</li>
</ol>
<p>Java 语言为一些基本类型设有对应的基本类，如表 3-2 所示。表 3-2 基本类型与基本类</p>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>对应的基本类</th>
<th>基本类型</th>
<th>对应的基本类</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>Boolean</td>
<td><strong>int</strong></td>
<td><strong>Integer</strong></td>
</tr>
<tr>
<td><strong>char</strong></td>
<td><strong>Character</strong></td>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
<p>基本类型值与对应基本类对象能相互转换。可以利用以下形式的基本类构造方法，由基本类型值得到对应基本类对象： public 基本类(基本类型 v)</p>
<p>例如，以下代码得到一个 Integer 对象，其值是 123 Integer n = new Integer(123);</p>
<p>也可以<strong>由基本类对象得到基本类型值</strong>。实现方法如以下例子所示： 设有 Double 类对象 dObj，Boolean 类对象 bObj,代码：</p>
<p>double d = dObj.doubleValue();</p>
<p>使得 dObj 对象的值赋值给 double 类型变量d。代码： boolean b = bObj.booleanValue();</p>
<p>bObj 对象的值赋值给 boolean 类型变量 b。类似的代码可以用于其他类对象与对应的基本类型变量。</p>
<ol>
<li><ol>
<li><strong>Java</strong> <strong>小应用程序基础</strong></li>
</ol>
</li>
</ol>
<p>Java 小应用程序即 Java Applet，是嵌入在 Web 面上供浏览器运行的程序，可放在服务器上供客户端下载使用。小应用程序的主要功能是显示图形、动画、播放声音、响应用户事件等。每个小应用程序都继承 java.applet.Applet 类。</p>
<p>如果小应用程序已用 import java.applet.Applet 导入系统的 Applet 类，小应用程序的主类必须按以下形式声明： public class 主类名 extends Applet</p>
<p>如果没有用 import 导入系统 Applet 类，则主类的声明应写成： public 类名 extends java.applet.Applet</p>
<p>为了系统的安全，对小应用程序有一定限制:<strong>不能**</strong>调用本地的<strong><strong>应用程序</strong></strong>和运行时的<strong>**动态连接库</strong>；<strong>不能**</strong>访问<strong>**本地文件</strong>，如读、写文件；<strong>除原小应用程序所在的位置</strong>(站点)外，<strong>不能再做**</strong>网络连接与<strong> </strong>WWW<strong> </strong>建立联系<strong>，</strong>不能<strong>**获得任何有关系统设置的信息</strong>。</p>
<ol>
<li><strong>小应用程序的建立和运行</strong></li>
</ol>
<p>例 3．20 是一个简单的小应用程序的例子，说明小应用程序的建立和运行的步骤。</p>
<p>[例 3.20]说明小应用程序的建立和运行步骤的小应用程序。有关图形界面的内容参见第 5 章。类中各方法参见后面关于Applet 类的方法的叙述。该程序启动后，如果不断地切换屏幕，文字的显示位置会往下移动。</p>
<p>import java.applet.<em> import java.awt.</em>;</p>
<p>public class Example3_20 extends Applet{ int pos;</p>
<p>public void init(){pos =5;} public void start(){repaint();} public void stop(){}</p>
<p>public void paint(Graphics g){</p>
<p>g.drawString(“我们正在学习 java 程序设计”，20，pos+10); pos = (pos+20)%100+5;</p>
<p>}</p>
<p>}</p>
<p>一个小应用程序从建立到运行需经历 4 个步骤：</p>
<ol>
<li><strong>用</strong> <strong>Java</strong> <strong>语言编写小应用程序的源程序。</strong></li>
</ol>
<p>小应用程序由若干类组成，在源程序中必须有一个类继承 java.applet.Applet 类，这个类是小应用程序的主类。小应用程序的主类，用 public 关键字修饰。小应用程序的源文件名必须与它的主类名完全相同。</p>
<ol>
<li><strong>把小应用程序的源程序编译成字节码**</strong>.class<strong> </strong>文件。**</li>
</ol>
<p>如果源文件有多个类，那么经编译后将生成多个.class 文件。</p>
<ol>
<li>将小应用程序的字节码文件嵌入在 Web 页中，设计一个指定小应用程序的 HTML 文件.html。以下是启动小应用程序的 HTML 文件结构：</li>
</ol>
<HTML><br><br><HEAD><br><br><TITLE>String named by Programmer </TITLE><br><br></HEAD><br><br><BODY><br><br><APPLET><br><br>[CODE BASE =Applet 的 路 径 ] CODE = Applet 的字节码文件名WIDTH = Applet 在 Web 页中的宽度<br><br>HEIGHT = Applet 在 Web 页中的高度[<PARAM NAME =参数名 VALUE= 参数值>]<br><br>[&lt;!注释&gt;][可选的辅助文本]<br><br></APPLET><br><br></BODY><br><br></HTML>

<p>​    <strong>(4)</strong>    <strong>在支持</strong> <strong>Java</strong> <strong>的浏览器上运行。</strong></p>
<p>或用观察器 appletviewer，或用 Netscape、Hotjava、IE 等。如果采用某个 Java 开发环境。也可在开发环境下执行小应用程序。</p>
<ol>
<li><strong>Applet</strong> <strong>类的基本方法**</strong>(1)init()<strong>**方法</strong></li>
</ol>
<p>初始化，由浏览器载入内存时调用 init()方法，<strong>该方法**</strong>只运行一次**。其用途是创建所需要的对象、设置初始状态、装载力图像、设置参数等。</p>
<ol>
<li><strong>start()**</strong>方法**</li>
</ol>
<p>初始化后，<strong>紧接着调用</strong> <strong>start()**</strong>方法<strong>、启动小应用程序主线程，或当用户从小应用程序所在的 Web 页面转到其他页面， 然后又</strong>返回该页面时<strong>，</strong>start()<strong>**方法将再次被调用</strong> 。</p>
<ol>
<li><strong>stop()**</strong>方法**</li>
</ol>
<p>当<strong>浏览器</strong>离开小应用程序所在的页面<strong>转到其他页面时</strong>，调用 <strong>stop</strong>()方法，挂起小应用程序的执行。<strong>(4)destroy()**</strong>方法**</p>
<p><strong>当关闭浏览器时</strong>，系统调用 <strong>destroy</strong>()方法，结束小应用程序的生命，关闭线程释放对象资源。</p>
<ol>
<li><strong>paint(Graphics</strong> <strong>g)**</strong>方法**</li>
</ol>
<p>该方法用于在屏幕窗口上显示某些信息。如文字、色彩、背景和图像等。当小应用程序启动时，浏览器产生一个 Graphics 类的对象，供小应用程序使用，并以参数g 传递给方法 paint()。小应用程序可以把 g 理解为一支画笔。</p>
<p>小应用程序主类的程序结构如下：</p>
<p>public class AppletName extends java.applet.Applet{ public void init(){…}</p>
<p>pulic void start(){…} public void stop(){…} public void destroy(){…}</p>
<p>public void paint(Graphics g){…}</p>
<p>…</p>
<p>}</p>
<ol>
<li><strong>repaint()**</strong>方法**</li>
</ol>
<p>为在 java 页面上显示动态效果，需要 repaint()方法，repaint()调用 update(),repaint()先清除 paint()方法以前所画的内容，然后再调用 paint()方法。</p>
<p>在例 3.20 的小应用程序中，start()方法调用 repaint()方法，因此每当小程序调用 start()方法时，将会导致以前用paint()方法所画的内容消失，并紧接着再调用 paint()方法。由于 paint()方法对显示字符串的位置有修改，这样每当调用 start()方法时，字符串的显示位置会移动。</p>
<ol>
<li><strong>update()**</strong>方法**</li>
</ol>
<p>调用 repaint()方法时，系统会自动调用 update()方法。update(Graphics g)方法是从父类 Applet 继承来的，该方法的功能是清除 paint()方法以前所画的内容，然后再调用 paint()方法。小应用程序重写 update()方法，可以达到特定的要求。参见 7.2.1 例 7.3。</p>
<ol>
<li><strong>小应用程序的生命周期**</strong>(<strong><strong>执行过程</strong></strong>)**</li>
</ol>
<p>(1)下载并实例化小应用程序，系统调用 init()方法。(2)启动，系统调用 start()方法。</p>
<ol>
<li>小应用程序暂停执行，或因Browser 转向其他网页，或小应用程序调用stop()方法，或小应用程序执行paint(Graphics g)方法</li>
<li>重新启动，或重新进入小应用程序所在页面，重新激活小应用程序，或小应用程执行 paint(Graphics g)方法完成。(5)终止，或退出浏览器，或执行 destroy()消亡方法。</li>
</ol>
<p>当浏览器打开超文本文件，例如 Example3_20.html,发现有 APPLET 标记时，就创建主类 Example3_20 对象，该对象是小应用程序主类的实例，具体表现是一个视窗。视窗是一个容器，它的大小由超文本中的 width 和 height 来确定，参见第5 章。</p>
<ol>
<li><strong>小应用程序数据输入输出</strong></li>
</ol>
<p>小应用程序的数据输入有多种方式。从图形界面的文本框、文本区输入；也可以采用系统标准输入；还可以由 HTML 文件</p>
<p>中的参数导入。</p>
<p>这里只小应用程序从它的 HTML 文件导入 参数的方法。设小应用程序有以下成员变量定义： int sleepTime;String filename;</p>
<p>该小应用程序的 HTML 文件 用以下形式的代码指定小应用程序主类成员变量 sleepTime 与 fileName 的值：</p>
<PARAM NAME = “sleepTime” VALUE= “1000”>

<PARAM NAME = “filename” VALUE = “mypic.jpg”>

<p>小应用程序在 init()方法中可帮以下代码读取上述两个成员变量的值： String s = getParameter(“sleeptime”);</p>
<p>sletpTime = Integer.parseInt(s); fineName = getParameter(“filename”);</p>
<p>小应用程序在窗口中输出数据，需要重新设计 paint()方法。该方法主要调用 drawstring()方法。调用 drawString() 方法的格式如下：</p>
<p>g.drawString(string,xPos,yPos);</p>
<p>参数 string 是要输出的字符串，xPos 和 yPos 是字符串在输出窗口的像素坐标。</p>
<p>习题</p>
<ol>
<li><ol>
<li>什么是面向对象技术？它有什么优点？</li>
<li>面向对象的程序设计与面向过程的程序设计有什么区别？</li>
<li>在程序中类和对象有什么区别？</li>
<li>举例说明类方法和实例方法，以及类变量和实例变量的区别。什么情况下用实例变量？什么情况下用类变量？</li>
<li>子类继承超类的哪些成员变量和方法？</li>
<li>子类在什么情况下能隐藏超类的成员变量和方法？</li>
<li>在子类中是否允许有一个方法和超类的方法名字相同，而类型不同？</li>
<li>试说出对象、类、继承和多态性的概念。</li>
<li>为什么要定义抽象类？为什么抽象类没有具体的对象？</li>
<li>试比较接口和抽象类的异同。使用接口有哪些注意事项？</li>
<li>指出 Applet 的程序结构及各方法的作用。</li>
<li>以下程序有什么错误？</li>
</ol>
</li>
</ol>
</div><div><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/2021/01/25/Java%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8A%80%E6%9C%AF/" target="_blank">Java应该掌握的知识</a><br></span><span>  2.<a class="is-size-6" href="/2020/10/31/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/" target="_blank">中国近现代史纲要</a><br></span><span>  3.<a class="is-size-6" href="/2020/10/16/%E5%8E%86%E5%8F%B2%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E6%97%A7%EF%BC%89/" target="_blank">中国近代史大纲</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://github.com/moruoyiming/Hotfix/blob/master/file/alipay-reward-image.jpeg?raw=true￿" alt="支付宝"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://raw.githubusercontent.com/moruoyiming/Hotfix/master/file/wechat-reward-image.jpeg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/22/Gralde%20%E6%8F%92%E4%BB%B6%E6%8F%90%E7%A4%BAbecause%20no%20repositories%20are%20defined%E9%94%99%E8%AF%AF/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Gradle插件开发no repositories are defined错误解决</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/31/%E4%B8%AD%E5%9B%BD%E8%BF%91%E7%8E%B0%E4%BB%A3%E5%8F%B2%E7%BA%B2%E8%A6%81/"><span class="level-item">中国近现代史纲要</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: '2cc2b31eb7bd534895d90458f8d26188',
            repo: 'moruoyiming.github.io',
            owner: 'moruoyiming',
            clientID: '9dd24089260d4de9145a',
            clientSecret: '2202ac99ec143c79f6124a7074ec5d1aac907aab',
            admin: ["moruoyiming"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8241795889030186" data-ad-slot="4571542544" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="" src="/img/avatar.png" alt="Brigitte Jian"></figure><p class="title is-size-4 is-block line-height-inherit">Brigitte Jian</p><p class="is-size-6 is-block">小小码农的奇妙世界</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京 朝阳</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">72</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">87</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/moruoyiming" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/moruoyiming"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="YouTube" href="https://www.youtube.com/channel/UCemLDs1nqPnjHN04JCNtmbg"><i class="fab fa-youtube"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Jianshu" href="https://www.jianshu.com/u/0352e2f94969"><i class="fab fa-leanpub"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://www.instagram.com/jianzeyicong/?hl=en"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Flickr" href="https://500px.com/p/moruoyiming123?view=photos"><i class="fab fa-500px"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://legacy.gitbook.com/book/alleniverson/java-basic-introduction/details" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">JAVA基础</span></span><span class="level-right"><span class="level-item tag">legacy.gitbook.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://www.androiddevtools.cn/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">安卓工具</span></span><span class="level-right"><span class="level-item tag">www.androiddevtools.cn</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://idea.lanyus.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">IDEA破解</span></span><span class="level-right"><span class="level-item tag">idea.lanyus.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://www.bejson.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线解析</span></span><span class="level-right"><span class="level-item tag">www.bejson.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="http://www.atool.org/httptest.php" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">在线接口</span></span><span class="level-right"><span class="level-item tag">www.atool.org</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://tinypng.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">图片压缩</span></span><span class="level-right"><span class="level-item tag">tinypng.com</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://wallpapershome.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">高清壁纸</span></span><span class="level-right"><span class="level-item tag">wallpapershome.com</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><a class="media-left" href="/2021/01/26/MAC%20OS%20Big%20Sur%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%B8%8B%20Android%20Studio%20%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E5%8D%A1(bug)/"><p class="image is-64x64"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug)"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-26T08:22:06.700Z">2021-01-26</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/26/MAC%20OS%20Big%20Sur%E6%96%B0%E7%B3%BB%E7%BB%9F%E4%B8%8B%20Android%20Studio%20%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%E5%8D%A1(bug)/">MAC OS Big Sur新系统下 Android Studio 打开新窗口卡(bug)</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article><article class="media"><a class="media-left" href="/2021/01/26/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/"><p class="image is-64x64"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="网络状态码分类"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-26T03:15:48.874Z">2021-01-26</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/26/%E7%BD%91%E7%BB%9C%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB/">网络状态码分类</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article><article class="media"><a class="media-left" href="/2021/01/26/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY:%20installPackageL/"><p class="image is-64x64"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-26T03:13:21.970Z">2021-01-26</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/26/%E5%AE%89%E8%A3%85apk%E6%8F%90%E7%A4%BAFailure%20%5BINSTALL_FAILED_TEST_ONLY:%20installPackageL/">安装apk提示Failure [INSTALL_FAILED_TEST_ONLY/ installPackageL</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article><article class="media"><a class="media-left" href="/2021/01/25/Java%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8A%80%E6%9C%AF/"><p class="image is-64x64"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="Java应该掌握的知识"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-25T07:27:35.812Z">2021-01-25</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/25/Java%E5%BC%80%E5%8F%91%E8%80%85%E5%BA%94%E8%AF%A5%E6%8E%8C%E6%8F%A1%E7%9A%84%E6%8A%80%E6%9C%AF/">Java应该掌握的知识</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E8%87%AA%E8%80%83/">自考</a></p></div></article><article class="media"><a class="media-left" href="/2021/01/22/CoordinatorLayout%20%E4%B8%8Eviewpage%20%E4%BD%BF%E7%94%A8%20viewpager%20%E5%86%85%E5%A6%82%E4%BD%95%E7%A9%BA%E5%87%BA%20%E9%AB%98%E5%BA%A6/"><p class="image is-64x64"><img class="thumbnail" src="/gallery/thumbnails/8e383593gy1gjqadonhthj23sw2j41l0.jpg" alt="CoordinatorLayout 与viewpage 使用 viewpager 内如何空出子布局高度"></p></a><div class="media-content size-small"><p><time dateTime="2021-01-21T16:12:53.000Z">2021-01-22</time></p><p class="title is-6"><a class="link-muted" href="/2021/01/22/CoordinatorLayout%20%E4%B8%8Eviewpage%20%E4%BD%BF%E7%94%A8%20viewpager%20%E5%86%85%E5%A6%82%E4%BD%95%E7%A9%BA%E5%87%BA%20%E9%AB%98%E5%BA%A6/">CoordinatorLayout 与viewpage 使用 viewpager 内如何空出子布局高度</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Android%E5%BC%80%E5%8F%91/">Android开发</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Android基础</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Android%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">Android开发</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/IOS%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">IOS应用</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Mac%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">Mac应用</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/TensorFlow/"><span class="level-start"><span class="level-item">TensorFlow</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"><span class="level-start"><span class="level-item">学习资料</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"><span class="level-start"><span class="level-item">科学上网</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%B2%BE%E5%93%81%E7%BE%8E%E6%96%87/"><span class="level-start"><span class="level-item">精品美文</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BB%8F%E5%85%B8%E7%94%B5%E5%BD%B1/"><span class="level-start"><span class="level-item">经典电影</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">51</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Android/"><span class="tag">Android</span><span class="tag is-grey-lightest">42</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"><span class="tag">蓝牙开发</span><span class="tag is-grey-lightest">37</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"><span class="tag">面试题</span><span class="tag is-grey-lightest">34</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AAPT/"><span class="tag">AAPT</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AIDL/"><span class="tag">AIDL</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ApkBuilder/"><span class="tag">ApkBuilder</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dex%E5%B7%A5%E5%85%B7/"><span class="tag">Dex工具</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/keystore/"><span class="tag">keystore</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/zipalign%E5%B7%A5%E5%85%B7/"><span class="tag">zipalign工具</span><span class="tag is-grey-lightest">31</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mac%E7%B3%BB%E7%BB%9F/"><span class="tag">Mac系统</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bt/"><span class="tag">bt</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8F%B2%E8%8C%85%E9%9D%A9/"><span class="tag">史茅革</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%92%95%E5%99%9C/"><span class="tag">咕噜</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%84%8F%E5%A4%96%E4%B9%8B%E6%97%85/"><span class="tag">意外之旅</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%88%92%E7%81%B5/"><span class="tag">戒灵</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8C%87%E7%8E%AF%E7%8E%8B/"><span class="tag">指环王</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%94%E5%B0%94%E5%8D%9A%C2%B7%E5%B7%B4%E9%87%91%E6%96%AF/"><span class="tag">比尔博·巴金斯</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%82%8E%E9%AD%94/"><span class="tag">炎魔</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%98%E9%81%93%E5%A4%AB/"><span class="tag">甘道夫</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%B2%BE%E7%81%B5/"><span class="tag">精灵</span><span class="tag is-grey-lightest">6</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-8241795889030186" data-ad-slot="3680041399" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.png" alt="Brigitte Jian&#039;Blog" height="28"></a><p class="size-small"><span>&copy; 2021 Brigitte Jian</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br />&nbsp;&nbsp;&nbsp;&nbsp;方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2017/08/12 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://moruoyiming.github.io/"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2512658634" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.12/js/lightgallery-all.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><!--!--><!--!--><!--!--><script src="/js/toc.js" defer></script><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('9dd24089260d4de9145a','2202ac99ec143c79f6124a7074ec5d1aac907aab','moruoyiming','moruoyiming.github.io',false);})</script><link rel="stylesheet" href="/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: '文章',
                    PAGES: '页面',
                    CATEGORIES: '分类',
                    TAGS: '标签',
                    UNTITLED: '(无标题)',
                },
                CONTENT_URL: '/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="/js/insight.js" defer></script></body></html>